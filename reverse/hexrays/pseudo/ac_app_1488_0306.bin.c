/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_80021E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __fastcall sub_800220C(int a1, void *a2, void *a3, void *a4);
int *sub_8002234();
unsigned int sub_80022A4();
unsigned int __fastcall _aeabi_memcpy8(unsigned int result, unsigned int a2, unsigned int a3); // idb
_BYTE *__fastcall sub_8002356(_BYTE *result, int a2, char a3);
_BYTE *__fastcall sub_8002364(_BYTE *a1, int a2);
_BYTE *__fastcall sub_8002368(_BYTE *a1, char a2, int a3);
int __fastcall sub_800237A(int result, unsigned __int8 *a2);
unsigned __int8 *__fastcall strstr(unsigned __int8 *a1, unsigned __int8 *a2);
_BYTE *__fastcall sub_80023B6(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_80023CE(int a1, unsigned __int8 a2);
unsigned __int8 *__fastcall sub_80023E2(unsigned __int8 *a1);
int __fastcall sub_80023F0(int a1, int a2);
_BYTE *__fastcall sub_800240C(_BYTE *a1, unsigned __int8 *a2);
int __fastcall sub_800241E(int a1, int a2, unsigned int a3);
unsigned int __fastcall sub_800243C(_BYTE *a1, _BYTE *a2);
_BYTE *__fastcall sub_8002480(_BYTE *result, char a2);
_BYTE *__fastcall sub_80024A0(_BYTE *result, _BYTE *a2);
int scanf(int a1, int a2, ...); // idb
int __fastcall scanf_int(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_8002644(char *a1);
void __fastcall sub_8002764(unsigned int a1);
int __fastcall sub_8002814(__int64 a1);
int __fastcall sub_8002878(int a1, int a2, int a3);
unsigned int __fastcall ll_ushift_r(unsigned int a1, unsigned int a2, int a3); // idb
unsigned int __fastcall sub_80028B6(unsigned int result, unsigned int a2);
int __fastcall sub_80028D4(_DWORD *a1, int a2);
int __fastcall sub_80028E0(int a1, int a2, _DWORD *a3);
int __fastcall sub_80028FC(unsigned __int8 **a1);
int __fastcall sbackspace(int *a1); // idb
int __fastcall strtol(char *nptr, char **endptr, int base); // idb
unsigned int __fastcall SVCall_handler(unsigned int a1, int a2, int a3);
unsigned int __fastcall sub_8002A1A(unsigned int result, int a2, __int64 a3);
void __fastcall sub_8002A38(unsigned int a1, unsigned int a2, __int64 a3);
unsigned int __fastcall Reset_handler(int a1, int a2, __int64 a3, __int64 a4);
int __fastcall sub_8002D00(unsigned int a1, unsigned int a2);
int __fastcall ll_sshift_r(unsigned int a1, int a2, int a3);
char *sub_8002DA8();
int __fastcall sub_8002DB0(int a1);
int __fastcall sub_8002DC4(int a1, int a2);
unsigned int strtoul(const char *nptr, char **endptr, int base);
void __fastcall _decompress1(unsigned __int8 *src, unsigned __int8 *dst, int len);
void sub_80031E4();
void sub_80031EE();
void sub_80031F8();
void sub_8003202();
void sub_800320C();
void sub_8003216();
void sub_8003220();
void sub_800322A();
void sub_8003234();
void sub_800323E();
void sub_8003248();
void sub_8003252();
void sub_8003266();
void sub_8003270();
void sub_800327A();
void sub_8003284();
void sub_800328E();
void sub_80032A2();
void sub_80032AC();
int __fastcall sub_80032B6(int a1);
int __fastcall sub_8003334(int a1);
int __fastcall sub_800334E(int a1);
int __fastcall sub_8003358(int *a1);
int __fastcall sub_80033DC(int *a1);
int __fastcall sub_8003468(int a1, int a2, int a3, int a4);
int sub_8003488();
int sub_8003720();
int sub_8003814();
int sub_80039A8();
int __fastcall sub_8003ABC(int result, int a2, int a3, int a4);
int __fastcall sub_8003AE8(int a1, int a2, _WORD *a3, int a4, int a5);
int __fastcall sub_8003BE8(int a1, int a2, int a3);
int __fastcall sub_8003C98(int a1, int a2);
int __fastcall sub_8003D24(unsigned int a1);
int __fastcall sub_8003DB8(int a1);
int __fastcall sub_8003DC0(int a1);
int __fastcall sub_8003DCC(int result, int a2);
int __fastcall sub_8003E1C(int a1, int a2);
int __fastcall sub_8003E4C(unsigned __int8 a1);
unsigned int __fastcall sub_8003E7C(unsigned int a1);
int __fastcall sub_8003E94(unsigned int a1);
unsigned int __fastcall sub_8003EA6(unsigned int result, int a2);
void sub_8003EBC();
int __fastcall sub_80040A0(char *a1, int a2, int a3, unsigned int a4);
int *__fastcall sub_8004188(int *a1, int a2, int a3);
int *__fastcall sub_80041AE(int *a1, int a2, int a3);
int *__fastcall sub_80041D6(int *a1, int a2);
int __fastcall sub_8004200(unsigned __int8 *a1);
int sub_8004258();
int sub_80043D0();
void __fastcall sub_800448C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void sub_80044A0();
void __fastcall sub_80044B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall sub_80044EC(int a1);
char *sub_8004678();
int sub_8004688();
int __fastcall sub_80046BC(int result, int *a2);
BOOL sub_800478C();
BOOL sub_8004798();
int sub_80047AC();
int sub_80047B8();
int sub_80047D0();
BOOL __fastcall sub_8004834(int a1, int a2, int a3);
int __fastcall sub_800486C(int a1, int a2, int a3);
int __fastcall sub_80048A0(int a1);
BOOL sub_80048CC();
BOOL __fastcall sub_8004934(_BYTE *a1, unsigned int a2);
void __fastcall sub_800497C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __fastcall BusFault_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __fastcall sub_8004A14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
BOOL __fastcall sub_8004B04(unsigned __int8 *a1);
BOOL __fastcall sub_8004B50(unsigned int a1);
int sub_8004BA8();
int sub_8004BE0();
int sub_8004C24();
int sub_8004C5C();
int __fastcall sub_8004C6E(int a1, __int16 a2, int a3, __int16 a4);
int __fastcall sub_8004CBE(int result, int a2, unsigned int a3);
unsigned int __fastcall sub_8004CE4(float *a1);
int *__fastcall sub_8004DAC(int *result);
int __fastcall sub_8004DEC(int result);
int __fastcall sub_8004E10(int *a1, int a2, int a3, int a4);
int sub_8004E54();
int sub_8004ED4();
int sub_8004F28();
int sub_8004FA8();
int __fastcall sub_8004FBC(int a1);
int __fastcall sub_8004FCC(int a1);
int sub_8004FE0(int a1, ...);
int __fastcall sub_8005004(int a1);
int sub_8005088();
int sub_800509E();
int __fastcall sub_80050B4(int a1);
int __fastcall sub_800511C(int a1);
int __fastcall sub_800515C(unsigned int a1, int a2, int a3, int a4);
int sub_8005188();
int __fastcall sub_80051B4(int a1, int a2, int a3);
BOOL __fastcall sub_8005498(unsigned int a1, int a2, __int16 a3);
void __fastcall IRQ_11_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
int __fastcall sub_80055B4(unsigned int a1);
int sub_80055E0();
int __fastcall sub_80055F0(unsigned int a1, _BYTE *a2, unsigned int a3);
unsigned int __fastcall sub_8005728(unsigned int result);
unsigned int __fastcall sub_8005744(unsigned int result);
void __fastcall sub_8005770(int a1, int a2, unsigned int a3);
unsigned int __fastcall sub_8005850(unsigned int result);
int __fastcall sub_800586C(__int16 a1);
int __fastcall IRQ_40_handler(int a1, int a2);
int __fastcall IRQ_23_handler(int a1, int a2, int a3);
void __noreturn sub_80058BC();
int sub_80058C0();
int sub_8005930();
int __fastcall sub_8005944(int *a1);
unsigned int __fastcall sub_80059B8(int a1, int *a2, int a3, int a4);
int sub_8005A2C();
int __fastcall sub_8005A88(int a1);
int __fastcall sub_8005AC4(unsigned __int8 a1, int a2);
_DWORD *__fastcall sub_8005B10(_DWORD *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_8005B2C(_DWORD *result, int *a2);
int __fastcall sub_8005B58(unsigned int a1);
int __fastcall sub_8005BC4(int a1);
int __fastcall sub_8005C38(int a1, int a2);
void __fastcall sub_8005CA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_8006124(); // weak
void __fastcall IRQ_86_handler(int a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_8006C90();
int __fastcall sub_8006ED8(int a1, int a2);
int __fastcall sub_8006EF4(int result, unsigned int a2, unsigned int a3);
int sub_8006F34();
int __fastcall sub_8007088(int a1, int a2);
unsigned __int8 *__fastcall sub_8007100(unsigned __int8 *result);
int __fastcall sub_80071B4(int a1);
int sub_8007210();
int sub_800725C();
int sub_80072FC();
_BYTE *__fastcall sub_8007364(unsigned __int8 *a1, int a2);
_BYTE *__fastcall sub_80073DC(unsigned __int8 *a1, int a2);
int __fastcall sub_8007434(const char *a1);
int sub_8007498();
char *sub_8007504();
int __fastcall sub_800754C(const char *a1);
int sub_80075B0();
unsigned int sub_80076F8();
BOOL sub_800777C();
int sub_8007788();
int sub_80077D0();
int __fastcall sub_800786C(int result);
void __fastcall __noreturn sub_8007880(int a1);
int __fastcall sub_8007960(int a1);
int __fastcall sub_8007A40(const char *a1, unsigned int a2, int a3);
int sub_8007B4C();
int sub_8007BB8();
int sub_8007C6C();
int __fastcall sub_8007CF8(int a1);
unsigned __int8 *__fastcall sub_8007E80(unsigned __int8 *result, int a2);
int sub_8007EA0(void); // weak
int __fastcall sub_8007F88(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_800807C(); // weak
int sub_80080E8();
int __fastcall sub_80083A4(int a1);
_BYTE *sub_80083F8();
int sub_800842C();
int __fastcall sub_800846C(int a1, int a2, unsigned int a3, int a4);
int sub_8008554();
int __fastcall sub_80085AC(int a1);
int sub_800860C();
int sub_8009708();
BOOL __fastcall sub_8009828(int a1, int a2);
int __fastcall sub_8009B44(int a1);
int __fastcall sub_8009D6C(__int64 a1);
int sub_8009DA8();
int sub_8009E38();
BOOL __fastcall sub_8009FA0(int a1);
BOOL __fastcall sub_8009FF8(int a1, const char *a2, int a3);
int sub_800A08C();
int sub_800A46C();
int __fastcall sub_800A54C(int a1, int a2, int a3);
int sub_800A604();
int sub_800A6E0();
int sub_800A824();
int sub_800A96C();
int __fastcall sub_800AA90(int a1, int a2, int a3);
int sub_800AB4C();
int __fastcall sub_800AB90(int a1, int a2, const char *a3, const char *a4, const char *a5);
int sub_800AC78();
int __fastcall sub_800AD3C(int result, unsigned int a2);
int __fastcall sub_800C26C(int a1, int a2, int a3, int a4, const char *a5, int a6, const char *a7);
int __fastcall sub_800C334(int a1);
int __fastcall sub_800C418(int result, unsigned int a2);
int __fastcall sub_800C4B8(int a1, int a2, int a3, int a4);
int __fastcall sub_800C570(int a1, int a2, const char *a3, int a4);
int sub_800C61C();
int __fastcall sub_800C6A0(int a1, unsigned int a2, int a3);
int sub_800C6F0();
int __fastcall sub_800C7A8(int a1, int a2, int a3);
int sub_800C860();
unsigned int __fastcall sub_800CB88(unsigned int result, int a2);
int __fastcall sub_800CBE0(int a1);
int sub_800CEC8(); // weak
int sub_800CF08(); // weak
int sub_800CF40(); // weak
int sub_800CF5C(); // weak
_BYTE *__fastcall sub_800CF80(_BYTE *result, unsigned int a2, signed int a3);
unsigned __int8 *sub_800D030();
int __fastcall sub_800D184(int a1);
int sub_800D640();
int __fastcall sub_800D758(int result);
int sub_800D9EC();
int __fastcall sub_800DAC0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_800DBD0(); // weak
BOOL __fastcall sub_800DC14(int a1, const char *a2, int a3);
int __fastcall sub_800DD3C(int a1, int a2, const char *a3);
int sub_800DDF0();
int __fastcall sub_800E07C(int a1, int a2, int a3);
int __fastcall sub_800E128(int a1, int a2, int a3);
int sub_800E1D4();
int __fastcall sub_800E274(int a1, int a2);
int __fastcall sub_800E28A(unsigned __int8 *a1);
int __fastcall sub_800E2B0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_800E36C();
int __fastcall sub_800E3A8(int result);
int __fastcall sub_800E458(int a1);
int __fastcall sub_800E4F8(int a1);
unsigned __int8 *sub_800E554();
void __fastcall sub_800EBEC(int a1, int a2, int a3, int a4);
int __fastcall sub_800ECDC(unsigned __int8 *a1);
int sub_800ED0C();
int __fastcall sub_800EF54(const char *a1, const char *a2, int a3, unsigned int a4);
int __fastcall sub_800F058(int a1);
int sub_800F1C4();
int sub_800F228();
BOOL __fastcall sub_800F4F4(unsigned int a1, int a2);
int __fastcall sub_800F558(_DWORD *a1, int a2, unsigned int a3);
unsigned int sub_800F5D0();
int __fastcall sub_800F61C(int a1, unsigned int a2);
int sub_800F638();
int sub_800F65C();
unsigned __int8 *sub_800F688();
_BYTE *sub_800F728();
unsigned int __fastcall sub_800F768(unsigned __int8 *a1, int a2, int a3, int a4);
int __fastcall sub_800F7D0(__int16 *a1, unsigned int a2);
int __fastcall nullsub_4(_DWORD); // weak
int __fastcall nullsub_3(_DWORD); // weak
__int64 __fastcall sub_800F808(__int64 a1);
int sub_800F8D8();
int __fastcall sub_800FAC4(unsigned __int8 *a1, unsigned __int8 *a2);
int sub_800FC08();
int __fastcall sub_800FC70(int result);
int __fastcall sub_800FCB4(int a1, __int16 a2);
int sub_800FD84();
unsigned int __fastcall sub_800FDF8(int a1);
int __fastcall sub_800FE14(int a1, unsigned int a2);
int sub_800FE34();
int __fastcall sub_8010014(int a1, int a2);
int __fastcall sub_8010134(int a1, int a2);
int __fastcall sub_80101D0(int a1, int a2);
int __fastcall sub_8010650(int *a1);
int __fastcall sub_8010680(int a1);
int *__fastcall sub_80108D0(int *a1);
int __fastcall sub_8010B40(int a1, int a2, int a3);
int __fastcall sub_8010C70(int a1);
int *__fastcall sub_8010EF0(int **a1);
int __fastcall sub_8010F94(int a1);
int __fastcall sub_8010FF0(int a1, _DWORD *a2);
int __fastcall sub_8011038(int a1);
int __fastcall sub_8011070(int a1, int a2, int a3);
int __fastcall sub_8011244(int a1);
int __fastcall sub_8011270(int *a1);
int __fastcall sub_8011304(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_8011336(_BYTE *a1, int a2);
int __fastcall sub_80113A4(int a1);
int __fastcall sub_801140C(int a1);
int __fastcall sub_8011550(int a1);
int __fastcall sub_8011610(int a1, int a2, int a3, int a4);
unsigned int __fastcall sub_80116A0(unsigned int a1);
int __fastcall sub_80116C4(unsigned __int8 *a1, int a2, int a3);
int __fastcall sub_80117A4(_DWORD *a1, int *a2, int a3);
int __fastcall sub_80117F2(int a1, int a2);
int __fastcall sub_8011850(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_8011886(int a1);
int __fastcall sub_80118B4(int a1, int a2, int *a3, int a4);
int __fastcall sub_8011B20(int a1);
int __fastcall nullsub_2(_DWORD); // weak
int __fastcall sub_8011D00(int *a1);
int __fastcall sub_8011D88(unsigned __int8 *a1, int a2);
int __fastcall sub_8011DC2(int a1);
int __fastcall sub_8011DEE(int *a1);
int __fastcall sub_8011E80(_DWORD *a1, unsigned int *a2);
BOOL sub_8011F78();
int __fastcall sub_8011F94(int a1, _DWORD *a2, int *a3, int a4);
int sub_8012014();
int __fastcall sub_801203C(int result);
int __fastcall sub_8012098(int result);
int *__fastcall sub_80120B0(int *result, int a2);
BOOL __fastcall sub_8012260(int a1, int a2);
int __fastcall sub_801226E(int result, int a2);
int __fastcall sub_801227E(int result, int a2, int a3);
unsigned int sub_801228C();
int sub_8012298();
int __fastcall sub_80122A4(_BYTE *a1, int a2, char a3);
int __fastcall sub_80123C0(_BYTE *a1, int a2, _DWORD *a3);
int __fastcall sub_8012612(int a1, int a2);
int __fastcall sub_8012652(_BYTE *a1, int a2);
int __fastcall sub_80126C4(int a1, int a2, int a3);
int __fastcall sub_8012754(int a1, int a2, _BYTE *a3);
int __fastcall sub_801278C(int a1);
int __fastcall sub_8012844(int *a1);
int *__fastcall sub_801286C(int **a1);
int __fastcall sub_8012930(_BYTE *a1, unsigned int a2);
int __fastcall sub_8012970(int a1, int a2, _DWORD *a3);
int __fastcall sub_80129A4(_BYTE *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_8012B26(int a1, int a2);
int __fastcall sub_8012B52(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_8012B8A(int a1, int a2);
int __fastcall sub_8012BBA(int a1, int a2);
int __fastcall sub_8012BEA(int a1, int a2, _DWORD *a3);
int __fastcall sub_8012C80(int a1, int a2, _DWORD *a3);
int __fastcall sub_8012CC4(int a1, int a2);
int __fastcall sub_8012D1E(int a1, int a2);
int __fastcall sub_8012D74(int a1);
int __fastcall sub_8012E34(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5);
int __fastcall sub_8012F80(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5);
int __fastcall sub_80130CC(int *a1);
int __fastcall sub_801317C(_DWORD *a1);
int *sub_80131F0();
int sub_8013200();
int __fastcall sub_8013220(unsigned int a1);
int sub_801326C();
int __fastcall sub_80132A4(int result);
int __fastcall sub_80132C0(int a1, unsigned __int8 a2, char a3);
int __fastcall sub_8013300(char a1);
void __noreturn sub_8013324();
int __fastcall sub_8013348(int a1);
int sub_8013414();
int __fastcall sub_8013424(_DWORD *a1);
int __fastcall sub_8013734(unsigned __int8 *a1, unsigned int a2);
int sub_80138FC();
unsigned int sub_8013908();
unsigned int sub_801392C();
unsigned int sub_8013950();
int __fastcall sub_80139C4(unsigned __int8 *a1);
int __fastcall sub_8013E1C(int a1, int a2, int a3, int a4);
int __fastcall sub_8013EB0(int a1, _BYTE *a2, int a3);
int __fastcall sub_8013EF4(int a1, int a2, int a3);
int __fastcall sub_8013F48(int a1);
int __fastcall sub_8013FDC(int *a1);
int __fastcall sub_8014030(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_80140D4(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_80141A0(int a1);
int sub_80141D4();
int __fastcall HAL_SYSTICK_Config(int a1);
int __fastcall nullsub_16(_DWORD); // weak
int __fastcall nullsub_17(_DWORD); // weak
int __fastcall nullsub_18(_DWORD); // weak
int __fastcall nullsub_19(_DWORD); // weak
int __fastcall nullsub_20(_DWORD); // weak
int __fastcall nullsub_21(_DWORD); // weak
int __fastcall sub_801422C(int a1, int a2);
int __fastcall sub_8014308(_BYTE *a1, int a2, int a3);
int __fastcall nullsub_22(_DWORD); // weak
int __fastcall sub_801439A(int a1);
int __fastcall sub_80143E8(int *a1);
int __fastcall sub_8014424(_BYTE *a1);
unsigned int __fastcall sub_80144B8(unsigned int *a1);
int __fastcall sub_8014508(int a1, int *a2, int a3);
int __fastcall sub_80145C8(int a1);
int __fastcall sub_8014618(int *a1);
int __fastcall sub_8014654(unsigned __int8 *a1, int a2);
int __fastcall sub_80147DC(int a1);
int __fastcall sub_80149E0(_DWORD **a1, _DWORD *a2, int a3);
int __fastcall sub_8014A50(int result);
int __fastcall sub_8014A90(int a1);
int __fastcall nullsub_25(_DWORD); // weak
int __fastcall sub_8014AE0(unsigned __int8 *a1, int a2);
int __fastcall sub_8014C4C(_DWORD **a1, _DWORD *a2, int a3);
int __fastcall sub_8014D82(int a1);
int *__fastcall sub_8014DD0(int *a1);
int __fastcall nullsub_23(_DWORD); // weak
int __fastcall sub_8014ED8(int a1, int a2);
int __fastcall sub_8015004(int a1, int a2);
int __fastcall sub_80150BC(int *a1);
int __fastcall sub_80150F0(int a1, int a2);
int __fastcall nullsub_24(_DWORD); // weak
int __fastcall sub_801511E(int a1);
int __fastcall sub_801515A(int a1);
int __fastcall nullsub_26(_DWORD, _DWORD); // weak
int __fastcall nullsub_27(_DWORD); // weak
int __fastcall sub_80151A6(int a1, int a2);
int __fastcall sub_80151F2(int a1, int a2);
int __fastcall nullsub_28(_DWORD); // weak
int __fastcall nullsub_29(_DWORD, _DWORD); // weak
int __fastcall nullsub_30(_DWORD); // weak
int __fastcall sub_8015244(int a1);
int __fastcall sub_8015308(_DWORD *a1);
int __fastcall nullsub_32(_DWORD); // weak
int __fastcall sub_801534C(_DWORD *a1);
int __fastcall sub_8015638(int a1);
int __fastcall nullsub_31(_DWORD); // weak
int __fastcall sub_80156AC(int *a1);
int __fastcall sub_80157DC(int a1, int a2, unsigned int a3);
int __fastcall sub_8015834(int *a1);
int __fastcall sub_8015924(int a1, int a2, int a3);
int __fastcall nullsub_33(_DWORD); // weak
int __fastcall nullsub_34(_DWORD); // weak
_DWORD *sub_80159CC();
_DWORD *__fastcall sub_8015B60(_DWORD *result, int a2, _BYTE *a3);
_DWORD *__fastcall sub_8015DF4(_DWORD *result, int a2);
int __fastcall sub_8015E74(int *a1, _DWORD *a2);
int __fastcall sub_8015E9A(int *a1, _DWORD *a2);
int __fastcall sub_8015F2E(int *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_801600C(int *a1, int a2, _DWORD *a3);
void __fastcall IRQ_71_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
unsigned int __fastcall sub_8016200(int *a1, int a2, _DWORD *a3);
int sub_8016254();
int sub_8016260();
int sub_8016270();
int sub_8016298();
int sub_80162B0();
char *sub_8016714();
int sub_80167E4();
int sub_801680C();
unsigned int __fastcall sub_8016824(unsigned int result);
int sub_801683C();
int sub_8016854();
int sub_801686C();
int sub_8016894();
int sub_80168BC();
int sub_80168D8();
int sub_80168EC();
int __fastcall I2C_Flush_TXDR(int *a1);
int __fastcall sub_801692C(int *a1, unsigned int a2, int a3);
int __fastcall sub_8016A3C(int a1, __int16 a2, int a3, int a4, int a5);
void __fastcall HardFault_handler(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_8016A6C(int a1, int a2, int a3, unsigned int a4, int a5);
int __fastcall sub_8016AC4(int a1, unsigned int a2, int a3);
int __fastcall sub_8016B6C(int *a1, unsigned int a2, int a3);
int __fastcall sub_8016BB8(int *a1, unsigned int a2, int a3);
int sub_8016C08();
int __fastcall sub_8016C60(int result, unsigned int a2);
int __fastcall sub_8016CA8(int a1, int a2);
int __fastcall sub_8016CB4(int a1);
int __fastcall sub_8016CBC(int a1);
int __fastcall sub_8016CC4(int a1);
BOOL __fastcall sub_8016CCC(int a1);
int __fastcall sub_8016CDC(int a1, unsigned int a2, int a3);
int __fastcall sub_8016CFA(int a1, int a2, int a3);
int sub_8016D0C();
int __fastcall sub_8016D24(char a1);
int sub_8016D3C();
unsigned int sub_8016E38();
_DWORD *sub_8016E6C();
int __fastcall sub_8016E90(_DWORD); // weak
int __fastcall IRQ_91_handler(int a1, int a2, int a3, int a4);
void sub_8017540();
float *__fastcall sub_8017D28(int a1);
_DWORD *__fastcall sub_8017DFC(int a1, int a2, int a3, int a4);
int sub_8017E4C();
unsigned int __fastcall sub_8017EA2(int a1, unsigned int a2);
int sub_8017ED8();
int sub_8017FE4();
int sub_8018004();
BOOL __fastcall sub_8018010(unsigned int a1);
char *__fastcall sub_801803C(char *result);
int *__fastcall sub_80180C0(int *result, int a2, unsigned int a3, int a4);
int __fastcall sub_80180E8(_WORD *a1, unsigned int a2);
int __fastcall sub_8018114(int result);
int __fastcall sub_80181A0(int result);
_BYTE *__fastcall sub_801822C(_BYTE *result, unsigned int a2, unsigned int a3);
int __fastcall sub_801828C(int result, unsigned int a2, unsigned int a3);
int __fastcall sub_8018344(int result, int a2);
BOOL __fastcall sub_8018560(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
char *__fastcall sub_80185F0(unsigned int a1, int a2, int a3);
unsigned int sub_8018634();
int __fastcall sub_8018684(unsigned int a1);
int __fastcall sub_8018696(unsigned int a1);
int __fastcall MemManage_fault_handler(unsigned int a1, char a2);
int __fastcall sub_80186AC(_BYTE *a1);
int __fastcall sub_80186F4(_BYTE *a1);
int __fastcall sub_8018744(_BYTE *a1, int *a2, int a3, int a4);
int sub_8018804();
void __fastcall NMI_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __fastcall sub_8018928(int result, int a2);
int sub_8018A5C();
char *sub_8018A74();
int __fastcall sub_8018AE4(int a1);
int __fastcall sub_8018B68(int a1, int a2, int a3, int a4);
void sub_8018B78();
int __fastcall sub_8018BA8(unsigned __int8 *a1, int a2);
int __fastcall sub_8018C90(unsigned __int8 *a1, int a2);
int __fastcall sub_8018CF4(unsigned __int8 *a1, int a2);
int __fastcall sub_8018D24(unsigned __int8 *a1, unsigned int a2, int a3, int a4);
int __fastcall sub_8018DFC(int result, unsigned int a2, int a3, int a4);
int __fastcall sub_8018E88(_BYTE *a1, int a2);
int sub_8018EA8();
int sub_8019018(void); // weak
void __fastcall sub_8019330(int a1);
int __fastcall sub_8019444(int a1);
void sub_8019450();
int __fastcall sub_8019988(int a1);
int sub_80199A4();
int __fastcall sub_801A028(int result, int a2, int (*a3)(void));
int __fastcall sub_801A078(_BYTE *a1, _DWORD *a2);
int *sub_801A140();
int *sub_801A190();
int __fastcall sub_801A1A0(_BYTE *a1);
int sub_801A2B0();
int sub_801A2BC();
int sub_801A2C8();
unsigned int *__fastcall sub_801A2D4(unsigned int *result, unsigned int *a2);
int __fastcall sub_801A3A8(int result, char a2, int a3);
int __fastcall sub_801A3C2(int result, char a2, int a3);
_DWORD *__fastcall sub_801A3DC(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801A48C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801A530(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801A5D4(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801A678(_DWORD *result, int a2);
_DWORD *__fastcall sub_801A6F0(_DWORD *result, int a2);
int __fastcall sub_801A76C(int result, char a2, int a3, char a4);
int __fastcall sub_801A7EC(int result, int a2, int a3, __int16 a4);
int __fastcall sub_801A822(int result, int a2, int a3, char a4);
int __fastcall sub_801A854(int result, int a2, int a3, __int16 a4);
int sub_801A88C(int a1, ...);
int __fastcall SysTick_handler(_DWORD **a1, _DWORD *a2, int a3);
int sub_801A96C();
int sub_801A978();
int sub_801A984();
void __fastcall sub_801A990(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int sub_801A9F4();
int __fastcall sub_801AA4C(int result);
unsigned int __fastcall sub_801AA6C(unsigned int result);
unsigned int __fastcall sub_801AA84(unsigned int result);
int sub_801AA9C();
int __fastcall IRQ_80_handler(int a1, int a2);
int __fastcall IRQ_30_handler(_BYTE *);
int __fastcall sub_801AACC(_WORD *a1, unsigned int a2);
int __fastcall sub_801AAF4(_WORD *a1, unsigned int a2);
void sub_801AB1C();
int __fastcall sub_801AB7C(int result);
int __fastcall sub_801ABC4(int result);
int __fastcall sub_801AC8C(int a1);
int __fastcall sub_801ACEC(int a1);
int __fastcall sub_801AD00(int a1);
int __fastcall sub_801AD50(int a1);
int __fastcall sub_801AD78(int a1);
int __fastcall sub_801ADBA(int a1);
int __fastcall sub_801ADC4(int result);
int __fastcall sub_801AE18(int a1);
int __fastcall sub_801AE3C(int result);
int __fastcall sub_801AE6A(int *a1);
unsigned int *__fastcall sub_801AF0C(_DWORD *a1);
int __fastcall sub_801B080(int *a1);
unsigned int *__fastcall sub_801B120(_DWORD *a1);
int __fastcall sub_801B294(_DWORD *a1);
int __fastcall sub_801B5A4(int a1, int a2, unsigned int a3);
int __fastcall sub_801B6D0(unsigned int **a1, int a2, int a3, int a4, unsigned int a5);
BOOL __fastcall sub_801B790(unsigned __int8 *a1);
int sub_801B818();
void __fastcall sub_801B824(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_801BF84(); // weak
void sub_801BFDC();
void __fastcall IRQ_38_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall sub_801C2EC(unsigned __int8 *a1, int a2, _DWORD *a3);
BOOL __fastcall sub_801C750(int a1);
_BYTE *__fastcall sub_801C7C0(_BYTE *result);
__int64 __fastcall sub_801C864(__int64 a1, int a2, unsigned int a3);
_BYTE *__fastcall sub_801C8E0(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_801C958(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_801C98C(_BYTE *result, int a2, int a3, int a4);
char *__fastcall sub_801CA30(int a1, int a2, int a3, int a4);
int __fastcall sub_801CB1C(int result, int a2);
int sub_801CB4C();
int __fastcall sub_801CB78(int, int, int, int);
int sub_801CB7C();
int sub_801CBE0();
int sub_801CBF8();
int sub_801CC20();
int sub_801CCE0();
int sub_801CE34();
int __fastcall sub_801CE90(int result);
unsigned int *__fastcall sub_801CEAC(int a1, unsigned __int16 a2);
int __fastcall sub_801CEDC(int result, int a2);
int __fastcall sub_801CF08(int result, int a2);
int __fastcall sub_801CF74(int result);
int __fastcall sub_801CF8C(int result, int a2);
int sub_801CFB4();
int sub_801CFC4();
int __fastcall sub_801CFE0(int a1, __int16 a2);
void sub_801D004();
int *sub_801DAE4();
int __fastcall sub_801DFE8(int a1, int a2, int a3, int a4);
int sub_801E1B0(int a1, ...);
int snprintf(int a1, int a2, const char *a3, ...);
int sprintf(int a1, const char *a2, ...);
int __fastcall sub_801E220(int a1, int a2);
int __fastcall _NVIC_SetPriority(int a1, char a2);
void __noreturn sub_801E274();
void __noreturn sub_801E298();
void __noreturn sub_801E2BC();
void *sub_801E2E0();
__int64 __fastcall fp_digits(__int64 a1, double a2, int a3, int a4);
int __fastcall printf_core(int a1, int a2, int a3, void (*a4)(void));
int __fastcall printf_post_padding(int a1, __int16 a2, int a3, void (__fastcall *a4)(int, int));
int __fastcall printf_pre_padding_0(int a1, int a2, int a3, void (__fastcall *a4)(int, int));
int __fastcall sub_801EBAE(int result, _DWORD *a2);
char __fastcall sub_801EBC4(char result, _DWORD *a2);
__int64 __fastcall sub_801EBD0(unsigned int a1);
int sub_801EC38();
int sub_801EC40();
int sub_801EC94();
int sub_801ECA0();
int sub_801ECDC();
int __fastcall sub_801ECF8(int a1);
int sub_801EDC8();
__int64 __fastcall sub_801EE84(_DWORD); // weak
int __fastcall sub_801EE88(int a1, unsigned int a2, int *a3);
int sub_801EEA4();
int sub_801EEB0();
int sub_801EEFC();
int sub_801EFEC();
int sub_801F064();
int sub_801F5A4();
int sub_801F7E0();
_DWORD *__fastcall sub_801F81C(int a1, int a2);
unsigned int __fastcall sub_801F8B0(_DWORD *a1);
int sub_801F95C();
_DWORD *__fastcall sub_801F998(_DWORD *result, unsigned int a2);
int __fastcall sub_801F9C0(unsigned int *a1, unsigned int a2, int a3);
void __fastcall sub_801FA2E(int a1);
int __fastcall sub_801FA42(int a1);
_DWORD *__fastcall sub_801FAC8(_DWORD *result);
int __fastcall sub_801FAE0(int a1, int a2, int a3, char a4, int a5);
_DWORD *__fastcall sub_801FB08(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, int a7);
int __fastcall sub_801FBC4(int a1);
int *sub_801FBD4();
int *__fastcall sub_801FC2C(int *result);
BOOL __fastcall sub_801FC80(int a1);
BOOL __fastcall sub_801FC9A(int a1);
int __fastcall sub_801FCB8(int a1, _DWORD *a2, int a3);
int __fastcall sub_801FD14(int a1);
int *sub_801FDC0();
int __fastcall sub_801FDE0(unsigned __int8 *a1);
int __fastcall sub_801FE60(int a1);
unsigned __int8 *__fastcall sub_801FEDC(unsigned __int8 *a1, unsigned __int8 *a2);
void __fastcall sub_801FF14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int sub_8020008();
_DWORD *__fastcall sub_8020020(int a1, int a2, int a3);
unsigned int __fastcall sub_8020044(unsigned int a1, unsigned int a2, __int16 a3);
int sub_8020090();
int __fastcall sub_80200DC(unsigned int a1, unsigned int a2, __int16 a3);
int __fastcall sub_8020108(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall sub_8020134(int result);
int __fastcall sub_802015C(int a1);
int __fastcall sub_802019C(int a1, _BYTE *a2);
int sub_80201CC();
int __fastcall sub_80201E8(int a1);
int __fastcall sub_80202D8(int result, int a2);
int __fastcall sub_80202F0(int a1, int a2);
int __fastcall sub_80202FC(int a1);
unsigned int __fastcall sub_8020314(int a1);
int __fastcall sub_8020388(unsigned __int8 *a1);
int __fastcall sub_80203D6(int a1);
float __fastcall sub_8020412(_BYTE *a1);
float __fastcall sub_80204D4(int a1, unsigned __int8 *a2);
int __fastcall sub_8020578(int a1, int a2, int a3, int a4);
int __fastcall sub_802064C(int a1);
int __fastcall sub_8020678(int a1);
_BYTE *__fastcall sub_8020684(int a1);
int sub_80206C4();
int __fastcall sub_80206EC(int a1, int a2);
int __fastcall sub_802072C(int result, int a2);
int __fastcall sub_8020804(int a1, int a2);
int __fastcall sub_802082C(int result, int a2);
unsigned int __fastcall sub_80208C6(int a1);
int __fastcall sub_8020934(int a1, int a2, unsigned int a3);
int __fastcall sub_80209BC(int a1, char a2);
int __fastcall sub_8020A84(int a1);
int __fastcall sub_8020A9E(int a1);
int __fastcall sub_8020AF0(int a1, int a2);
int __fastcall sub_8020B98(int a1, char a2);
int __fastcall sub_8020BA8(int result);
unsigned int __fastcall sub_8020C1E(int a1);
int __fastcall sub_8020C60(int result);
unsigned int __fastcall sub_8020C76(int a1, int a2);
int __fastcall sub_8020D08(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_8020D7C(int a1, int a2);
unsigned __int8 *__fastcall sub_8020DDC(int a1, int a2);
int __fastcall sub_8020E98(int a1, int a2);
int __fastcall sub_8020EBC(int a1, int a2);
int __fastcall sub_8020ED4(int a1);
int __fastcall sub_8021018(int a1, int a2);
int __fastcall sub_802106A(unsigned int a1, int a2);
int __fastcall sub_8021094(int a1);
int __fastcall sub_802109A(int a1, int a2);
int __fastcall sub_80210A8(int a1, _BYTE *a2);
int sub_80210F4();
int __fastcall sub_80210F8(int a1, int a2);
int __fastcall sub_8021158(int a1, int a2);
int __fastcall sub_80211BC(int a1, unsigned int a2);
int __fastcall sub_8021244(int a1, unsigned __int8 *a2);
void __fastcall sub_8021270(int a1);
int sub_8021298(); // weak
void sub_802135C();
int sub_80213FC();
int __fastcall sub_8021430(int a1);
int sub_8021450();
int sub_8021458();
int __fastcall sub_802148C(int result);
int sub_802157C();
int sub_802159C(); // weak
int sub_80215B4();
void __fastcall sub_80215BA(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_80215F0(int result, int a2);
int sub_8021988(); // weak
void sub_8021994();
int sub_8021B48(); // weak
int sub_80220E8();
void __fastcall sub_8022104(int a1, int a2);
__int16 *sub_8022118();
void __fastcall sub_8022134(int a1);
int sub_8022184(); // weak
void sub_80221F0();
void sub_8022240();
int __fastcall sub_80222F8(int a1);
int sub_8022348(); // weak
int sub_8022360();
int __fastcall sub_8022394(int result);
int __fastcall sub_80223A4(int a1);
int sub_8022454(); // weak
int sub_80224B8(); // weak
int sub_80224F8();
void sub_8022518();
void sub_8022676();
void __fastcall sub_80227CE(int a1);
int sub_80228A0();
char *sub_80228D4();
int __fastcall sub_8022904(int a1);
int sub_802292C(); // weak
unsigned int sub_8022A3C();
void __noreturn sub_8022ADC();
int sub_8022B00();
int sub_8022B90();
int __fastcall sub_8022C24(int a1, int a2, int a3);
int __fastcall sub_8022CE4(unsigned int a1, __int16 a2, unsigned int a3, int a4);
int sub_8022F0C();
int __fastcall sub_8022F20(_DWORD *a1);
int sub_8022F48();
int __fastcall sub_8022F54(int a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_8023000(_DWORD *result);
int __fastcall sub_8023016(int result);
_DWORD *__fastcall sub_802301C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_802304C(_DWORD *result, _DWORD *a2);
int sub_8023064();
int sub_80230E4();
int __fastcall sub_8023144(int result);
int sub_80231FC();
unsigned int sub_8023220();
int __fastcall sub_80232B4(int a1);
int __fastcall sub_802332C(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_80233A0(_DWORD *result);
int __fastcall sub_80233B0(unsigned __int8 *a1);
int sub_802345C();
_DWORD *__fastcall sub_8023468(_DWORD *a1, int a2);
int __fastcall sub_80234C8(int result, unsigned int a2);
int sub_80235B8();
int __fastcall sub_8023648(_DWORD *a1);
int *sub_8023734();
int sub_8023744();
int __fastcall sub_80238FC(_BYTE *a1, int a2, int a3, unsigned int a4);
int sub_8024764();
int sub_80248A0();
_DWORD *__fastcall sub_80248CC(char a1);
int __fastcall sub_80248E4(unsigned int a1, unsigned int a2, char a3);
int __fastcall sub_8024960(int a1, int a2);
int __fastcall sub_8024A40(int a1, unsigned int a2, unsigned int a3, int a4);
int __fastcall sub_8024BE4(int a1, unsigned int a2, _DWORD *a3, int a4);
int __fastcall sub_8024CF0(int a1, _DWORD *a2);
BOOL __fastcall sub_8024DD8(int a1);
int __fastcall sub_8024E28(int a1, unsigned int a2, int a3);
int __fastcall sub_8024F80(int a1, int a2);
int __fastcall sub_8025104(_DWORD *a1, unsigned int *a2);
int __fastcall sub_80251BC(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6);
int __fastcall sub_8025224(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int sub_80253CC();
int sub_80253E8();
int sub_80253F4();
int __fastcall sub_802554C(int a1);
int __fastcall sub_8025628(int a1);
int __fastcall sub_80256DC(int a1);
int sub_80257E4();
void sub_8025EBC();
void sub_8025EDE();
void sub_8025F44();
int sub_8025F56();
int sub_802615C(); // weak
int sub_8029114(); // weak
void sub_8029518();
void sub_8029522();
void sub_802952C();
void sub_8029536();
int __fastcall sub_8029540(char a1, char a2, char a3);
void sub_802954A();
void sub_802955E();
void sub_8029568();
void sub_8029572();
void sub_802957C();
void sub_8029586();
void sub_8029590();
void sub_802959A();
void sub_80295A4();
void sub_80295AE();
void sub_80295B8();
void sub_80295C2();
void sub_80295CC();
void sub_80295D6();
void sub_80295E0();
void sub_80295EA();
void sub_80295F4();
void sub_80295FE();
void sub_8029608();
void sub_8029612();
void sub_802961C();
void sub_8029626();
void sub_8029630();
void sub_802963A();
void sub_8029644();
void sub_802964E();
void sub_8029658();
void sub_8029662();
void sub_8029676();
void sub_8029680();
int sub_80296B4();
void sub_8029754();
void __fastcall sub_802980C(int a1, char a2, unsigned int a3);
int sub_8029B7C();
int sub_8029BC4();
float *__fastcall sub_8029C64(float *result, float *a2);
float *__fastcall sub_8029CB6(float *result);
_DWORD *__fastcall sub_8029D14(_DWORD *result);
float *__fastcall sub_8029D38(float *result);
_DWORD *__fastcall sub_8029DAC(_DWORD *result);
float *__fastcall sub_8029DD4(float *result, float *a2);
int __fastcall sub_8029E98(int result);
_DWORD *__fastcall sub_8029F28(_DWORD *result);
int __fastcall sub_8029F60(int result);
char *sub_802A044();
int sub_802A11C();
unsigned int __fastcall sub_802A148(unsigned int result);
_DWORD *__fastcall sub_802A8A4(_DWORD *result);
int sub_802A914();
void sub_802B7D4();
int sub_802F2A4();
int sub_802F324();
char *sub_802F3A4();
int __fastcall sub_802F3F0(int a1);
int __fastcall sub_802F408(int result, int a2);
_DWORD *__fastcall sub_802F4E8(_DWORD *result);
void sub_802F544();
int __fastcall sub_802FEF0(int *a1);
int __fastcall sub_802FF18(int a1, char a2, char a3);
char *__fastcall sub_802FF90(char *result);
void __fastcall sub_802FFA8(int a1, int a2, char a3);
float *sub_8030078();
int __fastcall sub_8030108(int a1, int a2, char a3);
int __fastcall sub_8030280(int result);
int __fastcall sub_80302B0(int a1);
float *__fastcall sub_803031C(float *result);
void __fastcall sub_80303A4(int a1);
int __fastcall sub_803043C(int result);
int __fastcall sub_8030510(float *a1);
int __fastcall sub_803069C(int a1, int a2);
void sub_8030968();
float *sub_8030A7C();
int __fastcall sub_8030AE4(int result);
int *sub_8030B94();
int __fastcall sub_8030BA8(int result);
void sub_8030BE0();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_8002230; // weak
_UNKNOWN loc_80030FC; // weak
_UNKNOWN loc_800311A; // weak
_UNKNOWN loc_8005534; // weak
int dword_8005C14 = 19279; // weak
_UNKNOWN loc_8006144; // weak
_UNKNOWN loc_8006164; // weak
_UNKNOWN loc_800617C; // weak
_UNKNOWN loc_8006180; // weak
_UNKNOWN loc_8006184; // weak
_UNKNOWN loc_80061BC; // weak
_UNKNOWN loc_80061C0; // weak
_UNKNOWN loc_80061DC; // weak
_UNKNOWN loc_8006218; // weak
_UNKNOWN loc_8006244; // weak
_UNKNOWN loc_8006248; // weak
_UNKNOWN loc_8006278; // weak
_UNKNOWN loc_8006290; // weak
_UNKNOWN loc_8006294; // weak
_UNKNOWN loc_80062B8; // weak
_UNKNOWN loc_80062D4; // weak
_UNKNOWN loc_80062D8; // weak
int dword_800723C = 19279; // weak
int dword_8007334 = 19279; // weak
int dword_80077B0 = 16707; // weak
int dword_8007B24 = 19279; // weak
int dword_8007CC4 = 19279; // weak
_UNKNOWN unk_80080A0; // weak
int dword_80082E4 = 15732; // weak
int dword_80083F4 = 19279; // weak
_UNKNOWN loc_800847C; // weak
int dword_8008608 = 19279; // weak
int dword_8009818 = 95; // weak
int dword_8009B40 = 19279; // weak
int dword_8009CF8 = 19279; // weak
int dword_800A4D8 = 20779; // weak
int dword_800AA6C[7] =
{
  1852989783,
  979857001,
  1414614304,
  1852383316,
  1696625769,
  -1125158286,
  658817
}; // weak
_UNKNOWN loc_800B164; // weak
int dword_800CBBC[9] =
{
  -425357594,
  -1763264876,
  -1229200249,
  -426525721,
  -1125146723,
  -1583290740,
  780970729,
  168635950,
  0
}; // weak
int dword_800CEA4[3] = { -427259417, -1863996260, -1750211187 }; // weak
int dword_800CEB0[5] = { -375283482, -1998156630, -1618287216, 226606319, 10 }; // weak
int dword_800CF68[5] = { -375283482, -1528460118, -1514870607, 226606319, 10 }; // weak
int dword_800DBB0[8] =
{
  -495430565,
  -1746759546,
  -2036866426,
  1569101794,
  1129595168,
  540697709,
  220230437,
  10
}; // weak
int dword_800E240 = 19279; // weak
int dword_800E42C = 16707; // weak
_UNKNOWN loc_800E7A8; // weak
_UNKNOWN loc_800E7E8; // weak
_UNKNOWN loc_800E828; // weak
_UNKNOWN loc_800E8A0; // weak
_UNKNOWN loc_800E8E4; // weak
_UNKNOWN loc_800E930; // weak
_UNKNOWN loc_800E974; // weak
_UNKNOWN loc_800E9C8; // weak
_UNKNOWN loc_800EA2C; // weak
_UNKNOWN loc_800EAA8; // weak
_UNKNOWN loc_800EB3C; // weak
int dword_800EC34[9] =
{
  -495431077,
  -1746759034,
  -2020089209,
  545757154,
  541412418,
  1564693077,
  555819296,
  1918981920,
  1735289198
}; // weak
int dword_800EC98 = -495431077; // weak
int dword_800ED08 = 2573; // weak
int dword_800F124 = 19279; // weak
int dword_800FB48 = 32044; // weak
_UNKNOWN loc_8010000; // weak
_UNKNOWN loc_8016044; // weak
_UNKNOWN loc_8018008; // weak
int dword_8018524[7] = { 1680146945, 2087921020, 628912933, 1931836531, 1751655804, 1747287139, 868 }; // weak
int dword_8018540[8] =
{
  1680146945,
  2087921020,
  628912933,
  1931836531,
  1751655804,
  1747287139,
  807732068,
  30770
}; // weak
_UNKNOWN loc_80187E4; // weak
_UNKNOWN loc_801B2C8; // weak
int dword_801B578 = -805344781; // weak
_UNKNOWN loc_801BFA4; // weak
_UNKNOWN loc_801BFC4; // weak
int dword_801C550 = 513; // weak
int dword_801C554[2] = { 1751655683, 120 }; // weak
int dword_801C55C = 124; // weak
int dword_801E474 = 48; // weak
char byte_801EB50 = '-'; // weak
char byte_801EB54 = '+'; // weak
char byte_801EB58 = ' '; // weak
_UNKNOWN loc_801F3AE; // weak
_UNKNOWN loc_801F3C4; // weak
_UNKNOWN loc_801FF00; // weak
int dword_8020380 = 2573; // weak
int dword_8020B90 = 8224; // weak
int dword_8020B94 = 2573; // weak
int dword_8021014 = 2573; // weak
int dword_8021154 = 2573; // weak
int dword_80211A8 = 2573; // weak
int dword_80211AC = 58; // weak
int dword_80211B0 = 47; // weak
int dword_80211B4 = 8228; // weak
_UNKNOWN loc_80212AC; // weak
int dword_80215C8[5] = { 757932081, -1866471392, -410213912, -2132363638, 658817 }; // weak
int dword_80215DC[5] = { 757932082, 1128546592, -427325463, 168671136, 0 }; // weak
int dword_8021940[9] =
{
  -2132205516,
  -1735400058,
  -408380955,
  -1796757573,
  -1466309195,
  -442003738,
  539014792,
  622862397,
  658788
}; // weak
int dword_8021964[3] = { -1176166347, -1849825354, -408437785 }; // weak
_UNKNOWN loc_80219AC; // weak
_UNKNOWN loc_80219D0; // weak
_UNKNOWN loc_80219F0; // weak
_UNKNOWN loc_8021A0C; // weak
int dword_8022170[5] = { -374110747, -1176130153, -1164122442, -442390298, 36796 }; // weak
int dword_8022198[5] = { -424232475, -2014987620, -2019236474, -442390298, 36796 }; // weak
int dword_8022220[8] =
{
  -423711000,
  -1964662633,
  -1618287201,
  -444100889,
  -2132436306,
  540876988,
  168650277,
  0
}; // weak
int dword_8022270[4] = { -440755227, 1718655662, 622869792, 658790 }; // weak
_UNKNOWN unk_8022320; // weak
_UNKNOWN unk_8022444; // weak
int dword_8022484[4] = { -425411868, -1461283944, -1883445855, 0 }; // weak
int dword_8022494[4] = { -443174427, -1461287538, -1883445855, 0 }; // weak
int dword_80224A4[2] = { -444497688, 38540 }; // weak
int dword_80224AC[3] = { -396004255, -1931116160, 150 }; // weak
_UNKNOWN loc_8023154; // weak
int dword_8026138[3] = { 1723154032, 251003720, -1185467039 }; // weak
int dword_8026144[6] = { -1642217082, 295237857, -1802577559, -377020773, -551004722, 227123596 }; // weak
int dword_8026160[3] = { 254646593, 381375664, -714471086 }; // weak
int dword_802616C[4] = { 950351408, -1633468225, -69733503, -2110135428 }; // weak
int dword_802617C[4] = { -2013319269, 1145278004, -873865532, 848591700 }; // weak
_UNKNOWN unk_802618C; // weak
char aV1rzima0gcsqgs[1154] = "V1RziMA0GCSqGSIb3DQEB\nCwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t\nIEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0yNDAxMTkwMzEw\nMzVaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh\ndGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDEGpsgZppFoNQ1yr+5\nObgc2c0k9Ms2RTzZvwl81O1qctxwizeVKF5bMws9ILmd3T2tHEVIvKP63oVSv0Kl\nRMtqlTSTWWeNVv+k+ezbGbdUlbsIP1PsY+dMLkPcAApXl5uqydSYtv5D3FY9Iazu\njZZQh+aLRxv81L9KLDJiv+WRzhdOnBwzU1Pl9SBTitZ+brLl5nIWTnufk5nMKO7m\npj2tjOZrkEHkaUUoY0dtd8SwTCLZDHRn6127GgY66Or7oCtddpzs5sLz5c/p4ZT3\n7ciILh5wVF6SSKP2IMVPt5+2IsKf8rn6+p733lNJXk4OiRBmCmKVv/XJ/thpzGcY\nAaoZAgMBAAGjYDBeMB8GA1UdIwQYMBaAFCijkDWFQrnESVOzFF5W4HHDhfEhMB0G\nA1UdDgQWBBSUxIPiTyDCvFeeT5WCtIR3cPTR3DAMBgNVHRMBAf8EAjAAMA4GA1Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n"; // weak
int dword_8026F58[3] = { 2000171623, 1215788886, 810578021 }; // weak
int dword_80273EC[52] =
{
  269488144,
  269488144,
  269488144,
  33686018,
  -2004352510,
  -2004318072,
  134744072,
  134744072,
  134744072,
  134744072,
  134744072,
  33686018,
  64,
  134380445,
  -1377423815,
  -1497569885,
  1352840166,
  -1092074682,
  -1165498989,
  -393497114,
  -434072145,
  -2098745675,
  -1332353351,
  -423970588,
  -1125801043,
  -1565268314,
  -460017690,
  -2132571202,
  808333456,
  808333613,
  546406627,
  2573,
  -1796797939,
  -1598953803,
  -408974619,
  1025542030,
  744891680,
  -407132441,
  -1964666435,
  -2020677729,
  622869792,
  -1494799258,
  -1849825349,
  -408974619,
  540182414,
  1713709117,
  -1229331156,
  -443433497,
  -1897422966,
  540876935,
  168650277,
  0
}; // weak
int dword_8028914[20] =
{
  539634218,
  1601071458,
  1936090735,
  723547237,
  1096044320,
  1313166175,
  1095786308,
  1398754115,
  541416009,
  589635645,
  1646275704,
  1935634025,
  543521385,
  589635645,
  -450876296,
  -1528461689,
  -1583290745,
  780970729,
  774778414,
  658734
}; // weak
_UNKNOWN *off_8028C5C = &loc_8029D18; // weak
_UNKNOWN *off_8028CC0 = (_UNKNOWN *)0x80261E8; // weak
_UNKNOWN *off_8028D30 = (_UNKNOWN *)0x80262CC; // weak
_UNKNOWN loc_8028D98; // weak
_UNKNOWN loc_8028DE0; // weak
_UNKNOWN loc_8028E44; // weak
_UNKNOWN loc_8028E94; // weak
_UNKNOWN loc_8028EE4; // weak
int dword_8029164[18] =
{
  417890820,
  -150679532,
  1191517956,
  -1710919675,
  -301612283,
  1124472837,
  -1722279708,
  -267991802,
  1208425478,
  -1610124281,
  -150484217,
  1325933319,
  -1526171128,
  -83308280,
  1342776840,
  -1542882807,
  -167129847,
  1175068169
}; // weak
int dword_80291AC[17] =
{
  -1794478582,
  -519390454,
  738920202,
  1946898443,
  -1173645557,
  -32777205,
  1057758987,
  2114739980,
  -1173578484,
  -183707636,
  416420108,
  1645037584,
  -1794278387,
  -972182003,
  -183640563,
  555720910,
  1292777230
}; // weak
int dword_80291F0[22] =
{
  1963876622,
  -1693546482,
  -1056002546,
  -485567986,
  84866062,
  604967951,
  34615823,
  418971927,
  66331859,
  151250979,
  53566742,
  1527238700,
  33832832,
  1142538047,
  269169665,
  -1458814392,
  1511653652,
  671155300,
  69412939,
  -1912333311,
  -654196910,
  -2011823217
}; // weak
int dword_8029248[21] =
{
  -858929901,
  1107508684,
  808655904,
  521933429,
  34743328,
  705442049,
  35458056,
  204603650,
  437783642,
  -399832013,
  18618395,
  1259090945,
  437004172,
  1547308085,
  16915468,
  1683622966,
  204937752,
  437018714,
  607783992,
  16849992,
  676990009
}; // weak
int dword_802929C[108] =
{
  205134348,
  205111321,
  319591450,
  538192052,
  18547716,
  -1202058090,
  217586188,
  -1710441382,
  1545276666,
  152193142,
  33628180,
  207421723,
  205666123,
  1510759962,
  1595542597,
  606689804,
  1259126554,
  437005656,
  873663680,
  35658542,
  213981708,
  705442394,
  1074933954,
  19996692,
  1998851108,
  805637707,
  1259112474,
  436994728,
  437914860,
  590358808,
  -719620016,
  806950967,
  444143651,
  202983432,
  209458203,
  2098880617,
  442525964,
  -2073490306,
  1510793242,
  1679503388,
  470957181,
  35921951,
  207945986,
  487328810,
  1711342098,
  469244684,
  454300172,
  437020673,
  1210661970,
  1510762778,
  -937817002,
  663497484,
  16849980,
  1547308233,
  16915468,
  -1742074678,
  440146188,
  -199619380,
  588786112,
  1683652140,
  204282416,
  437018714,
  1884949550,
  -2132270288,
  523179539,
  50594848,
  1510795777,
  -333837286,
  204364300,
  1510796826,
  -266728398,
  203577868,
  1510797850,
  -1205662682,
  -870303096,
  -1191116516,
  203708940,
  1510783514,
  -1038480344,
  -866248180,
  -1693314541,
  588038913,
  -1391228644,
  18881284,
  203823628,
  451955802,
  1314524199,
  203954700,
  588009562,
  -1137996640,
  605124648,
  1519191041,
  102370484,
  213408268,
  462456867,
  424936717,
  210311728,
  440197210,
  -497415030,
  210442764,
  437052506,
  -1742009204,
  454141991,
  1510771969,
  -1910892462,
  447244556,
  -1755706225,
  210770456
}; // weak
int dword_802947C[5] = { 35651844, 1020920095, 151066927, 640230417, 511772233 }; // weak
_UNKNOWN loc_802982C; // weak
_UNKNOWN loc_802A6B4; // weak
char byte_20000000; // weak
char byte_20000002; // weak
int dword_20000004; // weak
int dword_20000008; // weak
int dword_2000000C; // weak
int dword_20000010; // weak
_DWORD dword_20000014[2]; // weak
int dword_2000001C; // weak
int dword_20000020; // weak
int dword_20000024; // weak
__int16 word_20000028; // weak
__int16 word_2000002A; // weak
int dword_2000002C; // weak
char byte_20000030; // weak
char byte_20000031; // weak
char byte_20000032; // weak
int dword_20000034; // weak
_UNKNOWN unk_20000038; // weak
char byte_2000003C; // weak
char byte_2000003D; // weak
int dword_20000040; // weak
int dword_20000044; // weak
int dword_20000048; // weak
int dword_2000004C; // weak
int dword_20000050; // weak
int dword_20000054; // weak
__int16 word_20000058; // weak
int dword_2000005C; // weak
int dword_20000060; // weak
int (*off_20000064)(void); // weak
int (*off_20000068)(void); // weak
int dword_2000006C; // weak
int dword_20000070; // weak
__int16 word_20000074; // weak
__int16 word_20000076; // weak
__int16 word_20000078; // weak
__int16 word_2000007A; // weak
__int16 word_2000007C; // weak
__int16 word_2000007E; // weak
__int16 word_20000080; // weak
__int16 word_20000082; // weak
__int16 word_20000084; // weak
__int16 word_20000086; // weak
__int16 word_20000088; // weak
__int16 word_2000008A[115]; // weak
__int16 word_20000170; // weak
__int16 word_20000172[115]; // weak
__int16 word_20000258; // weak
_UNKNOWN unk_2000025A; // weak
__int16 word_20000262; // weak
int dword_20000264; // weak
int dword_20000268; // weak
int dword_2000026C; // weak
char byte_20000270; // weak
int dword_20000274; // weak
char byte_2000028C; // weak
int dword_20000290; // weak
char byte_20000294; // weak
int dword_20000298; // weak
int dword_2000029C; // weak
int dword_200002A0; // weak
char byte_200002A4; // weak
char byte_200002A5; // weak
char byte_200002A6; // weak
char byte_200002A7; // weak
char byte_200002A8; // weak
char byte_200002A9; // weak
char byte_200002AA; // weak
char byte_200002AB; // weak
char byte_200002AD; // weak
char byte_200002AE; // weak
char byte_200002AF; // weak
char byte_200002B0; // weak
char byte_200002B1; // weak
char byte_200002B2; // weak
char byte_200002B3; // weak
char byte_200002B4; // weak
char byte_200002B5; // weak
char byte_200002B6; // weak
char byte_200002B7; // weak
char byte_200002B8; // weak
char byte_200002B9; // weak
char byte_200002BA; // weak
char byte_200002BB; // weak
char byte_200002BC; // weak
char byte_200002BD; // weak
char byte_200002BE; // weak
char byte_200002BF; // weak
char byte_200002C0; // weak
char byte_200002C1; // weak
char byte_200002C2; // weak
char byte_200002C3; // weak
char byte_200002C4; // weak
char byte_200002C5; // weak
char byte_200002C6; // weak
char byte_200002C7; // weak
char byte_200002C8; // weak
char byte_200002C9; // weak
char byte_200002CA; // weak
char byte_200002CB; // weak
char byte_200002CC; // weak
char byte_200002CD; // weak
float flt_200002D0; // weak
float flt_200002D4; // weak
float flt_200002D8; // weak
float flt_200002DC; // weak
int dword_200002E0; // weak
int dword_200002E4; // weak
int dword_200002E8; // weak
int dword_200002EC; // weak
int dword_200002F0; // weak
float flt_200002F4; // weak
float flt_200002F8; // weak
int dword_200002FC; // weak
int dword_20000300; // weak
float flt_20000304; // weak
float flt_20000308; // weak
int dword_2000030C; // weak
float flt_20000310; // weak
float flt_20000314; // weak
float flt_20000318; // weak
float flt_2000031C; // weak
int dword_20000320; // weak
float flt_20000324; // weak
int dword_20000328; // weak
int dword_2000032C; // weak
float flt_20000330; // weak
float flt_20000334; // weak
float flt_20000338; // weak
float flt_2000033C; // weak
int dword_20000340; // weak
float flt_20000344; // weak
float flt_20000348; // weak
int dword_2000034C; // weak
int dword_20000350; // weak
float flt_20000354; // weak
float flt_20000358; // weak
float flt_2000035C; // weak
float flt_20000360; // weak
float flt_20000364; // weak
float flt_20000368; // weak
float flt_2000036C; // weak
int dword_20000370; // weak
int dword_20000374; // weak
int dword_20000378; // weak
float flt_2000037C; // weak
int dword_20000380; // weak
int dword_20000384; // weak
int dword_20000388; // weak
float flt_2000038C; // weak
float flt_20000390; // weak
float flt_20000394; // weak
float flt_20000398; // weak
int dword_2000039C; // weak
float flt_200003A0; // weak
int dword_200003A4; // weak
float flt_200003A8; // weak
int dword_200003AC; // weak
int dword_200003B8; // weak
int dword_200003BC; // weak
int dword_200003C0; // weak
int dword_200003C4; // weak
int dword_200003C8; // weak
int dword_200003CC; // weak
int dword_200003D0; // weak
int dword_200003D4; // weak
int dword_200003D8; // weak
int dword_200003DC; // weak
int dword_200003E0; // weak
int dword_200003E4; // weak
int dword_200003E8; // weak
int dword_200003EC; // weak
int dword_200003F0; // weak
int dword_200003F4; // weak
int dword_200003F8; // weak
int dword_200003FC; // weak
int dword_20000400; // weak
int dword_20000404; // weak
float flt_20000408; // weak
float flt_2000040C; // weak
float flt_20000410; // weak
float flt_20000414; // weak
int dword_20000418; // weak
float flt_20000420; // weak
int dword_20000424; // weak
int dword_20000428; // weak
int dword_2000042C; // weak
int dword_20000430; // weak
int dword_20000434; // weak
int dword_20000438; // weak
int dword_2000043C; // weak
int dword_20000440; // weak
int dword_20000444; // weak
int dword_20000448; // weak
int dword_2000044C; // weak
int dword_20000450; // weak
int dword_20000454; // weak
int dword_20000458; // weak
int dword_2000045C; // weak
int dword_20000460; // weak
int dword_20000464; // weak
int dword_20000468; // weak
int dword_2000046C; // weak
int dword_20000470; // weak
int dword_20000474; // weak
char byte_20000478; // weak
char byte_20000479; // weak
char byte_2000047A; // weak
char byte_2000047B; // weak
char byte_2000047C; // weak
char byte_2000047D; // weak
char byte_2000047E; // weak
char byte_2000047F; // weak
char byte_20000480; // weak
int dword_20000488; // weak
int dword_2000048C; // weak
int dword_20000490; // weak
int dword_20000494; // weak
int dword_20000498; // weak
int dword_2000049C; // weak
int dword_200004A0; // weak
int dword_200004A4; // weak
char byte_200004A8; // weak
char byte_200004A9; // weak
char byte_200004AA; // weak
char byte_200004AB; // weak
char byte_200004AC; // weak
char byte_200004AD; // weak
char byte_200004AE; // weak
char byte_200004AF; // weak
char byte_200004B2; // weak
char byte_200004B3; // weak
__int16 word_200004B6; // weak
__int16 word_200004B8; // weak
char byte_200004BA; // weak
char byte_200004BB; // weak
_WORD word_200004BC[3]; // weak
__int16 word_200004C2[2]; // weak
__int16 word_200004C6; // weak
__int16 word_200004C8; // weak
__int16 word_200004CA; // weak
_BYTE algn_200004CC[4]; // weak
char byte_200004D0; // weak
char byte_200004D1; // weak
char byte_200004D2; // weak
float flt_200004D4; // weak
int dword_200004D8; // weak
int dword_200004DC; // weak
float flt_200004E0; // weak
int dword_200004E4; // weak
int dword_200004E8; // weak
int dword_200004EC; // weak
int dword_200004F8; // weak
char byte_200004FC; // weak
char byte_200004FD; // weak
char byte_200004FE; // weak
char byte_200004FF; // weak
char byte_20000500; // weak
char byte_20000501; // weak
char byte_20000502; // weak
char byte_20000503; // weak
char byte_20000504; // weak
char byte_20000505; // weak
char byte_20000506; // weak
char byte_20000507; // weak
__int16 word_20000508; // weak
char byte_2000050C; // weak
char byte_2000050D; // weak
char byte_2000050E; // weak
char byte_20000511; // weak
char byte_20000512; // weak
__int16 word_20000513; // weak
__int16 word_20000515; // weak
char byte_20000517; // weak
char byte_20000518; // weak
__int16 word_2000051A; // weak
__int16 word_2000051C; // weak
__int16 word_2000051E; // weak
char byte_20000520; // weak
char byte_20000521; // weak
char byte_20000522; // weak
int dword_20000524; // weak
_UNKNOWN unk_20000528; // weak
int dword_200008AC; // weak
int dword_200008B0; // weak
_UNKNOWN unk_200008B8; // weak
char byte_200008B9; // weak
float flt_200008BC; // weak
char byte_200008C0; // weak
char byte_200008C1; // weak
__int16 word_200008C2; // weak
int dword_200008C4; // weak
_DWORD dword_200008C8[3]; // weak
_DWORD dword_200008D4[3]; // weak
_DWORD dword_200008E0[4]; // weak
char byte_200008F0; // weak
char byte_200008F1; // weak
char byte_200008F2; // weak
char byte_200008F3; // weak
__int16 word_200008F4; // weak
_WORD word_200008F6; // weak
__int16 word_200008F8; // weak
int dword_200008FC; // weak
__int64 qword_20000900; // weak
char byte_20000908; // weak
char byte_20000909; // weak
_WORD word_2000090A; // weak
char byte_2000090C; // weak
char byte_2000090D; // weak
char byte_2000090E; // weak
char byte_2000090F; // weak
_WORD word_20000910[2]; // weak
__int16 word_20000914; // weak
__int16 word_20000916; // weak
__int16 word_20000918; // weak
_BYTE algn_2000091A[2]; // weak
__int16 word_2000091C; // weak
_BYTE algn_2000091E[2]; // weak
__int16 word_20000920; // weak
char byte_20000922; // weak
_WORD word_20000924; // weak
char byte_20000926; // weak
char byte_20000927; // weak
char byte_20000928; // weak
char byte_20000929; // weak
_BYTE algn_2000092A[2]; // weak
__int16 word_2000092C; // weak
__int16 word_2000092E; // weak
char byte_20000930; // weak
char byte_20000931; // weak
char byte_20000932; // weak
char byte_20000933; // weak
char byte_20000934; // weak
char byte_20000935; // weak
char byte_20000936; // weak
char byte_20000937; // weak
char byte_20000938; // weak
char byte_20000939; // weak
char byte_2000093A; // weak
char byte_2000093B; // weak
char byte_2000093C; // weak
char byte_2000093D; // weak
char byte_2000093E; // weak
char byte_2000093F; // weak
char byte_20000940; // weak
char byte_20000941; // weak
char byte_20000942; // weak
char byte_20000943; // weak
_WORD word_20000944[3]; // weak
__int16 word_2000094A; // weak
_BYTE algn_2000094C[4]; // weak
__int16 word_20000950; // weak
__int16 word_20000952; // weak
_WORD word_20000954; // weak
__int16 word_20000956; // weak
__int16 word_20000958; // weak
_UNKNOWN unk_2000095A; // weak
char byte_2000095F; // weak
char byte_20000960; // weak
char byte_20000961; // weak
_DWORD dword_20000964[10]; // weak
char byte_2000098D[]; // weak
char byte_2000098E; // weak
__int16 word_2000098F; // weak
__int16 word_20000992; // weak
int dword_20000994; // weak
int dword_20000998; // weak
unsigned __int8 byte_2000099C[2048]; // weak
unsigned __int8 byte_2000119C[1024]; // weak
__int16 word_2000159C; // weak
char byte_2000159E; // weak
char byte_2000159F; // weak
int dword_200015A0; // weak
char byte_200015A4; // weak
char byte_200015A5; // weak
char byte_200015A6; // weak
char byte_200015A7; // weak
char byte_200015A8; // weak
char byte_200015A9; // weak
char byte_200015AA; // weak
char byte_200015AB; // weak
char byte_200015AC; // weak
char byte_200015AD; // weak
__int16 word_200015AE; // weak
__int16 word_200015B0; // weak
char byte_200015B2; // weak
__int16 word_200015B4; // weak
int dword_200015B8; // weak
int dword_200015BC; // weak
int dword_200015C0; // weak
int dword_200015C4; // weak
int dword_200015C8; // weak
int dword_200015CC; // weak
int dword_200015D0; // weak
char byte_200015D4; // weak
char byte_200015D5; // weak
char byte_200015D6; // weak
char byte_200015D7; // weak
char byte_200015D8; // weak
char byte_200015D9; // weak
char byte_200015DA; // weak
char byte_200015DB; // weak
char byte_200015DC; // weak
char byte_200015DD; // weak
char byte_200015DE; // weak
char byte_200015DF; // weak
char byte_200015E0; // weak
char byte_200015E1; // weak
char byte_200015E2; // weak
char byte_200015E3; // weak
char byte_200015E4; // weak
char byte_200015E6; // weak
char byte_200015E7; // weak
char byte_200015E8; // weak
__int16 word_200015EA; // weak
__int16 word_200015EC; // weak
__int16 word_200015EE; // weak
_WORD word_200015F0; // weak
_WORD word_200015F2; // weak
__int16 word_200015F4; // weak
int dword_200015F8; // weak
int dword_200015FC; // weak
int dword_20001600; // weak
int dword_20001610; // weak
int dword_20001624; // weak
int dword_20001628; // weak
int dword_2000162C; // weak
int dword_20001630; // weak
int dword_20001638; // weak
int dword_2000163C; // weak
int dword_20001640; // weak
int dword_20001644; // weak
int dword_20001648; // weak
int dword_2000164C; // weak
int dword_20001650; // weak
int dword_20001654; // weak
int dword_20001658; // weak
int dword_2000165C; // weak
int dword_20001660; // weak
int dword_20001664; // weak
int dword_20001668; // weak
int dword_2000166C; // weak
int dword_20001670; // weak
int dword_20001674; // weak
_DWORD dword_20001678; // weak
int dword_2000167C; // weak
int dword_20001680; // weak
int dword_20001684; // weak
int dword_20001688; // weak
int dword_2000168C; // weak
int dword_20001690; // weak
int dword_2000169C; // weak
int dword_200016A0; // weak
char byte_200016A8; // weak
int dword_200016AC; // weak
int dword_200016B0; // weak
int dword_200016B4; // weak
_UNKNOWN unk_200016B8; // weak
int dword_200016BC; // weak
int dword_200016C0; // weak
int dword_200016C4; // weak
int dword_200016C8; // weak
int dword_200016CC; // weak
int dword_200016D0; // weak
int dword_200016D4; // weak
int dword_200016D8; // weak
int dword_200016DC; // weak
int dword_200016E4; // weak
int dword_2000171C; // weak
int dword_20001720; // weak
int dword_20001724; // weak
int dword_20001728; // weak
int dword_2000172C; // weak
int dword_20001730; // weak
int dword_20001734; // weak
int dword_20001738; // weak
int dword_200017AC; // weak
int dword_200017B0; // weak
int dword_200017B4; // weak
int dword_200017B8; // weak
int dword_200017BC; // weak
int dword_200017C0; // weak
int dword_200017C4; // weak
int dword_200017C8; // weak
int dword_2000183C; // weak
int dword_20001840; // weak
int dword_20001844; // weak
int dword_20001938; // weak
int dword_2000193C; // weak
int dword_20001940; // weak
int dword_20001944; // weak
int dword_20001948; // weak
int dword_2000194C; // weak
int dword_20001950; // weak
int dword_2000195C; // weak
int dword_20001960; // weak
int dword_20001964; // weak
int dword_20001968; // weak
int dword_2000196C; // weak
int dword_20001970; // weak
int dword_20001974; // weak
int dword_20001980; // weak
int dword_20001984; // weak
int dword_20001988; // weak
int dword_2000198C; // weak
int dword_20001990; // weak
int dword_20001994; // weak
int dword_20001998; // weak
int dword_200019A4; // weak
int dword_200019A8; // weak
int dword_200019B0; // weak
int dword_200019B4; // weak
int dword_200019BC; // weak
_DWORD dword_200019F8[4]; // weak
int dword_20001A08; // weak
int dword_20001A0C; // weak
int dword_20001A10; // weak
int dword_20001A14; // weak
int dword_20001A54; // weak
int dword_20001A58; // weak
int dword_20001A5C; // weak
int dword_20001AA0; // weak
int dword_20001AA4; // weak
int dword_20001AA8; // weak
int dword_20001AAC; // weak
int dword_20001AB0; // weak
int dword_20001AB4; // weak
int dword_20001AB8; // weak
int dword_20001AEC; // weak
int dword_20001AF0; // weak
int dword_20001AF4; // weak
int dword_20001AF8; // weak
int dword_20001AFC; // weak
int dword_20001B00; // weak
int dword_20001B04; // weak
int dword_20001B38; // weak
int dword_20001B84; // weak
int dword_20001BD0; // weak
int dword_20001BD4; // weak
int dword_20001BD8; // weak
int dword_20001BDC; // weak
int dword_20001BE0; // weak
int dword_20001BE4; // weak
int dword_20001BE8; // weak
int dword_20001BEC; // weak
int dword_20001BF0; // weak
int dword_20001BF4; // weak
float flt_20001BF8; // weak
int dword_20001BFC; // weak
float flt_20001C00; // weak
int dword_20001C04; // weak
int dword_20001C08; // weak
int dword_20001C0C; // weak
int dword_20001C10; // weak
int dword_20001C14; // weak
int dword_20001C18; // weak
int dword_20001C1C; // weak
int dword_20001C20; // weak
int dword_20001C24; // weak
int dword_20001C28; // weak
__int16 word_20001C2C; // weak
__int16 word_20001C2E; // weak
__int16 word_20001C30; // weak
__int16 word_20001C32; // weak
__int16 word_20001C34; // weak
__int16 word_20001C36; // weak
__int16 word_20001C38; // weak
__int16 word_20001C3A; // weak
__int16 word_20001C3C; // weak
__int16 word_20001C3E; // weak
__int16 word_20001C40; // weak
__int16 word_20001C42; // weak
__int16 word_20001C44; // weak
__int16 word_20001C46; // weak
int dword_20001C48; // weak
int dword_20001C4C; // weak
int dword_20001C50; // weak
int dword_20001C54; // weak
int dword_20001C58; // weak
int dword_20001C5C; // weak
int dword_20001C60; // weak
int dword_20001C64; // weak
int dword_20001C68; // weak
int dword_20001C70; // weak
int dword_20001CA8; // weak
int dword_20001CAC; // weak
int dword_20001CB0; // weak
int dword_20001CB4; // weak
int dword_20001CB8; // weak
int dword_20001CBC; // weak
int dword_20001CC0; // weak
int dword_20001CC4; // weak
int dword_20001CC8; // weak
int dword_20001CD0; // weak
int dword_20001D08; // weak
int dword_20001D0C; // weak
int dword_20001D10; // weak
int dword_20001D14; // weak
int dword_20001D18; // weak
int dword_20001D1C; // weak
int dword_20001D20; // weak
int dword_20001D24; // weak
int dword_20001D28; // weak
int dword_20001D30; // weak
int dword_20001D68; // weak
int dword_20001D6C; // weak
int dword_20001D70; // weak
int dword_20001D74; // weak
int dword_20001D78; // weak
int dword_20001D7C; // weak
int dword_20001D80; // weak
int dword_20001D84; // weak
int dword_20001D88; // weak
int dword_20001D90; // weak
int dword_20001DC8; // weak
int dword_20001DCC; // weak
int dword_20001DD0; // weak
int dword_20001DD4; // weak
int dword_20001DD8; // weak
int dword_20001DDC; // weak
int dword_20001DE0; // weak
int dword_20001DE4; // weak
int dword_20001DE8; // weak
int dword_20001DF0; // weak
int dword_20001E28; // weak
int dword_20001E2C; // weak
int dword_20001E30; // weak
int dword_20001E34; // weak
int dword_20001E38; // weak
int dword_20001E3C; // weak
int dword_20001E40; // weak
char byte_20001E44; // weak
char byte_20001E45; // weak
int dword_20001E48; // weak
char byte_20001E4C; // weak
int dword_20001E50; // weak
int dword_20001E54; // weak
int dword_20001E58; // weak
char byte_20001E60; // weak
int dword_20001E64; // weak
char byte_20001E68; // weak
int dword_20001E7C; // weak
int dword_20001E94; // weak
int dword_20001E98; // weak
int dword_20001E9C; // weak
int dword_20001EA0; // weak
int dword_20001EA4; // weak
int dword_20001EA8; // weak
int dword_20001EAC; // weak
char byte_20001EB0; // weak
char byte_20001EB1; // weak
int dword_20001EB4; // weak
char byte_20001EB8; // weak
int dword_20001EBC; // weak
int dword_20001EC0; // weak
int dword_20001EC4; // weak
char byte_20001ECC; // weak
int dword_20001ED0; // weak
char byte_20001ED4; // weak
int dword_20001EE8; // weak
int dword_20001F00; // weak
int dword_20001F04; // weak
int dword_20001F08; // weak
int dword_20001F0C; // weak
int dword_20001F10; // weak
int dword_20001F14; // weak
int dword_20001F18; // weak
char byte_20001F1C; // weak
char byte_20001F1D; // weak
int dword_20001F20; // weak
char byte_20001F24; // weak
int dword_20001F28; // weak
int dword_20001F2C; // weak
int dword_20001F30; // weak
char byte_20001F38; // weak
int dword_20001F3C; // weak
char byte_20001F40; // weak
int dword_20001F54; // weak
int dword_20001F6C; // weak
int dword_20001F70; // weak
int dword_20001F74; // weak
int dword_20001F78; // weak
int dword_20001F7C; // weak
int dword_20001F80; // weak
int dword_20001F84; // weak
char byte_20001F88; // weak
char byte_20001F89; // weak
int dword_20001F8C; // weak
char byte_20001F90; // weak
int dword_20001F94; // weak
int dword_20001F98; // weak
int dword_20001F9C; // weak
char byte_20001FA4; // weak
int dword_20001FA8; // weak
char byte_20001FAC; // weak
int dword_20001FC0; // weak
int dword_20001FD8; // weak
int dword_20001FDC; // weak
int dword_20001FE0; // weak
int dword_20001FE4; // weak
int dword_20001FE8; // weak
int dword_20001FEC; // weak
int dword_20001FF0; // weak
char byte_20001FF4; // weak
char byte_20001FF5; // weak
int dword_20001FF8; // weak
char byte_20001FFC; // weak
int dword_20002000; // weak
int dword_20002004; // weak
int dword_20002008; // weak
char byte_20002010; // weak
int dword_20002014; // weak
char byte_20002018; // weak
int dword_2000201C; // weak
int dword_20002020; // weak
int dword_20002024; // weak
int dword_20002028; // weak
int dword_2000202C; // weak
__int16 word_20002044; // weak
__int16 word_20002046; // weak
__int16 word_20002048; // weak
int dword_20002050; // weak
int dword_20002054; // weak
int dword_20002058; // weak
int dword_2000205C; // weak
char byte_20002060; // weak
char byte_20002061; // weak
char byte_20002062; // weak
int dword_20002064; // weak
int dword_20002068; // weak
int dword_2000206C; // weak
int dword_20002070; // weak
int dword_20002084; // weak
int dword_20002088; // weak
int dword_2000208C; // weak
int dword_200020B4; // weak
int dword_200020B8; // weak
int dword_200020BC; // weak
int dword_200020C0; // weak
int dword_200020C4; // weak
int dword_200020C8; // weak
int dword_200020CC; // weak
int dword_200020D0; // weak
int dword_200020D4; // weak
int dword_200020D8; // weak
int dword_20002100[5]; // weak
int dword_20002114[5]; // weak
int dword_20002128[5]; // weak
int dword_2000213C; // weak
int dword_20002140; // weak
int dword_20002144; // weak
int dword_20002148; // weak
int dword_2000214C; // weak
int dword_20002154; // weak
int dword_20002158; // weak
int dword_2000215C; // weak
int dword_20002164; // weak
int dword_20002168; // weak
int dword_2000216C; // weak
int dword_20002170; // weak
int dword_20002174; // weak
int dword_20002178; // weak
int dword_2000217C; // weak
int dword_20002180; // weak
int dword_20002184; // weak
int dword_200021B0[]; // weak
int dword_200021B4; // weak
int dword_200021B8; // weak
int dword_200021BC; // weak
int dword_20002224; // weak
_UNKNOWN unk_20002228; // weak
__int16 word_20002428; // weak
float flt_2000242C; // weak
float flt_20002430; // weak
float flt_20002434; // weak
float flt_20002438; // weak
float flt_2000243C; // weak
float flt_20002440; // weak
float flt_20002444; // weak
float flt_20002448; // weak
int dword_2000244C; // weak
float flt_20002450; // weak
float flt_20002454; // weak
float flt_20002458; // weak
float flt_2000245C[60]; // weak
_DWORD dword_2000254C[25]; // weak
int dword_200025B0; // weak
float flt_200025B4; // weak
float flt_200025B8; // weak
float flt_200025BC; // weak
float flt_200025C0; // weak
float flt_200025C4; // weak
float flt_200025C8[15]; // weak
int dword_20002604; // weak
float flt_20002608; // weak
float flt_20002610; // weak
int dword_20002618; // weak
int dword_20002624; // weak
_UNKNOWN unk_20002654; // weak
char byte_200026CC; // weak
float flt_200026D0; // weak
_UNKNOWN unk_2000272C; // weak
int dword_2000273C; // weak
float flt_2000275C; // weak
float flt_20002760; // weak
int dword_20002764; // weak
int dword_20002768; // weak
int dword_2000276C; // weak
int dword_20002770; // weak
_UNKNOWN unk_20002778; // weak
int dword_2000278C; // weak
int dword_20002798; // weak
_UNKNOWN unk_200027A0; // weak
float flt_200027A8; // weak
float flt_200027AC; // weak
int dword_200027B4; // weak
float flt_200027BC[5]; // weak
float flt_200027D0; // weak
float flt_200027DC[6]; // weak
float flt_200027F4; // weak
float flt_200027F8; // weak
float flt_200027FC; // weak
float flt_20002804; // weak
float flt_20002810; // weak
float flt_20002814; // weak
float flt_20002824; // weak
_DWORD dword_20002828[4]; // weak
float flt_20002858; // weak
float flt_2000285C; // weak
float flt_20002864; // weak
float flt_20002870; // weak
float flt_20002874; // weak
float flt_20002884; // weak
float flt_20002888[2]; // weak
float flt_20002890; // weak
float flt_2000289C; // weak
float flt_200028A0[5]; // weak
int dword_200028B4; // weak
int dword_200028B8; // weak
int dword_200028BC; // weak
int dword_200028C0; // weak
int dword_200028C4; // weak
_DWORD dword_200028EC[250]; // weak
_UNKNOWN unk_20002CD4; // weak
int dword_20002D4C; // weak
__int16 word_20002D50; // weak
int dword_20002D52; // weak
__int16 word_20002D56; // weak
char byte_20002D58; // weak
int dword_20002D5A; // weak
__int16 word_20002D5E; // weak
int dword_20002D60; // weak
int dword_20002D64; // weak
int dword_20002D68; // weak
__int16 word_20002D6D; // weak
int dword_20002D6F; // weak
int dword_20002D73; // weak
int dword_20002D77; // weak
int dword_20002D7B; // weak
int dword_20002D7F; // weak
int dword_20002D83; // weak
int dword_20002D87; // weak
int dword_20002D8B; // weak
int dword_20002D8F; // weak
int dword_20002D93; // weak
__int16 word_20002D97; // weak
__int16 word_20002D99; // weak
int dword_20002D9C[]; // weak
int dword_20002DA0; // weak
int dword_20002DA4; // weak
int dword_20002DA8; // weak
int dword_20002DAC[]; // weak
int dword_20002DB4; // weak
int dword_20002DB8; // weak
int dword_20002DBC[]; // weak
int dword_20002DC4; // weak
int dword_20002DC8[]; // weak
int dword_20002DD0; // weak
int dword_20002DD4[]; // weak
int dword_20002DD8; // weak
int dword_20002DDC; // weak
__int16 word_20002DE0; // weak
__int16 word_20002DE2; // weak
__int16 word_20002DE4; // weak
int dword_20002DE8; // weak
int dword_20002DEC; // weak
int dword_20002DF0; // weak
char byte_20002DF4; // weak
char byte_20002DF5; // weak
_UNKNOWN unk_20002E08; // weak
_BYTE byte_20002E1C[20]; // weak
__int16 word_20002E30; // weak
__int16 word_20002E32; // weak
__int16 word_20002E34; // weak
char byte_20002E37[]; // weak
char byte_20002E38; // weak
char byte_20002E39; // weak
__int16 word_20002E9D; // weak
int dword_20002E9F; // weak
int dword_20002EA3; // weak
char byte_20002EA7; // weak
char byte_20002EA8; // weak
char byte_20002EA9; // weak
char byte_20002EAA; // weak
char byte_20002EAB; // weak
char byte_20002EAC; // weak
char byte_20002EAD; // weak
char byte_20002EAE; // weak
__int16 word_20002EAF; // weak
char byte_20002EB1[32]; // weak
char byte_20002ED1[64]; // weak
char byte_20002F11; // weak
char byte_20002F12; // weak
char byte_20002F13; // weak
char byte_20002F14; // weak
int dword_20002F16; // weak
int dword_20002F1A; // weak
int dword_20002F1E; // weak
int dword_20002F22; // weak
int dword_20002F26; // weak
int dword_20002F2A; // weak
int dword_20002F2E; // weak
int dword_20002F32; // weak
int dword_20002F36; // weak
char byte_20002F3A[]; // weak
char byte_20002F3B; // weak
char byte_20002F3C; // weak
__int16 word_20002F3D; // weak
__int16 word_20002F40; // weak
char byte_2000303A[]; // weak
char byte_2000303B; // weak
unsigned __int8 byte_2000303C[254]; // weak
int dword_2000353A; // weak
int dword_2000353E; // weak
int dword_20003542; // weak
int dword_20003546; // weak
_BYTE byte_2000354A[258]; // weak
_UNKNOWN unk_2000364C; // weak
float flt_20003650; // weak
float flt_20003654; // weak
float flt_20003658; // weak
float flt_2000365C; // weak
int dword_20003660; // weak
float flt_20003668; // weak
float flt_2000366C; // weak
float flt_20003670; // weak
float flt_20003674; // weak
float flt_20003678; // weak
float flt_2000367C; // weak
float flt_20003680; // weak
float flt_20003684; // weak
float flt_20003688; // weak
int dword_2000368C; // weak
float flt_20003690; // weak
float flt_20003694; // weak
float flt_20003698; // weak
float flt_200036A0; // weak
float flt_200036A4; // weak
char byte_200036A8; // weak
char byte_200036A9; // weak
char byte_200036AC[]; // weak
char byte_200036AD; // weak
char byte_200036AE; // weak
char byte_200036AF; // weak
char byte_200036B0; // weak
char byte_200036B1; // weak
char byte_200036B2; // weak
char byte_200036B3; // weak
char byte_200036B4; // weak
__int16 word_200036B5; // weak
__int16 word_200036B7; // weak
__int16 word_200036B9; // weak
char byte_200036BB; // weak
char byte_200036BC; // weak
char byte_200036BD; // weak
_BYTE byte_2000373B[128]; // weak
char byte_200037BB[26]; // weak
int dword_200037D5; // weak
int dword_200037D9; // weak
int dword_200037DD; // weak
char byte_200037E1; // weak
char byte_200037E2[256]; // weak
char byte_200038E2; // weak
int dword_200038E3; // weak
int dword_200038E7; // weak
char byte_200038EB[17]; // weak
char byte_200038FC[]; // weak
char byte_200038FD; // weak
char byte_200038FE; // weak
char byte_200038FF; // weak
char byte_20003900; // weak
_UNKNOWN unk_20003901; // weak
__int16 word_20003AFC; // weak
char byte_20003AFE; // weak
__int16 word_20003AFF; // weak
__int16 word_20003B01; // weak
__int16 word_20003B03; // weak
__int16 word_20003B05; // weak
__int16 word_20003B07; // weak
__int16 word_20003B09; // weak
__int16 word_20003B0B; // weak
__int16 word_20003B0D; // weak
__int16 word_20003B0F; // weak
char byte_20003B11; // weak
char byte_20003B12; // weak
char byte_20003B13; // weak
char byte_20003B14; // weak
char byte_20003B15; // weak
char byte_20003B16; // weak
char byte_20003B17; // weak
char byte_20003B18; // weak
char byte_20003B19; // weak
char byte_20003B1A; // weak
__int16 word_20003B1B; // weak
__int16 word_20003B1D; // weak
__int16 word_20003B1F; // weak
__int16 word_20003B21; // weak
__int16 word_20003B23; // weak
__int16 word_20003B25; // weak
__int16 word_20003B27; // weak
__int16 word_20003B29; // weak
__int16 word_20003B2B; // weak
__int16 word_20003B2D; // weak
__int16 word_20003B2F; // weak
__int16 word_20003B31; // weak
__int16 word_20003B33; // weak
__int16 word_20003B35; // weak
__int16 word_20003B37; // weak
__int16 word_20003B39; // weak
int dword_20003B3B; // weak
int dword_20003B3F; // weak
int dword_20003B43; // weak
int dword_20003B47; // weak
int dword_20003B4B; // weak
int dword_20003B4F; // weak
int dword_20003B53; // weak
int dword_20003B57; // weak
int dword_20003B5B; // weak
int dword_20003B5F; // weak
int dword_20003B63; // weak
int dword_20003B67; // weak
_UNKNOWN unk_20003B6B; // weak
_UNKNOWN unk_20003BEB; // weak
__int64 qword_20003BF8; // weak
int dword_20003C00; // weak
int dword_20003C04; // weak
int dword_20003C08; // weak
int dword_20003C0C; // weak
__int16 word_20003C10; // weak
__int16 word_20003C12; // weak
__int16 word_20003C14; // weak
__int16 word_20003C16; // weak
__int16 word_20003C18; // weak
__int16 word_20003C1A; // weak
__int16 word_20003C1C; // weak
__int16 word_20003C1E; // weak
char byte_20003C20; // weak
char byte_20003C21; // weak
char byte_20003C22; // weak
char byte_20003C23; // weak
char byte_20003C24; // weak
char byte_20003C25; // weak
char byte_20003C26[13]; // weak
_UNKNOWN unk_20003C33; // weak
char byte_20003C57; // weak
char byte_20003C58; // weak
int dword_20003C59; // weak
__int16 word_20003C5D; // weak
_BYTE byte_20003D71[180]; // weak
__int16 word_20003E25; // weak
int dword_20003E27; // weak
__int16 word_20003E2B; // weak
int dword_20003E2D; // weak
__int16 word_20003E31; // weak
int dword_20003E33; // weak
__int16 word_20003E37; // weak
char byte_20003E39; // weak
char byte_20003E3A; // weak
__int16 word_20003E3B; // weak
int dword_20003E3D; // weak
int dword_20003E41; // weak
int dword_20003E45; // weak
__int16 word_20003E49; // weak
__int16 word_20003E4B; // weak
int dword_20003E4D; // weak
int dword_20003E51; // weak
__int16 word_20003E55; // weak
__int16 word_20003E57; // weak
__int16 word_20003E59; // weak
__int16 word_20003E5B; // weak
__int16 word_20003E5D; // weak
__int16 word_20003E5F; // weak
__int16 word_20003E61; // weak
__int16 word_20003E63; // weak
__int16 word_20003E65; // weak
__int16 word_20003E67; // weak
__int16 word_20003E69; // weak
__int16 word_20003E6B; // weak
__int16 word_20003E6D; // weak
__int16 word_20003E6F; // weak
__int16 word_20003E71; // weak
__int16 word_20003E73; // weak
_BYTE byte_20003E75[128]; // weak
char byte_20003EF5[]; // weak
char byte_20003EF6; // weak
char byte_20003EF7; // weak
char byte_20003EF8; // weak
char byte_20003EF9; // weak
char byte_20003EFA; // weak
char byte_20003EFB; // weak
char byte_20003EFC; // weak
char byte_20003EFD; // weak
char byte_20003EFE; // weak
char byte_20003EFF; // weak
char byte_20003F00; // weak
char byte_20003F01; // weak
__int16 word_20003F75; // weak
__int16 word_20003F77; // weak
char byte_20003F79; // weak
char byte_20003F7A; // weak
char byte_20003F7B; // weak
char byte_20003F7C; // weak
char byte_20003F7D; // weak
__int16 word_20003F7E; // weak
char byte_20003F80; // weak
__int16 word_20003F81; // weak
int dword_20003F83; // weak
int dword_20003F87; // weak
int dword_20003F8B; // weak
int dword_20003F8F; // weak
int dword_20003F93; // weak
__int16 word_20003F97; // weak
__int16 word_20003F99; // weak
char byte_20003F9B; // weak
char byte_20003F9C; // weak
char byte_20003F9D; // weak
int dword_20003F9E; // weak
int dword_20003FA2; // weak
__int16 word_20003FA6; // weak
__int16 word_20003FA8; // weak
int dword_20003FAA; // weak
int dword_20003FAE; // weak
char byte_20003FB2; // weak
char byte_20003FB3; // weak
int dword_20003FB4; // weak
int dword_20003FB8; // weak
char byte_20003FBC; // weak
__int16 word_20003FBD; // weak
__int16 word_20003FBF; // weak
char byte_20003FC1; // weak
char byte_20003FC2; // weak
char byte_20003FC3; // weak
__int16 word_20003FC4; // weak
_UNKNOWN unk_20003FC6; // weak
char byte_20003FD3; // weak
char byte_20003FD4; // weak
char byte_20003FD5; // weak
char byte_20003FD6; // weak
char byte_20003FD7; // weak
char byte_20003FD8; // weak
_UNKNOWN unk_20003FD9; // weak
char byte_20004029[8]; // weak
char byte_20004031; // weak
char byte_20004032; // weak
char byte_20004033; // weak
char byte_20004034; // weak
char byte_20004035; // weak
char byte_20004036; // weak
char byte_20004037; // weak
char byte_20004038; // weak
char byte_20004039; // weak
_UNKNOWN unk_2000403A; // weak
char byte_20004236; // weak
char byte_20004237; // weak
int dword_20004238; // weak
int dword_2000423C; // weak
int dword_20004240; // weak
char byte_20004245[]; // weak
char byte_20004246; // weak
char byte_20004247; // weak
__int16 word_20004248; // weak
char byte_2000424A[512]; // weak
unsigned __int8 byte_2000444A[1024]; // weak
char byte_2000484A[1026]; // weak
char byte_20004C4C[1028]; // weak
int dword_20005050; // weak
int dword_20005054; // weak
int dword_20005058; // weak
unsigned __int16 word_2000505C[72]; // weak
char byte_200050EC; // weak
char byte_200050ED; // weak
char byte_200050EE; // weak
int dword_200050F0; // weak
int dword_200050F4; // weak
int dword_200050F8; // weak
int dword_200050FC; // weak
unsigned __int16 dword_20005100[13909]; // weak
int dword_20010D98; // weak
int dword_20010D9C; // weak
int dword_20010DA0; // weak
_UNKNOWN unk_20010DA4; // weak
char byte_20010EEC; // weak
char byte_20010EED; // weak
char byte_20010EEE; // weak
__int16 word_20010EEF; // weak
__int16 word_20010EF1; // weak
int dword_20010EF3; // weak
int dword_20010EF7; // weak
int dword_20010EFB; // weak
int dword_20010EFF; // weak
int dword_20010F03; // weak
__int16 word_20010F07; // weak
int dword_20010F09; // weak
int dword_20010F0D; // weak
unsigned __int8 byte_20010F11[67]; // weak
char byte_20010F54; // weak
int dword_20010F58; // weak
int dword_20010F5C; // weak
int dword_20010F60; // weak
int dword_20010F64; // weak
int dword_20010F68; // weak
int dword_20010F6C; // weak
char byte_20010F70[]; // weak
char byte_20010F71; // weak
char byte_20010F72; // weak
__int16 word_20011072; // weak
char byte_20011074[32]; // weak
int dword_20011094; // weak
__int16 word_20011098; // weak
char byte_2001109A; // weak
_UNKNOWN unk_2001109B; // weak
int dword_200110A8; // weak
int dword_200110AE; // weak
int dword_200110B2; // weak
int dword_200110B6; // weak
char byte_200110BB; // weak
__int16 word_200110BC; // weak
unsigned __int8 byte_200110C0[44]; // weak
int dword_200110EC; // weak
int dword_200110F0; // weak
int dword_200110F4; // weak
int dword_200110F8; // weak
char byte_200110FC; // weak
int dword_20011100; // weak
char byte_20011104; // weak
int dword_20011108; // weak
char byte_2001110C; // weak
char byte_2001110D; // weak
int dword_20011110; // weak
int dword_20011114; // weak
int dword_20011118; // weak
int dword_2001111C; // weak
int dword_20011120; // weak
int dword_20011124; // weak
int dword_20011128; // weak
int dword_2001112C; // weak
int dword_20011130; // weak
int dword_20011134; // weak
char byte_20011138[128]; // weak
_BYTE byte_200111B8[952]; // weak
int dword_200115B8; // weak
int dword_200115BC; // weak
int dword_200115C0; // weak
int dword_200115C4; // weak
int dword_200115C8; // weak
int dword_200115CC; // weak
int dword_200115D0; // weak
int dword_200115D4; // weak
_DWORD dword_200115D8[5]; // weak
_BYTE byte_200115EC[12]; // weak
int dword_200115F8[160]; // weak
_DWORD dword_20011878[10]; // weak
int dword_200118A0; // weak
int dword_200118A4; // weak
int dword_200118AC; // weak
_DWORD dword_200118B4[3]; // weak
int dword_200118C0; // weak
int dword_200118C8; // weak
int dword_200118CC; // weak
int SYST_CSR; // weak
int SYST_RVR; // weak
int SYST_CVR; // weak
char NVIC_IPR_0; // weak
int CPUID; // weak
int ICSR; // weak
int AIRCR; // weak
int SHPR3; // weak
int CPACR; // weak
int FPCCR; // weak
int dword_E0042000; // weak


//----- (080021E0) --------------------------------------------------------
// attributes: thunk
void __fastcall sub_80021E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  sub_801FF14((int)sub_801FF14, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0800220C) --------------------------------------------------------
int __fastcall sub_800220C(int a1, void *a2, void *a3, void *a4)
{
  void *v4; // r4
  void *v5; // r5
  void *v6; // r6
  int v7; // r7

  _R0 = *(_DWORD *)*loc_8002230;
  __asm { MSR.W           MSP, R0 }
  _R0 = 0;
  __asm { MSR.W           CONTROL, R0 }
  __enable_irq();
  __asm { CPSIE           F }
  __dsb(0xFu);
  __isb(0xFu);
  __asm { STC             p0, c14, [R8] }
  return sub_8002234(linux_eabi_syscall(v7, 0, a2, a3, a4, v4, v5, v6));
}
// 800222A: variable 'v7' is possibly undefined
// 800222A: variable 'v4' is possibly undefined
// 800222A: variable 'v5' is possibly undefined
// 800222A: variable 'v6' is possibly undefined
// 8002234: using guessed type int __fastcall sub_8002234(_DWORD);

//----- (08002234) --------------------------------------------------------
int *sub_8002234()
{
  int *result; // r0

  result = &CPACR;
  CPACR |= 0xF00000u;
  return result;
}
// E000ED88: using guessed type int CPACR;

//----- (080022A4) --------------------------------------------------------
unsigned int sub_80022A4()
{
  return __get_CPSR();
}

//----- (08002332) --------------------------------------------------------
unsigned int __fastcall _aeabi_memcpy8(unsigned int result, unsigned int a2, unsigned int a3)
{
  int v3; // r3
  char v4; // t1

  if ( !((result | a2) << 30) )
  {
    while ( a3 >= 4 )
    {
      v3 = *(_DWORD *)a2;
      a2 += 4;
      a3 -= 4;
      *(_DWORD *)result = v3;
      result += 4;
    }
  }
  while ( a3-- != 0 )
  {
    v4 = *(_BYTE *)a2++;
    *(_BYTE *)result++ = v4;
  }
  return result;
}

//----- (08002356) --------------------------------------------------------
_BYTE *__fastcall sub_8002356(_BYTE *result, int a2, char a3)
{
  while ( a2-- != 0 )
    *result++ = a3;
  return result;
}

//----- (08002364) --------------------------------------------------------
_BYTE *__fastcall sub_8002364(_BYTE *a1, int a2)
{
  return sub_8002356(a1, a2, 0);
}

//----- (08002368) --------------------------------------------------------
_BYTE *__fastcall sub_8002368(_BYTE *a1, char a2, int a3)
{
  sub_8002356(a1, a3, a2);
  return a1;
}

//----- (0800237A) --------------------------------------------------------
int __fastcall sub_800237A(int result, unsigned __int8 *a2)
{
  _BYTE *v2; // r2
  int v4; // t1

  v2 = (_BYTE *)(result - 1);
  while ( *++v2 )
    ;
  do
  {
    v4 = *a2++;
    *v2++ = v4;
  }
  while ( v4 );
  return result;
}

//----- (08002392) --------------------------------------------------------
unsigned __int8 *__fastcall strstr(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  unsigned __int8 *result; // r0
  unsigned __int8 *v6; // t1
  unsigned __int8 *v7; // r4
  unsigned __int8 *v8; // t1

  while ( 1 )
  {
    v3 = a1;
    v4 = a2;
    do
    {
      v6 = (unsigned __int8 *)*v3++;
      result = v6;
      v8 = (unsigned __int8 *)*v4++;
      v7 = v8;
    }
    while ( result && result == v7 );
    if ( !v7 )
      break;
    if ( !result )
      return result;
    ++a1;
  }
  return a1;
}

//----- (080023B6) --------------------------------------------------------
_BYTE *__fastcall sub_80023B6(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  _BYTE *v3; // r4
  int v4; // r3

  v3 = a1;
  while ( a3-- != 0 )
  {
    v4 = *a2;
    *a1++ = v4;
    if ( v4 )
      ++a2;
  }
  return v3;
}

//----- (080023CE) --------------------------------------------------------
int __fastcall sub_80023CE(int a1, unsigned __int8 a2)
{
  int v2; // r2
  int result; // r0
  int v4; // r1
  int v5; // t1

  v2 = a2;
  result = a1 - 1;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)++result;
    v4 = v5;
    if ( v2 == v5 )
      break;
    if ( !v4 )
      return 0;
  }
  return result;
}

//----- (080023E2) --------------------------------------------------------
unsigned __int8 *__fastcall sub_80023E2(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r2

  v1 = a1 + 1;
  while ( *a1++ )
    ;
  return (unsigned __int8 *)(a1 - v1);
}

//----- (080023F0) --------------------------------------------------------
int __fastcall sub_80023F0(int a1, int a2)
{
  int i; // r2
  int v3; // r3
  int v4; // r4

  for ( i = 0; ; ++i )
  {
    v3 = *(unsigned __int8 *)(a1 + i);
    v4 = *(unsigned __int8 *)(a2 + i);
    if ( v3 != v4 || !*(_BYTE *)(a1 + i) )
      break;
  }
  return (unsigned __int8)v3 - (unsigned __int8)v4;
}

//----- (0800240C) --------------------------------------------------------
_BYTE *__fastcall sub_800240C(_BYTE *a1, unsigned __int8 *a2)
{
  _BYTE *v2; // r3
  int v3; // t1

  v2 = a1;
  do
  {
    v3 = *a2++;
    *a1++ = v3;
  }
  while ( v3 );
  return v2;
}

//----- (0800241E) --------------------------------------------------------
int __fastcall sub_800241E(int a1, int a2, unsigned int a3)
{
  int result; // r0
  unsigned int i; // r3

  result = 0;
  for ( i = 0; i < a3; ++i )
  {
    result = *(unsigned __int8 *)(a1 + i) - *(unsigned __int8 *)(a2 + i);
    if ( result || !*(_BYTE *)(a1 + i) )
      break;
  }
  return result;
}

//----- (0800243C) --------------------------------------------------------
unsigned int __fastcall sub_800243C(_BYTE *a1, _BYTE *a2)
{
  unsigned int v2; // r4
  _BYTE *i; // r2
  int v4; // r3

  if ( !a1 )
    a1 = (_BYTE *)dword_200016B4;
  v2 = 0;
  while ( *a1 )
  {
    for ( i = a2; ; ++i )
    {
      v4 = (unsigned __int8)*i;
      if ( !*i || (unsigned __int8)*a1 == v4 )
        break;
    }
    if ( (unsigned __int8)v4 | v2 )
    {
      if ( *i && v2 )
      {
        *a1++ = 0;
        break;
      }
    }
    else
    {
      v2 = (unsigned int)a1;
    }
    ++a1;
  }
  dword_200016B4 = (int)a1;
  return v2;
}
// 200016B4: using guessed type int dword_200016B4;

//----- (08002480) --------------------------------------------------------
_BYTE *__fastcall sub_8002480(_BYTE *result, char a2)
{
  _BYTE *v2; // r2

  v2 = result;
  while ( *result )
    ++result;
  while ( --result >= v2 )
  {
    if ( *result == a2 )
      return result;
  }
  return 0;
}

//----- (080024A0) --------------------------------------------------------
_BYTE *__fastcall sub_80024A0(_BYTE *result, _BYTE *a2)
{
  _BYTE *i; // r2

  while ( *result )
  {
    for ( i = a2; *i; ++i )
    {
      if ( *i == *result )
        return result;
    }
    ++result;
  }
  return 0;
}

//----- (080024C0) --------------------------------------------------------
int scanf(int a1, int a2, ...)
{
  _DWORD v3[9]; // [sp+0h] [bp-48h] BYREF
  _DWORD v4[4]; // [sp+24h] [bp-24h] BYREF
  va_list varg_r2; // [sp+40h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  v4[0] = a1;
  v4[2] = a1;
  va_copy((va_list)v3, varg_r2);
  v4[1] = -1;
  v4[3] = 0;
  v3[6] = &loc_80030FC;
  v3[7] = &loc_800311A;
  return sub_80028E0((int)v4, a2, v3);
}

//----- (080024F8) --------------------------------------------------------
int __fastcall scanf_int(int a1, int a2, unsigned int a3, int a4)
{
  int v5; // r4
  int v6; // r6
  int v8; // r7
  int v9; // r8
  unsigned int v10; // r10
  unsigned int v11; // r4
  int v13; // r0
  int v14; // r0
  signed int v15; // r0
  int v16; // r0
  _BYTE **v17; // r1
  _BYTE *v18; // r1
  _BYTE **v19; // r0
  _BYTE *v20; // r0

  v6 = *(_DWORD *)(a4 + 8);
  v5 = *(_DWORD *)(a4 + 4);
  v8 = -1;
  v9 = 0;
  do
  {
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  }
  while ( (*(int (__fastcall **)(unsigned int))(a4 + 32))(v10) );
  if ( v10 == -1 )
    return -1;
  v11 = v5 & 0xFFFFF9FF;
  if ( v6 <= 0 )
    goto LABEL_12;
  if ( (v11 & 0x40) != 0 )
  {
    if ( v10 != 43 )
    {
      if ( v10 != 45 )
        goto LABEL_11;
      v11 |= 0x400u;
    }
    ++v8;
    --v6;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
    if ( v6 <= 0 )
    {
LABEL_12:
      if ( a3 )
        goto LABEL_26;
      v14 = 10;
      goto LABEL_24;
    }
  }
LABEL_11:
  if ( v10 != 48 )
    goto LABEL_12;
  --v6;
  v11 |= 0x200u;
  ++v8;
  v13 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  v10 = v13;
  if ( v6 <= 0 || v13 != 120 && v13 != 88 )
  {
    if ( a3 )
      goto LABEL_26;
    v14 = 8;
    goto LABEL_24;
  }
  if ( !a3 || a3 == 16 )
  {
    --v6;
    v11 &= ~0x200u;
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
    v14 = 16;
LABEL_24:
    a3 = v14;
  }
LABEL_26:
  while ( v6 > 0 )
  {
    v15 = sub_80028B6(v10, a3);
    if ( v15 < 0 )
      break;
    v9 = v15 + v9 * a3;
    --v6;
    v11 |= 0x200u;
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  }
  (*(void (__fastcall **)(int))(a4 + 28))(a2);
  if ( (v11 & 0x200) == 0 )
    return -2;
  if ( !(v11 << 31) )
  {
    if ( (v11 & 0x40) != 0 )
    {
      if ( (v11 & 0x400) != 0 )
        v16 = -v9;
      else
        v16 = v9;
      v17 = *(_BYTE ***)a4;
      *(_DWORD *)a4 += 4;
      v18 = *v17;
      if ( (v11 & 0x800) != 0 )
      {
        *v18 = v16;
      }
      else if ( (v11 & 8) != 0 )
      {
        *(_WORD *)v18 = v16;
      }
      else
      {
        *(_DWORD *)v18 = v16;
      }
    }
    else
    {
      v19 = *(_BYTE ***)a4;
      *(_DWORD *)a4 += 4;
      v20 = *v19;
      if ( (v11 & 0x800) != 0 )
      {
        *v20 = v9;
      }
      else if ( (v11 & 8) != 0 )
      {
        *(_WORD *)v20 = v9;
      }
      else
      {
        *(_DWORD *)v20 = v9;
      }
    }
  }
  return v8;
}

//----- (08002644) --------------------------------------------------------
int __fastcall sub_8002644(char *a1)
{
  _DWORD *v2; // r0
  int v3; // r4
  _DWORD *v4; // r5
  int result; // r0

  v2 = sub_801E2E0();
  v3 = *v2;
  v4 = v2;
  result = strtol(a1, 0, 10);
  *v4 = v3;
  return result;
}

//----- (08002764) --------------------------------------------------------
void __fastcall sub_8002764(unsigned int a1)
{
  sub_8002A38(a1, 0, 0);
}

//----- (08002814) --------------------------------------------------------
int __fastcall sub_8002814(__int64 a1)
{
  unsigned int v1; // r3
  int v2; // r2
  int result; // r0
  int v4; // r4
  int v5; // r1

  v1 = HIDWORD(a1) & 0x80000000;
  HIDWORD(a1) &= ~0x80000000;
  if ( !a1 )
    return 0;
  v2 = (HIDWORD(a1) >> 20) - 896;
  HIDWORD(a1) &= 0xFFFFFu;
  if ( v2 <= 0 )
    return 0;
  v4 = a1 >> 29;
  v5 = 8 * a1;
  result = v4 + v1 + (v2 << 23);
  if ( v5 < 0 )
  {
    ++result;
    if ( !(2 * v5) )
      return result & 0xFFFFFFFE;
  }
  return result;
}

//----- (08002878) --------------------------------------------------------
int __fastcall sub_8002878(int a1, int a2, int a3)
{
  if ( a3 < 32 )
    return a1 << a3;
  else
    return 0;
}

//----- (08002896) --------------------------------------------------------
unsigned int __fastcall ll_ushift_r(unsigned int a1, unsigned int a2, int a3)
{
  if ( a3 < 32 )
    return (a1 >> a3) | (a2 << (32 - a3));
  else
    return a2 >> (a3 - 32);
}

//----- (080028B6) --------------------------------------------------------
unsigned int __fastcall sub_80028B6(unsigned int result, unsigned int a2)
{
  if ( result < 0x3A )
    result -= 48;
  if ( (result & 0xFFFFFFDF) >= 0x41 )
    result = (result & 0xFFFFFFDF) - 55;
  if ( result >= a2 )
    return -1;
  return result;
}

//----- (080028D4) --------------------------------------------------------
int __fastcall sub_80028D4(_DWORD *a1, int a2)
{
  int v2; // r3

  v2 = *(unsigned __int8 *)*a1;
  *a1 += a2;
  return v2;
}

//----- (080028E0) --------------------------------------------------------
int __fastcall sub_80028E0(int a1, int a2, _DWORD *a3)
{
  a3[3] = a2;
  a3[5] = 134230229;
  a3[8] = 134231473;
  a3[4] = 0;
  return sub_8002DC4(a1, (int)a3);
}

//----- (080028FC) --------------------------------------------------------
int __fastcall sub_80028FC(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // r2
  int v2; // r3

  v1 = a1[1];
  if ( v1 && (v2 = **a1) != 0 )
  {
    ++*a1;
    a1[1] = v1 - 1;
    return v2;
  }
  else
  {
    a1[3] = (unsigned __int8 *)1;
    return -1;
  }
}

//----- (0800291A) --------------------------------------------------------
int __fastcall sbackspace(int *a1)
{
  int v1; // r2
  int v2; // r1

  v1 = a1[1];
  if ( !v1 )
    return -1;
  v2 = *a1;
  if ( a1[3] || a1[2] == v2 )
    return -1;
  *a1 = v2 - 1;
  a1[1] = v1 + 1;
  return 0;
}

//----- (0800293C) --------------------------------------------------------
int __fastcall strtol(char *nptr, char **endptr, int base)
{
  const char *v6; // r4
  __int16 v7; // r6
  int v8; // r5
  int v9; // t1
  int result; // r0

  v6 = nptr;
  v7 = 0;
  do
  {
    v9 = *(unsigned __int8 *)v6++;
    v8 = v9;
  }
  while ( v9 && *(unsigned __int8 *)(*(_DWORD *)sub_8002DA8() + v8) << 31 );
  if ( v8 != 43 )
  {
    if ( v8 == 45 )
      v7 = 1024;
    else
      --v6;
  }
  result = strtoul(v6, endptr, base);
  if ( endptr && *endptr == v6 )
    *endptr = nptr;
  if ( (v7 & 0x400) != 0 )
  {
    result = -result;
    if ( result > 0 )
    {
      *(_DWORD *)sub_801E2E0() = 2;
      return 0x80000000;
    }
  }
  else if ( result < 0 )
  {
    *(_DWORD *)sub_801E2E0() = 2;
    return 0x7FFFFFFF;
  }
  return result;
}

//----- (080029EC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall SVCall_handler(unsigned int a1, int a2, int a3)
{
  bool v3; // nf
  int v4; // r3
  int v5; // r1
  unsigned int v6; // r0
  unsigned int result; // r0

  v4 = a2 + 7;
  v3 = a2 + 7 < 0;
  v5 = a1 << 24;
  v6 = a1 >> 8;
  if ( v3 )
    return 0;
  result = v6 + (v4 << 23) + a3;
  if ( v5 < 0 )
  {
    ++result;
    if ( !(2 * v5) )
      result &= ~1u;
  }
  return result;
}
// 80029FC: positive sp value 4 has been found

//----- (08002A1A) --------------------------------------------------------
unsigned int __fastcall sub_8002A1A(unsigned int result, int a2, __int64 a3)
{
  if ( a3 < 0 )
  {
    ++result;
    if ( !((2 * (_DWORD)a3) | (unsigned int)(HIDWORD(a3) + ((a3 + (unsigned __int64)(unsigned int)a3) >> 32))) )
      result &= ~1u;
  }
  return result;
}

//----- (08002A38) --------------------------------------------------------
void __fastcall sub_8002A38(unsigned int a1, unsigned int a2, __int64 a3)
{
  int v4; // r2
  int v5; // r8
  __int64 v6; // r0

  if ( a2 )
    v4 = __clz(a2);
  else
    v4 = __clz(a1) + 32;
  v5 = v4;
  LODWORD(v6) = sub_8002878(a1, a2, v4);
  if ( v6 | a3 )
  {
    if ( a3 )
    {
      ll_ushift_r(a3, HIDWORD(a3), 64 - v5);
      sub_8002878(a3, SHIDWORD(a3), v5);
    }
    JUMPOUT(0x8002AAA);
  }
  JUMPOUT(0x8002A94);
}
// 8002A92: control flows out of bounds to 8002A94
// 8002AA8: control flows out of bounds to 8002AAA
// 8002A58: variable 'v6' is possibly undefined

//----- (08002AAC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall Reset_handler(int a1, int a2, __int64 a3, __int64 a4)
{
  int v5; // r4
  unsigned int v6; // r7
  __int64 v7; // r4
  int (__fastcall *v8)(_DWORD, _DWORD, _DWORD); // [sp-4h] [bp-4h]

  LODWORD(a3) = 0;
  HIDWORD(v7) = v6 >> 11;
  LODWORD(v7) = v5 | (v6 << 21);
  if ( a2 + 10 >= 0 )
    return sub_8002A1A(v7 + a4, (__PAIR64__((a2 + 10) << 20, 0) + v7 + a4) >> 32, a3);
  else
    return v8(0, 0, 0);
}
// 8002AD2: positive sp value 20 has been found
// 8002AAC: could not find valid save-restore pair for r5
// 8002AAC: could not find valid save-restore pair for r6
// 8002AAC: could not find valid save-restore pair for r8
// 8002AAC: could not find valid save-restore pair for r10
// 8002AAC: could not find valid save-restore pair for r11
// 8002AB0: variable 'v6' is possibly undefined
// 8002AB2: variable 'v5' is possibly undefined
// 8002A94: variable 'v8' is possibly undefined

//----- (08002D00) --------------------------------------------------------
int __fastcall sub_8002D00(unsigned int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r1
  bool v5; // cc
  int v6; // r2

  v2 = (a2 >> 20) & 0x7FF;
  v3 = a2 & 0xFFFFF | 0x100000;
  if ( v2 < 1023 )
    return 0;
  v5 = v2 <= 1075;
  v6 = v2 - 1075;
  if ( v5 )
    return ll_ushift_r(a1, v3, -v6);
  else
    return sub_8002878(a1, v3, v6);
}

//----- (08002D84) --------------------------------------------------------
int __fastcall ll_sshift_r(unsigned int a1, int a2, int a3)
{
  if ( a3 < 32 )
    return (a1 >> a3) | (a2 << (32 - a3));
  else
    return a2 >> (a3 - 32);
}

//----- (08002DA8) --------------------------------------------------------
char *sub_8002DA8()
{
  return "_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cpc=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d,b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d";
}

//----- (08002DB0) --------------------------------------------------------
int __fastcall sub_8002DB0(int a1)
{
  return *(_BYTE *)(*(_DWORD *)sub_8002DA8() + a1) & 1;
}

//----- (08002DC4) --------------------------------------------------------
int __fastcall sub_8002DC4(int a1, int a2)
{
  int v2; // r8
  int v4; // r11
  int v5; // r6
  int v6; // r0
  int v7; // r5
  int v8; // r0
  int v9; // r0
  int v10; // r7
  int v11; // r7
  int v12; // r5
  int v13; // r0
  int v14; // r5
  int v15; // r0
  int v16; // r3
  unsigned int v17; // r2
  _BYTE **v18; // r0
  _BYTE *v19; // r0
  int v20; // r9
  int v21; // r0
  int i; // r1
  int j; // r0
  int v25; // [sp+4h] [bp-54h]
  _DWORD v26[9]; // [sp+8h] [bp-50h]
  int v27; // [sp+2Ch] [bp-2Ch]
  int v28; // [sp+30h] [bp-28h]

  v27 = a1;
  v28 = a2;
  v2 = 0;
  v4 = 1;
  v5 = 0;
  v25 = a2 + 12;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        v7 = v6;
        if ( !v6 )
          return v2;
        if ( v6 == 37 )
          break;
        if ( (*(int (__fastcall **)(int))(a2 + 32))(v6) )
        {
          do
            v8 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          while ( (*(int (__fastcall **)(int))(a2 + 32))(v8) );
          (*(void (__fastcall **)(int, int))(a2 + 20))(v25, -1);
          while ( 1 )
          {
            v9 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
            if ( !(*(int (__fastcall **)(int))(a2 + 32))(v9) )
              break;
            ++v5;
          }
          (*(void (__fastcall **)(int))(a2 + 28))(v27);
        }
        else
        {
          v10 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
          if ( v10 != v7 )
          {
            (*(void (__fastcall **)(int))(a2 + 28))(v27);
            if ( v10 != -1 )
              return v2;
            goto LABEL_14;
          }
LABEL_12:
          ++v5;
        }
      }
      v11 = 0;
      v12 = 0;
      if ( (*(int (__fastcall **)(int, _DWORD))(a2 + 20))(v25, 0) == 42 )
      {
        (*(void (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        v12 = 1;
      }
      while ( 1 )
      {
        v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        if ( (unsigned int)(v13 - 48) >= 0xA )
          break;
        if ( v11 > 214748364 )
          return v2;
        v11 = v13 + 10 * v11 - 48;
        if ( v11 < 0 )
          return v2;
        v12 |= 0x10u;
      }
      if ( (v12 & 0x10) == 0 )
        v11 = 0x7FFFFFFF;
      switch ( v13 )
      {
        case 'l':
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          if ( v13 != 108 )
          {
            v12 |= 4u;
            break;
          }
LABEL_33:
          v12 |= 2u;
LABEL_38:
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          break;
        case 'L':
          v12 |= 0x20u;
          goto LABEL_38;
        case 'h':
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          if ( v13 != 104 )
          {
            v12 |= 8u;
            break;
          }
          v12 |= 0x800u;
          goto LABEL_38;
        case 'j':
          goto LABEL_33;
        case 't':
        case 'z':
          goto LABEL_38;
      }
      *(_DWORD *)(a2 + 4) = v12;
      *(_DWORD *)(a2 + 8) = v11;
      if ( v13 == 101 )
        goto LABEL_72;
      if ( v13 <= 101 )
        break;
      if ( v13 == 111 )
      {
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 8;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
      if ( v13 > 111 )
      {
        switch ( v13 )
        {
          case 'p':
            *(_DWORD *)(a2 + 4) = v12 & 0xFFFFF7F1;
            break;
          case 's':
            goto LABEL_93;
          case 'u':
            goto LABEL_86;
          case 'x':
LABEL_88:
            *(_DWORD *)(a2 + 4) = v12 | 0x40;
            if ( (v12 & 2) != 0 )
            {
LABEL_89:
              v15 = -2;
              goto LABEL_112;
            }
            break;
          default:
            return v2;
        }
        v16 = a2;
        v17 = 16;
LABEL_92:
        v15 = scanf_int(-2, v27, v17, v16);
        goto LABEL_112;
      }
      if ( v13 == 102 || v13 == 103 )
        goto LABEL_72;
      if ( v13 == 105 )
      {
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 0;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
      if ( v13 != 110 )
        return v2;
      if ( !(v12 << 31) )
      {
        v18 = *(_BYTE ***)a2;
        *(_DWORD *)a2 += 4;
        v19 = *v18;
        if ( (v12 & 0x800) != 0 )
        {
          *v19 = v5;
        }
        else if ( (v12 & 8) != 0 )
        {
          *(_WORD *)v19 = v5;
        }
        else if ( (v12 & 2) != 0 )
        {
          *(_QWORD *)v19 = v5;
        }
        else
        {
          *(_DWORD *)v19 = v5;
        }
      }
    }
    if ( v13 == 88 )
      goto LABEL_88;
    if ( v13 <= 88 )
      break;
    if ( v13 != 91 )
    {
      if ( v13 == 97 )
        goto LABEL_72;
      if ( v13 != 99 )
      {
        if ( v13 != 100 )
          return v2;
LABEL_86:
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 10;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
    }
LABEL_93:
    v20 = 0;
    if ( v13 == 99 )
    {
      if ( (v12 & 0x10) == 0 )
        *(_DWORD *)(a2 + 8) = 1;
    }
    else if ( v13 == 91 )
    {
      v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
      if ( v21 == 94 )
      {
        v20 = 1;
        v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
      }
      if ( !*(_DWORD *)(a2 + 16) )
      {
        for ( i = 0; i < 8; ++i )
          v26[i] = 0;
      }
      while ( v21 )
      {
        if ( !*(_DWORD *)(a2 + 16) )
          v26[v21 / 32] |= 1 << (v21 % 32);
        v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        if ( v21 == 93 )
        {
          if ( v20 )
          {
            for ( j = 0; j < 8; ++j )
              v26[j] = ~v26[j];
          }
          goto LABEL_111;
        }
      }
      return v2;
    }
LABEL_111:
    v15 = -2;
LABEL_112:
    if ( v15 < 0 )
    {
      if ( v15 == -1 && v4 )
        return -1;
      return v2;
    }
    if ( !(v12 << 31) )
      ++v2;
    v5 += v15;
    v4 = 0;
  }
  if ( v13 == 69 )
  {
LABEL_72:
    v15 = -2;
    goto LABEL_112;
  }
  if ( v13 > 69 )
  {
    if ( v13 != 70 && v13 != 71 )
      return v2;
    goto LABEL_72;
  }
  if ( v13 != 37 )
  {
    if ( v13 != 65 )
      return v2;
    goto LABEL_72;
  }
  v14 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
  if ( v14 == 37 )
    goto LABEL_12;
  (*(void (__fastcall **)(int))(a2 + 28))(v27);
  if ( v14 != -1 )
    return v2;
LABEL_14:
  if ( !v2 )
    return -1;
  return v2;
}

//----- (080030F0) --------------------------------------------------------
unsigned int strtoul(const char *nptr, char **endptr, int base)
{
  unsigned int v4; // r0
  int v5; // r7
  unsigned int v6; // r5
  const char *v8; // r4
  int v9; // r9
  unsigned int v10; // t1
  unsigned int v11; // t1
  unsigned int v12; // r6
  int v13; // r8
  unsigned int v14; // r0
  unsigned int v15; // t1
  signed int v16; // r0
  char *v17; // r4

  v4 = *(unsigned __int8 *)nptr;
  v5 = 0;
  v6 = base;
  v8 = nptr + 1;
  v9 = 0;
  if ( v4 == 48 )
  {
    v10 = *(unsigned __int8 *)v8;
    v8 = nptr + 2;
    v4 = v10;
    v5 = 1;
    if ( v10 == 120 || v4 == 88 )
    {
      if ( !base || base == 16 )
      {
        v5 = 0;
        v6 = 16;
        v11 = *(unsigned __int8 *)v8;
        v8 = nptr + 3;
        v4 = v11;
      }
    }
    else if ( !base )
    {
      v6 = 8;
    }
  }
  else if ( !base )
  {
    v6 = 10;
  }
  v12 = 0;
  v13 = 0;
  while ( 1 )
  {
    v16 = sub_80028B6(v4, v6);
    if ( v16 < 0 )
      break;
    v14 = v16 + v6 * v13;
    v5 = 1;
    v12 = v6 * v12 + HIWORD(v14);
    v13 = (unsigned __int16)v14;
    if ( v12 >= 0x10000 )
      v9 = 1;
    v15 = *(unsigned __int8 *)v8++;
    v4 = v15;
  }
  if ( endptr )
  {
    if ( v5 )
      v17 = (char *)(v8 - 1);
    else
      v17 = (char *)nptr;
    *endptr = v17;
  }
  if ( !v9 )
    return v13 | (v12 << 16);
  *(_DWORD *)sub_801E2E0() = 2;
  return -1;
}

//----- (0800318E) --------------------------------------------------------
void __fastcall _decompress1(unsigned __int8 *src, unsigned __int8 *dst, int len)
{
  unsigned __int8 *v3; // r4
  int v4; // r5
  int v5; // t1
  int v6; // r3
  int v7; // t1
  int v8; // r2
  int v9; // t1
  unsigned __int8 v10; // t1
  int v11; // t1
  unsigned __int8 *v12; // r3
  int v13; // r2
  unsigned __int8 v14; // t1

  v3 = &dst[len];
  do
  {
    v5 = *src++;
    v4 = v5;
    v6 = v5 & 7;
    if ( (v5 & 7) == 0 )
    {
      v7 = *src++;
      v6 = v7;
    }
    v8 = v4 >> 4;
    if ( !(v4 >> 4) )
    {
      v9 = *src++;
      v8 = v9;
    }
    while ( --v6 )
    {
      v10 = *src++;
      *dst++ = v10;
    }
    if ( (v4 & 8) != 0 )
    {
      v11 = *src++;
      v12 = &dst[-v11];
      v13 = v8 + 2;
      while ( --v13 >= 0 )
      {
        v14 = *v12++;
        *dst++ = v14;
      }
    }
    else
    {
      while ( --v8 >= 0 )
        *dst++ = 0;
    }
  }
  while ( dst < v3 );
}

//----- (080031E4) --------------------------------------------------------
void sub_80031E4()
{
  JUMPOUT(0x10000C30);
}
// 80031EC: control flows out of bounds to 10000C30

//----- (080031EE) --------------------------------------------------------
void sub_80031EE()
{
  JUMPOUT(0x100075E8);
}
// 80031F6: control flows out of bounds to 100075E8

//----- (080031F8) --------------------------------------------------------
void sub_80031F8()
{
  JUMPOUT(0x10007644);
}
// 8003200: control flows out of bounds to 10007644

//----- (08003202) --------------------------------------------------------
void sub_8003202()
{
  JUMPOUT(0x10007680);
}
// 800320A: control flows out of bounds to 10007680

//----- (0800320C) --------------------------------------------------------
void sub_800320C()
{
  JUMPOUT(0x100013FC);
}
// 8003214: control flows out of bounds to 100013FC

//----- (08003216) --------------------------------------------------------
void sub_8003216()
{
  JUMPOUT(0x100069D8);
}
// 800321E: control flows out of bounds to 100069D8

//----- (08003220) --------------------------------------------------------
void sub_8003220()
{
  JUMPOUT(0x10006A78);
}
// 8003228: control flows out of bounds to 10006A78

//----- (0800322A) --------------------------------------------------------
void sub_800322A()
{
  JUMPOUT(0x100022BC);
}
// 8003232: control flows out of bounds to 100022BC

//----- (08003234) --------------------------------------------------------
void sub_8003234()
{
  JUMPOUT(0x100001B0);
}
// 800323C: control flows out of bounds to 100001B0

//----- (0800323E) --------------------------------------------------------
void sub_800323E()
{
  JUMPOUT(0x10007450);
}
// 8003246: control flows out of bounds to 10007450

//----- (08003248) --------------------------------------------------------
void sub_8003248()
{
  JUMPOUT(0x1000747C);
}
// 8003250: control flows out of bounds to 1000747C

//----- (08003252) --------------------------------------------------------
void sub_8003252()
{
  JUMPOUT(0x10000FFC);
}
// 800325A: control flows out of bounds to 10000FFC

//----- (08003266) --------------------------------------------------------
void sub_8003266()
{
  JUMPOUT(0x10000BE8);
}
// 800326E: control flows out of bounds to 10000BE8

//----- (08003270) --------------------------------------------------------
void sub_8003270()
{
  JUMPOUT(0x10000C04);
}
// 8003278: control flows out of bounds to 10000C04

//----- (0800327A) --------------------------------------------------------
void sub_800327A()
{
  JUMPOUT(0x10000B2C);
}
// 8003282: control flows out of bounds to 10000B2C

//----- (08003284) --------------------------------------------------------
void sub_8003284()
{
  JUMPOUT(0x10000B14);
}
// 800328C: control flows out of bounds to 10000B14

//----- (0800328E) --------------------------------------------------------
void sub_800328E()
{
  JUMPOUT(0x10005E8C);
}
// 8003296: control flows out of bounds to 10005E8C

//----- (080032A2) --------------------------------------------------------
void sub_80032A2()
{
  JUMPOUT(0x10000A8C);
}
// 80032AA: control flows out of bounds to 10000A8C

//----- (080032AC) --------------------------------------------------------
void sub_80032AC()
{
  JUMPOUT(0x10000174);
}
// 80032B4: control flows out of bounds to 10000174

//----- (080032B6) --------------------------------------------------------
int __fastcall sub_80032B6(int a1)
{
  int *v1; // r4
  int v3; // r0

  v1 = *(int **)(a1 + 40);
  if ( (v1[23] & 0x50) != 0 )
  {
    if ( (v1[23] & 0x10) != 0 )
      return nullsub_3(*(_DWORD *)(a1 + 40));
    else
      return (*(int (**)(void))(v1[21] + 52))();
  }
  else
  {
    v1[23] |= 0x200u;
    v3 = *v1;
    if ( (*(_DWORD *)*v1 & 8) != 0 )
    {
      if ( sub_8016CCC(v3) )
      {
        if ( (*(_DWORD *)(*v1 + 12) & 0x2000) == 0 )
        {
          v1[23] &= ~0x100u;
          if ( (v1[23] & 0x1000) == 0 )
            v1[23] |= 1u;
        }
      }
    }
    else if ( (*(_DWORD *)(v3 + 12) & 2) == 0 )
    {
      v1[23] &= ~0x100u;
      if ( (v1[23] & 0x1000) == 0 )
        v1[23] |= 1u;
    }
    return sub_8010650(v1);
  }
}
// 800F7FC: using guessed type int __fastcall nullsub_3(_DWORD);

//----- (08003334) --------------------------------------------------------
int __fastcall sub_8003334(int a1)
{
  int v1; // r0

  v1 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v1 + 92) |= 0x40u;
  *(_DWORD *)(v1 + 96) |= 4u;
  return nullsub_3();
}
// 800F7FC: using guessed type int nullsub_3(void);

//----- (0800334E) --------------------------------------------------------
int __fastcall sub_800334E(int a1)
{
  return nullsub_4(*(_DWORD *)(a1 + 40));
}
// 800F7FA: using guessed type int __fastcall nullsub_4(_DWORD);

//----- (08003358) --------------------------------------------------------
int __fastcall sub_8003358(int *a1)
{
  int v2; // r0
  int v3; // r5
  int v5; // r5

  v2 = *a1;
  v3 = (*(_DWORD *)(v2 + 8) >> 1) & 1;
  if ( sub_8016CBC(v2) && !v3 )
  {
    if ( (*(_DWORD *)(*a1 + 8) & 0xD) != 1 )
    {
      a1[23] |= 0x10u;
      a1[24] |= 1u;
      return 1;
    }
    *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 2;
    *(_DWORD *)*a1 = 3;
    v5 = sub_8012298();
    while ( *(_DWORD *)(*a1 + 8) << 31 )
    {
      if ( (unsigned int)(sub_8012298() - v5) > 2 && *(_DWORD *)(*a1 + 8) << 31 )
      {
        a1[23] |= 0x10u;
        a1[24] |= 1u;
        return 1;
      }
    }
  }
  return 0;
}

//----- (080033DC) --------------------------------------------------------
int __fastcall sub_80033DC(int *a1)
{
  int v3; // r5

  if ( !sub_8016CBC(*a1) )
  {
    if ( (*(_DWORD *)(*a1 + 8) & 0x8000003F) != 0 )
    {
      a1[23] |= 0x10u;
      a1[24] |= 1u;
      return 1;
    }
    *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 1;
    v3 = sub_8012298();
    while ( ~*(_DWORD *)*a1 << 31 )
    {
      if ( !sub_8016CBC(*a1) )
        *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 1;
      if ( (unsigned int)(sub_8012298() - v3) > 2 && ~*(_DWORD *)*a1 << 31 )
      {
        a1[23] |= 0x10u;
        a1[24] |= 1u;
        return 1;
      }
    }
  }
  return 0;
}

//----- (08003468) --------------------------------------------------------
int __fastcall sub_8003468(int a1, int a2, int a3, int a4)
{
  _DWORD v5[9]; // [sp+4h] [bp-24h] BYREF

  v5[0] = a2;
  v5[1] = a3;
  v5[2] = a4;
  v5[3] = 127;
  v5[4] = 4;
  v5[5] = 0;
  return sub_80101D0(a1, (int)v5);
}

//----- (08003488) --------------------------------------------------------
int sub_8003488()
{
  MEMORY[0x40021048] |= 4u;
  MEMORY[0x40021048] |= 1u;
  dword_20001C48 = 1073872904;
  dword_20001C4C = 5;
  dword_20001C50 = 0;
  dword_20001C54 = 0;
  dword_20001C58 = 128;
  dword_20001C5C = 256;
  dword_20001C60 = 1024;
  dword_20001C64 = 32;
  dword_20001C68 = 4096;
  sub_8011550((int)&dword_20001C48);
  dword_20001CA8 = 1073872924;
  dword_20001CAC = 36;
  dword_20001CB0 = 0;
  dword_20001CB4 = 0;
  dword_20001CB8 = 128;
  dword_20001CBC = 256;
  dword_20001CC0 = 1024;
  dword_20001CC4 = 32;
  dword_20001CC8 = 4096;
  sub_8011550((int)&dword_20001CA8);
  dword_20001D08 = 1073872944;
  dword_20001D0C = 37;
  dword_20001D10 = 0;
  dword_20001D14 = 0;
  dword_20001D18 = 128;
  dword_20001D1C = 256;
  dword_20001D20 = 1024;
  dword_20001D24 = 32;
  dword_20001D28 = 4096;
  sub_8011550((int)&dword_20001D08);
  dword_20001D68 = 1073872964;
  dword_20001D6C = 38;
  dword_20001D70 = 0;
  dword_20001D74 = 0;
  dword_20001D78 = 128;
  dword_20001D7C = 256;
  dword_20001D80 = 1024;
  dword_20001D84 = 32;
  dword_20001D88 = 4096;
  sub_8011550((int)&dword_20001D68);
  dword_20001DC8 = 1073872984;
  dword_20001DCC = 39;
  dword_20001DD0 = 0;
  dword_20001DD4 = 0;
  dword_20001DD8 = 128;
  dword_20001DDC = 256;
  dword_20001DE0 = 1024;
  dword_20001DE4 = 32;
  dword_20001DE8 = 4096;
  sub_8011550((int)&dword_20001DC8);
  sub_8003814();
  sub_8003468((int)&dword_20001E28, 632291840, 6, 5);
  sub_8003468((int)&dword_20001E28, 210763784, 12, 5);
  sub_8003468((int)&dword_20001E28, 562036992, 18, 5);
  sub_8003468((int)&dword_20001E94, 70254594, 6, 3);
  sub_8003468((int)&dword_20001E94, 281018384, 12, 5);
  sub_8003468((int)&dword_20001F00, 210763784, 6, 5);
  sub_8003468((int)&dword_20001F00, 70254594, 12, 5);
  sub_8003468((int)&dword_20001F00, 140509188, 18, 5);
  sub_8003468((int)&dword_20001F6C, 281018384, 6, 5);
  sub_8003468((int)&dword_20001F6C, 140509188, 12, 6);
  sub_8003468((int)&dword_20001F6C, 70254594, 18, 6);
  sub_8003468((int)&dword_20001FD8, 704644096, 6, 7);
  sub_8003468((int)&dword_20001FD8, 845156352, 12, 7);
  sub_8003468((int)&dword_20001FD8, 915415040, 18, 7);
  dword_20001E7C = (int)&dword_20001C48;
  dword_20001C70 = (int)&dword_20001E28;
  dword_20001EE8 = (int)&dword_20001CA8;
  dword_20001CD0 = (int)&dword_20001E94;
  dword_20001F54 = (int)&dword_20001D08;
  dword_20001D30 = (int)&dword_20001F00;
  dword_20001FC0 = (int)&dword_20001D68;
  dword_20001D90 = (int)&dword_20001F6C;
  dword_2000202C = (int)&dword_20001DC8;
  dword_20001DF0 = (int)&dword_20001FD8;
  sub_80132C0(11, 2u, 0);
  sub_80132A4(11);
  sub_8010B40((int)&dword_20001E28, (int)&word_20000078, 3);
  sub_8010B40((int)&dword_20001E94, (int)&word_20000074, 2);
  sub_8010B40((int)&dword_20001F00, (int)&word_2000007E, 3);
  sub_8010B40((int)&dword_20001F6C, (int)&word_20000084, 3);
  return sub_8010B40((int)&dword_20001FD8, (int)&word_20002044, 6);
}
// 20000074: using guessed type __int16 word_20000074;
// 20000078: using guessed type __int16 word_20000078;
// 2000007E: using guessed type __int16 word_2000007E;
// 20000084: using guessed type __int16 word_20000084;
// 20001C48: using guessed type int dword_20001C48;
// 20001C4C: using guessed type int dword_20001C4C;
// 20001C50: using guessed type int dword_20001C50;
// 20001C54: using guessed type int dword_20001C54;
// 20001C58: using guessed type int dword_20001C58;
// 20001C5C: using guessed type int dword_20001C5C;
// 20001C60: using guessed type int dword_20001C60;
// 20001C64: using guessed type int dword_20001C64;
// 20001C68: using guessed type int dword_20001C68;
// 20001C70: using guessed type int dword_20001C70;
// 20001CA8: using guessed type int dword_20001CA8;
// 20001CAC: using guessed type int dword_20001CAC;
// 20001CB0: using guessed type int dword_20001CB0;
// 20001CB4: using guessed type int dword_20001CB4;
// 20001CB8: using guessed type int dword_20001CB8;
// 20001CBC: using guessed type int dword_20001CBC;
// 20001CC0: using guessed type int dword_20001CC0;
// 20001CC4: using guessed type int dword_20001CC4;
// 20001CC8: using guessed type int dword_20001CC8;
// 20001CD0: using guessed type int dword_20001CD0;
// 20001D08: using guessed type int dword_20001D08;
// 20001D0C: using guessed type int dword_20001D0C;
// 20001D10: using guessed type int dword_20001D10;
// 20001D14: using guessed type int dword_20001D14;
// 20001D18: using guessed type int dword_20001D18;
// 20001D1C: using guessed type int dword_20001D1C;
// 20001D20: using guessed type int dword_20001D20;
// 20001D24: using guessed type int dword_20001D24;
// 20001D28: using guessed type int dword_20001D28;
// 20001D30: using guessed type int dword_20001D30;
// 20001D68: using guessed type int dword_20001D68;
// 20001D6C: using guessed type int dword_20001D6C;
// 20001D70: using guessed type int dword_20001D70;
// 20001D74: using guessed type int dword_20001D74;
// 20001D78: using guessed type int dword_20001D78;
// 20001D7C: using guessed type int dword_20001D7C;
// 20001D80: using guessed type int dword_20001D80;
// 20001D84: using guessed type int dword_20001D84;
// 20001D88: using guessed type int dword_20001D88;
// 20001D90: using guessed type int dword_20001D90;
// 20001DC8: using guessed type int dword_20001DC8;
// 20001DCC: using guessed type int dword_20001DCC;
// 20001DD0: using guessed type int dword_20001DD0;
// 20001DD4: using guessed type int dword_20001DD4;
// 20001DD8: using guessed type int dword_20001DD8;
// 20001DDC: using guessed type int dword_20001DDC;
// 20001DE0: using guessed type int dword_20001DE0;
// 20001DE4: using guessed type int dword_20001DE4;
// 20001DE8: using guessed type int dword_20001DE8;
// 20001DF0: using guessed type int dword_20001DF0;
// 20001E28: using guessed type int dword_20001E28;
// 20001E7C: using guessed type int dword_20001E7C;
// 20001E94: using guessed type int dword_20001E94;
// 20001EE8: using guessed type int dword_20001EE8;
// 20001F00: using guessed type int dword_20001F00;
// 20001F54: using guessed type int dword_20001F54;
// 20001F6C: using guessed type int dword_20001F6C;
// 20001FC0: using guessed type int dword_20001FC0;
// 20001FD8: using guessed type int dword_20001FD8;
// 2000202C: using guessed type int dword_2000202C;
// 20002044: using guessed type __int16 word_20002044;

//----- (08003720) --------------------------------------------------------
int sub_8003720()
{
  int v0; // r1
  int result; // r0

  *(float *)&dword_20001BE0 = (float)((unsigned __int16)word_2000007C - (unsigned __int16)word_2000007A) * 0.21606;
  *(float *)&dword_20001C14 = (float)((unsigned __int16)word_20000084 - (unsigned __int16)word_2000007A) * 0.21606;
  *(float *)&dword_20001BEC = (float)((unsigned __int16)word_20000078 - (unsigned __int16)word_2000007A) * 0.21606;
  v0 = (unsigned __int16)word_20000074 - (unsigned __int16)word_2000007A;
  if ( byte_20000002 )
    *(float *)&dword_20001BE4 = (float)v0 * 0.018311;
  else
    *(float *)&dword_20001BE4 = (float)v0 * -0.017577;
  *(float *)&dword_20001BE8 = (float)(unsigned __int16)word_20000080 * 0.15271;
  if ( dword_20001BE8 < 1065353216 )
    dword_20001BE8 = 1.0;
  result = (unsigned __int16)word_20000076 - (unsigned __int16)word_2000007A;
  *(float *)&dword_20001BFC = (float)result * -0.017;
  return result;
}
// 20000002: using guessed type char byte_20000002;
// 20000074: using guessed type __int16 word_20000074;
// 20000076: using guessed type __int16 word_20000076;
// 20000078: using guessed type __int16 word_20000078;
// 2000007A: using guessed type __int16 word_2000007A;
// 2000007C: using guessed type __int16 word_2000007C;
// 20000080: using guessed type __int16 word_20000080;
// 20000084: using guessed type __int16 word_20000084;
// 20001BE0: using guessed type int dword_20001BE0;
// 20001BE4: using guessed type int dword_20001BE4;
// 20001BE8: using guessed type int dword_20001BE8;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C14: using guessed type int dword_20001C14;

//----- (08003814) --------------------------------------------------------
int sub_8003814()
{
  dword_20001E28 = 1342177280;
  dword_20001E2C = 196608;
  dword_20001E30 = 0;
  dword_20001E38 = 0;
  dword_20001E34 = 0;
  dword_20001E3C = 1;
  dword_20001E40 = 8;
  byte_20001E44 = 0;
  byte_20001E45 = 0;
  dword_20001E48 = 3;
  byte_20001E4C = 0;
  dword_20001E50 = 0;
  dword_20001E54 = 1696;
  dword_20001E58 = 1024;
  byte_20001E60 = 1;
  dword_20001E64 = 4096;
  byte_20001E68 = 0;
  sub_8010680((int)&dword_20001E28);
  dword_20001E94 = 1342177536;
  dword_20001E98 = 196608;
  dword_20001E9C = 0;
  dword_20001EA4 = 0;
  dword_20001EA0 = 0;
  dword_20001EA8 = 1;
  dword_20001EAC = 8;
  byte_20001EB0 = 0;
  byte_20001EB1 = 0;
  dword_20001EB4 = 2;
  byte_20001EB8 = 0;
  dword_20001EBC = 0;
  dword_20001EC0 = 1696;
  dword_20001EC4 = 1024;
  byte_20001ECC = 1;
  dword_20001ED0 = 4096;
  byte_20001ED4 = 0;
  sub_8010680((int)&dword_20001E94);
  dword_20001F00 = 1342178304;
  dword_20001F04 = 196608;
  dword_20001F08 = 0;
  dword_20001F10 = 0;
  dword_20001F0C = 0;
  dword_20001F14 = 1;
  dword_20001F18 = 8;
  byte_20001F1C = 0;
  byte_20001F1D = 0;
  dword_20001F20 = 3;
  byte_20001F24 = 0;
  dword_20001F28 = 0;
  dword_20001F2C = 1696;
  dword_20001F30 = 1024;
  byte_20001F38 = 1;
  dword_20001F3C = 4096;
  byte_20001F40 = 0;
  sub_8010680((int)&dword_20001F00);
  dword_20001F6C = 1342178560;
  dword_20001F70 = 196608;
  dword_20001F74 = 0;
  dword_20001F7C = 0;
  dword_20001F78 = 0;
  dword_20001F80 = 1;
  dword_20001F84 = 8;
  byte_20001F88 = 0;
  byte_20001F89 = 0;
  dword_20001F8C = 3;
  byte_20001F90 = 0;
  dword_20001F94 = 0;
  dword_20001F98 = 1696;
  dword_20001F9C = 1024;
  byte_20001FA4 = 1;
  dword_20001FA8 = 4096;
  byte_20001FAC = 0;
  sub_8010680((int)&dword_20001F6C);
  dword_20001FD8 = 1342178816;
  dword_20001FDC = 196608;
  dword_20001FE0 = 0;
  dword_20001FE8 = 0;
  dword_20001FE4 = 0;
  dword_20001FEC = 1;
  dword_20001FF0 = 8;
  byte_20001FF4 = 0;
  byte_20001FF5 = 1;
  dword_20001FF8 = 6;
  byte_20001FFC = 0;
  dword_20002000 = 0;
  dword_20002004 = 0;
  dword_20002008 = 1024;
  byte_20002010 = 1;
  dword_20002014 = 4096;
  byte_20002018 = 1;
  dword_2000201C = 20;
  dword_20002020 = 192;
  dword_20002024 = 0;
  dword_20002028 = 1;
  sub_8010680((int)&dword_20001FD8);
  sub_8010134((int)&dword_20001E28, 127);
  sub_8010134((int)&dword_20001E94, 127);
  sub_8010134((int)&dword_20001F00, 127);
  sub_8010134((int)&dword_20001F6C, 127);
  return sub_8010134((int)&dword_20001FD8, 127);
}
// 20001E28: using guessed type int dword_20001E28;
// 20001E2C: using guessed type int dword_20001E2C;
// 20001E30: using guessed type int dword_20001E30;
// 20001E34: using guessed type int dword_20001E34;
// 20001E38: using guessed type int dword_20001E38;
// 20001E3C: using guessed type int dword_20001E3C;
// 20001E40: using guessed type int dword_20001E40;
// 20001E44: using guessed type char byte_20001E44;
// 20001E45: using guessed type char byte_20001E45;
// 20001E48: using guessed type int dword_20001E48;
// 20001E4C: using guessed type char byte_20001E4C;
// 20001E50: using guessed type int dword_20001E50;
// 20001E54: using guessed type int dword_20001E54;
// 20001E58: using guessed type int dword_20001E58;
// 20001E60: using guessed type char byte_20001E60;
// 20001E64: using guessed type int dword_20001E64;
// 20001E68: using guessed type char byte_20001E68;
// 20001E94: using guessed type int dword_20001E94;
// 20001E98: using guessed type int dword_20001E98;
// 20001E9C: using guessed type int dword_20001E9C;
// 20001EA0: using guessed type int dword_20001EA0;
// 20001EA4: using guessed type int dword_20001EA4;
// 20001EA8: using guessed type int dword_20001EA8;
// 20001EAC: using guessed type int dword_20001EAC;
// 20001EB0: using guessed type char byte_20001EB0;
// 20001EB1: using guessed type char byte_20001EB1;
// 20001EB4: using guessed type int dword_20001EB4;
// 20001EB8: using guessed type char byte_20001EB8;
// 20001EBC: using guessed type int dword_20001EBC;
// 20001EC0: using guessed type int dword_20001EC0;
// 20001EC4: using guessed type int dword_20001EC4;
// 20001ECC: using guessed type char byte_20001ECC;
// 20001ED0: using guessed type int dword_20001ED0;
// 20001ED4: using guessed type char byte_20001ED4;
// 20001F00: using guessed type int dword_20001F00;
// 20001F04: using guessed type int dword_20001F04;
// 20001F08: using guessed type int dword_20001F08;
// 20001F0C: using guessed type int dword_20001F0C;
// 20001F10: using guessed type int dword_20001F10;
// 20001F14: using guessed type int dword_20001F14;
// 20001F18: using guessed type int dword_20001F18;
// 20001F1C: using guessed type char byte_20001F1C;
// 20001F1D: using guessed type char byte_20001F1D;
// 20001F20: using guessed type int dword_20001F20;
// 20001F24: using guessed type char byte_20001F24;
// 20001F28: using guessed type int dword_20001F28;
// 20001F2C: using guessed type int dword_20001F2C;
// 20001F30: using guessed type int dword_20001F30;
// 20001F38: using guessed type char byte_20001F38;
// 20001F3C: using guessed type int dword_20001F3C;
// 20001F40: using guessed type char byte_20001F40;
// 20001F6C: using guessed type int dword_20001F6C;
// 20001F70: using guessed type int dword_20001F70;
// 20001F74: using guessed type int dword_20001F74;
// 20001F78: using guessed type int dword_20001F78;
// 20001F7C: using guessed type int dword_20001F7C;
// 20001F80: using guessed type int dword_20001F80;
// 20001F84: using guessed type int dword_20001F84;
// 20001F88: using guessed type char byte_20001F88;
// 20001F89: using guessed type char byte_20001F89;
// 20001F8C: using guessed type int dword_20001F8C;
// 20001F90: using guessed type char byte_20001F90;
// 20001F94: using guessed type int dword_20001F94;
// 20001F98: using guessed type int dword_20001F98;
// 20001F9C: using guessed type int dword_20001F9C;
// 20001FA4: using guessed type char byte_20001FA4;
// 20001FA8: using guessed type int dword_20001FA8;
// 20001FAC: using guessed type char byte_20001FAC;
// 20001FD8: using guessed type int dword_20001FD8;
// 20001FDC: using guessed type int dword_20001FDC;
// 20001FE0: using guessed type int dword_20001FE0;
// 20001FE4: using guessed type int dword_20001FE4;
// 20001FE8: using guessed type int dword_20001FE8;
// 20001FEC: using guessed type int dword_20001FEC;
// 20001FF0: using guessed type int dword_20001FF0;
// 20001FF4: using guessed type char byte_20001FF4;
// 20001FF5: using guessed type char byte_20001FF5;
// 20001FF8: using guessed type int dword_20001FF8;
// 20001FFC: using guessed type char byte_20001FFC;
// 20002000: using guessed type int dword_20002000;
// 20002004: using guessed type int dword_20002004;
// 20002008: using guessed type int dword_20002008;
// 20002010: using guessed type char byte_20002010;
// 20002014: using guessed type int dword_20002014;
// 20002018: using guessed type char byte_20002018;
// 2000201C: using guessed type int dword_2000201C;
// 20002020: using guessed type int dword_20002020;
// 20002024: using guessed type int dword_20002024;
// 20002028: using guessed type int dword_20002028;

//----- (080039A8) --------------------------------------------------------
int sub_80039A8()
{
  int v0; // r8
  double v1; // r0
  int v2; // s0
  int result; // r0

  word_20001C30 = word_20000078;
  word_20001C2E = word_2000007A;
  word_20001C2C = word_2000007C;
  word_20001C3C = word_20000084;
  word_20001C32 = word_20000074;
  word_20001C34 = word_20000076;
  word_20001C3A = word_2000007E;
  word_20001C36 = word_20000080;
  word_20001C38 = word_20000082;
  word_20001C3E = word_20000086;
  word_20001C40 = word_20000088;
  v0 = word_20002044;
  word_20001C42 = word_20002044;
  word_20001C44 = word_20002046;
  word_20001C46 = word_20002048;
  flt_20001C00 = (float)word_2000007A * 0.00073242;
  *(float *)&dword_20001C18 = (float)(word_20000086 - word_2000007A) * 0.0046762;
  *(float *)&dword_20001C1C = (float)(word_20000088 - word_2000007A) * 0.0034526;
  sub_8002764((unsigned __int16)word_2000007E);
  dword_20001BF0 = sub_8002814(COERCE__INT64(v1 * 0.019293064));
  *(float *)&v2 = (float)((unsigned __int16)word_20000082 - (unsigned __int16)word_2000007A) * 0.06;
  dword_20001BF4 = v2;
  sub_80181A0(v0);
  dword_20001C20 = v2;
  sub_8018114(word_20001C44);
  dword_20001C24 = v2;
  result = sub_8018114(word_20001C46);
  dword_20001C28 = v2;
  return result;
}
// 8003A50: variable 'v1' is possibly undefined
// 20000074: using guessed type __int16 word_20000074;
// 20000076: using guessed type __int16 word_20000076;
// 20000078: using guessed type __int16 word_20000078;
// 2000007A: using guessed type __int16 word_2000007A;
// 2000007C: using guessed type __int16 word_2000007C;
// 2000007E: using guessed type __int16 word_2000007E;
// 20000080: using guessed type __int16 word_20000080;
// 20000082: using guessed type __int16 word_20000082;
// 20000084: using guessed type __int16 word_20000084;
// 20000086: using guessed type __int16 word_20000086;
// 20000088: using guessed type __int16 word_20000088;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001C00: using guessed type float flt_20001C00;
// 20001C18: using guessed type int dword_20001C18;
// 20001C1C: using guessed type int dword_20001C1C;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 20001C2C: using guessed type __int16 word_20001C2C;
// 20001C2E: using guessed type __int16 word_20001C2E;
// 20001C30: using guessed type __int16 word_20001C30;
// 20001C32: using guessed type __int16 word_20001C32;
// 20001C34: using guessed type __int16 word_20001C34;
// 20001C36: using guessed type __int16 word_20001C36;
// 20001C38: using guessed type __int16 word_20001C38;
// 20001C3A: using guessed type __int16 word_20001C3A;
// 20001C3C: using guessed type __int16 word_20001C3C;
// 20001C3E: using guessed type __int16 word_20001C3E;
// 20001C40: using guessed type __int16 word_20001C40;
// 20001C42: using guessed type __int16 word_20001C42;
// 20001C44: using guessed type __int16 word_20001C44;
// 20001C46: using guessed type __int16 word_20001C46;
// 20002044: using guessed type __int16 word_20002044;
// 20002046: using guessed type __int16 word_20002046;
// 20002048: using guessed type __int16 word_20002048;

//----- (08003ABC) --------------------------------------------------------
int __fastcall sub_8003ABC(int result, int a2, int a3, int a4)
{
  int i; // r4
  int v5; // r5

  for ( i = 0; ; ++i )
  {
    v5 = dword_200008E0[result];
    if ( v5 <= i )
      break;
    *(_DWORD *)(a2 + 4 * i) ^= *(_DWORD *)(a3 + 4 * (i + a4 * v5));
  }
  return result;
}
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003AE8) --------------------------------------------------------
int __fastcall sub_8003AE8(int a1, int a2, _WORD *a3, int a4, int a5)
{
  int v9; // r0
  int v10; // r1
  int i; // r0
  int j; // r7
  int k; // r4
  _DWORD v15[4]; // [sp+4h] [bp-124h] BYREF
  _BYTE v16[276]; // [sp+14h] [bp-114h] BYREF

  if ( !a2 || !a3 || !*a3 || (unsigned __int16)*a3 >= 0x400u || !a4 || !a5 )
    return 0;
  sub_8002364(v16, 240);
  memset(v15, 0, sizeof(v15));
  sub_8003BE8(a1, a4, (int)v16);
  v9 = (unsigned __int16)*a3;
  if ( v9 << 28 )
    v10 = 16 - (v9 & 0xF);
  else
    v10 = 16;
  if ( (unsigned int)(v9 + v10) > 0x400 )
    return 0;
  for ( i = 0; i < v10; ++i )
    *(_BYTE *)((unsigned __int16)*a3 + a2 + i) = v10;
  *a3 += v10;
  for ( j = 0; (unsigned __int16)*a3 > j; j += 4 * dword_200008E0[a1] )
  {
    qmemcpy((unsigned int)v15, a2 + j, 4 * dword_200008E0[a1]);
    for ( k = 0; dword_200008C8[a1] >= k; ++k )
    {
      if ( k > 0 )
      {
        sub_8003E1C(a1, (int)v15);
        sub_8003DCC(a1, (int)v15);
        if ( dword_200008C8[a1] > k )
          sub_8003C98(a1, (int)v15);
      }
      sub_8003ABC(a1, (int)v15, (int)v16, k);
    }
    qmemcpy(a2 + j, (unsigned int)v15, 4 * dword_200008E0[a1]);
  }
  return a2;
}
// 200008C8: using guessed type _DWORD dword_200008C8[3];
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003BE8) --------------------------------------------------------
int __fastcall sub_8003BE8(int a1, int a2, int a3)
{
  int v5; // r4
  int v6; // r0
  int v7; // r0
  int result; // r0
  unsigned __int8 v9; // r0
  unsigned int v10; // r0
  int v11; // r3

  v5 = 0;
  do
  {
    *(_DWORD *)(a3 + 4 * v5) = *(_DWORD *)(a2 + 4 * v5);
    ++v5;
  }
  while ( v5 < dword_200008D4[a1] );
  do
  {
    v6 = dword_200008D4[a1];
    if ( v5 % v6 )
    {
      if ( v6 > 6 && v5 % v6 == 4 )
        v7 = sub_8003E4C(*(_DWORD *)(a3 + 4 * (v5 - 1)));
      else
        v7 = *(_DWORD *)(a3 + 4 * (v5 - 1));
    }
    else
    {
      v9 = sub_8003DB8(*(_DWORD *)(a3 + 4 * (v5 - 1)));
      sub_8003E4C(v9);
      v10 = sub_8003E7C(*(_DWORD *)&aV1rzima0gcsqgs[4 * (v5 / dword_200008D4[a1]) + 136]);
      v7 = v10 ^ v11;
    }
    *(_DWORD *)(a3 + 4 * v5) = *(_DWORD *)(a3 + 4 * (v5 - dword_200008D4[a1])) ^ v7;
    result = dword_200008E0[a1] * (dword_200008C8[a1] + 1);
    ++v5;
  }
  while ( result > v5 );
  return result;
}
// 8003C80: variable 'v11' is possibly undefined
// 200008C8: using guessed type _DWORD dword_200008C8[3];
// 200008D4: using guessed type _DWORD dword_200008D4[3];
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003C98) --------------------------------------------------------
int __fastcall sub_8003C98(int a1, int a2)
{
  int i; // r6
  int j; // r4
  int k; // r5
  int m; // r0
  int result; // r0
  _BYTE v9[4]; // [sp+0h] [bp-38h]
  int v10; // [sp+4h] [bp-34h]
  int v11; // [sp+8h] [bp-30h]
  int v12; // [sp+Ch] [bp-2Ch]
  int v13; // [sp+10h] [bp-28h]

  v10 = 16843522;
  v11 = 16974337;
  v12 = 50462977;
  v13 = 33620227;
  for ( i = 0; ; ++i )
  {
    result = dword_200008E0[a1];
    if ( result <= i )
      break;
    for ( j = 0; j < 4; ++j )
    {
      v9[j] = 0;
      for ( k = 0; k < 4; ++k )
        v9[j] ^= sub_8003D24(*(unsigned __int8 *)(a2 + k + 4 * i));
    }
    for ( m = 0; m < 4; ++m )
      *(_BYTE *)(a2 + m + 4 * i) = v9[m];
  }
  return result;
}
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003D24) --------------------------------------------------------
int __fastcall sub_8003D24(unsigned int a1)
{
  __int16 v2; // r0
  char v3; // r3
  __int16 v4; // r4
  __int16 v5; // r0
  unsigned int v6; // r3
  __int16 v7; // r4
  __int16 v8; // r0
  unsigned int v9; // r3
  __int16 v10; // r5
  __int16 v11; // r0
  unsigned int v12; // r3
  __int16 v13; // r5
  __int16 v14; // r0
  unsigned int v15; // r3
  __int16 v16; // r4
  __int16 v17; // r0
  unsigned int v18; // r3
  __int16 v19; // r4
  __int16 v20; // r0
  unsigned int v21; // r3
  __int16 v22; // r4
  char v23; // r0
  unsigned int v24; // r3

  v2 = sub_8003EA6(a1, 0);
  v4 = v2 * (v3 & 1);
  v5 = sub_8003EA6(a1, 1);
  v7 = v4 ^ (v5 * ((v6 >> 1) & 1));
  v8 = sub_8003EA6(a1, 2);
  v10 = v8 * ((v9 >> 2) & 1);
  v11 = sub_8003EA6(a1, 3);
  v13 = v10 ^ (v11 * ((v12 >> 3) & 1));
  v14 = sub_8003EA6(a1, 4);
  v16 = v7 ^ v13 ^ (v14 * ((v15 >> 4) & 1));
  v17 = sub_8003EA6(a1, 5);
  v19 = v16 ^ (v17 * ((v18 >> 5) & 1));
  v20 = sub_8003EA6(a1, 6);
  v22 = v19 ^ (v20 * ((v21 >> 6) & 1));
  v23 = sub_8003EA6(a1, 7);
  return (unsigned __int8)v22 ^ (unsigned __int8)(v23 * (v24 >> 7));
}
// 8003D32: variable 'v3' is possibly undefined
// 8003D42: variable 'v6' is possibly undefined
// 8003D54: variable 'v9' is possibly undefined
// 8003D64: variable 'v12' is possibly undefined
// 8003D78: variable 'v15' is possibly undefined
// 8003D8A: variable 'v18' is possibly undefined
// 8003D9C: variable 'v21' is possibly undefined
// 8003DAE: variable 'v24' is possibly undefined

//----- (08003DB8) --------------------------------------------------------
int __fastcall sub_8003DB8(int a1)
{
  return __ROR4__(a1, 8);
}

//----- (08003DC0) --------------------------------------------------------
int __fastcall sub_8003DC0(int a1)
{
  return (unsigned __int8)aV1rzima0gcsqgs[a1 + 200];
}

//----- (08003DCC) --------------------------------------------------------
int __fastcall sub_8003DCC(int result, int a2)
{
  int i; // r2
  int j; // r4
  char v4; // r7
  int k; // r3

  for ( i = 1; dword_200008E0[result] > i; ++i )
  {
    for ( j = 0; j < i; ++j )
    {
      v4 = *(_BYTE *)(a2 + i);
      for ( k = 0; dword_200008E0[result] > k; ++k )
        *(_BYTE *)(a2 + i + 4 * k) = *(_BYTE *)(a2 + i + 4 * (k + 1));
      *(_BYTE *)(a2 + i + 4 * (dword_200008E0[result] - 1)) = v4;
    }
  }
  return result;
}
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003E1C) --------------------------------------------------------
int __fastcall sub_8003E1C(int a1, int a2)
{
  int i; // r3
  int j; // r2
  int v6; // r2
  int result; // r0

  for ( i = 0; ; ++i )
  {
    result = dword_200008E0[a1];
    if ( result <= i )
      break;
    for ( j = 0; j < 4; j = v6 + 1 )
      *(_BYTE *)(a2 + j + 4 * i) = sub_8003DC0(*(unsigned __int8 *)(a2 + j + 4 * i));
  }
  return result;
}
// 8003E2A: variable 'i' is possibly undefined
// 8003E36: variable 'v6' is possibly undefined
// 200008E0: using guessed type _DWORD dword_200008E0[4];

//----- (08003E4C) --------------------------------------------------------
int __fastcall sub_8003E4C(unsigned __int8 a1)
{
  unsigned __int8 v1; // r2^1
  unsigned __int8 v2; // r2^2
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r3

  sub_8003DC0(a1);
  sub_8003DC0(v1);
  sub_8003DC0(v2);
  v4 = sub_8003DC0(HIBYTE(v3));
  return v5 | (v4 << 24);
}
// 8003E58: variable 'v1' is possibly undefined
// 8003E64: variable 'v2' is possibly undefined
// 8003E70: variable 'v3' is possibly undefined
// 8003E76: variable 'v5' is possibly undefined

//----- (08003E7C) --------------------------------------------------------
unsigned int __fastcall sub_8003E7C(unsigned int a1)
{
  return (a1 << 24) | ((a1 & 0xFF00) << 8) | ((a1 & 0xFF0000) >> 8) | HIBYTE(a1);
}

//----- (08003E94) --------------------------------------------------------
int __fastcall sub_8003E94(unsigned int a1)
{
  return (unsigned __int8)(27 * (a1 >> 7)) ^ (unsigned __int8)(2 * a1);
}

//----- (08003EA6) --------------------------------------------------------
unsigned int __fastcall sub_8003EA6(unsigned int result, int a2)
{
  int v2; // r2

  v2 = a2;
  while ( v2 > 0 )
    result = sub_8003E94(result);
  return result;
}
// 8003EB6: variable 'v2' is possibly undefined

//----- (08003EBC) --------------------------------------------------------
void sub_8003EBC()
{
  unsigned int v0; // r0

  v0 = (dword_2000002C - dword_200008C4) / (unsigned int)(unsigned __int16)word_200008C2;
  if ( byte_200008C0 )
  {
    if ( byte_200008C0 == 1 )
    {
      if ( v0 >= 9 )
      {
        if ( v0 >= 0x12 )
        {
          sub_80031E4();
          byte_200008C0 = 0;
        }
        else if ( (unsigned __int8)byte_200008C1 != v0 )
        {
          byte_200008C1 = (dword_2000002C - dword_200008C4) / (unsigned int)(unsigned __int16)word_200008C2;
          goto LABEL_7;
        }
      }
      else if ( (unsigned __int8)byte_200008C1 != v0 )
      {
        byte_200008C1 = (dword_2000002C - dword_200008C4) / (unsigned int)(unsigned __int16)word_200008C2;
        goto LABEL_7;
      }
    }
    else if ( byte_200008C0 == 2 )
    {
      if ( v0 >= 0xA )
      {
        sub_80031E4();
        byte_200008C0 = 0;
      }
      else if ( (unsigned __int8)byte_200008C1 != v0 )
      {
        byte_200008C1 = (dword_2000002C - dword_200008C4) / (unsigned int)(unsigned __int16)word_200008C2;
LABEL_7:
        sub_80031E4();
      }
    }
  }
}
// 2000002C: using guessed type int dword_2000002C;
// 200008C0: using guessed type char byte_200008C0;
// 200008C1: using guessed type char byte_200008C1;
// 200008C2: using guessed type __int16 word_200008C2;
// 200008C4: using guessed type int dword_200008C4;

//----- (080040A0) --------------------------------------------------------
int __fastcall sub_80040A0(char *a1, int a2, int a3, unsigned int a4)
{
  int v5; // r3
  int v6; // r4
  int v7; // r7
  char v8; // t1
  int i; // r0
  int v10; // [sp+0h] [bp-1Ch]
  int v11; // [sp+0h] [bp-1Ch]
  _DWORD v12[6]; // [sp+4h] [bp-18h]

  v12[0] = a4;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a4 < 4 * ((a2 + 2) / 3u) )
    return 0;
  v5 = 0;
  v6 = 0;
  while ( --a2 != -1 )
  {
    v7 = v5;
    v8 = *a1++;
    ++v5;
    *((_BYTE *)v12 + v7) = v8;
    if ( v5 == 3 )
    {
      LOBYTE(v10) = aV1rzima0gcsqgs[(LOBYTE(v12[0]) >> 2) + 72];
      BYTE1(v10) = aV1rzima0gcsqgs[((16 * LOBYTE(v12[0])) & 0x3F) + 72 + (BYTE1(v12[0]) >> 4)];
      BYTE2(v10) = aV1rzima0gcsqgs[((4 * BYTE1(v12[0])) & 0x3F) + 72 + (BYTE2(v12[0]) >> 6)];
      HIBYTE(v10) = aV1rzima0gcsqgs[(BYTE2(v12[0]) & 0x3F) + 72];
      *(_DWORD *)(a3 + v6) = v10;
      v6 += 4;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    for ( i = v5; i < 3; ++i )
      *((_BYTE *)v12 + i) = 0;
    if ( v5 == 1 )
      BYTE2(v11) = 61;
    else
      BYTE2(v11) = aV1rzima0gcsqgs[4 * (BYTE1(v12[0]) & 0xF) + 72];
    HIBYTE(v11) = 61;
    BYTE1(v11) = aV1rzima0gcsqgs[((16 * LOBYTE(v12[0])) & 0x3F) + 72 + (BYTE1(v12[0]) >> 4)];
    LOBYTE(v11) = aV1rzima0gcsqgs[(LOBYTE(v12[0]) >> 2) + 72];
    *(_DWORD *)(a3 + v6) = v11;
    v6 += 4;
  }
  *(_BYTE *)(a3 + v6) = 0;
  return 1;
}

//----- (08004188) --------------------------------------------------------
int *__fastcall sub_8004188(int *a1, int a2, int a3)
{
  _DWORD v7[9]; // [sp+4h] [bp-24h] BYREF

  sub_8002364(v7, 20);
  v7[0] = a2;
  v7[1] = 0;
  v7[2] = a3;
  return sub_80120B0(a1, (int)v7);
}

//----- (080041AE) --------------------------------------------------------
int *__fastcall sub_80041AE(int *a1, int a2, int a3)
{
  _DWORD v7[9]; // [sp+4h] [bp-24h] BYREF

  sub_8002364(v7, 20);
  v7[0] = a2;
  v7[1] = 1114112;
  v7[2] = a3;
  return sub_80120B0(a1, (int)v7);
}

//----- (080041D6) --------------------------------------------------------
int *__fastcall sub_80041D6(int *a1, int a2)
{
  _DWORD v5[8]; // [sp+0h] [bp-20h] BYREF

  sub_8002364(v5, 20);
  v5[0] = a2;
  v5[1] = 1;
  v5[2] = 2;
  v5[3] = 2;
  return sub_80120B0(a1, (int)v5);
}

//----- (08004200) --------------------------------------------------------
int __fastcall sub_8004200(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !sub_8024F80(dword_20000458, 400) )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  sub_800E274((int)a1, (unsigned __int16)(v2 - 1));
  byte_200036B1 = 2;
  sub_801A88C(
    (int)"%s %d %s\r\n",
    "8EAjAAMA4GA1Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n",
    582,
    (const char *)a1);
  return 1;
}
// 20000458: using guessed type int dword_20000458;
// 200036B1: using guessed type char byte_200036B1;

//----- (08004258) --------------------------------------------------------
int sub_8004258()
{
  int result; // r0
  unsigned __int8 *v1; // r0
  int v2; // r0
  char *v3; // r0
  int v4; // r0
  unsigned __int8 v5[148]; // [sp+4h] [bp-94h] BYREF

  sub_8002364(v5, 128);
  result = (unsigned __int8)byte_200015E1;
  if ( !byte_200015E1 )
  {
    if ( byte_200015E0 )
    {
      if ( byte_200015E0 == 1 )
      {
        if ( sub_8024E28(dword_20000430, (unsigned int)v5, 400) == 1 )
        {
          sub_801A88C((int)"\r\n%s %d %s", "_ver: %d, bms_ver: %d, fc_ver: %s.\r\n", 867, (const char *)v5);
          if ( strstr(v5, "+QIRD") )
          {
            sub_8002364(v5, 128);
            if ( sub_8024E28(dword_20000430, (unsigned int)v5, 400) == 1 )
            {
              sub_801A88C((int)"\r\n%s %d %s", "_ver: %d, bms_ver: %d, fc_ver: %s.\r\n", 873, (const char *)v5);
              sub_801ECA0();
              v4 = sub_801A1A0(v5);
              byte_200015E6 = byte_200015E3;
              byte_200015E7 = byte_200015E2;
              if ( v4 )
                byte_200015E8 = 0;
              else
                ++byte_200015E8;
            }
            else
            {
              sub_801ECA0();
            }
          }
          else
          {
            ++byte_200015E8;
          }
        }
        else
        {
          ++byte_200015E8;
          sub_801ECA0();
        }
        byte_200015E0 = 0;
      }
    }
    else if ( sub_8024E28(dword_20000430, (unsigned int)v5, 400) == 1 )
    {
      sub_801ECA0();
      sub_801A88C((int)"\r\n%s %d %s", "_ver: %d, bms_ver: %d, fc_ver: %s.\r\n", 823, (const char *)v5);
      v1 = strstr(v5, "+QIRD");
      if ( v1 )
      {
        v2 = sub_80023CE((int)v1, 0x2Cu);
        if ( v2 )
        {
          v3 = (char *)(sub_80023CE(v2 + 1, 0x2Cu) + 1);
          if ( v3 == (char *)1 )
          {
            ++byte_200015E8;
          }
          else
          {
            word_200015EE = sub_8002644(v3);
            sub_801A88C(
              (int)"\r\n%s %d %d",
              "_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
              833,
              (unsigned __int16)word_200015EE);
            if ( word_200015EE )
            {
              if ( (unsigned __int16)word_200015EE <= 0x68u )
                byte_200015E8 = 0;
              else
                word_200015EE = 104;
              byte_200015E0 = 1;
              byte_200015DD = 1;
            }
            else
            {
              ++byte_200015E8;
            }
          }
        }
        else
        {
          ++byte_200015E8;
        }
      }
      else
      {
        ++byte_200015E8;
      }
    }
    else
    {
      sub_801ECA0();
    }
    result = (unsigned __int8)byte_200015E8;
    if ( (unsigned __int8)byte_200015E8 > 0x14u )
    {
      byte_200015E8 = 0;
      byte_200015E0 = 0;
      byte_200015DE = 0;
    }
  }
  return result;
}
// 20000430: using guessed type int dword_20000430;
// 200015DD: using guessed type char byte_200015DD;
// 200015DE: using guessed type char byte_200015DE;
// 200015E0: using guessed type char byte_200015E0;
// 200015E1: using guessed type char byte_200015E1;
// 200015E2: using guessed type char byte_200015E2;
// 200015E3: using guessed type char byte_200015E3;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 200015E8: using guessed type char byte_200015E8;
// 200015EE: using guessed type __int16 word_200015EE;

//----- (080043D0) --------------------------------------------------------
int sub_80043D0()
{
  int result; // r0
  unsigned __int8 v1[140]; // [sp+4h] [bp-8Ch] BYREF

  if ( byte_200015DF )
    byte_200015DF = 0;
  sub_8002364(v1, 128);
  result = (unsigned __int8)byte_200015E0;
  if ( byte_200015E0 )
  {
    if ( byte_200015E0 == 1 )
    {
      result = (unsigned __int8)byte_200015E1;
      if ( byte_200015E1 )
      {
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015E3, (unsigned __int16)word_200015EE);
        result = sub_8004200(v1);
        if ( result )
          byte_200015E1 = 0;
      }
    }
  }
  else if ( sub_8024F80(dword_2000042C, 400) == 1 || (result = sub_801AACC(&word_200015F2, 0x320u)) != 0 )
  {
    result = (unsigned __int8)byte_200015E1;
    if ( byte_200015E1 )
    {
      byte_200015DD = 1;
      sub_8002364(v1, 128);
      sprintf((int)v1, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015E3);
      result = sub_8004200(v1);
      if ( result )
        byte_200015E1 = 0;
    }
  }
  return result;
}
// 2000042C: using guessed type int dword_2000042C;
// 200015DD: using guessed type char byte_200015DD;
// 200015DF: using guessed type char byte_200015DF;
// 200015E0: using guessed type char byte_200015E0;
// 200015E1: using guessed type char byte_200015E1;
// 200015E3: using guessed type char byte_200015E3;
// 200015EE: using guessed type __int16 word_200015EE;
// 200015F2: using guessed type _WORD;

//----- (0800448C) --------------------------------------------------------
void __fastcall sub_800448C(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  if ( byte_200015DE )
    sub_8004258();
  else
    sub_801B824(0, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}
// 200015DE: using guessed type char byte_200015DE;

//----- (080044A0) --------------------------------------------------------
void sub_80044A0()
{
  if ( byte_200015DE )
    sub_80043D0();
  else
    sub_801BFDC();
}
// 200015DE: using guessed type char byte_200015DE;

//----- (080044B4) --------------------------------------------------------
void __fastcall sub_80044B4(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3

  if ( byte_20000928 )
  {
    sub_80044A0();
    sub_800448C(v13, v14, v15, v16, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  }
  else
  {
    byte_200015E3 = 1;
    byte_200015E2 = 0;
    sub_8004678();
  }
}
// 80044CC: variable 'v13' is possibly undefined
// 80044CC: variable 'v14' is possibly undefined
// 80044CC: variable 'v15' is possibly undefined
// 80044CC: variable 'v16' is possibly undefined
// 20000928: using guessed type char byte_20000928;
// 200015E2: using guessed type char byte_200015E2;
// 200015E3: using guessed type char byte_200015E3;

//----- (080044EC) --------------------------------------------------------
int __fastcall sub_80044EC(int a1)
{
  int v1; // r2

  v1 = (unsigned __int8)byte_200008F1;
  switch ( byte_200008F1 )
  {
    case 0:
      if ( a1 == 43 )
      {
        byte_200008F1 = 1;
        byte_20003EF5[0] = 43;
      }
      else
      {
        sub_8002364(byte_20003EF5, 128);
      }
      goto LABEL_37;
    case 1:
      if ( a1 != 81 )
        goto LABEL_33;
      byte_200008F1 = 2;
      byte_20003EF6 = 81;
      goto LABEL_37;
    case 2:
      if ( a1 != 73 )
        goto LABEL_33;
      byte_200008F1 = 3;
      byte_20003EF7 = 73;
      goto LABEL_37;
    case 3:
      if ( a1 != 85 )
        goto LABEL_33;
      byte_200008F1 = 4;
      byte_20003EF8 = 85;
      goto LABEL_37;
    case 4:
      if ( a1 != 82 )
        goto LABEL_33;
      byte_200008F1 = 5;
      byte_20003EF9 = 82;
      goto LABEL_37;
    case 5:
      if ( a1 != 67 )
        goto LABEL_33;
      byte_200008F1 = 6;
      byte_20003EFA = 67;
      goto LABEL_37;
    case 6:
      if ( a1 != 58 )
        goto LABEL_33;
      byte_200008F1 = 7;
      byte_20003EFB = 58;
      goto LABEL_37;
    case 7:
      if ( a1 != 32 )
        goto LABEL_33;
      byte_200008F1 = 8;
      byte_20003EFC = 32;
      goto LABEL_37;
    case 8:
      if ( a1 != 34 )
        goto LABEL_33;
      byte_200008F1 = 9;
      byte_20003EFD = 34;
      goto LABEL_37;
    case 9:
      if ( a1 != 114 )
        goto LABEL_33;
      byte_200008F1 = 10;
      byte_20003EFE = 114;
      goto LABEL_37;
    case 10:
      if ( a1 != 101 )
        goto LABEL_33;
      byte_200008F1 = 11;
      byte_20003EFF = 101;
      goto LABEL_37;
    case 11:
      if ( a1 != 99 )
        goto LABEL_33;
      byte_200008F1 = 12;
      byte_20003F00 = 99;
      goto LABEL_37;
    case 12:
      if ( a1 == 118 )
      {
        byte_200008F1 = 13;
        byte_20003F01 = 118;
      }
      else
      {
LABEL_33:
        byte_200008F1 = 0;
        sub_8002364(byte_20003EF5, 128);
      }
      goto LABEL_37;
    default:
      if ( a1 == 10 )
      {
        byte_20003EF5[(unsigned __int8)byte_200008F1] = 10;
        byte_200008F1 = 0;
        return 3;
      }
      else
      {
        ++byte_200008F1;
        byte_20003EF5[v1] = a1;
LABEL_37:
        if ( (unsigned __int8)byte_200008F1 >= 0x7Fu )
        {
          byte_200008F1 = 0;
          sub_8002364(byte_20003EF5, 128);
        }
        return 0;
      }
  }
}
// 200008F1: using guessed type char byte_200008F1;
// 20003EF6: using guessed type char byte_20003EF6;
// 20003EF7: using guessed type char byte_20003EF7;
// 20003EF8: using guessed type char byte_20003EF8;
// 20003EF9: using guessed type char byte_20003EF9;
// 20003EFA: using guessed type char byte_20003EFA;
// 20003EFB: using guessed type char byte_20003EFB;
// 20003EFC: using guessed type char byte_20003EFC;
// 20003EFD: using guessed type char byte_20003EFD;
// 20003EFE: using guessed type char byte_20003EFE;
// 20003EFF: using guessed type char byte_20003EFF;
// 20003F00: using guessed type char byte_20003F00;
// 20003F01: using guessed type char byte_20003F01;

//----- (08004678) --------------------------------------------------------
char *sub_8004678()
{
  char *result; // r0

  result = &byte_200015D4;
  byte_200015DE = 0;
  byte_200015DF = 0;
  byte_200015E0 = 0;
  return result;
}
// 200015D4: using guessed type char byte_200015D4;
// 200015DE: using guessed type char byte_200015DE;
// 200015DF: using guessed type char byte_200015DF;
// 200015E0: using guessed type char byte_200015E0;

//----- (08004688) --------------------------------------------------------
int sub_8004688()
{
  unsigned int v0; // r2
  unsigned int v1; // r3
  int result; // r0
  unsigned int v3; // r1

  v0 = (unsigned __int16)dword_20002D77;
  v1 = (unsigned __int16)dword_20002D77;
  for ( result = 1; result < 16; ++result )
  {
    v3 = *(unsigned __int16 *)((char *)&dword_20002D4C + 2 * result + 43);
    if ( v3 > v0 )
      v0 = *(unsigned __int16 *)((char *)&dword_20002D4C + 2 * result + 43);
    if ( v3 < v1 )
      v1 = *(unsigned __int16 *)((char *)&dword_20002D4C + 2 * result + 43);
  }
  word_20002D97 = v0;
  word_20002D99 = v1;
  return result;
}
// 20002D4C: using guessed type int dword_20002D4C;
// 20002D77: using guessed type int dword_20002D77;
// 20002D97: using guessed type __int16 word_20002D97;
// 20002D99: using guessed type __int16 word_20002D99;

//----- (080046BC) --------------------------------------------------------
int __fastcall sub_80046BC(int result, int *a2)
{
  int v2; // r3
  int v3; // r3

  if ( result == 864 )
  {
    dword_20002D77 = *a2;
    result = a2[1];
    dword_20002D7B = result;
  }
  else if ( result > 864 )
  {
    v3 = result - 867;
    if ( result == 867 )
    {
      dword_20002D8F = *a2;
      result = a2[1];
      dword_20002D93 = result;
    }
    else if ( result > 867 )
    {
      if ( result == 874 )
      {
        dword_20002D6F = *a2;
        result = a2[1];
        dword_20002D73 = result;
      }
      else if ( result == 875 )
      {
        result = *a2;
        *(int *)((char *)&dword_20002D68 + 3) = *a2;
      }
    }
    else
    {
      result -= 865;
      if ( v3 == -2 )
      {
        dword_20002D7F = *a2;
        result = a2[1];
        dword_20002D83 = result;
      }
      else if ( v3 == -1 )
      {
        dword_20002D87 = *a2;
        result = a2[1];
        dword_20002D8B = result;
      }
    }
  }
  else
  {
    v2 = result - 854;
    if ( result == 854 )
    {
      dword_20002D5A = *a2;
      result = *((unsigned __int16 *)a2 + 2);
      word_20002D5E = *((_WORD *)a2 + 2);
    }
    else if ( result > 854 )
    {
      if ( result == 857 )
      {
        dword_20002D60 = *a2;
        result = a2[1];
        dword_20002D64 = result;
      }
      else if ( result == 860 )
      {
        dword_20002D68 = *a2;
        result = sub_8012298();
        dword_20000474 = result;
      }
    }
    else
    {
      result -= 849;
      if ( v2 == -5 )
      {
        dword_20002D4C = *a2;
        result = *((unsigned __int16 *)a2 + 2);
        word_20002D50 = *((_WORD *)a2 + 2);
      }
      else if ( v2 == -1 )
      {
        dword_20002D52 = *a2;
        result = a2[1];
        *(_DWORD *)&word_20002D56 = result;
      }
    }
  }
  return result;
}
// 20000474: using guessed type int dword_20000474;
// 20002D4C: using guessed type int dword_20002D4C;
// 20002D50: using guessed type __int16 word_20002D50;
// 20002D52: using guessed type int dword_20002D52;
// 20002D56: using guessed type __int16 word_20002D56;
// 20002D5A: using guessed type int dword_20002D5A;
// 20002D5E: using guessed type __int16 word_20002D5E;
// 20002D60: using guessed type int dword_20002D60;
// 20002D64: using guessed type int dword_20002D64;
// 20002D68: using guessed type int dword_20002D68;
// 20002D6F: using guessed type int dword_20002D6F;
// 20002D73: using guessed type int dword_20002D73;
// 20002D77: using guessed type int dword_20002D77;
// 20002D7B: using guessed type int dword_20002D7B;
// 20002D7F: using guessed type int dword_20002D7F;
// 20002D83: using guessed type int dword_20002D83;
// 20002D87: using guessed type int dword_20002D87;
// 20002D8B: using guessed type int dword_20002D8B;
// 20002D8F: using guessed type int dword_20002D8F;
// 20002D93: using guessed type int dword_20002D93;

//----- (0800478C) --------------------------------------------------------
BOOL sub_800478C()
{
  return sub_8004834(0, 773, 0);
}

//----- (08004798) --------------------------------------------------------
BOOL sub_8004798()
{
  int v1; // [sp+0h] [bp-8h] BYREF

  v1 = 1;
  return sub_8004834((int)&v1, 768, 1);
}

//----- (080047AC) --------------------------------------------------------
int sub_80047AC()
{
  return sub_800486C(2, 768, 768);
}

//----- (080047B8) --------------------------------------------------------
int sub_80047B8()
{
  sub_80047D0();
  return sub_800486C(2, 768, 768);
}

//----- (080047D0) --------------------------------------------------------
int sub_80047D0()
{
  sub_8011886((int)&dword_20002050);
  dword_20002050 = 1073768448;
  dword_20002054 = 0;
  dword_20002058 = 0;
  dword_2000205C = 0;
  byte_20002060 = 0;
  byte_20002061 = 0;
  byte_20002062 = 0;
  dword_20002064 = 17;
  dword_20002068 = 8;
  dword_2000206C = 11;
  dword_20002070 = 8;
  dword_20002084 = 4;
  dword_20002088 = 4;
  dword_2000208C = 0;
  sub_8011B20((int)&dword_20002050);
  sub_8011850((int)&dword_20002050, 2, 2, 1, 1);
  sub_8011DC2((int)&dword_20002050);
  sub_80116C4((unsigned __int8 *)&dword_20002050, 1, 1);
  return 0;
}
// 20002050: using guessed type int dword_20002050;
// 20002054: using guessed type int dword_20002054;
// 20002058: using guessed type int dword_20002058;
// 2000205C: using guessed type int dword_2000205C;
// 20002060: using guessed type char byte_20002060;
// 20002061: using guessed type char byte_20002061;
// 20002062: using guessed type char byte_20002062;
// 20002064: using guessed type int dword_20002064;
// 20002068: using guessed type int dword_20002068;
// 2000206C: using guessed type int dword_2000206C;
// 20002070: using guessed type int dword_20002070;
// 20002084: using guessed type int dword_20002084;
// 20002088: using guessed type int dword_20002088;
// 2000208C: using guessed type int dword_2000208C;

//----- (08004834) --------------------------------------------------------
BOOL __fastcall sub_8004834(int a1, int a2, int a3)
{
  dword_200020B4 = a2;
  dword_200020B8 = 0;
  dword_200020BC = 0;
  dword_200020C0 = a3 << 16;
  dword_200020C4 = 0;
  dword_200020C8 = 0;
  dword_200020CC = 0;
  dword_200020D0 = 0;
  dword_200020D4 = 0;
  return sub_80117A4(&dword_20002050, &dword_200020B4, a1) != 0;
}
// 20002050: using guessed type int dword_20002050;
// 200020B4: using guessed type int dword_200020B4;
// 200020B8: using guessed type int dword_200020B8;
// 200020BC: using guessed type int dword_200020BC;
// 200020C0: using guessed type int dword_200020C0;
// 200020C4: using guessed type int dword_200020C4;
// 200020C8: using guessed type int dword_200020C8;
// 200020CC: using guessed type int dword_200020CC;
// 200020D0: using guessed type int dword_200020D0;
// 200020D4: using guessed type int dword_200020D4;

//----- (0800486C) --------------------------------------------------------
int __fastcall sub_800486C(int a1, int a2, int a3)
{
  _DWORD v7[10]; // [sp+0h] [bp-28h] BYREF

  sub_8002364(v7, 24);
  v7[0] = 0;
  v7[1] = a1;
  v7[2] = 2;
  v7[3] = 1;
  v7[4] = a2;
  v7[5] = a3;
  return sub_80117F2((int)&dword_20002050, (int)v7);
}
// 20002050: using guessed type int dword_20002050;

//----- (080048A0) --------------------------------------------------------
int __fastcall sub_80048A0(int a1)
{
  int i; // r4
  int result; // r0
  _DWORD v3[6]; // [sp+0h] [bp-18h] BYREF

  v3[0] = 0;
  v3[1] = 0;
  sprintf((int)v3, "%02x", a1);
  for ( i = 0; i < 2; ++i )
    result = sub_801CF74(*((unsigned __int8 *)v3 + i));
  return result;
}

//----- (080048CC) --------------------------------------------------------
BOOL sub_80048CC()
{
  int v0; // r4
  unsigned int i; // r0
  int v2; // r5

  v0 = 255;
  for ( i = 0; i < (unsigned __int8)byte_200015AB; ++i )
  {
    if ( byte_20010F11[i] == 115 && byte_20010F11[i + 2] == 14 )
      v0 = (unsigned __int8)i;
  }
  v2 = byte_20010F11[v0 + 1];
  if ( v0 == 255 || (unsigned __int8)byte_200015AB - v0 < v2 )
    return 0;
  if ( byte_20010F11[v0 - 1 + v2] == sub_800FE14((int)&byte_20010F11[v0], (unsigned __int8)(v2 - 1)) )
    return byte_20010F11[v0 + 5] == 0;
  return 0;
}
// 200015AB: using guessed type char byte_200015AB;
// 20010F11: using guessed type unsigned __int8 byte_20010F11[67];

//----- (08004934) --------------------------------------------------------
BOOL __fastcall sub_8004934(_BYTE *a1, unsigned int a2)
{
  if ( !a1 )
    return 0;
  if ( a2 > 0x8A )
    return 0;
  if ( a1[4] != 16 )
    return 0;
  if ( *a1 == 115 )
    return (unsigned __int8)a1[a2 - 1] == sub_800FE14((int)a1, (unsigned __int8)(a2 - 1));
  return 0;
}

//----- (0800497C) --------------------------------------------------------
void __fastcall sub_800497C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // r1
  int v9; // r0
  __int16 v10; // r0
  __int16 v11; // r0
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3

  v8 = 0;
  v9 = (int)(float)(*(float *)&dword_20002798 - flt_200004D4);
  if ( v9 < 0 )
    v9 = -v9;
  if ( (unsigned __int16)v9 > 0x1Eu || flt_200004D4 == 0.0 )
    word_200004C2[0] = 0;
  else
    v8 = 1;
  if ( byte_200004AA != 1 )
    JUMPOUT(0x8004A00);
  if ( v8 && (v10 = sub_800F65C(), sub_80180E8(word_200004C2, (unsigned __int16)(1000 * v10))) )
  {
    byte_200004AA = 2;
  }
  else
  {
    v11 = sub_800F65C();
    v12 = sub_80180E8(&word_200004B6, (unsigned __int16)(1000 * (v11 + 3)));
    BusFault_handler(v12, v13, v14, v15, a5, a6, a7, a8);
  }
}
// 80049BC: control flows out of bounds to 8004A00
// 80049FB: variable 'v13' is possibly undefined
// 80049FB: variable 'v14' is possibly undefined
// 80049FB: variable 'v15' is possibly undefined
// 200004AA: using guessed type char byte_200004AA;
// 200004B6: using guessed type __int16 word_200004B6;
// 200004C2: using guessed type __int16 word_200004C2[2];
// 200004D4: using guessed type float flt_200004D4;
// 20002798: using guessed type int dword_20002798;

//----- (080049FE) --------------------------------------------------------
void __fastcall BusFault_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // r4
  char v9; // r5

  if ( a1 )
  {
    *(_BYTE *)(v8 + 2) = v9;
    __asm { POP             {R4-R6,PC} }
  }
  __asm { POP             {R4-R6,PC} }
}
// 8004A08: unbalanced stack, ignored a potential tail call
// 8004A00: variable 'v9' is possibly undefined
// 8004A00: variable 'v8' is possibly undefined

//----- (08004A14) --------------------------------------------------------
void __fastcall sub_8004A14(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r1
  int v14; // [sp+0h] [bp-20h]
  int v15; // [sp+4h] [bp-1Ch]

  v14 = a3;
  v15 = a4;
  if ( byte_200015D6 )
  {
    sub_801A88C(
      (int)"%s %d choose_meter=%d, rechrg_mode=%d g_ct_type=%d\r\n",
      "_ver: %d, fc_ver: %s.\r\n",
      989,
      (unsigned __int8)byte_20002EA9,
      (unsigned __int8)byte_20002EA8,
      (unsigned __int8)byte_200015DC);
    byte_200015D6 = 0;
    byte_200015DF = 0;
    byte_200015E0 = 0;
    byte_200015D7 = 0;
    byte_200015DE = 0;
    byte_200015DC = 0;
    sub_8002364(byte_200110C0, 120);
    sub_80055F0(0x372u, &byte_20002EA9, 1u);
    dword_200050F0 = 0;
    dword_200050F4 = 0;
    dword_200050F8 = 0;
    dword_200050FC = 0;
  }
  if ( byte_20000928 )
  {
    sub_800F688();
    if ( (unsigned __int8)byte_20000929 < 0x50u )
    {
      if ( byte_20002EA9 )
      {
        if ( byte_20002EA9 != 2 && byte_20002EA9 != 7 )
          sub_80199A4();
      }
      else
      {
        sub_80044B4(0, v13, v14, v15, a5, a6, a7, a8, a9, a10, a11, a12, a13);
      }
    }
    else
    {
      byte_200015DE = 0;
    }
  }
  else
  {
    sub_8002364(byte_20011138, 128);
    byte_200015DF = 0;
    byte_200015E0 = 0;
    byte_200015D7 = 0;
    byte_200015DE = 0;
  }
}
// 8004AAE: variable 'v13' is possibly undefined
// 8004AAE: variable 'v14' is possibly undefined
// 8004AAE: variable 'v15' is possibly undefined
// 20000928: using guessed type char byte_20000928;
// 20000929: using guessed type char byte_20000929;
// 200015D6: using guessed type char byte_200015D6;
// 200015D7: using guessed type char byte_200015D7;
// 200015DC: using guessed type char byte_200015DC;
// 200015DE: using guessed type char byte_200015DE;
// 200015DF: using guessed type char byte_200015DF;
// 200015E0: using guessed type char byte_200015E0;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002EA9: using guessed type char byte_20002EA9;
// 200050F0: using guessed type int dword_200050F0;
// 200050F4: using guessed type int dword_200050F4;
// 200050F8: using guessed type int dword_200050F8;
// 200050FC: using guessed type int dword_200050FC;
// 200110C0: using guessed type unsigned __int8 byte_200110C0[44];

//----- (08004B04) --------------------------------------------------------
BOOL __fastcall sub_8004B04(unsigned __int8 *a1)
{
  if ( !a1 )
    return 0;
  if ( *(unsigned __int16 *)a1 > 0x63u )
    return 0;
  if ( (unsigned int)a1[2] - 1 >= 0xC )
    return 0;
  if ( (unsigned int)a1[3] - 1 >= 0x1F )
    return 0;
  if ( a1[5] > 0x18u )
    return 0;
  if ( a1[6] <= 0x3Cu )
    return a1[7] <= 0x3Cu;
  return 0;
}

//----- (08004B50) --------------------------------------------------------
BOOL __fastcall sub_8004B50(unsigned int a1)
{
  if ( !byte_200004D1 && !byte_200004D2 && !byte_200004D0 )
    return 0;
  if ( byte_200004D1 != byte_200050ED || byte_200004D2 != byte_200050EE )
    return 0;
  return word_2000505C[3 * (unsigned __int8)byte_200004D0] <= a1
      && word_2000505C[3 * (unsigned __int8)byte_200004D0 + 3] > a1;
}
// 200004D0: using guessed type char byte_200004D0;
// 200004D1: using guessed type char byte_200004D1;
// 200004D2: using guessed type char byte_200004D2;
// 2000505C: using guessed type unsigned __int16 word_2000505C[72];
// 200050ED: using guessed type char byte_200050ED;
// 200050EE: using guessed type char byte_200050EE;

//----- (08004BA8) --------------------------------------------------------
int sub_8004BA8()
{
  dword_20001938 = 1073807872;
  dword_2000193C = 0;
  dword_20001940 = 64;
  dword_20001948 = 0;
  dword_20001944 = 196608;
  dword_2000194C = 0;
  dword_20001950 = 0;
  if ( sub_8010C70((int)&dword_20001938) )
    sub_80058BC();
  return sub_8010F94((int)&dword_20001938);
}
// 20001938: using guessed type int dword_20001938;
// 2000193C: using guessed type int dword_2000193C;
// 20001940: using guessed type int dword_20001940;
// 20001944: using guessed type int dword_20001944;
// 20001948: using guessed type int dword_20001948;
// 2000194C: using guessed type int dword_2000194C;
// 20001950: using guessed type int dword_20001950;

//----- (08004BE0) --------------------------------------------------------
int sub_8004BE0()
{
  int result; // r0

  dword_2000195C = 1073807880;
  dword_20001960 = 256;
  dword_20001964 = 112;
  dword_2000196C = 0;
  dword_20001968 = 458752;
  dword_20001970 = 0;
  dword_20001974 = 0;
  if ( sub_8010C70((int)&dword_2000195C) )
    sub_80058BC();
  result = sub_8010F94((int)&dword_2000195C);
  if ( result )
    sub_80058BC();
  return result;
}
// 2000195C: using guessed type int dword_2000195C;
// 20001960: using guessed type int dword_20001960;
// 20001964: using guessed type int dword_20001964;
// 20001968: using guessed type int dword_20001968;
// 2000196C: using guessed type int dword_2000196C;
// 20001970: using guessed type int dword_20001970;
// 20001974: using guessed type int dword_20001974;

//----- (08004C24) --------------------------------------------------------
int sub_8004C24()
{
  dword_20001980 = 1073807884;
  dword_20001984 = 0;
  dword_20001988 = 80;
  dword_20001990 = 0;
  dword_2000198C = 196608;
  dword_20001994 = 0;
  dword_20001998 = 0;
  if ( sub_8010C70((int)&dword_20001980) )
    sub_80058BC();
  return sub_8010F94((int)&dword_20001980);
}
// 20001980: using guessed type int dword_20001980;
// 20001984: using guessed type int dword_20001984;
// 20001988: using guessed type int dword_20001988;
// 2000198C: using guessed type int dword_2000198C;
// 20001990: using guessed type int dword_20001990;
// 20001994: using guessed type int dword_20001994;
// 20001998: using guessed type int dword_20001998;

//----- (08004C5C) --------------------------------------------------------
int sub_8004C5C()
{
  sub_8004BA8();
  sub_8004BE0();
  return sub_8004C24();
}

//----- (08004C6E) --------------------------------------------------------
int __fastcall sub_8004C6E(int a1, __int16 a2, int a3, __int16 a4)
{
  if ( (unsigned __int16)a1 != (unsigned __int16)a3 )
    return (unsigned __int16)a1 - (unsigned __int16)a3;
  if ( BYTE2(a1) != BYTE2(a3) )
    return BYTE2(a1) - BYTE2(a3);
  if ( HIBYTE(a1) != HIBYTE(a3) )
    return HIBYTE(a1) - HIBYTE(a3);
  if ( (unsigned __int8)a2 == (unsigned __int8)a4 )
    return HIBYTE(a2) - HIBYTE(a4);
  return (unsigned __int8)a2 - (unsigned __int8)a4;
}

//----- (08004CBE) --------------------------------------------------------
int __fastcall sub_8004CBE(int result, int a2, unsigned int a3)
{
  unsigned int i; // r3

  if ( result && a2 && a3 )
  {
    for ( i = 0; i < a3; ++i )
      *(_BYTE *)(result + i) = *(_BYTE *)(a3 - i + a2 - 1);
  }
  return result;
}

//----- (08004CE4) --------------------------------------------------------
unsigned int __fastcall sub_8004CE4(float *a1)
{
  unsigned int v2; // r4
  unsigned int result; // r0
  unsigned int v4; // r5
  int v5; // r1

  v2 = 255;
  result = (unsigned __int8)byte_20002DF4;
  v4 = (unsigned __int8)byte_20002DF5 | ((unsigned __int8)byte_20002DF4 << 8);
  if ( a1 )
  {
    result = (unsigned __int8)byte_20002E38;
    if ( byte_20002E38 == 5 )
    {
      result = (unsigned __int8)byte_200050ED;
      if ( (unsigned __int8)byte_200050ED != 255 )
      {
        result = (unsigned __int8)byte_200050EC;
        if ( byte_200050EC )
        {
          if ( (unsigned __int8)byte_200050EC <= 0x18u )
          {
            result = sub_8004B50((unsigned __int8)byte_20002DF5 | ((unsigned __int8)byte_20002DF4 << 8));
            if ( result )
            {
              result = (unsigned int)&byte_200004D0;
              v2 = (unsigned __int8)byte_200004D0;
            }
            if ( v2 == 255 )
            {
              v5 = 0;
              while ( 1 )
              {
                result = word_2000505C[3 * v5];
                if ( result <= v4 )
                {
                  result = word_2000505C[3 * v5 + 3];
                  if ( result > v4 )
                    break;
                }
                if ( (unsigned int)++v5 >= 0x18 )
                  goto LABEL_14;
              }
              v2 = (unsigned __int8)v5;
              result = sub_8016D24(v5);
            }
LABEL_14:
            if ( v2 < 0x18 )
            {
              result = sub_800FCB4(*(_DWORD *)&word_2000505C[3 * v2], word_2000505C[3 * v2 + 2]);
              *a1 = (float)(int)result;
            }
          }
        }
      }
    }
  }
  return result;
}
// 200004D0: using guessed type char byte_200004D0;
// 20002DF4: using guessed type char byte_20002DF4;
// 20002DF5: using guessed type char byte_20002DF5;
// 20002E38: using guessed type char byte_20002E38;
// 2000505C: using guessed type unsigned __int16 word_2000505C[72];
// 200050EC: using guessed type char byte_200050EC;
// 200050ED: using guessed type char byte_200050ED;

//----- (08004DAC) --------------------------------------------------------
int *__fastcall sub_8004DAC(int *result)
{
  int v1; // r2
  int v2; // r1

  v1 = *result;
  if ( (unsigned int)*result >= 0x40020408 )
    v2 = 1073874976;
  else
    v2 = 1073874944;
  result[18] = v2 + (result[17] & 0xFFFFFFFC);
  result[19] = 1073875072;
  result[20] = 1 << ((((unsigned int)(unsigned __int8)v1 - 8) / 0x14) & 0x1F);
  return result;
}

//----- (08004DEC) --------------------------------------------------------
int __fastcall sub_8004DEC(int result)
{
  int v1; // r1

  v1 = *(unsigned __int8 *)(result + 4) - 1;
  *(_DWORD *)(result + 84) = 4 * v1 + 1073875200;
  *(_DWORD *)(result + 88) = 1073875264;
  *(_DWORD *)(result + 92) = 1 << (v1 & 0x1F);
  return result;
}

//----- (08004E10) --------------------------------------------------------
int __fastcall sub_8004E10(int *a1, int a2, int a3, int a4)
{
  int result; // r0

  *(_DWORD *)(a1[19] + 4) = a1[20];
  if ( a1[21] )
    *(_DWORD *)(a1[22] + 4) = a1[23];
  *(_DWORD *)(a1[16] + 4) = 1 << (a1[17] & 0x1F);
  *(_DWORD *)(*a1 + 4) = a4;
  if ( a1[2] == 16 )
  {
    *(_DWORD *)(*a1 + 8) = a3;
    result = *a1;
    *(_DWORD *)(result + 12) = a2;
  }
  else
  {
    *(_DWORD *)(*a1 + 8) = a2;
    result = *a1;
    *(_DWORD *)(result + 12) = a3;
  }
  return result;
}

//----- (08004E54) --------------------------------------------------------
int sub_8004E54()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_20002100[0] = 1342179328;
  sub_8011244((int)dword_20002100);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 2;
  v8 = 2;
  v9 = 0;
  sub_8011070((int)dword_20002100, (int)&v1, 0);
  sub_8011070((int)dword_20002100, (int)&v1, 16);
  sub_8011336(dword_20002100, 0);
  if ( byte_20000002 )
    return sub_8011304(dword_20002100, 0, 0, 11);
  else
    return sub_8011304(dword_20002100, 0, 0, 311);
}
// 20000002: using guessed type char byte_20000002;
// 20002100: using guessed type int dword_20002100[5];

//----- (08004ED4) --------------------------------------------------------
int sub_8004ED4()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_20002114[0] = 1342180352;
  sub_8011244((int)dword_20002114);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 1;
  v9 = 1;
  sub_8011070((int)dword_20002114, (int)&v1, 0);
  return sub_8011336(dword_20002114, 0);
}
// 20002114: using guessed type int dword_20002114[5];

//----- (08004F28) --------------------------------------------------------
int sub_8004F28()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_20002128[0] = 1342181376;
  sub_8011244((int)dword_20002128);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 2;
  v8 = 2;
  v9 = 0;
  if ( sub_8011070((int)dword_20002128, (int)&v1, 0) )
    sub_80058BC();
  sub_8011336(dword_20002128, 0);
  if ( byte_20000002 )
    return sub_8011304(dword_20002128, 0, 0, 3800);
  else
    return sub_8011304(dword_20002128, 0, 0, 3500);
}
// 20000002: using guessed type char byte_20000002;
// 20002128: using guessed type int dword_20002128[5];

//----- (08004FA8) --------------------------------------------------------
int sub_8004FA8()
{
  sub_8004E54();
  sub_8004ED4();
  return sub_8004F28();
}

//----- (08004FBC) --------------------------------------------------------
int __fastcall sub_8004FBC(int a1)
{
  return sub_8011304(dword_20002128, 0, 0, a1);
}
// 20002128: using guessed type int dword_20002128[5];

//----- (08004FCC) --------------------------------------------------------
int __fastcall sub_8004FCC(int a1)
{
  return sub_8011304(dword_20002100, 0, 0, a1);
}
// 20002100: using guessed type int dword_20002100[5];

//----- (08004FE0) --------------------------------------------------------
int sub_8004FE0(int a1, ...)
{
  int result; // r0
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  result = (unsigned __int8)byte_200036AD;
  if ( byte_200036AD == 1 )
  {
    sub_801E220(a1, (int)varg_r1);
    return 0;
  }
  return result;
}
// 200036AD: using guessed type char byte_200036AD;

//----- (08005004) --------------------------------------------------------
int __fastcall sub_8005004(int a1)
{
  return a1 + 5;
}

//----- (08005088) --------------------------------------------------------
int sub_8005088()
{
  sub_8012098(1024);
  return sub_8012098(2048);
}

//----- (0800509E) --------------------------------------------------------
int sub_800509E()
{
  sub_8012098(128);
  return sub_8012098(256);
}

//----- (080050B4) --------------------------------------------------------
int __fastcall sub_80050B4(int a1)
{
  int result; // r0
  unsigned int v2; // r0
  int v3; // [sp+0h] [bp-8h] BYREF

  v3 = 1;
  if ( a1 == 2 )
  {
    v3 = 2;
  }
  else if ( !a1 )
  {
    v3 = 0;
  }
  result = (unsigned __int8)v3;
  if ( (unsigned __int8)v3 != 1 )
  {
    sub_80031E4();
    sub_8005744(0);
    sub_8005728(0);
    v2 = sub_8005850(1u);
    sub_801EE84(v2);
    sub_80055F0(0x90u, &byte_20000507, 1u);
    sub_80055F0(0, &v3, 1u);
    sub_8022ADC();
  }
  return result;
}
// 801EE84: using guessed type int __fastcall sub_801EE84(_DWORD);
// 20000507: using guessed type char byte_20000507;

//----- (0800511C) --------------------------------------------------------
int __fastcall sub_800511C(int a1)
{
  switch ( a1 )
  {
    case 3:
      sub_8002364(&byte_20002F12, 40);
      break;
    case 2:
      dword_20002F22 = 0;
      dword_20002F26 = 0;
      dword_20002F2A = 0;
      dword_20002F2E = 0;
      dword_20002F32 = 0;
      dword_20002F36 = 0;
      break;
    case 1:
      dword_20002F2E = 0;
      dword_20002F32 = 0;
      dword_20002F36 = 0;
      break;
  }
  return sub_80055E0();
}
// 20002F12: using guessed type char byte_20002F12;
// 20002F22: using guessed type int dword_20002F22;
// 20002F26: using guessed type int dword_20002F26;
// 20002F2A: using guessed type int dword_20002F2A;
// 20002F2E: using guessed type int dword_20002F2E;
// 20002F32: using guessed type int dword_20002F32;
// 20002F36: using guessed type int dword_20002F36;

//----- (0800515C) --------------------------------------------------------
int __fastcall sub_800515C(unsigned int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v6; // [sp+0h] [bp-10h] BYREF

  v6 = a4;
  if ( byte_20000000 )
    return sub_80232B4(a1);
  v6 = 0;
  do
    result = sub_801AACC(&v6, a1);
  while ( !result );
  return result;
}
// 20000000: using guessed type char byte_20000000;

//----- (08005188) --------------------------------------------------------
int sub_8005188()
{
  int result; // r0

  result = 1010;
  if ( (unsigned __int8)byte_20002EAE == 170 )
    return (unsigned __int16)word_20002EAF;
  if ( byte_20002EA9 == 5 )
    return 2222;
  return result;
}
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAE: using guessed type char byte_20002EAE;
// 20002EAF: using guessed type __int16 word_20002EAF;

//----- (080051B4) --------------------------------------------------------
int __fastcall sub_80051B4(int a1, int a2, int a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r1
  int v22; // r2
  int v23; // r3
  char v24; // r0
  char v25; // r0
  int v26; // r0
  int v27; // r1
  int v28; // r2
  int v29; // r3
  int v30; // r1
  int v31; // r2
  int v32; // r3
  int v33; // r1
  int v34; // r2
  int v35; // r3
  int v36; // r1
  int v37; // r2
  int v38; // r3
  int v39; // r1
  int v40; // r2
  int v41; // r3
  int v42; // r1
  int v43; // r2
  int v44; // r3
  int v45; // r1
  int v46; // r2
  int v47; // r3
  int v48; // r1
  int v49; // r2
  int v50; // r3
  int v51; // r1
  int v52; // r2
  int v53; // r3
  int v55; // [sp+0h] [bp-30h] BYREF
  int v56; // [sp+4h] [bp-2Ch] BYREF

  v55 = a3;
  v56 = 0;
  ((void (__fastcall *)(int, char *, int))loc_8005534)(144, &byte_20000507, 1);
  if ( (unsigned __int8)byte_20000507 == 255 )
    byte_20000507 = 0;
  ((void (__fastcall *)(int, char *, int))loc_8005534)(336, &byte_20000505, 1);
  if ( (unsigned __int8)byte_20000505 == 255 )
    byte_20000505 = 0;
  ((void (__fastcall *)(_DWORD, int *, int))loc_8005534)(0, &v55, 1);
  sub_801EEA4();
  if ( (unsigned __int8)v55 == 1 )
  {
    ((void (__fastcall *)(int, void *, int))loc_8005534)(1, &unk_20002E08, 47);
    sub_800515C(1u, v3, v4, v5);
    ((void (__fastcall *)(int, char *, int))loc_8005534)(256, &byte_2000050C, 5);
    sub_800515C(1u, v6, v7, v8);
    ((void (__fastcall *)(int, char *, int))loc_8005534)(512, &byte_20000511, 7);
    sub_800515C(1u, v9, v10, v11);
    ((void (__fastcall *)(int, char *, int))loc_8005534)(768, byte_20002E37, 122);
    sub_800515C(1u, v12, v13, v14);
    ((void (__fastcall *)(int, char *, int))loc_8005534)(1024, &byte_20002EB1, 97);
    sub_800515C(1u, v15, v16, v17);
    ((void (__fastcall *)(int, char *))loc_8005534)(1280, &byte_20002F12);
    sub_800515C(1u, v18, v19, v20);
    ((void (__fastcall *)(int, __int16 *))loc_8005534)(2048, &word_20000508);
    sub_800515C(1u, v21, v22, v23);
    ((void (__fastcall *)(int, char *, int))loc_8005534)(2304, &byte_20000504, 1);
    v24 = byte_20002EA9;
    if ( (unsigned __int8)byte_20002EA9 >= 8u )
      v24 = 0;
    byte_20002EA9 = v24;
    v25 = byte_20002EA8;
    if ( (unsigned __int8)byte_20002EA8 > 1u )
      v25 = 1;
    byte_20002EA8 = v25;
    v26 = (unsigned __int8)byte_20002EAA;
    if ( (unsigned __int8)byte_20002EAA > 4u )
      v26 = 0;
    byte_200004AC = v26;
    byte_200004BA = v26 == 0;
  }
  sub_801EEA4();
  if ( (unsigned __int16)word_20002E32 < 0x78u )
  {
    if ( (unsigned __int8)v55 == 2 )
    {
      ((void (__fastcall *)(int, char *))loc_8005534)(1280, &byte_20002F12);
      sub_800515C(1u, v27, v28, v29);
    }
    sprintf((int)&unk_20002E08, "AC01");
    word_20002E30 = 13;
    word_20002E32 = 1488;
    word_20002E34 = MEMORY[0x8001000];
    byte_20000511 = 100;
    byte_20000512 = 12;
    byte_2000050D = 1;
    byte_2000050E = 1;
    word_20000513 = 2500;
    word_20000515 = 2500;
    byte_20000517 = 0;
    byte_20002E37[0] = 0;
    byte_20002EAB = 0;
    byte_20002E38 = 1;
    word_20002E9D = 1;
    dword_20002E9F = 0;
    dword_20002EA3 = 0;
    byte_20002EA8 = 1;
    byte_20002EA9 = 4;
    qmemcpy((unsigned int)&byte_20002EB1, (unsigned int)"SM471", 0x20u);
    qmemcpy((unsigned int)&byte_20002ED1, (unsigned int)"Hame147258", 0x40u);
    byte_20002F11 = 0;
    byte_20000504 = 0;
    sub_801EEA4();
    sub_8005770(1, (int)&unk_20002E08, 0x2Fu);
    sub_800515C(1u, v30, v31, v32);
    sub_801EEA4();
    sub_8005770(256, (int)&byte_2000050C, 5u);
    sub_800515C(1u, v33, v34, v35);
    sub_801EEA4();
    sub_8005770(512, (int)&byte_20000511, 7u);
    sub_800515C(1u, v36, v37, v38);
    sub_801EEA4();
    sub_8005770(768, (int)byte_20002E37, 0x7Au);
    sub_800515C(1u, v39, v40, v41);
    sub_801EEA4();
    sub_8005770(1024, (int)&byte_20002EB1, 0x61u);
    sub_800515C(1u, v42, v43, v44);
    sub_801EEA4();
    sub_8005770(1280, (int)&byte_20002F12, 0x28u);
    sub_800515C(1u, v45, v46, v47);
    sub_801EEA4();
    sub_8005770(2048, (int)&word_20000508, 4u);
    sub_800515C(1u, v48, v49, v50);
    sub_801EEA4();
    sub_8005770(2304, (int)&byte_20000504, 1u);
    sub_800515C(1u, v51, v52, v53);
    sub_801EEA4();
    v55 = 1;
    sub_8005770(0, (int)&v55, 1u);
  }
  ((void (__fastcall *)(int, char *, int))loc_8005534)(1152, &byte_20000506, 1);
  sub_8005770(1152, (int)&v56, 1u);
  word_20002E34 = MEMORY[0x8001000];
  word_20002E32 = 1488;
  return 0;
}
// 8005218: variable 'v3' is possibly undefined
// 8005218: variable 'v4' is possibly undefined
// 8005218: variable 'v5' is possibly undefined
// 800522A: variable 'v6' is possibly undefined
// 800522A: variable 'v7' is possibly undefined
// 800522A: variable 'v8' is possibly undefined
// 800523C: variable 'v9' is possibly undefined
// 800523C: variable 'v10' is possibly undefined
// 800523C: variable 'v11' is possibly undefined
// 800524E: variable 'v12' is possibly undefined
// 800524E: variable 'v13' is possibly undefined
// 800524E: variable 'v14' is possibly undefined
// 8005262: variable 'v15' is possibly undefined
// 8005262: variable 'v16' is possibly undefined
// 8005262: variable 'v17' is possibly undefined
// 8005274: variable 'v18' is possibly undefined
// 8005274: variable 'v19' is possibly undefined
// 8005274: variable 'v20' is possibly undefined
// 8005286: variable 'v21' is possibly undefined
// 8005286: variable 'v22' is possibly undefined
// 8005286: variable 'v23' is possibly undefined
// 80052F8: variable 'v27' is possibly undefined
// 80052F8: variable 'v28' is possibly undefined
// 80052F8: variable 'v29' is possibly undefined
// 800538A: variable 'v30' is possibly undefined
// 800538A: variable 'v31' is possibly undefined
// 800538A: variable 'v32' is possibly undefined
// 80053A0: variable 'v33' is possibly undefined
// 80053A0: variable 'v34' is possibly undefined
// 80053A0: variable 'v35' is possibly undefined
// 80053B6: variable 'v36' is possibly undefined
// 80053B6: variable 'v37' is possibly undefined
// 80053B6: variable 'v38' is possibly undefined
// 80053CC: variable 'v39' is possibly undefined
// 80053CC: variable 'v40' is possibly undefined
// 80053CC: variable 'v41' is possibly undefined
// 80053E6: variable 'v42' is possibly undefined
// 80053E6: variable 'v43' is possibly undefined
// 80053E6: variable 'v44' is possibly undefined
// 80053FC: variable 'v45' is possibly undefined
// 80053FC: variable 'v46' is possibly undefined
// 80053FC: variable 'v47' is possibly undefined
// 8005412: variable 'v48' is possibly undefined
// 8005412: variable 'v49' is possibly undefined
// 8005412: variable 'v50' is possibly undefined
// 800542A: variable 'v51' is possibly undefined
// 800542A: variable 'v52' is possibly undefined
// 800542A: variable 'v53' is possibly undefined
// 200004AC: using guessed type char byte_200004AC;
// 200004BA: using guessed type char byte_200004BA;
// 20000504: using guessed type char byte_20000504;
// 20000505: using guessed type char byte_20000505;
// 20000506: using guessed type char byte_20000506;
// 20000507: using guessed type char byte_20000507;
// 20000508: using guessed type __int16 word_20000508;
// 2000050C: using guessed type char byte_2000050C;
// 2000050D: using guessed type char byte_2000050D;
// 2000050E: using guessed type char byte_2000050E;
// 20000511: using guessed type char byte_20000511;
// 20000512: using guessed type char byte_20000512;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 20000517: using guessed type char byte_20000517;
// 20002E30: using guessed type __int16 word_20002E30;
// 20002E32: using guessed type __int16 word_20002E32;
// 20002E34: using guessed type __int16 word_20002E34;
// 20002E38: using guessed type char byte_20002E38;
// 20002E9D: using guessed type __int16 word_20002E9D;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EA3: using guessed type int dword_20002EA3;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAA: using guessed type char byte_20002EAA;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002EB1: using guessed type char byte_20002EB1;
// 20002ED1: using guessed type char byte_20002ED1;
// 20002F11: using guessed type char byte_20002F11;
// 20002F12: using guessed type char byte_20002F12;

//----- (08005498) --------------------------------------------------------
BOOL __fastcall sub_8005498(unsigned int a1, int a2, __int16 a3)
{
  int v5; // r4
  __int16 v6; // r6
  int v7; // r5
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v12; // [sp+4h] [bp-2Ch] BYREF

  v5 = 0;
  v6 = 160;
  v12 = 0;
  if ( a1 >= 0x10000 )
    v6 = 162;
  LOBYTE(v12) = BYTE1(a1);
  BYTE1(v12) = a1;
  if ( sub_8024F80(dword_20000464, 1000) )
  {
    sub_801227E(1207961600, 4096, 0);
    v7 = sub_8012F80((int)&dword_20002164, v6, (int)&v12, 2, 0x32u);
    v5 = sub_8012E34((int)&dword_20002164, v6, a2, a3, 0x32u) | v7;
    sub_800515C(1u, v8, v9, v10);
    sub_801227E(1207961600, 4096, 1);
    sub_8024A40(dword_20000464, 0, 0, 0);
  }
  return v5 == 0;
}
// 8005502: variable 'v8' is possibly undefined
// 8005502: variable 'v9' is possibly undefined
// 8005502: variable 'v10' is possibly undefined
// 20000464: using guessed type int dword_20000464;
// 20002164: using guessed type int dword_20002164;

//----- (08005594) --------------------------------------------------------
void __fastcall IRQ_11_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14)
{
  int v14; // r6
  int v15; // r7

  __asm { STCL            p2, c2, [R3,#4]! }
  sub_801227E(v15, v14, a3);
  __asm { POP.W           {R2-R10,PC} }
}
// 800559C: variable 'v15' is possibly undefined
// 800559C: variable 'v14' is possibly undefined

//----- (080055B4) --------------------------------------------------------
int __fastcall sub_80055B4(unsigned int a1)
{
  if ( a1 >= 0xA )
    return sub_80055F0(0x302u, &byte_20002E39, 0x64u);
  else
    return sub_80055F0(10 * a1 + 770, &byte_20002E37[10 * a1 + 2], 0xAu);
}
// 20002E39: using guessed type char byte_20002E39;

//----- (080055E0) --------------------------------------------------------
int sub_80055E0()
{
  return sub_80055F0(0x500u, &byte_20002F12, 0x28u);
}
// 20002F12: using guessed type char byte_20002F12;

//----- (080055F0) --------------------------------------------------------
int __fastcall sub_80055F0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v5; // r5
  int result; // r0
  unsigned int v7; // r6
  int v8; // r1
  int v9; // r2
  int v10; // r3
  __int16 v11; // r8
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // [sp+4h] [bp-2Ch] BYREF
  _DWORD v19[10]; // [sp+8h] [bp-28h] BYREF

  v5 = a3;
  result = 0;
  v19[0] = 0;
  v18 = 0;
  v7 = 0;
  if ( a3 <= 0x10000 )
  {
    do
    {
      if ( !v5 )
        return 1;
      BYTE2(v19[0]) = *a2;
      v18 = BYTE2(v19[0]) + 1;
      if ( sub_8024F80(dword_20000464, 1000) )
      {
        sub_801227E(1207961600, 4096, 0);
        sub_800515C(1u, v8, v9, v10);
        if ( a1 < 0x10000 )
          v11 = 160;
        else
          v11 = 162;
        LOBYTE(v19[0]) = BYTE1(a1);
        BYTE1(v19[0]) = a1;
        sub_8012F80((int)&dword_20002164, v11, (int)v19, 3, 0x32u);
        sub_800515C(5u, v12, v13, v14);
        sub_8012F80((int)&dword_20002164, v11, (int)v19, 2, 0x32u);
        sub_8012E34((int)&dword_20002164, v11, (int)&v18, 1, 0x32u);
        sub_800515C(1u, v15, v16, v17);
        sub_801227E(1207961600, 4096, 1);
        sub_8024A40(dword_20000464, 0, 0, 0);
      }
      if ( BYTE2(v19[0]) == (unsigned __int8)v18 )
      {
        --v5;
        ++a2;
        ++a1;
      }
      else
      {
        v7 = (unsigned __int8)(v7 + 1);
      }
    }
    while ( v7 <= 3 );
    sub_8017DFC(66, 0, 0, 0);
    if ( sub_8024F80(dword_20000464, 1000) )
    {
      sub_8016C08();
      sub_8024A40(dword_20000464, 0, 0, 0);
    }
    else
    {
      sub_8024A40(dword_20000464, 0, 0, 0);
      sub_8016C08();
    }
    return 0;
  }
  return result;
}
// 800563A: variable 'v8' is possibly undefined
// 800563A: variable 'v9' is possibly undefined
// 800563A: variable 'v10' is possibly undefined
// 800566C: variable 'v12' is possibly undefined
// 800566C: variable 'v13' is possibly undefined
// 800566C: variable 'v14' is possibly undefined
// 8005692: variable 'v15' is possibly undefined
// 8005692: variable 'v16' is possibly undefined
// 8005692: variable 'v17' is possibly undefined
// 20000464: using guessed type int dword_20000464;
// 20002164: using guessed type int dword_20002164;

//----- (08005728) --------------------------------------------------------
unsigned int __fastcall sub_8005728(unsigned int result)
{
  if ( result <= 2 )
  {
    byte_20002EAC = result;
    return sub_80055F0(0x375u, &byte_20002EAC, 1u);
  }
  return result;
}
// 20002EAC: using guessed type char byte_20002EAC;

//----- (08005744) --------------------------------------------------------
unsigned int __fastcall sub_8005744(unsigned int result)
{
  if ( result <= 4 )
  {
    byte_200004AC = result;
    if ( result )
    {
      byte_200004BA = 0;
      byte_200004BB = 3;
    }
    return sub_80055F0(0x373u, &byte_200004AC, 1u);
  }
  return result;
}
// 200004AC: using guessed type char byte_200004AC;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;

//----- (08005770) --------------------------------------------------------
void __fastcall sub_8005770(int a1, int a2, unsigned int a3)
{
  if ( a3 > 0x10000 )
    JUMPOUT(0x800578A);
  JUMPOUT(0x8005840);
}
// 8005788: control flows out of bounds to 800578A
// 8005792: control flows out of bounds to 8005840

//----- (080057DC) --------------------------------------------------------
#error "80057EC: call analysis failed (funcsize=70)"

//----- (08005850) --------------------------------------------------------
unsigned int __fastcall sub_8005850(unsigned int result)
{
  if ( result <= 1 )
  {
    byte_20002EA8 = result;
    return sub_80055F0(0x371u, &byte_20002EA8, 1u);
  }
  return result;
}
// 20002EA8: using guessed type char byte_20002EA8;

//----- (0800586C) --------------------------------------------------------
int __fastcall sub_800586C(__int16 a1)
{
  int v1; // r0

  byte_20002EAE = -86;
  word_20002EAF = a1;
  v1 = sub_80055F0(0x377u, &byte_20002EAE, 1u);
  return IRQ_40_handler(v1, (int)byte_20002E37);
}
// 20002EAE: using guessed type char byte_20002EAE;
// 20002EAF: using guessed type __int16 word_20002EAF;

//----- (08005888) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall IRQ_40_handler(int a1, int a2)
{
  return sub_80055F0(0x378u, (_BYTE *)(a2 + 120), 2u);
}
// 800588E: positive sp value 8 has been found

//----- (0800589E) --------------------------------------------------------
int __fastcall IRQ_23_handler(int a1, int a2, int a3)
{
  int result; // r0

  *(_DWORD *)(a3 + 64) += a1;
  *(_DWORD *)(a3 + 68) += a2;
  result = a2 - a1;
  dword_20001C10 = result;
  return result;
}
// 20001C10: using guessed type int dword_20001C10;

//----- (080058BC) --------------------------------------------------------
void __noreturn sub_80058BC()
{
  __disable_irq();
  while ( 1 )
    ;
}

//----- (080058C0) --------------------------------------------------------
int sub_80058C0()
{
  __int64 v0; // r4
  int result; // r0

  v0 = 0;
  sub_800F228();
  if ( word_20003B31 || word_20003B35 || (result = qword_20003BF8 | HIDWORD(qword_20003BF8), qword_20003BF8) )
  {
    if ( byte_200008F2 )
    {
      if ( byte_200008F2 == 1 )
      {
        v0 = (unsigned __int16)word_20003B35;
        byte_200008F2 = 2;
      }
      else if ( byte_200008F2 == 2 )
      {
        v0 = qword_20003BF8;
        byte_200008F2 = 3;
      }
      else
      {
        byte_200008F2 = 0;
      }
    }
    else
    {
      v0 = (unsigned __int16)word_20003B31;
      byte_200008F2 = 1;
    }
    result = v0 | HIDWORD(v0);
    if ( v0 )
      return sub_8018804();
  }
  return result;
}
// 200008F2: using guessed type char byte_200008F2;
// 20003B31: using guessed type __int16 word_20003B31;
// 20003B35: using guessed type __int16 word_20003B35;
// 20003BF8: using guessed type __int64 qword_20003BF8;

//----- (08005930) --------------------------------------------------------
int sub_8005930()
{
  int v0; // s0

  return v0;
}
// 8005930: variable 'v0' is possibly undefined

//----- (08005944) --------------------------------------------------------
int __fastcall sub_8005944(int *a1)
{
  unsigned int v1; // r1
  int v2; // r2
  int result; // r0
  unsigned int v4; // r2

  v1 = 1073783808;
  v2 = *a1;
  if ( *a1 == 1073768448 )
    v1 = 1073784656;
  if ( v2 == 1073769472 )
    v1 += 1696;
  a1[16] = v1;
  *(_DWORD *)(v2 + 128) = *(_DWORD *)(v2 + 128) & 0xFFE0FFFF | (*((unsigned __int16 *)a1 + 26) << 16);
  a1[17] = v1 + 112;
  *(_DWORD *)(*a1 + 128) = *(_DWORD *)(*a1 + 128) & 0xF0FFFFFF | (*((unsigned __int8 *)a1 + 56) << 24);
  a1[18] = v1 + 176;
  a1[19] = v1 + 392;
  a1[20] = v1 + 608;
  a1[21] = v1 + 632;
  result = 0;
  v4 = v1 + 848;
  while ( v1 < v4 )
  {
    *(_DWORD *)v1 = 0;
    v1 += 4;
  }
  return result;
}

//----- (080059B8) --------------------------------------------------------
unsigned int __fastcall sub_80059B8(int a1, int *a2, int a3, int a4)
{
  __int64 v4; // kr00_8
  int v5; // r4
  int v6; // r5
  int v7; // r4
  int v8; // r5
  int *v9; // r3
  int *v10; // r3
  unsigned int result; // r0

  v4 = *(_QWORD *)(a2 + 1);
  v5 = a2[4] | HIDWORD(v4);
  v6 = *a2;
  if ( (_DWORD)v4 )
    v7 = v5 | v6 | 0x40000000;
  else
    v7 = v5 | (v6 << 18);
  v8 = a2[7] | a2[6] | a2[5] | (*((unsigned __int8 *)a2 + 32) << 24) | a2[3];
  v9 = (int *)(*(_DWORD *)(a1 + 84) + 72 * a4);
  *v9 = v7;
  v9[1] = v8;
  v10 = v9 + 2;
  for ( result = 0; *((unsigned __int8 *)dword_802616C + HIWORD(a2[3])) > result; result += 4 )
    *v10++ = *(unsigned __int8 *)(a3 + result)
           | (*(unsigned __int8 *)(a3 + result + 3) << 24)
           | (*(unsigned __int8 *)(a3 + result + 2) << 16)
           | (*(unsigned __int8 *)(a3 + result + 1) << 8);
  return result;
}
// 802616C: using guessed type int dword_802616C[4];

//----- (08005A2C) --------------------------------------------------------
int sub_8005A2C()
{
  int result; // r0

  if ( byte_2000028C == 1 || byte_2000028C == 3 )
  {
    MEMORY[0x40022000] &= ~0x200u;
    MEMORY[0x40022000] |= 0x800u;
    MEMORY[0x40022000] &= ~0x800u;
    MEMORY[0x40022000] |= 0x200u;
  }
  if ( byte_2000028C == 2 || byte_2000028C == 3 )
  {
    MEMORY[0x40022000] |= 0x1000u;
    MEMORY[0x40022000] &= ~0x1000u;
    MEMORY[0x40022000] |= 0x400u;
  }
  result = 0;
  byte_2000028C = 0;
  return result;
}
// 2000028C: using guessed type char byte_2000028C;

//----- (08005A88) --------------------------------------------------------
int __fastcall sub_8005A88(int a1)
{
  int result; // r0

  if ( (MEMORY[0x40022020] & 0x400000) != 0 )
  {
    if ( a1 << 31 )
      MEMORY[0x40022014] |= 4u;
    if ( (a1 & 2) != 0 )
      MEMORY[0x40022014] |= 0x8000u;
  }
  else
  {
    MEMORY[0x40022014] |= 0x8004u;
  }
  result = MEMORY[0x40022014] | 0x10000;
  MEMORY[0x40022014] |= 0x10000u;
  return result;
}

//----- (08005AC4) --------------------------------------------------------
int __fastcall sub_8005AC4(unsigned __int8 a1, int a2)
{
  int result; // r0

  if ( (MEMORY[0x40022020] & 0x400000) != 0 )
  {
    if ( a2 << 31 )
      MEMORY[0x40022014] &= ~0x800u;
    else
      MEMORY[0x40022014] |= 0x800u;
  }
  else
  {
    MEMORY[0x40022014] &= ~0x800u;
  }
  MEMORY[0x40022014] = MEMORY[0x40022014] & 0xFFFFFC07 | (8 * a1);
  MEMORY[0x40022014] |= 2u;
  result = MEMORY[0x40022014] | 0x10000;
  MEMORY[0x40022014] |= 0x10000u;
  return result;
}

//----- (08005B10) --------------------------------------------------------
_DWORD *__fastcall sub_8005B10(_DWORD *result, int a2, int a3, int a4)
{
  MEMORY[0x40022014] |= 1u;
  *result = a3;
  __isb(0xFu);
  result[1] = a4;
  return result;
}

//----- (08005B2C) --------------------------------------------------------
_DWORD *__fastcall sub_8005B2C(_DWORD *result, int *a2)
{
  int v2; // r2
  int v4; // r4

  LOBYTE(v2) = 64;
  MEMORY[0x40022014] |= 0x40000u;
  _R3 = __get_CPSR();
  __disable_irq();
  do
  {
    v4 = *a2++;
    *result++ = v4;
    v2 = (unsigned __int8)(v2 - 1);
  }
  while ( v2 );
  __asm { MSR.W           PRIMASK, R3 }
  return result;
}

//----- (08005B58) --------------------------------------------------------
int __fastcall sub_8005B58(unsigned int a1)
{
  int v2; // r5
  int v4; // r0

  v2 = sub_8012298();
  while ( (~MEMORY[0x40022010] & 0x10000) == 0 )
  {
    if ( sub_8012298() - v2 > a1 )
      return 3;
  }
  v4 = MEMORY[0x40022010] & 0xC3FA;
  if ( (MEMORY[0x40022010] & 0xC3FA) != 0 )
  {
    dword_20000274 |= v4;
    if ( 16 * v4 )
      MEMORY[0x40022010] = MEMORY[0x40022010] & 0xC3FA;
    return 1;
  }
  else
  {
    if ( !(~MEMORY[0x40022010] << 31) )
      MEMORY[0x40022010] = 1;
    return 0;
  }
}
// 8005BA4: masking with 0xFFFFFFF was optimized away because r0.4 <= 0xC3FA
// 20000274: using guessed type int dword_20000274;

//----- (08005BC4) --------------------------------------------------------
int __fastcall sub_8005BC4(int a1)
{
  unsigned int v2; // r4

  LOBYTE(v2) = 0;
  do
  {
    if ( a1 )
    {
      if ( sub_800DAC0("AT+QBLEADVSTART", (unsigned __int8 *)&dword_8005C14, 0, 1200) )
        return 1;
    }
    else if ( sub_800DAC0("AT+QBLEADVSTOP", (unsigned __int8 *)&dword_8005C14, 0, 1200) )
    {
      return 1;
    }
    v2 = (unsigned __int8)(v2 + 1);
    sub_80232B4(100);
  }
  while ( v2 < 3 );
  return 0;
}
// 8005C14: using guessed type int dword_8005C14;

//----- (08005C38) --------------------------------------------------------
int __fastcall sub_8005C38(int a1, int a2)
{
  unsigned int v4; // r4
  unsigned __int8 v6[80]; // [sp+0h] [bp-50h] BYREF

  sub_8002364(v6, 64);
  v4 = 0;
  sprintf((int)v6, "AT+QBLEADVPARAM=%d,%d", a1, a2);
  while ( v4 < 3 )
  {
    if ( sub_800DAC0(v6, "OK", 0, 300) )
      return 1;
    v4 = (unsigned __int8)(v4 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (08005CA0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_8005CA0(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v14; // r1
  int v15; // r2
  int v16; // r12
  int v17; // r0
  unsigned int v18; // r0
  int v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r0
  unsigned int v22; // r8
  char *v23; // r7
  int v24; // r4
  int v25; // r4
  int v26; // r0
  int v27; // r0
  unsigned __int8 *v28; // r0
  int v29; // r10
  unsigned int v30; // r6
  unsigned int v31; // r7
  unsigned int v32; // r0
  int v33; // r4
  int v34; // t1
  unsigned int v35; // r0
  int v36; // r1
  int v37; // r5
  unsigned __int16 v38; // r0
  unsigned __int16 v39; // r0
  unsigned int v40; // r0
  int v41; // r4
  int v42; // r0
  unsigned __int8 *v43; // r6
  unsigned int v44; // r4
  unsigned int v45; // r0
  unsigned __int8 *v46; // r0
  __int16 v47; // r0
  int v48; // [sp-B8h] [bp-198h]
  int v49; // [sp-B4h] [bp-194h]
  _BYTE v50[128]; // [sp-A8h] [bp-188h] BYREF
  _DWORD v51[2]; // [sp-28h] [bp-108h] BYREF
  int v52; // [sp-20h] [bp-100h] BYREF
  int v53; // [sp-1Ch] [bp-FCh]
  int v54; // [sp-18h] [bp-F8h]
  int v55; // [sp-14h] [bp-F4h] BYREF
  int v56; // [sp-10h] [bp-F0h] BYREF
  unsigned __int8 *v57; // [sp-Ch] [bp-ECh]

  v56 = 255;
  if ( !a1 || *(_BYTE *)(a1 + 2) != 35 )
LABEL_5:
    __asm { POP.W           {R4-R11,PC} }
  sub_8004FE0((int)"### [BLE] Recv cmd: %#x\r\n", *(unsigned __int8 *)(a1 + 3));
  v14 = sub_8006ED8(a1, *(unsigned __int8 *)(a1 + 1) - 1);
  v15 = *(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 1);
  if ( v15 != v14 )
  {
    sub_8004FE0((int)"### [BLE] Data crc error: %#x, %#x.\r\n", v14, v15);
    goto LABEL_5;
  }
  word_200036B9 = 0;
  byte_200036B0 = 1;
  v16 = *(unsigned __int8 *)(a1 + 3);
  v57 = (unsigned __int8 *)&byte_20004036;
  switch ( v16 )
  {
    case 2:
      v55 = 0;
      sub_8004FE0((int)"[BLE] Get server type: %d.\r\n", *(unsigned __int8 *)(a1 + 4));
      v17 = *(unsigned __int8 *)(a1 + 4);
      if ( !*(_BYTE *)(a1 + 4) || v17 == 1 || v17 == 2 )
      {
        sub_8005498(0x441u, (int)&v55, 1);
        if ( *(unsigned __int8 *)(a1 + 4) != (unsigned __int8)v55 || (unsigned __int8)v55 == 255 )
        {
          byte_20002F11 = *(_BYTE *)(a1 + 4);
          sub_80055F0(0x441u, &byte_20002F11, 1u);
        }
      }
      else
      {
        byte_20002F11 = 0;
      }
      sub_8004FE0((int)sub_8006124, (unsigned __int8)byte_20002F11);
      goto LABEL_5;
    case 3:
      sub_8004FE0((int)&loc_8006144, 2500, &byte_20000507, 516);
      sub_80075B0();
      sub_8006EF4(3, (unsigned int)&word_20003F75, 0x64u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 4:
      sub_8002364(v50, 152);
      sub_800F8D8();
      sub_8004FE0((int)&loc_8006164);
      v18 = sprintf((int)v50, (const char *)&loc_8006184);
      sub_8006EF4(4, (unsigned int)v50, v18);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      sub_8004FE0(
        loc_80061BC,
        &dword_200038E3,
        byte_200037BB,
        &unk_20004029,
        *(unsigned __int16 *)(loc_8006180 + 0x2A),
        *(unsigned __int8 *)(loc_800617C + 6),
        &dword_200037D5);
      goto LABEL_5;
    case 5:
      sub_8007100((unsigned __int8 *)a1);
      goto LABEL_5;
    case 6:
      sub_8004FE0((int)&loc_80061C0, *(unsigned __int8 *)(a1 + 4), &byte_20000507, 516);
      v19 = *(unsigned __int8 *)(a1 + 4);
      if ( v19 == 1 )
      {
        sub_800786C(1);
      }
      else if ( v19 == 2 )
      {
        sub_800786C(2);
      }
      goto LABEL_5;
    case 8:
      sub_8004FE0((int)&loc_80061DC, (unsigned __int8)byte_20000928, byte_20002EB1, 516);
      if ( byte_20000928 )
      {
        v20 = sub_80023E2((unsigned __int8 *)byte_20002EB1);
        sub_8006EF4(8, (unsigned int)byte_20002EB1, (unsigned int)v20);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      goto LABEL_5;
    case 9:
      sub_8004FE0((int)&loc_8006218, *(unsigned __int8 *)(a1 + 4), &byte_20000507, 516);
      v21 = *(unsigned __int8 *)(a1 + 4);
      if ( *(_BYTE *)(a1 + 4) )
      {
        if ( v21 == 1 )
        {
          byte_20002E38 = 1;
          v22 = *(unsigned __int8 *)(a1 + 5);
          if ( v22 < 0xA )
          {
            v23 = &byte_20002E37[10 * v22];
            *((_WORD *)v23 + 3) = _byteswap_ushort(*(_WORD *)(a1 + 6));
            *((_WORD *)v23 + 4) = _byteswap_ushort(*(_WORD *)(a1 + 8));
            v23[2] = *(_BYTE *)(a1 + 10);
            *((_WORD *)v23 + 2) = *(unsigned __int8 *)(a1 + 11) | (*(unsigned __int8 *)(a1 + 12) << 8);
            v23[3] = *(_BYTE *)(a1 + 13);
            sub_80055B4(v22);
            sub_8004FE0(
              loc_8006244,
              v22,
              *(unsigned __int8 *)(a1 + 6),
              *(unsigned __int8 *)(a1 + 7),
              *(unsigned __int8 *)(a1 + 8),
              *(unsigned __int8 *)(a1 + 9),
              (unsigned __int8)v23[2],
              *((__int16 *)v23 + 2),
              (unsigned __int8)v23[3]);
          }
        }
        else if ( v21 == 5 )
        {
          byte_20002E38 = 5;
          byte_2000159E = 1;
          sub_8004FE0((int)&loc_8006248, *(unsigned __int8 *)(a1 + 5));
        }
      }
      else
      {
        byte_20002E38 = *(_BYTE *)(a1 + 4);
      }
      sub_8006EF4(9, (unsigned int)&byte_20002E38, 1u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      sub_80055F0(0x301u, &byte_20002E38, 1u);
      goto LABEL_5;
    case 10:
      sub_8004FE0((int)&loc_8006278, 2500, &byte_20000507, 516);
      sub_8007504();
      sub_8006EF4(10, (unsigned int)&unk_20003FD9, 0x50u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 11:
      LOWORD(v54) = (*(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8)) - 2000;
      HIWORD(v54) = *(_WORD *)(a1 + 6);
      *(_WORD *)((char *)&v55 + 1) = *(_WORD *)(a1 + 8);
      v24 = *(unsigned __int8 *)(a1 + 10);
      HIBYTE(v55) = v24;
      sub_8004FE0(loc_8006290, (unsigned __int16)v54, BYTE2(v54), HIBYTE(v54), BYTE1(v55), BYTE2(v55), v24);
      sub_80200DC((unsigned __int8)v54, BYTE2(v54), HIBYTE(v54));
      sub_8020108(BYTE1(v55), BYTE2(v55), v24);
      sub_800FC70((int)&v52);
      sub_8006EF4(11, (unsigned int)&v52, 8u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 12:
      if ( *(_BYTE *)(a1 + 4) == 10 && *(_BYTE *)(a1 + 5) == 11 && *(_BYTE *)(a1 + 6) == 12 )
      {
        v25 = *(unsigned __int8 *)(a1 + 7);
        sub_8004FE0((int)&loc_8006294, v25, &byte_20000507, 516);
        if ( v25 )
        {
          if ( v25 == 1 )
          {
            sub_80031E4();
            sub_801EE84(v27);
            sub_801E274();
          }
          if ( v25 == 2 )
          {
            sub_8007788();
            sub_80031E4();
            sub_801EE84(v26);
            sub_801E274();
          }
        }
        else
        {
          sub_8007CF8(0);
        }
      }
      goto LABEL_5;
    case 13:
      sub_8004FE0((int)&loc_80062B8, 2500, &byte_20000507, 516);
      sub_80077D0();
      sub_8006EF4(13, loc_80062D4, 0x13u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 14:
      sub_8004FE0((int)&loc_80062D8, *(unsigned __int8 *)(a1 + 4), &byte_20000507, 516);
      if ( *(_BYTE *)(a1 + 4) == 1 )
      {
        byte_20002EA7 = 1;
        if ( byte_200015DE == 1 )
        {
          byte_20002E38 = 0;
        }
        else if ( !byte_200015DE || byte_200015DE == 2 )
        {
          byte_20002E38 = 1;
        }
      }
      else
      {
        byte_20002EA7 = 0;
      }
      JUMPOUT(0x8006308);
    case 15:
      if ( *(_BYTE *)(a1 + 4) == 1 )
      {
        sub_8004FE0((int)"[BLE] Setting eps enable.\r\n", 2500, &byte_20000507, 516);
        sub_80031EE();
      }
      else if ( !*(_BYTE *)(a1 + 4) )
      {
        sub_8004FE0((int)"[BLE] Setting eps disable.\r\n", 2500, &byte_20000507, 516);
        sub_80031EE();
      }
      sub_8006EF4(15, (unsigned int)byte_20002E37, 1u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 16:
      if ( *(_BYTE *)(a1 + 4) == 10 && *(_BYTE *)(a1 + 5) == 11 && *(_BYTE *)(a1 + 6) == 12 && byte_20000928 )
      {
        if ( !*(_BYTE *)(a1 + 7) )
          sub_8007880(0);
        if ( *(_BYTE *)(a1 + 7) == 1 )
          sub_8007880(1);
      }
      goto LABEL_161;
    case 17:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_161;
      sub_8007C6C();
      v28 = sub_80023E2((unsigned __int8 *)&dword_200037D5);
      sub_8006EF4(17, (unsigned int)&dword_200037D5, (unsigned int)v28);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 18:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_161;
      sub_8007788();
      goto LABEL_5;
    case 19:
      sub_8004FE0((int)"[BLE] Getting err code info.\r\n", 2500, &byte_20000507, 516);
      sub_8006EF4(19, (unsigned int)&dword_20003C59, 0x118u);
      sub_8004FE0((int)"[BLE] err info len = %d, tx len = %d.\r\n", 280, (unsigned __int8)byte_20004037);
      sub_8007364(v57, 285);
      goto LABEL_5;
    case 20:
      sub_8004FE0((int)"[BLE] Getting bms data info.\r\n", 2500, &byte_20000507, 516);
      sub_80076F8();
      sub_8006EF4(20, (unsigned int)&word_20003E25, 0x50u);
      sub_8004FE0((int)"[BLE] bms info len = %d, tx len = %d.\r\n", 80, (unsigned __int8)byte_20004037);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 21:
      v29 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( byte_20000507 == 2 )
      {
        sub_8006EF4(21, (unsigned int)&byte_20000507, 1u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      else if ( v29 == 800 )
      {
        byte_20000507 = 1;
        word_20000515 = 800;
        sub_80055F0(0x204u, &word_20000515, 2u);
        sub_80055F0(0x90u, &byte_20000507, 1u);
        sub_8006EF4(21, (unsigned int)&byte_20000507, 1u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
        sub_800E36C();
      }
      else if ( v29 == 2500 )
      {
        byte_20000507 = 0;
        word_20000515 = 2500;
        sub_80055F0(0x204u, &word_20000515, 2u);
        sub_80055F0(0x90u, &byte_20000507, 1u);
        sub_8006EF4(21, (unsigned int)&byte_20000507, 1u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      sub_8004FE0((int)"th: %d.\r\n", v29);
      goto LABEL_5;
    case 22:
      v30 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( v30 <= 0x9C4 )
      {
        word_20000513 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
        sub_80055F0(0x202u, &word_20000513, 2u);
        sub_8006EF4(22, (unsigned int)&word_20000513, 2u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      sub_8004FE0(
        (int)" power3: %d.\r\n[HTTP] P1 wifi strength: %d, AC wifi strength: %d.\r\n",
        v30,
        *(unsigned __int8 *)(a1 + 4),
        *(unsigned __int8 *)(a1 + 5));
      goto LABEL_5;
    case 23:
      v31 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( v31 > 0x9C4 )
        goto LABEL_94;
      if ( byte_20000507 != 1 || v31 <= 0x320 )
      {
        word_20000515 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
        sub_80055F0(0x204u, &word_20000515, 2u);
        sub_8006EF4(23, (unsigned int)&word_20000515, 2u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
LABEL_94:
        sub_8004FE0(
          (int)"wer: %d.\r\n[HTTP] total_power: %d, power1: %d, power2: %d, power3: %d.\r\n[HTTP] AC wifi strength: %d.\r\n",
          v31,
          *(unsigned __int8 *)(a1 + 4),
          *(unsigned __int8 *)(a1 + 5),
          (unsigned __int16)word_20000515,
          v48,
          v49);
      }
      goto LABEL_5;
    case 24:
      v32 = *(unsigned __int8 *)(a1 + 4);
      v56 = v32;
      if ( (unsigned __int8)byte_20002EA9 != v32 && v32 < 8 )
      {
        sub_8018B78();
        byte_20002EA9 = v56;
        byte_200015D6 = 1;
      }
      if ( byte_20002EA9 == 2 )
      {
        byte_200015A4 = 1;
        byte_200015A5 = 0;
      }
      else if ( byte_20002EA9 == 7 )
      {
        byte_200015A5 = 1;
        byte_200015A4 = 0;
      }
      else
      {
        byte_200015A4 = 0;
        byte_200015A5 = 0;
      }
      byte_200015A6 = 0;
      v34 = *(_DWORD *)(a1 + 5);
      v33 = a1 + 5;
      dword_20004238 = v34;
      dword_2000423C = *(_DWORD *)(v33 + 4);
      dword_20004240 = *(_DWORD *)(v33 + 8);
      goto LABEL_5;
    case 25:
      v35 = *(unsigned __int8 *)(a1 + 4);
      v56 = v35;
      if ( (unsigned __int8)byte_20002EA8 != v35 && v35 <= 1 )
      {
        sub_8005850(v35);
        sub_8018B78();
      }
      goto LABEL_5;
    case 26:
      v55 = (int)*(float *)&dword_20002798;
      sub_8002364(v51, 20);
      v51[0] = dword_20002D9C;
      v51[1] = dword_20002DA0;
      v52 = dword_20002DA4;
      v53 = dword_20002DA8;
      LOWORD(v54) = v55;
      sub_8006EF4(26, (unsigned int)v51, 0x12u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_5;
    case 27:
      v55 = 0;
      v36 = *(unsigned __int8 *)(a1 + 4);
      if ( v36 == 170 )
      {
        if ( byte_20000928 )
        {
          v55 = 1;
          sub_8006EF4(27, (unsigned int)&v55, 1u);
          sub_8007364(v57, (unsigned __int8)byte_20004037);
          if ( sub_8007088(a1, 0) )
          {
            v39 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_200037E2);
            sub_8007A40(byte_200037E2, v39, 0);
          }
        }
      }
      else if ( v36 == 10 )
      {
        if ( byte_20000928 )
        {
          v55 = 1;
          sub_8006EF4(27, (unsigned int)&v55, 1u);
          sub_8007364(v57, (unsigned __int8)byte_20004037);
          v37 = (unsigned __int16)(*(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 3)
                                 + (*(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 2) << 8));
          sub_8004FE0((int)"[BLE] Set url port = %d.\r\n", v37);
          if ( sub_8007088(a1, 1) )
          {
            v38 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_200037E2);
            sub_8007A40(byte_200037E2, v38, v37);
          }
        }
      }
      goto LABEL_5;
    case 28:
      sub_8004FE0((int)"[BLE] Getting event log info.\r\n", 2500, &byte_20000507, 516);
      sub_8006EF4(28, (unsigned int)byte_20003D71, 0xB4u);
      sub_8004FE0((int)"[BLE] event info len = %d, tx len = %d.\r\n", 180, (unsigned __int8)byte_20004037);
      sub_8007364(v57, 185);
      goto LABEL_5;
    case 29:
      sub_8018B78();
      goto LABEL_161;
    case 30:
      v40 = *(unsigned __int8 *)(a1 + 4);
      v56 = v40;
      sub_8005744(v40);
      goto LABEL_161;
    case 31:
      if ( *(_BYTE *)(a1 + 4) == 10 && *(_BYTE *)(a1 + 5) == 11 && *(_BYTE *)(a1 + 6) == 12 )
      {
        sub_8004FE0((int)"[BLE] Info active upgrade.\r\n", 2500, &byte_20000507, 516);
        byte_2000159F = 1;
        sub_8006EF4(31, (unsigned int)&byte_2000159F, 1u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      goto LABEL_161;
    case 32:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_161;
      v41 = *(unsigned __int8 *)(a1 + 7);
      sub_8004FE0((int)"[BLE] Setting parallel machine, enable = %d.\r\n", v41);
      switch ( v41 )
      {
        case 2:
          if ( byte_20002EAB != 1 )
          {
            sub_8004FE0((int)"[BLE] !!! Parallel machine not ready.\r\n");
            sub_8006EF4(32, (unsigned int)&byte_20002EAB, 1u);
            sub_8007364(v57, (unsigned __int8)byte_20004037);
            goto LABEL_161;
          }
          sub_8004FE0((int)"[BLE] Parallel machine ON.\r\n");
          sub_80031F8();
          break;
        case 1:
          sub_8004FE0((int)"[BLE] Parallel machine Ready.\r\n");
          sub_80031F8();
          break;
        case 0:
          if ( byte_20002EAB != 1 )
          {
            sub_8004FE0((int)"[BLE] !!! Parallel machine Not ready.\r\n");
            sub_8006EF4(32, (unsigned int)&byte_20002EAB, 1u);
            sub_8007364(v57, (unsigned __int8)byte_20004037);
            goto LABEL_161;
          }
          sub_8004FE0((int)"[BLE] Parallel machine OFF.\r\n");
          sub_80031F8();
          break;
      }
      sub_8006EF4(32, (unsigned int)&byte_20002EAB, 1u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
LABEL_161:
      JUMPOUT(0x800631E);
    case 33:
      v52 = 0;
      v53 = 0;
      v54 = 0;
      v55 = 0;
      v42 = *(unsigned __int8 *)(a1 + 4);
      if ( v42 == 10 )
      {
        v43 = (unsigned __int8 *)(a1 + 5);
        v44 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 6);
        if ( v44 < 0x10 )
        {
          sub_8002364(byte_200038EB, 16);
          sub_80023B6(byte_200038EB, v43, v44);
          sub_8004FE0((int)"[BLE] Receive ip_len = %d, meter_ip: %s.\r\n", v44, byte_200038EB);
          byte_200036AC[v44 + 575] = 0;
          sub_8005498(0x3500u, (int)&v52, 16);
          if ( sub_80023F0((int)byte_200038EB, (int)&v52) )
          {
            sub_8004FE0((int)"[BLE] *** Receive ip: %s, read ip: %s.\r\n", byte_200038EB, (const char *)&v52);
            sub_80055F0(0x3500u, byte_200038EB, 0x10u);
          }
          sub_8006EF4(33, (unsigned int)byte_200038EB, 0x10u);
          sub_8007364(v57, (unsigned __int8)byte_20004037);
        }
        else
        {
          sub_8004FE0((int)"[BLE] !!! IP len is too long.\r\n", 2500, &byte_20000507, 516);
        }
      }
      else if ( v42 == 11 )
      {
        sub_8005498(0x3500u, (int)byte_200038EB, 16);
        sub_8004FE0((int)"[BLE] Read ip: %s.\r\n", byte_200038EB);
        sub_8006EF4(33, (unsigned int)byte_200038EB, 0x10u);
        sub_8007364(v57, (unsigned __int8)byte_20004037);
      }
      goto LABEL_161;
    case 34:
      v45 = *(unsigned __int8 *)(a1 + 4);
      v56 = v45;
      sub_8005728(v45);
      sub_8006EF4(34, (unsigned int)&v56, 1u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_161;
    case 35:
      if ( *(_BYTE *)(a1 + 4) == 1 )
      {
        sub_8004FE0((int)"[BLE] Setting generator enable.\r\n", 2500, &byte_20000507, 516);
        byte_20002EAD = 1;
      }
      else if ( !*(_BYTE *)(a1 + 4) )
      {
        sub_8004FE0((int)"[BLE] Setting generator disable.\r\n", 2500, &byte_20000507, 516);
        byte_20002EAD = 0;
      }
      sub_8006EF4(15, (unsigned int)&byte_20002EAD, 1u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_161;
    case 36:
      v46 = sub_80023E2((unsigned __int8 *)byte_20011138);
      sub_8006EF4(36, (unsigned int)byte_20011138, (unsigned int)(v46 + 1));
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_161;
    case 37:
      v47 = _byteswap_ushort(*(_WORD *)(a1 + 4));
      v55 = *(unsigned __int8 *)(a1 + 5) | (*(unsigned __int8 *)(a1 + 4) << 8);
      sub_800586C(v47);
      sub_8006EF4(37, (unsigned int)&v55, 2u);
      sub_8007364(v57, (unsigned __int8)byte_20004037);
      goto LABEL_161;
    default:
      goto LABEL_5;
  }
}
// 8005CE4: positive sp value BC has been found
// 8006098: control flows out of bounds to 8006308
// 800637A: control flows out of bounds to 800631E
// 8006036: variable 'v26' is possibly undefined
// 8006054: variable 'v27' is possibly undefined
// 8006578: variable 'v48' is possibly undefined
// 8006578: variable 'v49' is possibly undefined
// 8006124: using guessed type int sub_8006124();
// 801EE84: using guessed type int __fastcall sub_801EE84(_DWORD);
// 20000507: using guessed type char byte_20000507;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 20000928: using guessed type char byte_20000928;
// 2000159E: using guessed type char byte_2000159E;
// 2000159F: using guessed type char byte_2000159F;
// 200015A4: using guessed type char byte_200015A4;
// 200015A5: using guessed type char byte_200015A5;
// 200015A6: using guessed type char byte_200015A6;
// 200015D6: using guessed type char byte_200015D6;
// 200015DE: using guessed type char byte_200015DE;
// 20002798: using guessed type int dword_20002798;
// 20002D9C: using guessed type int dword_20002D9C;
// 20002DA0: using guessed type int dword_20002DA0;
// 20002DA4: using guessed type int dword_20002DA4;
// 20002DA8: using guessed type int dword_20002DA8;
// 20002E38: using guessed type char byte_20002E38;
// 20002EA7: using guessed type char byte_20002EA7;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002EAD: using guessed type char byte_20002EAD;
// 20002F11: using guessed type char byte_20002F11;
// 200036B0: using guessed type char byte_200036B0;
// 200036B9: using guessed type __int16 word_200036B9;
// 200037D5: using guessed type int dword_200037D5;
// 200038E3: using guessed type int dword_200038E3;
// 20003C59: using guessed type int dword_20003C59;
// 20003D71: using guessed type _BYTE byte_20003D71[180];
// 20003E25: using guessed type __int16 word_20003E25;
// 20003F75: using guessed type __int16 word_20003F75;
// 20004036: using guessed type char byte_20004036;
// 20004037: using guessed type char byte_20004037;
// 20004238: using guessed type int dword_20004238;
// 2000423C: using guessed type int dword_2000423C;
// 20004240: using guessed type int dword_20004240;

//----- (08006138) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall IRQ_86_handler(
        int a1,
        unsigned int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4
  int v14; // r6
  int v15; // r7
  unsigned int v16; // r5
  int v17; // r7
  unsigned int v18; // r1
  unsigned int v19; // r6
  int v20; // r4
  int v21; // r3
  int v22; // r3
  int v23; // r3
  int v24; // r6
  int v25; // r4
  int v26; // r6
  unsigned int v27; // r1
  unsigned int v28; // r5
  int v29; // r3
  int v30; // r0
  unsigned int v31; // r6
  int v32; // r3
  int v33; // r7
  int v34; // r5
  int v35; // r4
  unsigned int v36; // r5
  int v37; // r3
  unsigned int v38; // r1
  unsigned int v39; // r6
  int v40; // r3
  int v41; // r4
  int v42; // r4
  unsigned int v43; // r5
  _BYTE *v44; // r1
  _DWORD *v45; // r4
  unsigned __int8 *v46; // [sp-Ch] [bp-Ch]

  v16 = a2 >> 8;
  MEMORY[0xB1] = v15;
  v17 = *(_DWORD *)(v14 + 116);
  *(_BYTE *)(v13 + 12) = 116;
  *(_DWORD *)(v14 + 20) = v13;
  *(_BYTE *)(v14 + 21) = v13;
  MEMORY[0xB1] = v17;
  v18 = *(_DWORD *)((a2 >> 8) + 0x64);
  v19 = v16 >> 20;
  v20 = *(unsigned __int8 *)((v16 >> 20) + 5);
  *(_DWORD *)((v16 >> 20) + 0x54) = 0;
  MEMORY[0x81] = v18;
  MEMORY[0x51] = 61;
  *(_BYTE *)(v20 + 12) = -38;
  MEMORY[0x1A] = v20;
  *(_BYTE *)(v20 + 25) = -38;
  *(_BYTE *)(a4 + 25) = v17;
  *(_BYTE *)(v20 + 9) = -38;
  *(_DWORD *)((v16 >> 20) + 0x54) = v16 >> 20;
  *(_DWORD *)(v20 + 64) = -53;
  MEMORY[0x2B] = v20;
  v21 = *(__int16 *)(v20 - 53);
  *(_DWORD *)((v16 >> 20) + 0x54) = v16 >> 20;
  *(_BYTE *)(v20 + 12) = 89;
  MEMORY[0xFFFFFF6D] = v20;
  v22 = -v21;
  MEMORY[0x71] = v16 >> 20;
  *(_BYTE *)(v20 + 17) = v22;
  MEMORY[0xFFFFFF62] = v17;
  *(_DWORD *)(v19 + 84) = 0;
  *(_DWORD *)(v19 + 84) = v22;
  MEMORY[0xFFFFFFE0] = -116;
  *(_DWORD *)(v20 + 68) = v18;
  *(_BYTE *)(v20 + 28) = 93;
  *(_DWORD *)((v18 >> 8) + 0x64) = v18;
  *(_DWORD *)((v18 >> 8) + 0x14) = v16 >> 20;
  *(_DWORD *)((v18 >> 8) + 0x54) = v18 >> 8;
  v23 = *(_DWORD *)(v20 + 116);
  v24 = *(_DWORD *)((v18 >> 8) + 0x64);
  *(_DWORD *)(v20 + 52) = v18 >> 8;
  v25 = *(__int16 *)(v24 + (v18 >> 8));
  v26 = *(_DWORD *)(v25 + 0x44);
  *(_DWORD *)(v25 + 116) = v18;
  *(_BYTE *)(v25 + 28) = 44;
  MEMORY[0x84] = v18;
  v27 = MEMORY[0x40];
  MEMORY[0x34] = v26;
  MEMORY[0x74] = 32;
  v28 = (unsigned int)MEMORY[0x40] >> 8;
  v29 = -v23;
  MEMORY[0xFFFFFFE0] = v29;
  v30 = *(_DWORD *)(v25 + 80);
  *(_DWORD *)(v28 + 0x44) = *(_DWORD *)(v26 + 116);
  *(_BYTE *)(v25 + 20) = v30;
  *(_DWORD *)(v26 + 84) = v29;
  *(_DWORD *)(v28 + 68) = *(_DWORD *)(v29 + 84);
  *(_DWORD *)(v25 + 64) = v28;
  v31 = v28 >> 20;
  *(_WORD *)(v27 + 8) = v25;
  v32 = -v29;
  MEMORY[0x54] = v32;
  *(_DWORD *)(v25 + 52) = v28;
  v33 = *(_DWORD *)(v28 + 84);
  v34 = *(_DWORD *)(v28 + 116);
  *(_DWORD *)(v25 + 84) = v25;
  *(_BYTE *)(v25 + 21) = v32;
  *(_BYTE *)(v31 + 9) = 44;
  *(_BYTE *)(v34 + 17) = v33;
  *(_DWORD *)(v25 + 52) = v34;
  v35 = *(__int16 *)(v31 + v34);
  v36 = v27 >> 8;
  v37 = -v32;
  MEMORY[0xB1] = v33;
  *(_DWORD *)(v31 + 84) = v37;
  v38 = *(_DWORD *)((v27 >> 8) + 0x64);
  v39 = v36 >> 20;
  MEMORY[0x7A] = 116;
  v40 = -v37;
  MEMORY[0x54] = v40;
  *(_DWORD *)(v35 + 84) = v35;
  *(_DWORD *)((v36 >> 20) + 0x54) = v36 >> 20;
  v41 = *(_DWORD *)(v36 + 116);
  *(_DWORD *)(v41 + 84) = v41;
  MEMORY[0xB1] = v41;
  *(_DWORD *)((v36 >> 20) + 0x54) = v36 >> 20;
  v42 = *(_DWORD *)((v38 >> 8) + 0x74);
  *(_DWORD *)(v42 + 84) = v42;
  *(_DWORD *)(v42 + 100) = v36 >> 20;
  v43 = v38 >> 8;
  MEMORY[0xFFFFFF56] = v40;
  *(_BYTE *)(v39 + 17) = v42;
  v44 = *(_BYTE **)((v38 >> 8) + 0x64);
  *(_DWORD *)(v43 + 68) = *(_DWORD *)(v39 + 116);
  *(_BYTE *)(v42 + 21) = (_BYTE)v44;
  v45 = *(_DWORD **)(v39 + 116);
  v45[12] = 101;
  *(_DWORD *)(v43 + 20) = 101;
  *(_DWORD *)(v43 + 116) = v39;
  v45[20] = 101;
  v45[16] = v43;
  sub_80055F0(0x3Du, v44, (unsigned int)v44);
  sub_8006EF4(14, (unsigned int)v45, 1u);
  sub_8007364(v46, *(unsigned __int8 *)(v43 + 14));
  __asm { POP.W           {R4-R11,PC} }
}
// 8005CE4: positive sp value BC has been found
// 800614A: variable 'v15' is possibly undefined
// 800614E: variable 'v14' is possibly undefined
// 8006152: variable 'v13' is possibly undefined
// 800631A: variable 'v46' is possibly undefined

//----- (08006C90) --------------------------------------------------------
int sub_8006C90()
{
  int result; // r0
  unsigned __int8 *v1; // r0
  bool v2; // zf
  int v3; // r1
  int v4; // r1
  int v5; // r1
  int v6; // r1

  if ( byte_20004237 )
    return 1;
  if ( (unsigned __int8)byte_20000909 > 5u )
  {
    byte_20000909 = 0;
    byte_20000908 = 11;
  }
  switch ( byte_20000908 )
  {
    case 0:
      if ( sub_8007210() )
      {
        v1 = strstr((unsigned __int8 *)byte_200038FC, "+QBLEADDR:");
        if ( !v1 )
          goto LABEL_49;
        v2 = v1[12] == 58;
        while ( 1 )
        {
          if ( !v2 )
            goto LABEL_49;
          v3 = v1[15];
          v2 = v3 == 58;
          if ( v3 == 58 )
          {
            v4 = v1[18];
            v2 = v4 == 58;
            if ( v4 == 58 )
            {
              v5 = v1[21];
              v2 = v5 == 58;
              if ( v5 == 58 )
              {
                v6 = v1[24];
                v2 = v6 == 58;
                if ( v6 == 58 )
                  break;
              }
            }
          }
        }
        sprintf(
          (int)&unk_20004029,
          "%c%c%c%c%c%c%c%c%c%c%c%c",
          v1[10],
          v1[11],
          v1[13],
          v1[14],
          v1[16],
          v1[17],
          v1[19],
          v1[20],
          v1[22],
          v1[23],
          v1[25],
          v1[26]);
        byte_20004035 = 0;
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 1:
      if ( sub_80071B4(2) )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 2:
      if ( sub_80072FC() )
      {
        byte_20000908 = 4;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000908;
      }
      goto LABEL_49;
    case 3:
      if ( sub_800725C() )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 4:
      if ( sub_8007434("ff00") )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 5:
      if ( sub_800754C("ff01") )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 6:
      if ( sub_800754C("ff02") )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 7:
      if ( sub_800754C("ff06") )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 8:
      if ( sub_8005C38(150, 150) )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 9:
      if ( sub_8005BC4(1) )
      {
        ++byte_20000908;
        byte_20000909 = 0;
      }
      else
      {
        ++byte_20000909;
      }
      goto LABEL_49;
    case 10:
      if ( sub_8006F34() )
      {
        byte_20004237 = 1;
        sub_8007C6C();
        sub_800F8D8();
        byte_20000908 = 0;
        byte_20000909 = 0;
        result = 1;
      }
      else
      {
        ++byte_20000909;
LABEL_49:
        result = 0;
      }
      break;
    case 11:
      byte_20000908 = 0;
      byte_20004237 = 0;
      sub_8004FE0((int)"Please check ble!\r\n");
      sub_8018928(4, 406);
      sub_8007CF8(0);
      goto LABEL_49;
    default:
      goto LABEL_49;
  }
  return result;
}
// 20000908: using guessed type char byte_20000908;
// 20000909: using guessed type char byte_20000909;
// 20004035: using guessed type char byte_20004035;
// 20004237: using guessed type char byte_20004237;

//----- (08006ED8) --------------------------------------------------------
int __fastcall sub_8006ED8(int a1, int a2)
{
  int v3; // r2
  int result; // r0

  v3 = 0;
  result = 0;
  if ( a1 )
  {
    while ( v3 < a2 )
      result ^= *(unsigned __int8 *)(a1 + v3++);
  }
  return result;
}

//----- (08006EF4) --------------------------------------------------------
int __fastcall sub_8006EF4(int result, unsigned int a2, unsigned int a3)
{
  if ( a2 )
  {
    if ( a3 < 0x1FC )
    {
      byte_20004036 = 115;
      byte_20004037 = a3 + 5;
      byte_20004038 = 35;
      byte_20004039 = result;
      qmemcpy((unsigned int)&unk_2000403A, a2, a3);
      result = sub_8006ED8((int)&byte_20004036, (unsigned __int8)byte_20004037 - 1);
      *((_BYTE *)&unk_20004029 + a3 + 17) = result;
    }
  }
  return result;
}
// 20004036: using guessed type char byte_20004036;
// 20004037: using guessed type char byte_20004037;
// 20004038: using guessed type char byte_20004038;
// 20004039: using guessed type char byte_20004039;

//----- (08006F34) --------------------------------------------------------
int sub_8006F34()
{
  unsigned __int8 i; // r4
  int result; // r0

  for ( i = 0; i < 9u; ++i )
  {
    if ( byte_200036AE == 1 || byte_20004236 == 1 )
    {
      sub_8004FE0((int)"[BLE] Wait for urc or set wifi, don't check ble state!\r\n");
      return 1;
    }
    if ( sub_800DAC0("AT+QBLESTAT", "+QBLESTAT:", 0, 600) )
    {
      if ( strstr((unsigned __int8 *)byte_200038FC, "+QBLESTAT:ADVERTISING") )
      {
        result = 1;
        byte_20004237 = 1;
        return result;
      }
      if ( strstr((unsigned __int8 *)byte_200038FC, "+QBLESTAT:CONNECTED") )
      {
        byte_20004237 = 2;
        return 1;
      }
      if ( strstr((unsigned __int8 *)byte_200038FC, "+QBLESTAT:DISCONNECTED") )
      {
        byte_20004237 = 3;
        return 1;
      }
    }
    sub_80232B4(500);
  }
  sub_8004FE0((int)"[BLE] State disnormal!\r\n");
  result = 0;
  byte_20004237 = 0;
  return result;
}
// 200036AE: using guessed type char byte_200036AE;
// 20004236: using guessed type char byte_20004236;
// 20004237: using guessed type char byte_20004237;

//----- (08007088) --------------------------------------------------------
int __fastcall sub_8007088(int a1, int a2)
{
  unsigned int v2; // r5
  unsigned int v3; // r4

  if ( !a1 )
    return 0;
  v2 = a1 + 5;
  if ( a2 == 1 )
    v3 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 8);
  else
    v3 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 6);
  if ( v3 >= 0xFF )
    return 0;
  sub_8002364(byte_200037E2, 256);
  qmemcpy((unsigned int)byte_200037E2, v2, v3);
  sub_8004FE0((int)"Receive ota url: %s, url_len = %d.\r\n", byte_200037E2, v3);
  return 1;
}

//----- (08007100) --------------------------------------------------------
unsigned __int8 *__fastcall sub_8007100(unsigned __int8 *result)
{
  unsigned __int8 *v1; // r4
  unsigned int v2; // r7
  unsigned __int8 *v3; // r0
  unsigned int v4; // r6
  unsigned int v5; // r5
  unsigned int v6; // r4

  v1 = result;
  if ( result )
  {
    v2 = (unsigned int)(result + 4);
    v3 = strstr(result, "<.,.>");
    v4 = (unsigned __int8)((_BYTE)v3 - v2);
    v5 = (unsigned int)(v3 + 5);
    result = (unsigned __int8 *)(&v1[v1[1]] - (v3 + 5) - 1);
    v6 = (unsigned __int8)result;
    if ( v4 < 0x20 && (unsigned __int8)result < 0x40u )
    {
      sub_8002364(byte_20002EB1, 32);
      qmemcpy((unsigned int)byte_20002EB1, v2, v4);
      sub_8002364(byte_20002ED1, 64);
      qmemcpy((unsigned int)byte_20002ED1, v5, v6);
      byte_20004236 = 1;
      byte_20000929 = 0;
      byte_20000928 = 0;
      byte_200036AC = 2;
      byte_200036AE = 0;
      return (unsigned __int8 *)sub_8004FE0((int)"Waiting for wifi setting...\r\n");
    }
  }
  return result;
}
// 20000928: using guessed type char byte_20000928;
// 20000929: using guessed type char byte_20000929;
// 200036AC: using guessed type char byte_200036AC;
// 200036AE: using guessed type char byte_200036AE;
// 20004236: using guessed type char byte_20004236;

//----- (080071B4) --------------------------------------------------------
int __fastcall sub_80071B4(int a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  sprintf((int)v4, "AT+QBLEINIT=%d", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DAC0(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (08007210) --------------------------------------------------------
int sub_8007210()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DAC0("AT+QBLEADDR?", "+QBLEADDR:", (unsigned __int8 *)&dword_800723C, 300) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  while ( v0 < 3 );
  return 0;
}
// 800723C: using guessed type int dword_800723C;

//----- (0800725C) --------------------------------------------------------
int sub_800725C()
{
  unsigned int v0; // r4
  unsigned __int8 v2[76]; // [sp+Ch] [bp-4Ch] BYREF

  sub_8002364(v2, 64);
  v0 = 0;
  sprintf(
    (int)v2,
    "AT+QBLENAME=MST_ACCP_%c%c%c%c",
    (unsigned __int8)byte_20004031,
    (unsigned __int8)byte_20004032,
    (unsigned __int8)byte_20004033,
    (unsigned __int8)byte_20004034);
  while ( v0 < 3 )
  {
    if ( sub_800DAC0(v2, "OK", 0, 300) )
    {
      sub_800DAC0("AT+QBLENAME?", "+QBLENAME:", "OK", 300);
      return 1;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  return 0;
}
// 20004031: using guessed type char byte_20004031;
// 20004032: using guessed type char byte_20004032;
// 20004033: using guessed type char byte_20004033;
// 20004034: using guessed type char byte_20004034;

//----- (080072FC) --------------------------------------------------------
int sub_80072FC()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DAC0("AT+QBLENAME?", "+QBLENAME:", (unsigned __int8 *)&dword_8007334, 300)
      && strstr((unsigned __int8 *)byte_200038FC, "MST_ACCP_") )
    {
      return 1;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  while ( v0 < 3 );
  return 0;
}
// 8007334: using guessed type int dword_8007334;

//----- (08007364) --------------------------------------------------------
_BYTE *__fastcall sub_8007364(unsigned __int8 *a1, int a2)
{
  _BYTE *result; // r0
  unsigned __int8 v5[80]; // [sp+0h] [bp-50h] BYREF

  result = sub_8002364(v5, 64);
  if ( a1 )
  {
    result = (_BYTE *)sub_8024F80(dword_20000458, 500);
    if ( result )
    {
      sprintf((int)v5, "AT+QBLEGATTSNTFY=ff02,%d,", a2);
      sub_800E28A(v5);
      sub_8007E80(a1, (unsigned __int16)a2);
      sub_800E274((int)"\r\n", 2);
      return (_BYTE *)sub_8024A40(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;

//----- (080073DC) --------------------------------------------------------
_BYTE *__fastcall sub_80073DC(unsigned __int8 *a1, int a2)
{
  _BYTE *result; // r0
  unsigned __int8 v5[76]; // [sp+4h] [bp-4Ch] BYREF

  result = sub_8002364(v5, 64);
  if ( a1 )
  {
    sprintf((int)v5, "AT+QBLEGATTSNTFY=ff02,%d,", a2);
    sub_800E28A(v5);
    sub_8007E80(a1, (unsigned __int16)a2);
    return (_BYTE *)sub_800E274((int)"\r\n", 2);
  }
  return result;
}

//----- (08007434) --------------------------------------------------------
int __fastcall sub_8007434(const char *a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  if ( !a1 )
    return 0;
  sprintf((int)v4, "AT+QBLEGATTSSRV=%s", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DAC0(v4, "OK", 0, 600) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (08007498) --------------------------------------------------------
int sub_8007498()
{
  int result; // r0

  result = (unsigned __int8)byte_200015AC;
  if ( byte_200015AC && !byte_200036AF )
  {
    result = (unsigned __int8)byte_200015A9;
    if ( !byte_200015A9 )
    {
      byte_200015AC = byte_200015A9;
      sub_80031E4();
      sub_801EE84();
      sub_801E274();
    }
  }
  else if ( byte_200036B4 == 7 && !byte_200015AC )
  {
    result = (unsigned __int8)byte_200036AE;
    if ( !byte_200036AE )
    {
      result = sub_801AAF4(&word_2000090A, 0x3Cu);
      if ( result )
        return sub_8006F34();
    }
  }
  return result;
}
// 801EE84: using guessed type int sub_801EE84(void);
// 2000090A: using guessed type _WORD word_2000090A;
// 200015A9: using guessed type char byte_200015A9;
// 200015AC: using guessed type char byte_200015AC;
// 200036AE: using guessed type char byte_200036AE;
// 200036AF: using guessed type char byte_200036AF;
// 200036B4: using guessed type char byte_200036B4;

//----- (08007504) --------------------------------------------------------
char *sub_8007504()
{
  unsigned int i; // r1
  char *v1; // r2
  char *result; // r0
  __int16 v3; // r3
  __int16 v4; // r3

  for ( i = 0; i < 0xA; i = (unsigned __int8)(i + 1) )
  {
    v1 = &byte_20002E37[10 * i];
    result = (char *)&unk_20003FD9 + 8 * i;
    v3 = *((_WORD *)v1 + 3);
    result[1] = v3;
    *result = HIBYTE(v3);
    v4 = *((_WORD *)v1 + 4);
    result[3] = v4;
    result[2] = HIBYTE(v4);
    result[4] = v1[2];
    *(_WORD *)(result + 5) = *((_WORD *)v1 + 2);
    result[7] = v1[3];
  }
  return result;
}

//----- (0800754C) --------------------------------------------------------
int __fastcall sub_800754C(const char *a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  if ( !a1 )
    return 0;
  sprintf((int)v4, "AT+QBLEGATTSCHAR=%s", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DAC0(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (080075B0) --------------------------------------------------------
int sub_80075B0()
{
  int result; // r0

  sub_800F228();
  word_20003F75 = word_20003B1D;
  word_20003F77 = word_20003B1F;
  byte_20003F79 = byte_20003B11;
  byte_20003F7A = byte_20000928;
  byte_20003F7B = 1;
  byte_20003F7C = byte_20003B12;
  byte_20003F7D = byte_20003B13;
  word_20003F7E = word_20003B21;
  byte_20003F80 = byte_20003B14;
  word_20003F81 = word_20003B1B;
  dword_20003F83 = dword_20003B3B;
  dword_20003F87 = dword_20002F22;
  dword_20003F8B = dword_20003B43;
  dword_20003F8F = dword_20003B47;
  dword_20003F93 = dword_20003B53;
  word_20003F97 = word_20003B31;
  word_20003F99 = word_20003B33;
  byte_20003F9B = byte_20003B15;
  byte_20003F9C = byte_20003B16;
  byte_20003F9D = byte_20003B17;
  dword_20003F9E = dword_20003B57;
  dword_20003FA2 = dword_20003B5B;
  word_20003FA6 = word_20003B39;
  word_20003FA8 = dword_20003B5F;
  dword_20003FAA = dword_20003B63;
  dword_20003FAE = dword_20003B67;
  byte_20003FB2 = byte_20003B18;
  byte_20003FB3 = byte_20003B19;
  dword_20003FB4 = dword_20003B4B;
  dword_20003FB8 = dword_20003B4F;
  byte_20003FBC = byte_20003B1A;
  word_20003FBD = word_20003C10;
  word_20003FBF = word_20003C12;
  byte_20003FC1 = byte_200015DC;
  byte_20003FC2 = byte_200004AC;
  byte_20003FC3 = byte_20002EA8;
  word_20003FC4 = word_20003C1C;
  byte_20003FD3 = byte_200004BB;
  qmemcpy((unsigned int)&unk_20003FC6, (unsigned int)&dword_200037D5, 0xDu);
  byte_20003FD4 = sub_800F638();
  byte_20003FD5 = byte_20003C57;
  byte_20003FD6 = byte_20003C58;
  byte_20003FD7 = (unsigned __int16)sub_8005188() >> 8;
  result = sub_8005188();
  byte_20003FD8 = result;
  return result;
}
// 200004AC: using guessed type char byte_200004AC;
// 200004BB: using guessed type char byte_200004BB;
// 20000928: using guessed type char byte_20000928;
// 200015DC: using guessed type char byte_200015DC;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002F22: using guessed type int dword_20002F22;
// 200037D5: using guessed type int dword_200037D5;
// 20003B11: using guessed type char byte_20003B11;
// 20003B12: using guessed type char byte_20003B12;
// 20003B13: using guessed type char byte_20003B13;
// 20003B14: using guessed type char byte_20003B14;
// 20003B15: using guessed type char byte_20003B15;
// 20003B16: using guessed type char byte_20003B16;
// 20003B17: using guessed type char byte_20003B17;
// 20003B18: using guessed type char byte_20003B18;
// 20003B19: using guessed type char byte_20003B19;
// 20003B1A: using guessed type char byte_20003B1A;
// 20003B1B: using guessed type __int16 word_20003B1B;
// 20003B1D: using guessed type __int16 word_20003B1D;
// 20003B1F: using guessed type __int16 word_20003B1F;
// 20003B21: using guessed type __int16 word_20003B21;
// 20003B31: using guessed type __int16 word_20003B31;
// 20003B33: using guessed type __int16 word_20003B33;
// 20003B39: using guessed type __int16 word_20003B39;
// 20003B3B: using guessed type int dword_20003B3B;
// 20003B43: using guessed type int dword_20003B43;
// 20003B47: using guessed type int dword_20003B47;
// 20003B4B: using guessed type int dword_20003B4B;
// 20003B4F: using guessed type int dword_20003B4F;
// 20003B53: using guessed type int dword_20003B53;
// 20003B57: using guessed type int dword_20003B57;
// 20003B5B: using guessed type int dword_20003B5B;
// 20003B5F: using guessed type int dword_20003B5F;
// 20003B63: using guessed type int dword_20003B63;
// 20003B67: using guessed type int dword_20003B67;
// 20003C10: using guessed type __int16 word_20003C10;
// 20003C12: using guessed type __int16 word_20003C12;
// 20003C1C: using guessed type __int16 word_20003C1C;
// 20003C57: using guessed type char byte_20003C57;
// 20003C58: using guessed type char byte_20003C58;
// 20003F75: using guessed type __int16 word_20003F75;
// 20003F77: using guessed type __int16 word_20003F77;
// 20003F79: using guessed type char byte_20003F79;
// 20003F7A: using guessed type char byte_20003F7A;
// 20003F7B: using guessed type char byte_20003F7B;
// 20003F7C: using guessed type char byte_20003F7C;
// 20003F7D: using guessed type char byte_20003F7D;
// 20003F7E: using guessed type __int16 word_20003F7E;
// 20003F80: using guessed type char byte_20003F80;
// 20003F81: using guessed type __int16 word_20003F81;
// 20003F83: using guessed type int dword_20003F83;
// 20003F87: using guessed type int dword_20003F87;
// 20003F8B: using guessed type int dword_20003F8B;
// 20003F8F: using guessed type int dword_20003F8F;
// 20003F93: using guessed type int dword_20003F93;
// 20003F97: using guessed type __int16 word_20003F97;
// 20003F99: using guessed type __int16 word_20003F99;
// 20003F9B: using guessed type char byte_20003F9B;
// 20003F9C: using guessed type char byte_20003F9C;
// 20003F9D: using guessed type char byte_20003F9D;
// 20003F9E: using guessed type int dword_20003F9E;
// 20003FA2: using guessed type int dword_20003FA2;
// 20003FA6: using guessed type __int16 word_20003FA6;
// 20003FA8: using guessed type __int16 word_20003FA8;
// 20003FAA: using guessed type int dword_20003FAA;
// 20003FAE: using guessed type int dword_20003FAE;
// 20003FB2: using guessed type char byte_20003FB2;
// 20003FB3: using guessed type char byte_20003FB3;
// 20003FB4: using guessed type int dword_20003FB4;
// 20003FB8: using guessed type int dword_20003FB8;
// 20003FBC: using guessed type char byte_20003FBC;
// 20003FBD: using guessed type __int16 word_20003FBD;
// 20003FBF: using guessed type __int16 word_20003FBF;
// 20003FC1: using guessed type char byte_20003FC1;
// 20003FC2: using guessed type char byte_20003FC2;
// 20003FC3: using guessed type char byte_20003FC3;
// 20003FC4: using guessed type __int16 word_20003FC4;
// 20003FD3: using guessed type char byte_20003FD3;
// 20003FD4: using guessed type char byte_20003FD4;
// 20003FD5: using guessed type char byte_20003FD5;
// 20003FD6: using guessed type char byte_20003FD6;
// 20003FD7: using guessed type char byte_20003FD7;
// 20003FD8: using guessed type char byte_20003FD8;

//----- (080076F8) --------------------------------------------------------
unsigned int sub_80076F8()
{
  word_20003E25 = (unsigned __int8)byte_20002D58;
  dword_20003E27 = dword_20002D4C;
  word_20003E2B = word_20002D50;
  dword_20003E2D = dword_20002D52;
  word_20003E31 = word_20002D56;
  dword_20003E33 = dword_20002D5A;
  word_20003E37 = word_20002D5E;
  byte_20003E39 = dword_20002D68;
  byte_20003E3A = BYTE2(dword_20002D68);
  word_20003E3B = (unsigned __int16)word_20002D56 * (unsigned __int16)dword_20002D52 / 1000;
  dword_20003E3D = dword_20002D60;
  dword_20003E41 = dword_20002D64;
  dword_20003E45 = dword_20000474;
  word_20003E49 = *(_WORD *)((char *)&dword_20002D68 + 3);
  word_20003E4B = word_20002D6D;
  dword_20003E4D = dword_20002D6F;
  dword_20003E51 = dword_20002D73;
  return qmemcpy((unsigned int)&word_20003E55, (unsigned int)&dword_20002D77, 0x20u);
}
// 20000474: using guessed type int dword_20000474;
// 20002D4C: using guessed type int dword_20002D4C;
// 20002D50: using guessed type __int16 word_20002D50;
// 20002D52: using guessed type int dword_20002D52;
// 20002D56: using guessed type __int16 word_20002D56;
// 20002D58: using guessed type char byte_20002D58;
// 20002D5A: using guessed type int dword_20002D5A;
// 20002D5E: using guessed type __int16 word_20002D5E;
// 20002D60: using guessed type int dword_20002D60;
// 20002D64: using guessed type int dword_20002D64;
// 20002D68: using guessed type int dword_20002D68;
// 20002D6D: using guessed type __int16 word_20002D6D;
// 20002D6F: using guessed type int dword_20002D6F;
// 20002D73: using guessed type int dword_20002D73;
// 20002D77: using guessed type int dword_20002D77;
// 20003E25: using guessed type __int16 word_20003E25;
// 20003E27: using guessed type int dword_20003E27;
// 20003E2B: using guessed type __int16 word_20003E2B;
// 20003E2D: using guessed type int dword_20003E2D;
// 20003E31: using guessed type __int16 word_20003E31;
// 20003E33: using guessed type int dword_20003E33;
// 20003E37: using guessed type __int16 word_20003E37;
// 20003E39: using guessed type char byte_20003E39;
// 20003E3A: using guessed type char byte_20003E3A;
// 20003E3B: using guessed type __int16 word_20003E3B;
// 20003E3D: using guessed type int dword_20003E3D;
// 20003E41: using guessed type int dword_20003E41;
// 20003E45: using guessed type int dword_20003E45;
// 20003E49: using guessed type __int16 word_20003E49;
// 20003E4B: using guessed type __int16 word_20003E4B;
// 20003E4D: using guessed type int dword_20003E4D;
// 20003E51: using guessed type int dword_20003E51;
// 20003E55: using guessed type __int16 word_20003E55;

//----- (0800777C) --------------------------------------------------------
BOOL sub_800777C()
{
  return sub_800DC14(3, 0, 0);
}

//----- (08007788) --------------------------------------------------------
int sub_8007788()
{
  int result; // r0

  sub_800DC14(0, (const char *)&dword_80077B0, 0);
  sub_800DC14(0, "User Cert", 0);
  sub_800DC14(0, "User Key", 0);
  result = 0;
  byte_200036B4 = 0;
  return result;
}
// 80077B0: using guessed type int dword_80077B0;
// 200036B4: using guessed type char byte_200036B4;

//----- (080077D0) --------------------------------------------------------
int sub_80077D0()
{
  int result; // r0

  byte_20003AFE = byte_2000050D;
  word_20003AFF = (unsigned int)flt_200002F4;
  word_20003B01 = (unsigned int)*(float *)&dword_2000278C;
  word_20003B03 = (unsigned int)*(float *)&dword_20002798;
  word_20003B05 = (unsigned int)*(float *)&dword_20001C20;
  word_20003B07 = (unsigned int)*(float *)&dword_20001C24;
  word_20003B09 = (unsigned int)*(float *)&dword_20001C28;
  word_20003B0B = word_20002D5E;
  word_20003B0D = sub_800F7D0((__int16 *)&dword_20002D6F, 4u);
  result = (unsigned __int8)byte_20002E38;
  word_20003B0F = (unsigned __int8)byte_20002E38;
  return result;
}
// 200002F4: using guessed type float flt_200002F4;
// 2000050D: using guessed type char byte_2000050D;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 2000278C: using guessed type int dword_2000278C;
// 20002798: using guessed type int dword_20002798;
// 20002D5E: using guessed type __int16 word_20002D5E;
// 20002D6F: using guessed type int dword_20002D6F;
// 20002E38: using guessed type char byte_20002E38;
// 20003AFE: using guessed type char byte_20003AFE;
// 20003AFF: using guessed type __int16 word_20003AFF;
// 20003B01: using guessed type __int16 word_20003B01;
// 20003B03: using guessed type __int16 word_20003B03;
// 20003B05: using guessed type __int16 word_20003B05;
// 20003B07: using guessed type __int16 word_20003B07;
// 20003B09: using guessed type __int16 word_20003B09;
// 20003B0B: using guessed type __int16 word_20003B0B;
// 20003B0D: using guessed type __int16 word_20003B0D;
// 20003B0F: using guessed type __int16 word_20003B0F;

//----- (0800786C) --------------------------------------------------------
int __fastcall sub_800786C(int result)
{
  if ( result == 1 )
    return sub_80050B4(0);
  if ( result == 2 )
    return sub_80050B4(2);
  return result;
}

//----- (08007880) --------------------------------------------------------
void __fastcall __noreturn sub_8007880(int a1)
{
  int v2; // r4
  unsigned __int8 v3[128]; // [sp+0h] [bp-80h] BYREF

  sub_8002364(v3, 128);
  if ( a1 )
  {
    sprintf((int)v3, "AT+QWLANOTA=http://192.168.137.1/FC41D_OTA.rbl");
    v2 = 200;
  }
  else
  {
    sprintf((int)v3, (const char *)dword_8029248);
    v2 = 400;
  }
  if ( sub_8024F80(dword_20000458, 5000) )
  {
    sub_8023648((_DWORD *)dword_20000010);
    sub_8023648((_DWORD *)dword_20000004);
    sub_8023648((_DWORD *)dword_20000008);
    sub_8024A40(dword_20000458, 0, 0, 0);
    sub_8004FE0((int)"Fc41d OTA GIVE MUTEX.\r\n");
  }
  sub_800DAC0(v3, "OK", 0, 300 * v2);
  sub_80232B4(10000);
  __disable_irq();
  sub_801E2BC();
}
// 8029248: using guessed type int dword_8029248[21];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007960) --------------------------------------------------------
int __fastcall sub_8007960(int a1)
{
  int v2; // r4
  unsigned __int8 v4[140]; // [sp+4h] [bp-8Ch] BYREF

  sub_8002364(v4, 128);
  if ( a1 )
  {
    sprintf((int)v4, "AT+QWLANOTA=http://192.168.137.1/FC41D_OTA.rbl");
    v2 = 200;
  }
  else
  {
    sprintf((int)v4, (const char *)dword_8029248);
    v2 = 400;
  }
  if ( sub_8024F80(dword_20000458, 5000) )
  {
    sub_8023648((_DWORD *)dword_20000010);
    sub_8023648((_DWORD *)dword_20000004);
    sub_8023648((_DWORD *)dword_20000008);
    sub_8024A40(dword_20000458, 0, 0, 0);
    sub_8004FE0((int)"Fc41d OTA GIVE MUTEX.\r\n");
  }
  sub_800DAC0(v4, "OK", 0, 300 * v2);
  return sub_80232B4(10000);
}
// 8029248: using guessed type int dword_8029248[21];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007A40) --------------------------------------------------------
int __fastcall sub_8007A40(const char *a1, unsigned int a2, int a3)
{
  unsigned __int8 v7[272]; // [sp+0h] [bp-110h] BYREF

  sub_8002364(v7, 256);
  if ( a1 && a2 <= 0xFF )
  {
    if ( a3 )
      sprintf((int)v7, "AT+QWLANOTA=%s,%d", a1, a3);
    else
      sprintf((int)v7, "AT+QWLANOTA=%s", a1);
    if ( sub_8024F80(dword_20000458, 5000) )
    {
      sub_8023648((_DWORD *)dword_20000010);
      sub_8023648((_DWORD *)dword_20000004);
      sub_8023648((_DWORD *)dword_20000008);
      sub_8024A40(dword_20000458, 0, 0, 0);
      sub_8004FE0((int)"Fc41d OTA GIVE MUTEX.\r\n");
    }
    if ( sub_800DAC0(v7, (unsigned __int8 *)&dword_8007B24, 0, 180000) )
    {
      sub_8004FE0((int)"Fc41d OTA OK!.\r\n");
      __disable_irq();
      sub_801E2BC();
    }
    __disable_irq();
    sub_801E2BC();
  }
  return sub_8004FE0((int)dword_8029164, a1, a2, a3);
}
// 8007B24: using guessed type int dword_8007B24;
// 8029164: using guessed type int dword_8029164[18];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007B4C) --------------------------------------------------------
int sub_8007B4C()
{
  sub_8002364(byte_200037BB, 26);
  sprintf((int)byte_200037BB, "%x%x%x", MEMORY[0x1FFF7598], MEMORY[0x1FFF7594], MEMORY[0x1FFF7590]);
  return sub_8004FE0((int)"*** Fc41d_info.uid = %s ***\r\n", byte_200037BB);
}

//----- (08007BB8) --------------------------------------------------------
int sub_8007BB8()
{
  int result; // r0
  unsigned __int16 v1; // r0

  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sprintf((int)byte_2000484A, "dev_net_info:%s", byte_20011138);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (08007C6C) --------------------------------------------------------
int sub_8007C6C()
{
  unsigned int v0; // r4
  unsigned __int8 *v1; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( v0 >= 3 )
      return 0;
    if ( sub_800DAC0("AT+QVERSION", 0, (unsigned __int8 *)&dword_8007CC4, 300) )
      break;
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  v1 = strstr((unsigned __int8 *)byte_200038FC, "bin_");
  if ( v1 )
  {
    dword_200037D5 = *((_DWORD *)v1 + 1);
    dword_200037D9 = *((_DWORD *)v1 + 2);
    dword_200037DD = *((_DWORD *)v1 + 3);
    byte_200037E1 = 0;
    sub_8004FE0((int)"Blue version: %s\r\n", (const char *)&dword_200037D5);
  }
  return 1;
}
// 8007CC4: using guessed type int dword_8007CC4;
// 200037D5: using guessed type int dword_200037D5;
// 200037D9: using guessed type int dword_200037D9;
// 200037DD: using guessed type int dword_200037DD;
// 200037E1: using guessed type char byte_200037E1;

//----- (08007CF8) --------------------------------------------------------
int __fastcall sub_8007CF8(int a1)
{
  int result; // r0
  int v3; // r1

  sub_8004FE0((int)"Hardware reset, type:%d, reset_time:%d min.\r\n", a1, (unsigned __int16)word_200036B5);
  result = (unsigned __int8)byte_200015AC;
  if ( !byte_200015AC )
  {
    if ( a1 == 1 )
    {
      if ( !sub_801AAF4(&word_200008F6, (unsigned __int16)(60 * word_200036B5)) )
      {
        result = (unsigned __int16)word_200036B5;
        if ( word_200036B5 != 15 )
          return result;
      }
      if ( (unsigned __int16)word_200036B5 < 0xF0u )
        word_200036B5 *= 2;
      else
        word_200036B5 = 15;
    }
    else if ( a1 == 2 )
    {
      result = sub_801AAF4(&word_200008F6, 0x708u);
      if ( !result )
        return result;
    }
    sub_8018928(4, 401);
    v3 = dword_200008FC++;
    sub_8017DFC(1, v3, 1, 2);
    if ( sub_8024F80(dword_20000458, 1500) )
    {
      sub_801227E(1207962624, 2048, 1);
      sub_80232B4(2000);
      sub_801227E(1207962624, 2048, 0);
      sub_80232B4(1000);
      sub_8024A40(dword_20000458, 0, 0, 0);
    }
    else
    {
      sub_801227E(1207962624, 2048, 1);
      sub_80232B4(2000);
      sub_801227E(1207962624, 2048, 0);
      sub_80232B4(1000);
    }
    result = 0;
    if ( byte_20000506 == 1 )
      byte_200036AC = 2;
    else
      byte_200036AC = 0;
    byte_20000929 = 0;
    byte_20004245 = 0;
    byte_20004237 = 0;
    byte_2000098D = 1;
    byte_200036AE = 0;
    byte_20004246 = 0;
    byte_2000098E = 0;
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20000506: using guessed type char byte_20000506;
// 200008F6: using guessed type _WORD word_200008F6;
// 200008FC: using guessed type int dword_200008FC;
// 20000929: using guessed type char byte_20000929;
// 2000098D: using guessed type char byte_2000098D;
// 2000098E: using guessed type char byte_2000098E;
// 200015AC: using guessed type char byte_200015AC;
// 200036AC: using guessed type char byte_200036AC;
// 200036AE: using guessed type char byte_200036AE;
// 200036B5: using guessed type __int16 word_200036B5;
// 20004237: using guessed type char byte_20004237;
// 20004245: using guessed type char byte_20004245;
// 20004246: using guessed type char byte_20004246;

//----- (08007E80) --------------------------------------------------------
unsigned __int8 *__fastcall sub_8007E80(unsigned __int8 *result, int a2)
{
  unsigned __int8 *v2; // r4
  int v4; // t1

  v2 = result;
  if ( result )
  {
    while ( a2 )
    {
      v4 = *v2++;
      sub_80048A0(v4);
      a2 = (unsigned __int16)(a2 - 1);
    }
    return 0;
  }
  return result;
}

//----- (08007EA0) --------------------------------------------------------
#error "8007F36: call analysis failed (funcsize=69)"

//----- (08007F88) --------------------------------------------------------
int __fastcall sub_8007F88(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v7; // r4

  v7 = 0;
  if ( !a1 )
    return 0;
  if ( sub_8024F80(dword_20000458, 500) )
  {
    sub_8002364(byte_2000099C, 2048);
    word_20000992 = 0;
    sub_800ECDC(a1);
    byte_200036B1 = 3;
    sub_8004FE0((int)sub_800807C, a1);
    if ( sub_8022C24(0, 0, 400) == 1 )
    {
      sub_80232B4(a4);
      byte_2000099C[(unsigned __int16)word_20000992] = 0;
      sub_8004FE0((int)&unk_80080A0, byte_2000099C);
      if ( (unsigned int)a2 | (unsigned int)a3 )
      {
        if ( a2 && a3 && strstr(byte_2000099C, a2) && strstr(byte_2000099C, a3) )
        {
          v7 = 1;
        }
        else if ( a2 && strstr(byte_2000099C, a2) )
        {
          v7 = 1;
        }
        else if ( strstr(byte_2000099C, a3) )
        {
          v7 = 1;
        }
      }
      else
      {
        sub_8004FE0((int)"Set expected reply content error!\r\n");
      }
    }
    byte_200036B1 = 0;
    sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return v7;
}
// 800807C: using guessed type int sub_800807C();
// 20000458: using guessed type int dword_20000458;
// 20000992: using guessed type __int16 word_20000992;
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];
// 200036B1: using guessed type char byte_200036B1;

//----- (080080E8) --------------------------------------------------------
int sub_80080E8()
{
  unsigned int v0; // r4
  unsigned __int8 *v1; // r0
  unsigned int v2; // r6
  unsigned __int8 *v4; // r0
  int v5; // r9
  unsigned __int8 *v6; // r0
  int v7; // r8
  unsigned __int8 *v8; // r0
  char *i; // r5
  int v10; // r10
  __int16 v11; // r0
  unsigned int v12; // r1
  int v13; // r1
  unsigned int j; // r0
  unsigned int k; // r5
  unsigned int m; // r0
  unsigned __int16 *v17; // r1
  unsigned int v18; // r2
  unsigned int n; // r4
  _WORD v20[96]; // [sp+8h] [bp-120h] BYREF
  __int16 v21; // [sp+C8h] [bp-60h]
  __int16 v22; // [sp+CAh] [bp-5Eh]

  v0 = 0;
  sub_8002364(v20, 256);
  v1 = strstr(byte_2000099C, (unsigned __int8 *)&dword_80082E4);
  if ( v1 )
  {
    v2 = (unsigned __int16)sub_8002644((char *)v1 + 2);
    if ( v2 > 0xE10 || !v2 )
      v2 = 3600;
    v4 = strstr(byte_2000099C, "c=");
    if ( v4 )
    {
      v5 = (unsigned __int16)sub_8002644((char *)v4 + 2);
      v6 = strstr(byte_2000099C, "l=");
      if ( v6 )
      {
        v7 = (unsigned __int16)sub_8002644((char *)v6 + 2);
        v8 = strstr(byte_2000099C, "d=");
        if ( v8 )
        {
          for ( i = (char *)(v8 + 2); *i; i = (char *)(v10 + 1) )
          {
            if ( v0 >= 0x80 )
              break;
            v10 = sub_80023CE((int)i, 0x2Cu);
            v11 = sub_8002644(i);
            v12 = v0++;
            v20[v12] = v11;
            if ( !v10 )
              break;
          }
          if ( v0 < 0x80 )
          {
            v13 = 0;
            for ( j = 0; j < v0; ++j )
              v13 ^= (unsigned __int16)v20[j];
            if ( v13 == v5 && v7 == v0 )
            {
              if ( byte_200036AD == 1 )
              {
                sub_8004FE0((int)&off_8028C5C, v2, v13, v5, v7, v0);
                for ( k = 0; k < v0; ++k )
                  sub_8004FE0((int)"%u, ", (unsigned __int16)v20[k]);
                sub_8004FE0((int)"\r\n");
              }
              for ( m = 0; m < 0x18; m = (unsigned __int8)(m + 1) )
              {
                v18 = 4 * m + 3;
                if ( v18 >= v0 )
                  break;
                word_2000505C[3 * m] = v20[4 * m];
                v17 = &word_2000505C[3 * m];
                v17[1] = v20[4 * m + 1];
                *((_BYTE *)v17 + 4) = v20[4 * m + 2];
                *((_BYTE *)v17 + 5) = v20[v18];
              }
              if ( v0 >= 0x60 )
              {
                byte_200050EC = v21;
                byte_200050ED = v22;
              }
              dword_200015A0 = dword_2000002C + v2 + 10;
              if ( byte_200036AD == 1 )
              {
                sub_8004FE0((int)"[HTTP] Get economy data :\r\n");
                for ( n = 0; n < 0x18; n = (unsigned __int8)(n + 1) )
                  sub_8004FE0(
                    (int)"not Found\r\n",
                    n,
                    word_2000505C[3 * n],
                    (__int16)word_2000505C[3 * n + 1],
                    LOBYTE(word_2000505C[3 * n + 2]),
                    HIBYTE(word_2000505C[3 * n + 2]));
                sub_8004FE0(
                  (int)"\r\ntotal_time = %d, info_idx = %d.\r\n",
                  (unsigned __int8)byte_200050EC,
                  (unsigned __int8)byte_200050ED);
              }
              return 1;
            }
            else
            {
              sub_8004FE0((int)"var\r\n");
              return 0;
            }
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else if ( strstr(byte_2000099C, "ERROR") )
  {
    sub_8004FE0((int)"[HTTP] Get economy data error.\r\n");
    if ( (unsigned __int8)byte_20000943 <= 3u )
    {
      ++byte_20000943;
      return 0;
    }
    else
    {
      sub_8004FE0((int)"[HTTP] Wait next time.\r\n");
      byte_20000943 = 0;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}
// 80082E4: using guessed type int dword_80082E4;
// 8028C5C: using guessed type _UNKNOWN *off_8028C5C;
// 2000002C: using guessed type int dword_2000002C;
// 20000943: using guessed type char byte_20000943;
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];
// 200015A0: using guessed type int dword_200015A0;
// 200036AD: using guessed type char byte_200036AD;
// 2000505C: using guessed type unsigned __int16 word_2000505C[72];
// 200050EC: using guessed type char byte_200050EC;
// 200050ED: using guessed type char byte_200050ED;

//----- (080083A4) --------------------------------------------------------
int __fastcall sub_80083A4(int a1)
{
  unsigned int v1; // r4

  v1 = 0;
  sprintf((int)byte_2000119C, "AT+QHTTPGET=%d", a1);
  while ( v1 < 2 )
  {
    if ( sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_80083F4, 0, 300) )
      return 1;
    v1 = (unsigned __int8)(v1 + 1);
    sub_80232B4(100);
  }
  return 0;
}
// 80083F4: using guessed type int dword_80083F4;
// 2000119C: using guessed type unsigned __int8 byte_2000119C[1024];

//----- (080083F8) --------------------------------------------------------
_BYTE *sub_80083F8()
{
  int i; // r4
  char *v1; // r0
  _BYTE *result; // r0

  for ( i = 0; i < 143; ++i )
  {
    v1 = (char *)&unk_20005100 + 340 * i;
    *(_DWORD *)v1 = -1;
    result = sub_8002364(v1 + 12, 328);
  }
  return result;
}

//----- (0800842C) --------------------------------------------------------
int sub_800842C()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_8007F88((unsigned __int8 *)sub_800846C, "OK", "+QHTTPREAD: 0", 900) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  while ( v0 < 2 );
  return 0;
}

//----- (0800846C) --------------------------------------------------------
int __fastcall sub_800846C(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r4
  int v5; // r5
  int v6; // r6
  int v7; // r8
  int *v8; // r1
  int v9; // r5
  int *v10; // r6
  char *v12; // r0
  int i; // r4

  *(_BYTE *)(a1 + a2) = a2;
  *(_DWORD *)(v5 + v4) = a4;
  *(_BYTE *)(2 * a2) = a1;
  *(_DWORD *)(a3 + a2) = v4;
  v8 = (int *)(a2 + v7);
  v9 = v6 + 61;
  v10 = v8;
  if ( !v8 || !a3 )
    return 0;
  if ( dword_20000994 == v9 )
    return 0;
  if ( (unsigned __int16)word_2000098F >= 0x8Fu )
  {
    for ( i = 1; i < 143; ++i )
      qmemcpy((unsigned int)&dword_20005100[85 * i - 85], (unsigned int)&dword_20005100[85 * i], 0x154u);
    dword_20010D98 = v9;
    dword_20010D9C = *v10;
    dword_20010DA0 = v10[1];
    qmemcpy((unsigned int)&unk_20010DA4, a3, 0x148u);
  }
  else
  {
    dword_20005100[85 * (unsigned __int16)word_2000098F] = v9;
    v12 = (char *)&dword_20005100[85 * (unsigned __int16)word_2000098F];
    *((_DWORD *)v12 + 1) = *v8;
    *((_DWORD *)v12 + 2) = v8[1];
    qmemcpy((unsigned int)&dword_20005100[85 * (unsigned __int16)word_2000098F++ + 3], a3, 0x148u);
  }
  dword_20000994 = v9;
  return 1;
}
// 800846E: variable 'v5' is possibly undefined
// 800846E: variable 'v4' is possibly undefined
// 8008476: variable 'v7' is possibly undefined
// 8008480: variable 'v6' is possibly undefined
// 2000098F: using guessed type __int16 word_2000098F;
// 20000994: using guessed type int dword_20000994;
// 20005100: using guessed type _DWORD dword_20005100[6954];
// 20010D98: using guessed type int dword_20010D98;
// 20010D9C: using guessed type int dword_20010D9C;
// 20010DA0: using guessed type int dword_20010DA0;

//----- (08008554) --------------------------------------------------------
int sub_8008554()
{
  unsigned __int8 *v0; // r0
  int v1; // r4

  v0 = strstr(byte_2000099C, "\"de\":");
  if ( !v0 )
    return 0;
  v1 = (unsigned __int8)sub_8002644((char *)v0 + 5);
  sub_8004FE0((int)"[HTTP] Upload decrypt result = %d.\r\n", v1);
  return v1;
}
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];

//----- (080085AC) --------------------------------------------------------
int __fastcall sub_80085AC(int a1)
{
  unsigned int v1; // r4

  v1 = 0;
  sprintf((int)byte_2000119C, "AT+QHTTPCFG=\"sslctxid\",%d", a1);
  while ( v1 < 3 )
  {
    if ( sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8008608, 0, 300) )
      return 1;
    v1 = (unsigned __int8)(v1 + 1);
    sub_80232B4(100);
  }
  return 0;
}
// 8008608: using guessed type int dword_8008608;
// 2000119C: using guessed type unsigned __int8 byte_2000119C[1024];

//----- (0800860C) --------------------------------------------------------
int sub_800860C()
{
  int result; // r0
  bool v1; // zf
  bool v2; // zf
  unsigned int i; // r0
  unsigned __int8 v4; // r8
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // [sp+1Ch] [bp-44h]
  int v11; // [sp+20h] [bp-40h] BYREF
  int v12; // [sp+24h] [bp-3Ch]
  int v13; // [sp+28h] [bp-38h]
  int v14; // [sp+2Ch] [bp-34h]
  char *v15; // [sp+30h] [bp-30h]
  unsigned __int8 *v16; // [sp+34h] [bp-2Ch]
  unsigned __int8 *v17; // [sp+38h] [bp-28h]

  if ( byte_2000098D == 1 )
  {
    byte_2000098D = 0;
    byte_20000930 = 0;
  }
  sub_800FC70((int)&unk_2000095A);
  dword_20000998 = sub_800FDF8((int)&unk_2000095A);
  if ( dword_20000998 != dword_20000994 && sub_801AAF4(word_20000944, 0x14u) )
  {
    sub_800F228();
    ((void (__fastcall *)(_DWORD, void *, char *))loc_800847C)(
      (unsigned __int16)dword_20000998,
      &unk_2000095A,
      &byte_20003B11);
    sub_8004FE0((int)"", (unsigned __int16)word_2000098F, dword_20000994, dword_20000998);
    sub_8003202();
    byte_2000093F = 1;
    byte_2000093E = 3;
  }
  result = (unsigned __int8)byte_20000928;
  v1 = byte_20000928 == 0;
LABEL_7:
  if ( !v1 )
  {
    result = (unsigned __int8)byte_200015AC;
    v2 = byte_200015AC == 0;
    while ( v2 )
    {
      result = (unsigned __int8)byte_200036B4;
      v2 = byte_200036B4 == 7;
      if ( byte_200036B4 == 7 )
      {
        result = (unsigned __int8)byte_200015A7;
        v1 = byte_200015A7 == 1;
        if ( byte_200015A7 == 1 )
          goto LABEL_7;
        if ( !byte_2000093B && word_2000098F && sub_801AAF4(&word_20000944[1], 0x12Cu) )
        {
          byte_2000093B = 1;
          byte_2000093E = 3;
        }
        if ( !byte_2000093E )
        {
          byte_2000093B = 0;
          byte_2000093F = 0;
        }
        if ( byte_2000093D == 1 )
        {
          if ( sub_801AAF4(&word_20000944[2], 0x12Cu) )
            byte_2000093C = 1;
        }
        else if ( !byte_2000093C )
        {
          byte_2000093C = sub_801AAF4(&word_20000944[2], 0x708u) != 0;
        }
        if ( byte_20002E38 == 5
          && (dword_200015A0 < (unsigned int)dword_2000002C || sub_801AAF4(&algn_2000094C[2], 0xE10u)) )
        {
          byte_2000159E = 1;
        }
        if ( !byte_200015A4 && byte_20002EA9 == 2 )
        {
          if ( byte_20002E38 == 1 && sub_801AAF4(&word_20000954, 0x3Cu) )
          {
            byte_200015A4 = 1;
          }
          else if ( (!byte_20002E38 || byte_20002E38 == 5) && sub_801AAF4(&word_20000954, 0xAu) )
          {
            byte_200015A4 = 1;
          }
        }
        if ( byte_20002EA9 == 2 && byte_200015DE && (unsigned __int8)byte_20000941 > 3u )
        {
          byte_200015DE = 0;
          byte_20000941 = 0;
          dword_200050F0 = 0;
          dword_200050F4 = 0;
          dword_200050F8 = 0;
          dword_200050FC = 0;
          sub_8004FE0((int)"!!! [HTTP] Warning : P1 METER DISCONNECT!!!\r\n");
        }
        if ( !byte_200015A5 && byte_20002EA9 == 7 )
        {
          if ( byte_20002E38 == 1 && sub_801AAF4(&word_20000954, 0x3Cu) )
          {
            byte_200015A5 = 1;
          }
          else if ( (!byte_20002E38 || byte_20002E38 == 5) && sub_801AAF4(&word_20000954, 0xAu) )
          {
            byte_200015A5 = 1;
          }
        }
        if ( byte_20002EA9 == 7 && byte_200015DE && (unsigned __int8)byte_20000941 > 3u )
        {
          byte_200015DE = 0;
          byte_20000941 = 0;
          dword_200050F0 = 0;
          dword_200050F4 = 0;
          dword_200050F8 = 0;
          dword_200050FC = 0;
          sub_8004FE0((int)"!!! [HTTP] Warning : ECO-TRACKER DISCONNECT!!!\r\n");
        }
        if ( (unsigned __int8)byte_20000931 > 6u || (unsigned __int8)byte_20000932 > 0xAu )
        {
          sub_8004FE0((int)"\r");
          byte_2000093F = 0;
          byte_20000931 = 0;
          byte_20000932 = 0;
          byte_20000933 = 0;
          byte_20000934 = 0;
          byte_20000935 = 0;
          byte_200036AE = 0;
          byte_20000930 = 1;
          sub_8018928(4, 407);
          if ( byte_200015DE != 1 || byte_20004237 == 2 || byte_200036B0 )
          {
            if ( byte_20004237 != 2 && !byte_200036B0 )
              sub_8007CF8(0);
          }
          else
          {
            sub_8007CF8(1);
          }
        }
        if ( (unsigned __int8)byte_20000933 <= 2u )
        {
          if ( (unsigned __int8)byte_20000934 <= 2u )
          {
            if ( (unsigned __int8)byte_20000935 <= 2u )
            {
              if ( (unsigned __int8)byte_20000936 <= 2u )
              {
                if ( (unsigned __int8)byte_20000940 > 2u )
                {
                  sub_8004FE0(
                    (int)"&war1=%llx&wifi_s=%d&inc_a=%d&pri_c=%d&pri_d=%d&set_v=%d&mxc_p=%d&mxd_p=%d&soc=%d&rec_i=%d&red_i=%d&cell_v=%d&cell_i=%d&bat_p=%d&dsoc=%d&pha=%d&ble=%d&mqqt=%d&ct_t=%d&ct_w=%d&ct_p=%s&ct_m=%s",
                    (unsigned __int8)byte_20000941);
                  byte_20000940 = 0;
                  byte_200036AE = 0;
                  byte_20000930 = 1;
                  byte_200015A4 = 0;
                  byte_200015A5 = 0;
                }
              }
              else
              {
                sub_8004FE0((int)"!!! [HTTP] Warning : GET ACTIVE ERR!!!\r\n");
                byte_20000936 = 0;
                byte_200036AE = 0;
                byte_20000930 = 18;
                byte_2000159F = 0;
              }
            }
            else
            {
              sub_8004FE0((int)"!!! [HTTP] Warning : GET PRICE ERR!!!\r\n");
              byte_20000935 = 0;
              byte_200036AE = 0;
              byte_20000930 = 14;
              byte_2000159E = 0;
              dword_200015A0 = dword_2000002C + 120;
            }
          }
          else
          {
            sub_8004FE0((int)"!!! [HTTP] Warning : GET DATA ERR!!!\r\n");
            byte_20000934 = 0;
            byte_200036AE = 0;
            byte_20000930 = 10;
            byte_2000093B = 0;
            byte_2000093F = 0;
          }
        }
        else
        {
          sub_8004FE0((int)"!!! [HTTP] Warning : GET TIME ERR!!!\r\n");
          byte_20000933 = 0;
          byte_200036AE = 0;
          byte_20000930 = 5;
          byte_2000093C = 0;
        }
        v17 = (unsigned __int8 *)&dword_200037D5;
        result = (int)byte_200038EB;
        v15 = byte_200038EB;
        v16 = byte_2000099C;
        switch ( byte_20000930 )
        {
          case 0:
            result = sub_80085AC(3);
            if ( result )
            {
              byte_20000931 = 0;
              byte_20000930 = 1;
            }
            else
            {
              result = (unsigned __int8)byte_20000931++ + 1;
            }
            break;
          case 1:
            result = (unsigned __int8)byte_2000093C;
            if ( byte_2000093C == 1 )
            {
              if ( sub_8009B44(2) )
              {
                byte_20000931 = 0;
                result = 2;
                byte_20000930 = 2;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)byte_20000933++ + 1;
                byte_20000930 = 5;
              }
            }
            else
            {
              byte_20000930 = 5;
            }
            break;
          case 2:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              if ( word_20000950 == 60 && strstr(v17, "2025") )
                word_20000950 = 30;
              if ( sub_80083A4((unsigned __int8)word_20000950) )
              {
                result = 3;
                byte_20000930 = 3;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                ++byte_20000932;
                result = 3;
                byte_20000930 = 3;
              }
              word_2000094A = 0;
            }
            break;
          case 3:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000933 = 0;
              byte_20000930 = 4;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              result = (unsigned __int8)byte_20000933++ + 1;
              byte_20000930 = 5;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, (unsigned __int16)(word_20000950 + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000933 = 0;
                  byte_20000930 = 4;
                }
                else
                {
                  ++byte_20000931;
                  result = (unsigned __int8)byte_20000933++ + 1;
                  byte_20000930 = 5;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 4:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_20000937 = 0;
                result = sub_8009708();
                if ( result )
                {
                  byte_2000093D = 0;
                  byte_2000093C = 0;
                }
                byte_20000930 = 5;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)++byte_20000937;
                byte_20000930 = 5;
                if ( (unsigned __int8)byte_20000937 > 3u )
                {
                  byte_20000937 = 0;
                  byte_2000093C = 0;
                }
              }
              word_2000094A = 0;
            }
            break;
          case 5:
            result = (unsigned __int8)byte_2000093B | (unsigned __int8)byte_2000093F | (unsigned __int8)byte_2000093E;
            if ( result )
            {
              result = (unsigned __int16)word_2000098F;
              if ( word_2000098F )
              {
                if ( (unsigned __int16)word_2000098F <= 3u || (result = sub_801AAF4(algn_2000094C, 0x3Cu)) != 0 )
                {
                  sub_8004FE0(
                    (int)"l",
                    (unsigned __int16)word_2000098F,
                    (unsigned __int8)byte_2000093E,
                    (unsigned __int8)byte_2000093F,
                    (unsigned __int8)byte_2000093B);
                  if ( sub_8009828(
                         dword_20005100[170 * (unsigned __int16)word_2000098F - 170],
                         (unsigned __int16)(word_2000098F - 1)) )
                  {
                    word_2000159C = word_2000098F - 1;
                    byte_2000093B = 0;
                    byte_20000931 = 0;
                    byte_20000930 = 6;
                    byte_2000093F = 0;
                    result = (unsigned __int8)byte_2000093E;
                    if ( byte_2000093E )
                      result = (unsigned __int8)byte_2000093E-- - 1;
                  }
                  else
                  {
                    ++byte_20000931;
                    result = (unsigned __int8)byte_20000934++ + 1;
                    byte_20000930 = 10;
                  }
                }
                else
                {
                  byte_20000930 = 10;
                }
              }
              else
              {
                byte_2000093B = 0;
                byte_2000093F = 0;
                byte_2000093E = 0;
                byte_20000930 = 10;
              }
            }
            else
            {
              byte_20000930 = 10;
            }
            break;
          case 6:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              if ( word_20000952 == 60 && strstr(v17, "2025") )
                word_20000952 = 30;
              result = sub_80083A4((unsigned __int8)word_20000952);
              if ( result )
              {
                byte_20000930 = 7;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                result = (unsigned __int8)byte_20000932++ + 1;
                byte_20000930 = 7;
              }
              word_2000094A = 0;
            }
            break;
          case 7:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000934 = 0;
              byte_20000930 = 8;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              result = (unsigned __int8)byte_20000934++ + 1;
              byte_20000930 = 10;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, (unsigned __int16)(word_20000952 + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000934 = 0;
                  byte_20000930 = 8;
                }
                else
                {
                  ++byte_20000931;
                  result = (unsigned __int8)byte_20000934++ + 1;
                  byte_20000930 = 10;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 8:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_20000938 = 0;
                result = sub_8008554();
                if ( result )
                {
                  result = 9;
                  byte_20000930 = 9;
                }
                else
                {
                  byte_20000930 = 10;
                }
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)++byte_20000938;
                byte_20000930 = 10;
                if ( (unsigned __int8)byte_20000938 > 3u )
                {
                  byte_20000938 = 0;
                  byte_2000093E = 0;
                }
              }
              word_2000094A = 0;
            }
            break;
          case 9:
            if ( (unsigned __int16)word_2000098F - (unsigned __int16)word_2000159C <= 1 )
            {
              qmemcpy(
                (unsigned int)&dword_20005100[170 * (unsigned __int16)word_2000098F - 170],
                (unsigned int)&dword_20005100[170 * (unsigned __int16)word_2000098F],
                0x154u);
              result = (unsigned __int16)word_2000098F-- - 1;
            }
            else
            {
              sub_8004FE0(
                (int)"[HTTP] Delete data, upload_cnt = %d, delate_flag = %d.\r\n",
                (unsigned __int16)word_2000098F,
                (unsigned __int16)word_2000159C);
              for ( i = (unsigned __int8)word_2000159C; (unsigned __int16)word_2000098F > i; i = v4 )
              {
                v4 = i + 1;
                qmemcpy((unsigned int)&dword_20005100[170 * i], (unsigned int)&dword_20005100[170 * i + 170], 0x154u);
              }
              result = (unsigned __int16)word_2000098F-- - 1;
            }
            byte_20000931 = 0;
            byte_20000930 = 10;
            break;
          case 10:
            if ( byte_2000159E == 1 )
            {
              if ( byte_20002E38 != 5 )
                byte_20000930 = 14;
              if ( sub_8009B44(4) )
              {
                byte_20000931 = 0;
                result = 11;
                byte_20000930 = 11;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)byte_20000935++ + 1;
              }
            }
            else
            {
              result = 14;
              byte_20000930 = 14;
            }
            break;
          case 11:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              result = sub_80083A4(60);
              if ( result )
              {
                byte_20000930 = 12;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                result = (unsigned __int8)byte_20000932++ + 1;
                byte_20000930 = 12;
              }
              word_2000094A = 0;
            }
            break;
          case 12:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000935 = 0;
              byte_20000930 = 13;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              result = (unsigned __int8)byte_20000935++ + 1;
              byte_20000930 = 10;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, 0x46u);
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000935 = 0;
                  byte_20000930 = 13;
                }
                else
                {
                  ++byte_20000931;
                  result = (unsigned __int8)byte_20000935++ + 1;
                  byte_20000930 = 10;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 13:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_20000939 = 0;
                if ( sub_80080E8() )
                  byte_2000159E = 0;
                result = 14;
                byte_20000930 = 14;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)++byte_20000939;
                if ( (unsigned __int8)byte_20000939 > 3u )
                {
                  byte_20000939 = 0;
                  byte_20000930 = 14;
                  byte_2000159E = 0;
                  result = dword_2000002C + 120;
                  dword_200015A0 = dword_2000002C + 120;
                }
              }
              word_2000094A = 0;
            }
            break;
          case 14:
            if ( byte_2000159F == 1 )
            {
              if ( sub_8009B44(5) )
              {
                byte_20000931 = 0;
                result = 15;
                byte_20000930 = 15;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)byte_20000936++ + 1;
              }
            }
            else
            {
              result = 18;
              byte_20000930 = 18;
            }
            break;
          case 15:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              result = sub_80083A4(60);
              if ( result )
              {
                byte_20000930 = 16;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                result = (unsigned __int8)byte_20000932++ + 1;
                byte_20000930 = 16;
              }
              word_2000094A = 0;
            }
            break;
          case 16:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000936 = 0;
              byte_20000930 = 17;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              ++byte_20000936;
              result = 14;
              byte_20000930 = 14;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, 0x46u);
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000936 = 0;
                  byte_20000930 = 17;
                }
                else
                {
                  ++byte_20000931;
                  ++byte_20000936;
                  result = 14;
                  byte_20000930 = 14;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 17:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_2000093A = 0;
                if ( sub_8007EA0() )
                  byte_2000159F = 0;
                result = 18;
                byte_20000930 = 18;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)++byte_2000093A;
                if ( (unsigned __int8)byte_2000093A > 3u )
                {
                  byte_2000093A = 0;
                  result = 18;
                  byte_20000930 = 18;
                  byte_2000159F = 0;
                }
              }
              word_2000094A = 0;
            }
            break;
          case 18:
            if ( byte_200015A4 == 1 )
            {
              if ( !sub_80023E2((unsigned __int8 *)v15) )
              {
                sub_8005498(0x3500u, (int)v15, 16);
                sub_8004FE0((int)"[HTTP] Read P1 meter ip: %s.\r\n", v15);
              }
              if ( sub_8009B44(6) )
              {
                byte_20000931 = 0;
                result = 19;
                byte_20000930 = 19;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)byte_20000940++ + 1;
              }
            }
            else
            {
              result = 23;
              byte_20000930 = 23;
            }
            break;
          case 19:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              if ( strstr(v17, "2025") )
                word_20000956 = 30;
              result = sub_80083A4((unsigned __int8)word_20000956);
              if ( result )
              {
                byte_20000930 = 20;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                result = (unsigned __int8)byte_20000932++ + 1;
                byte_20000930 = 20;
              }
              word_2000094A = 0;
            }
            break;
          case 20:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000940 = 0;
              byte_20000941 = 0;
              byte_20000930 = 21;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              ++byte_20000940;
              result = 18;
              byte_20000930 = 18;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, (unsigned __int16)(word_20000956 + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000940 = 0;
                  byte_20000941 = 0;
                  byte_20000930 = 21;
                }
                else
                {
                  ++byte_20000931;
                  ++byte_20000940;
                  if ( !byte_20000932 )
                    ++byte_20000941;
                  if ( (unsigned __int8)byte_20000941 > 6u )
                    byte_20000941 = 6;
                  result = 18;
                  byte_20000930 = 18;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 21:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                v11 = 0;
                v12 = 0;
                v13 = 0;
                v14 = 0;
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_20000940 = 0;
                byte_20000930 = 22;
                v10 = sub_800FAC4(v16, "wifi_strength");
                v5 = sub_800FAC4(v16, "active_power_w");
                dword_200050F0 = v5;
                if ( v5 == 0xFFFF )
                {
                  ++byte_20000942;
                  v11 = 0;
                  if ( (unsigned __int8)byte_20000942 > 4u )
                  {
                    byte_20000942 = 0;
                    byte_200015A6 = 1;
                    if ( byte_20002EA9 == 2 )
                    {
                      if ( byte_200015DE )
                        byte_200015DE = 0;
                    }
                  }
                }
                else
                {
                  byte_20000942 = 0;
                  v11 = v5;
                  byte_200015A6 = 0;
                  byte_20000941 = 0;
                  byte_200015DC = 5;
                  if ( byte_20002EA9 == 2 )
                    byte_200015DE = 1;
                }
                v6 = sub_800FAC4(v16, "active_power_l1_w");
                dword_200050F4 = v6;
                if ( v6 == 0xFFFF )
                  v12 = 0;
                else
                  v12 = v6;
                v7 = sub_800FAC4(v16, "active_power_l2_w");
                dword_200050F8 = v7;
                if ( v7 == 0xFFFF )
                  v13 = 0;
                else
                  v13 = v7;
                v8 = sub_800FAC4(v16, "active_power_l3_w");
                dword_200050FC = v8;
                if ( v8 == 0xFFFF )
                  v14 = 0;
                else
                  v14 = v8;
                sub_8004FE0(
                  (int)dword_8028914,
                  dword_200050F0,
                  dword_200050F4,
                  dword_200050F8,
                  v8,
                  v11,
                  v12,
                  v13,
                  v14,
                  v10,
                  (unsigned __int8)byte_20000929);
                result = sub_8024A40(dword_20000434, (unsigned int)&v11, 0, 2);
                byte_200015A4 = 0;
              }
              else
              {
                ++byte_20000931;
                ++byte_20000940;
                if ( (unsigned __int8)++byte_20000942 > 4u )
                {
                  byte_20000942 = 0;
                  byte_200015A6 = 2;
                }
                result = 23;
                byte_20000930 = 23;
              }
              word_2000094A = 0;
            }
            break;
          case 22:
            byte_20000931 = 0;
            byte_20000940 = 0;
            result = 23;
            byte_20000930 = 23;
            break;
          case 23:
            if ( byte_200015A5 == 1 )
            {
              if ( !sub_80023E2((unsigned __int8 *)v15) )
              {
                sub_8005498(0x3500u, (int)v15, 16);
                sub_8004FE0((int)"[HTTP] Read Eco-Tracker ip: %s.\r\n", v15);
              }
              if ( sub_8009B44(7) )
              {
                byte_20000931 = 0;
                result = 24;
                byte_20000930 = 24;
              }
              else
              {
                ++byte_20000931;
                result = (unsigned __int8)byte_20000940++ + 1;
              }
            }
            else
            {
              result = 27;
              byte_20000930 = 27;
            }
            break;
          case 24:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              byte_2000098E = 0;
              if ( strstr(v17, "2025") )
                word_20000958 = 30;
              result = sub_80083A4((unsigned __int8)word_20000958);
              if ( result )
              {
                byte_20000930 = 25;
                byte_200036AE = 1;
                byte_20000932 = 0;
              }
              else
              {
                result = (unsigned __int8)byte_20000932++ + 1;
                byte_20000930 = 25;
              }
              word_2000094A = 0;
            }
            break;
          case 25:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
            {
              byte_2000098E = 0;
              byte_20000931 = 0;
              byte_20000940 = 0;
              byte_20000941 = 0;
              byte_20000930 = 26;
              byte_200036AE = 0;
            }
            else if ( byte_2000098E == 4 && byte_20000932 )
            {
              byte_2000098E = 0;
              ++byte_20000931;
              ++byte_20000940;
              result = 23;
              byte_20000930 = 23;
              byte_200036AE = 0;
            }
            else
            {
              result = sub_801AAF4(&word_2000094A, (unsigned __int16)(word_20000958 + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_2000098E, byte_2000098E == 1) )
                {
                  byte_2000098E = 0;
                  byte_20000931 = 0;
                  byte_20000940 = 0;
                  byte_20000941 = 0;
                  byte_20000930 = 26;
                }
                else
                {
                  ++byte_20000931;
                  ++byte_20000940;
                  if ( !byte_20000932 )
                    ++byte_20000941;
                  if ( (unsigned __int8)byte_20000941 > 6u )
                    byte_20000941 = 6;
                  result = 23;
                  byte_20000930 = 23;
                }
                byte_200036AE = 0;
                word_2000094A = 0;
              }
            }
            break;
          case 26:
            result = sub_801AACC(&word_2000094A, 0x12Cu);
            if ( result )
            {
              if ( sub_800842C() )
              {
                v11 = 0;
                v12 = 0;
                v13 = 0;
                v14 = 0;
                byte_2000098E = 0;
                byte_20000931 = 0;
                byte_20000940 = 0;
                byte_20000930 = 27;
                v9 = sub_800FAC4(v16, "power");
                dword_200050F0 = v9;
                if ( v9 == 0xFFFF )
                {
                  ++byte_20000942;
                  v11 = 0;
                  if ( (unsigned __int8)byte_20000942 > 4u )
                  {
                    byte_20000942 = 0;
                    byte_200015A6 = 1;
                    if ( byte_20002EA9 == 7 )
                    {
                      if ( byte_200015DE )
                        byte_200015DE = 0;
                    }
                  }
                }
                else
                {
                  byte_20000942 = 0;
                  v11 = v9;
                  byte_200015A6 = 0;
                  byte_20000941 = 0;
                  byte_200015DC = 9;
                  if ( byte_20002EA9 == 7 )
                    byte_200015DE = 1;
                }
                v12 = 0;
                v13 = 0;
                v14 = 0;
                sub_8004FE0((int)" = %d, bin_crc = %d.\r\n", v9, v11);
                result = sub_8024A40(dword_20000434, (unsigned int)&v11, 0, 2);
                byte_200015A5 = 0;
              }
              else
              {
                ++byte_20000931;
                ++byte_20000940;
                if ( (unsigned __int8)++byte_20000942 > 4u )
                {
                  byte_20000942 = 0;
                  byte_200015A6 = 2;
                }
                result = 27;
                byte_20000930 = 27;
              }
              word_2000094A = 0;
            }
            break;
          case 27:
            byte_20000931 = 0;
            byte_20000940 = 0;
            byte_20000930 = 1;
            break;
          default:
            return result;
        }
        return result;
      }
    }
  }
  return result;
}
// 8007EA0: using guessed type int sub_8007EA0(void);
// 8028914: using guessed type int dword_8028914[20];
// 2000002C: using guessed type int dword_2000002C;
// 20000434: using guessed type int dword_20000434;
// 20000928: using guessed type char byte_20000928;
// 20000929: using guessed type char byte_20000929;
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 20000932: using guessed type char byte_20000932;
// 20000933: using guessed type char byte_20000933;
// 20000934: using guessed type char byte_20000934;
// 20000935: using guessed type char byte_20000935;
// 20000936: using guessed type char byte_20000936;
// 20000937: using guessed type char byte_20000937;
// 20000938: using guessed type char byte_20000938;
// 20000939: using guessed type char byte_20000939;
// 2000093A: using guessed type char byte_2000093A;
// 2000093B: using guessed type char byte_2000093B;
// 2000093C: using guessed type char byte_2000093C;
// 2000093D: using guessed type char byte_2000093D;
// 2000093E: using guessed type char byte_2000093E;
// 2000093F: using guessed type char byte_2000093F;
// 20000940: using guessed type char byte_20000940;
// 20000941: using guessed type char byte_20000941;
// 20000942: using guessed type char byte_20000942;
// 20000944: using guessed type _WORD[3];
// 2000094A: using guessed type __int16 word_2000094A;
// 2000094C: using guessed type _BYTE[4];
// 20000950: using guessed type __int16 word_20000950;
// 20000952: using guessed type __int16 word_20000952;
// 20000954: using guessed type _WORD;
// 20000956: using guessed type __int16 word_20000956;
// 20000958: using guessed type __int16 word_20000958;
// 2000098D: using guessed type char byte_2000098D;
// 2000098E: using guessed type char byte_2000098E;
// 2000098F: using guessed type __int16 word_2000098F;
// 20000994: using guessed type int dword_20000994;
// 20000998: using guessed type int dword_20000998;
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];
// 2000159C: using guessed type __int16 word_2000159C;
// 2000159E: using guessed type char byte_2000159E;
// 2000159F: using guessed type char byte_2000159F;
// 200015A0: using guessed type int dword_200015A0;
// 200015A4: using guessed type char byte_200015A4;
// 200015A5: using guessed type char byte_200015A5;
// 200015A6: using guessed type char byte_200015A6;
// 200015A7: using guessed type char byte_200015A7;
// 200015AC: using guessed type char byte_200015AC;
// 200015DC: using guessed type char byte_200015DC;
// 200015DE: using guessed type char byte_200015DE;
// 20002E38: using guessed type char byte_20002E38;
// 20002EA9: using guessed type char byte_20002EA9;
// 200036AE: using guessed type char byte_200036AE;
// 200036B0: using guessed type char byte_200036B0;
// 200036B4: using guessed type char byte_200036B4;
// 200037D5: using guessed type int dword_200037D5;
// 20003B11: using guessed type char byte_20003B11;
// 20004237: using guessed type char byte_20004237;
// 200050F0: using guessed type int dword_200050F0;
// 200050F4: using guessed type int dword_200050F4;
// 200050F8: using guessed type int dword_200050F8;
// 200050FC: using guessed type int dword_200050FC;
// 20005100: using guessed type unsigned __int16 dword_20005100[13909];

//----- (08009708) --------------------------------------------------------
int sub_8009708()
{
  unsigned __int8 *v0; // r0
  const char *v1; // r0
  const char *v3; // [sp+Ch] [bp-1Ch] BYREF
  unsigned __int8 v4; // [sp+11h] [bp-17h]
  unsigned __int8 v5; // [sp+12h] [bp-16h]
  unsigned __int8 v6; // [sp+13h] [bp-15h]

  v0 = strstr(byte_2000099C, (unsigned __int8 *)&dword_8009818);
  if ( !v0 )
    return 0;
  LOWORD(v3) = 100 * (v0[2] - 48) + 10 * (v0[3] - 48) + v0[4] + 1000 * (v0[1] - 48) - 2048;
  BYTE2(v3) = 10 * (v0[6] - 48) - 48 + v0[7];
  HIBYTE(v3) = 10 * (v0[9] - 48) - 48 + v0[10];
  v4 = 10 * (v0[12] - 48) - 48 + v0[13];
  v5 = 10 * (v0[15] - 48) - 48 + v0[16];
  v1 = (const char *)(unsigned __int8)(10 * (v0[18] - 48) - 48 + v0[19]);
  v6 = (unsigned __int8)v1;
  sub_8004FE0(
    (int)"=%d&ble=%d&mqqt=%d&ct_t=%d&ct_w=%d&ct_p=%s&ct_m=%s",
    (unsigned __int16)v3,
    BYTE2(v3),
    HIBYTE(v3),
    v4,
    v5,
    v1,
    v3);
  if ( !sub_8004B04((unsigned __int8 *)&v3) )
    return 0;
  sub_80200DC((unsigned __int8)v3, BYTE2(v3), HIBYTE(v3));
  sub_8020108(v4, v5, v6);
  if ( !byte_200038E2 )
  {
    byte_200038E2 = 1;
    sub_8018928(2, 203);
  }
  return 1;
}
// 8009818: using guessed type int dword_8009818;
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];
// 200038E2: using guessed type char byte_200038E2;

//----- (08009828) --------------------------------------------------------
BOOL __fastcall sub_8009828(int a1, int a2)
{
  int v4; // r6
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r1
  int v7; // r0
  char *v8; // r5
  int i; // r4
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // [sp+78h] [bp-A0h]
  int v13; // [sp+A4h] [bp-74h]
  int v14; // [sp+BCh] [bp-5Ch]
  int v15; // [sp+C0h] [bp-58h]
  int v16; // [sp+C4h] [bp-54h]
  int v17; // [sp+C8h] [bp-50h]
  int v18; // [sp+CCh] [bp-4Ch]
  int v19; // [sp+D0h] [bp-48h]
  int v20; // [sp+D4h] [bp-44h]
  int v21; // [sp+D8h] [bp-40h]
  int v22; // [sp+DCh] [bp-3Ch]
  int v23; // [sp+E0h] [bp-38h]
  int v24; // [sp+E4h] [bp-34h]
  int v25; // [sp+E8h] [bp-30h]
  int v26; // [sp+100h] [bp-18h] BYREF

  sub_8005498(0x441u, (int)&byte_20002F11, 1);
  if ( byte_20002F11 && byte_20002F11 != 1 && byte_20002F11 != 2 )
    byte_20002F11 = 0;
  if ( byte_20002F11 == 1 )
    v4 = 2;
  else
    v4 = (unsigned __int8)byte_20002F11;
  sub_8004FE0((int)"http://www.hamedata.com/app/download/neng/HM_HIE_FC41D_remote_ota.rbl", v4);
  v22 = HIBYTE(dword_20005100[85 * a2 + 70]);
  v23 = LOBYTE(dword_20005100[85 * a2 + 71]);
  v24 = BYTE1(dword_20005100[85 * a2 + 71]);
  v25 = BYTE2(dword_20005100[85 * a2 + 71]);
  v18 = *(unsigned __int16 *)((char *)&dword_20005100[85 * a2 + 68] + 1);
  v19 = *(unsigned __int16 *)((char *)&dword_20005100[85 * a2 + 68] + 3);
  v20 = *(__int16 *)((char *)&dword_20005100[85 * a2 + 69] + 1);
  v21 = *(__int16 *)((char *)&dword_20005100[85 * a2 + 70] + 1);
  v14 = *(unsigned __int16 *)((char *)&dword_20005100[85 * a2 + 66] + 3);
  v15 = *(unsigned __int16 *)((char *)&dword_20005100[85 * a2 + 67] + 1);
  v16 = HIBYTE(dword_20005100[85 * a2 + 3]);
  v17 = *(unsigned __int16 *)((char *)&dword_20005100[85 * a2 + 67] + 3);
  v13 = *(_DWORD *)((char *)&dword_20005100[85 * a2 + 63] + 3);
  v5 = (unsigned __int8 *)&dword_20005100[85 * a2];
  v12 = v5 + 230;
  v6 = v5 + 102;
  v5 += 14;
  sprintf(
    (int)byte_2000119C,
    (const char *)&loc_8028EE4,
    &unk_200037BB,
    &unk_20004029,
    *((_DWORD *)v5 + 17),
    *((_DWORD *)v5 + 18),
    *((_DWORD *)v5 + 10),
    *((_DWORD *)v5 + 11),
    *((_DWORD *)v5 + 12),
    *((_DWORD *)v5 + 13),
    *((_DWORD *)v5 + 14),
    *((_DWORD *)v5 + 15),
    v5[2],
    v5[4],
    *((unsigned __int16 *)v5 + 5),
    *((__int16 *)v5 + 6),
    *(v5 - 2),
    *((unsigned __int16 *)v5 + 8),
    *((unsigned __int16 *)v5 + 9),
    *(v5 - 1),
    *v5,
    *((unsigned __int16 *)v5 + 7),
    *((unsigned __int16 *)v5 + 15),
    *((unsigned __int16 *)v5 + 16),
    *((unsigned __int16 *)v5 + 17),
    *((unsigned __int16 *)v5 + 18),
    1488,
    *((unsigned __int16 *)v5 + 19),
    *((__int16 *)v5 + 10),
    *((__int16 *)v5 + 11),
    *((__int16 *)v5 + 12),
    *((__int16 *)v5 + 13),
    *((__int16 *)v5 + 14),
    v6,
    v12,
    LOWORD(dword_20005100[85 * a2 + 1]),
    BYTE2(dword_20005100[85 * a2 + 1]),
    HIBYTE(dword_20005100[85 * a2 + 1]),
    (unsigned __int8)byte_2000095F,
    (unsigned __int8)byte_20000960,
    (unsigned __int8)byte_20000961,
    a1,
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 60] + 3),
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 61] + 3),
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 62] + 3),
    v13,
    HIBYTE(dword_20005100[85 * a2 + 4]),
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 19] + 2),
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 64] + 3),
    *(_DWORD *)((char *)&dword_20005100[85 * a2 + 65] + 3),
    BYTE1(dword_20005100[85 * a2 + 5]),
    v14,
    v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25);
  v26 = (unsigned __int16)sub_80023E2(byte_2000119C);
  sub_8004FE0((int)"[HTTP] Upload data_len : %d, data: %s.\r\n\r\n", v26, (const char *)byte_2000119C);
  v7 = sub_8003AE8(0, (int)byte_2000119C, &v26, (int)&dword_20000964[6], 16);
  v8 = (char *)v7;
  if ( !v7 )
    return 0;
  if ( byte_200036AD == 1 )
  {
    sub_8004FE0((int)"\r\n<<< Output info: \r\n    [Encrypted data (%d byte)]: ", (unsigned __int16)v26);
    for ( i = 0; i < (unsigned __int16)v26; ++i )
      sub_8004FE0((int)"%02x ", (unsigned __int8)v8[i]);
    sub_8004FE0((int)"\r\n");
  }
  sub_80040A0(v8, (unsigned __int16)v26, (int)byte_20004C4C, 0x400u);
  v11 = sub_80023E2((unsigned __int8 *)byte_20004C4C);
  sub_8004FE0((int)"\r\n    [URL Base64 data (%d byte)]: %s.\r\n\r\n", v11, byte_20004C4C);
  sub_8002364(byte_2000119C, 1024);
  sprintf((int)byte_2000119C, (const char *)&loc_8028E94, dword_20000964[v4], byte_20004C4C);
  return sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009B40, 0, 300) != 0;
}
// 80099C0: too many varargs, some ignored
// 8009B40: using guessed type int dword_8009B40;
// 2000095F: using guessed type char byte_2000095F;
// 20000960: using guessed type char byte_20000960;
// 20000961: using guessed type char byte_20000961;
// 20000964: using guessed type _DWORD dword_20000964[10];
// 2000098F: using guessed type __int16 word_2000098F;
// 2000119C: using guessed type unsigned __int8 byte_2000119C[1024];
// 20002F11: using guessed type char byte_20002F11;
// 200036AD: using guessed type char byte_200036AD;
// 20005100: using guessed type _DWORD dword_20005100[6954];

//----- (08009B44) --------------------------------------------------------
int __fastcall sub_8009B44(int a1)
{
  int result; // r0

  sub_8005498(0x441u, (int)&byte_20002F11, 1);
  if ( byte_20002F11 && byte_20002F11 != 1 && byte_20002F11 != 2 )
    byte_20002F11 = 0;
  sub_8004FE0((int)"[HTTP] URL server type: %d\r\n", (unsigned __int8)byte_20002F11);
  switch ( a1 )
  {
    case 1:
      sprintf((int)byte_2000119C, (const char *)&loc_8028D98, dword_20000964[(unsigned __int8)byte_20002F11]);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 2:
      sub_800F8D8();
      sprintf(
        (int)byte_2000119C,
        (const char *)&off_8028CC0,
        dword_20000964[(unsigned __int8)byte_20002F11],
        dword_20000964[(unsigned __int8)byte_20002F11 + 3],
        &unk_200037BB,
        &dword_200037D5,
        &dword_200038E3,
        1488,
        (unsigned __int8)byte_20002D58);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 3:
      if ( !word_20002E9D || (unsigned __int16)word_20002E9D == 0xFFFF )
        word_20002E9D = 1;
      sprintf((int)byte_2000119C, (const char *)&off_8028D30, (unsigned __int16)word_20002E9D);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 4:
      sprintf(
        (int)byte_2000119C,
        (const char *)&loc_8028DE0,
        dword_20000964[(unsigned __int8)byte_20002F11],
        &unk_200037BB);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 5:
      sprintf(
        (int)byte_2000119C,
        (const char *)&loc_8028E44,
        dword_20000964[(unsigned __int8)byte_20002F11],
        &unk_200037BB);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 6:
      sprintf((int)byte_2000119C, "AT+QHTTPCFG=\"url\",\"http://%s/api/v1/data\"", byte_200038EB);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 7:
      sprintf((int)byte_2000119C, "AT+QHTTPCFG=\"url\",\"http://%s/v1/json\"", byte_200038EB);
      if ( !sub_8007F88(byte_2000119C, (unsigned __int8 *)&dword_8009CF8, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    default:
LABEL_24:
      result = 0;
      break;
  }
  return result;
}
// 8009CF8: using guessed type int dword_8009CF8;
// 8028CC0: using guessed type _UNKNOWN *off_8028CC0;
// 8028D30: using guessed type _UNKNOWN *off_8028D30;
// 20000964: using guessed type _DWORD dword_20000964[10];
// 2000119C: using guessed type unsigned __int8 byte_2000119C[1024];
// 20002D58: using guessed type char byte_20002D58;
// 20002E9D: using guessed type __int16 word_20002E9D;
// 20002F11: using guessed type char byte_20002F11;
// 200037D5: using guessed type int dword_200037D5;
// 200038E3: using guessed type int dword_200038E3;

//----- (08009D6C) --------------------------------------------------------
int __fastcall sub_8009D6C(__int64 a1)
{
  sub_800F808(a1);
  sub_8018928(2, 200);
  sub_800E1D4();
  sub_8007B4C();
  sub_800E4F8(1);
  sub_8007C6C();
  sub_800F728();
  sub_800E36C();
  word_200036B5 = 15;
  return sub_800F8D8();
}
// 200036B5: using guessed type __int16 word_200036B5;

//----- (08009DA8) --------------------------------------------------------
int sub_8009DA8()
{
  switch ( byte_200036AC )
  {
    case 0:
      if ( sub_8006C90() )
        byte_200036AC = 1;
      break;
    case 1:
      if ( sub_800DDF0() )
        byte_200036AC = 4;
      break;
    case 2:
      if ( sub_800ED0C() )
        byte_200036AC = 4;
      break;
    case 3:
      if ( sub_800A08C() )
        byte_200036AC = 4;
      break;
    case 4:
      if ( byte_20000928 )
      {
        if ( byte_20004237 )
        {
          if ( !byte_20004245 )
            byte_200036AC = 3;
        }
        else
        {
          byte_200036AC = 0;
        }
      }
      else
      {
        byte_200036AC = 2;
      }
      break;
    default:
      byte_200036AC = 4;
      break;
  }
  sub_8007498();
  sub_800F1C4();
  sub_800C61C();
  return sub_80058C0();
}
// 20000928: using guessed type char byte_20000928;
// 200036AC: using guessed type char byte_200036AC;
// 20004237: using guessed type char byte_20004237;
// 20004245: using guessed type char byte_20004245;

//----- (08009E38) --------------------------------------------------------
int sub_8009E38()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_80076F8();
  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sprintf(
      (int)byte_2000484A,
      ".\r\n",
      (unsigned __int16)word_20003E25,
      (unsigned __int16)dword_20003E27,
      HIWORD(dword_20003E27),
      (unsigned __int16)word_20003E2B,
      (unsigned __int16)dword_20003E2D,
      HIWORD(dword_20003E2D),
      (unsigned __int16)word_20003E31,
      (unsigned __int16)dword_20003E33,
      SHIWORD(dword_20003E33),
      word_20003E37,
      (unsigned __int8)byte_20003E39,
      (unsigned __int8)byte_20003E3A,
      (unsigned __int16)word_20003E3B,
      dword_20003E3D,
      dword_20003E41,
      dword_20003E45,
      word_20003E49,
      word_20003E4B,
      (__int16)dword_20003E4D,
      SHIWORD(dword_20003E4D),
      (__int16)dword_20003E51,
      SHIWORD(dword_20003E51),
      (unsigned __int16)word_20003E55,
      (unsigned __int16)word_20003E57,
      (unsigned __int16)word_20003E59,
      (unsigned __int16)word_20003E5B,
      (unsigned __int16)word_20003E5D,
      (unsigned __int16)word_20003E5F,
      (unsigned __int16)word_20003E61,
      (unsigned __int16)word_20003E63,
      (unsigned __int16)word_20003E65,
      (unsigned __int16)word_20003E67,
      (unsigned __int16)word_20003E69,
      (unsigned __int16)word_20003E6B,
      (unsigned __int16)word_20003E6D,
      (unsigned __int16)word_20003E6F,
      (unsigned __int16)word_20003E71,
      (unsigned __int16)word_20003E73);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 20003E25: using guessed type __int16 word_20003E25;
// 20003E27: using guessed type int dword_20003E27;
// 20003E2B: using guessed type __int16 word_20003E2B;
// 20003E2D: using guessed type int dword_20003E2D;
// 20003E31: using guessed type __int16 word_20003E31;
// 20003E33: using guessed type int dword_20003E33;
// 20003E37: using guessed type __int16 word_20003E37;
// 20003E39: using guessed type char byte_20003E39;
// 20003E3A: using guessed type char byte_20003E3A;
// 20003E3B: using guessed type __int16 word_20003E3B;
// 20003E3D: using guessed type int dword_20003E3D;
// 20003E41: using guessed type int dword_20003E41;
// 20003E45: using guessed type int dword_20003E45;
// 20003E49: using guessed type __int16 word_20003E49;
// 20003E4B: using guessed type __int16 word_20003E4B;
// 20003E4D: using guessed type int dword_20003E4D;
// 20003E51: using guessed type int dword_20003E51;
// 20003E55: using guessed type __int16 word_20003E55;
// 20003E57: using guessed type __int16 word_20003E57;
// 20003E59: using guessed type __int16 word_20003E59;
// 20003E5B: using guessed type __int16 word_20003E5B;
// 20003E5D: using guessed type __int16 word_20003E5D;
// 20003E5F: using guessed type __int16 word_20003E5F;
// 20003E61: using guessed type __int16 word_20003E61;
// 20003E63: using guessed type __int16 word_20003E63;
// 20003E65: using guessed type __int16 word_20003E65;
// 20003E67: using guessed type __int16 word_20003E67;
// 20003E69: using guessed type __int16 word_20003E69;
// 20003E6B: using guessed type __int16 word_20003E6B;
// 20003E6D: using guessed type __int16 word_20003E6D;
// 20003E6F: using guessed type __int16 word_20003E6F;
// 20003E71: using guessed type __int16 word_20003E71;
// 20003E73: using guessed type __int16 word_20003E73;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (08009FA0) --------------------------------------------------------
BOOL __fastcall sub_8009FA0(int a1)
{
  unsigned __int8 v3[72]; // [sp+0h] [bp-48h] BYREF

  sub_8002364(v3, 64);
  sprintf((int)v3, "AT+QMTCLOSE=%d", a1);
  return sub_800DAC0(v3, "OK", 0, 300) && sub_800C6A0(9, 0x3A98u, 300);
}

//----- (08009FF8) --------------------------------------------------------
BOOL __fastcall sub_8009FF8(int a1, const char *a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[148]; // [sp+4h] [bp-94h] BYREF

  sub_8002364(v8, 128);
  v6 = 0;
  if ( !a2 )
    return 0;
  sprintf((int)v8, "AT+QMTOPEN=%d,\"%s\",%d", a1, a2, a3);
  while ( v6 < 3 )
  {
    if ( sub_800DAC0(v8, "OK", 0, 300) )
      return strstr((unsigned __int8 *)byte_200038FC, "+QMTOPEN: 0, 2") == 0;
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (0800A08C) --------------------------------------------------------
int sub_800A08C()
{
  int result; // r0

  if ( byte_20000928 )
  {
    if ( byte_200015AC )
    {
      return 0;
    }
    else if ( byte_20004245 )
    {
      return 1;
    }
    else
    {
      if ( byte_20004246 == 4 )
      {
        sub_8009FA0(0);
        byte_2000090C = 8;
        byte_20004246 = 0;
      }
      else if ( byte_20004246 == 3 )
      {
        byte_2000090C = 10;
        byte_20004246 = 0;
      }
      switch ( byte_2000090C )
      {
        case 0:
          if ( sub_801AAF4(&word_20000918, 0xAu) )
            byte_2000090C = 1;
          goto LABEL_63;
        case 1:
          if ( sub_800A96C() )
            byte_2000090C = 2;
          goto LABEL_63;
        case 2:
          if ( sub_8009FF8(
                 0,
                 "B/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n",
                 8883) )
          {
            byte_2000090C = 3;
            byte_200036AE = 1;
            byte_200015A7 = 1;
            sub_8004FE0((int)"Wait for MQTT chatlink......\r\n");
          }
          else
          {
            byte_2000090C = 8;
          }
          goto LABEL_63;
        case 3:
          if ( byte_20004246 == 6 || sub_801AAF4(&word_20000916, 0x1Eu) )
          {
            byte_2000090C = 4;
            word_20000916 = 0;
            byte_200036AE = 0;
            byte_20004246 = 0;
            byte_200015A7 = 0;
          }
          goto LABEL_63;
        case 4:
          if ( sub_800AB4C() )
          {
            byte_2000090C = 5;
            word_2000091C = 0;
            sub_8004FE0((int)"MQTT chatlink ok!\r\n");
          }
          else
          {
            sub_8004FE0((int)"MQTT chatlink err!\r\n");
            if ( (unsigned __int16)++word_2000091C > 2u )
            {
              word_2000091C = 0;
              byte_2000090C = 8;
            }
          }
          goto LABEL_63;
        case 5:
          sub_8004FE0((int)"Mqtt link......\r\n");
          if ( sub_800AB90(0, 0, byte_200037BB, 0, 0) )
            byte_2000090C = 6;
          else
            byte_2000090C = 8;
          goto LABEL_63;
        case 6:
          sub_8004FE0((int)"Mqtt subscribe......\r\n");
          if ( sub_800C570(0, 1, byte_200037BB, 0) )
            byte_2000090C = 7;
          else
            byte_2000090C = 8;
          goto LABEL_63;
        case 7:
          if ( sub_800C26C(
                 0,
                 0,
                 0,
                 0,
                 byte_200037BB,
                 5,
                 "Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n") )
          {
            sub_8004FE0((int)"Mqtt publish ok!\r\n");
            byte_20004245 = 1;
            byte_2000090C = 0;
            result = 1;
          }
          else
          {
            byte_2000090C = 8;
LABEL_63:
            result = 0;
          }
          break;
        case 8:
          sub_8004FE0((int)"Mqtt chatlink close......\r\n");
          if ( sub_8009FA0(0) )
          {
            sub_8004FE0((int)"Mqtt chatlink off!\r\n");
            byte_2000090C = 2;
          }
          else
          {
            byte_2000090C = 9;
          }
          goto LABEL_63;
        case 9:
          if ( sub_801AACC(&word_20000918, 0x12Cu) )
          {
            sub_8004FE0((int)"Mqtt chatlink close again......\r\n");
            sub_8009FA0(0);
            word_20000918 = 0;
            ++byte_2000090D;
            byte_2000090C = 0;
            if ( (unsigned __int8)byte_2000090D > 0xAu )
            {
              byte_2000090D = 0;
              byte_2000090C = 10;
            }
          }
          goto LABEL_63;
        case 10:
          sub_8004FE0((int)"MQTT ERROR!\r\n");
          sub_8009FA0(0);
          if ( (byte_20002EA9 == 2 || byte_20002EA9 == 7) && byte_200015DE == 1 && !byte_20002E38 || byte_20002E38 == 5 )
          {
            if ( (unsigned __int8)++byte_2000090D <= 1u )
            {
              byte_2000090C = 0;
            }
            else
            {
              byte_2000090D = 0;
              byte_2000090C = 11;
            }
            sub_8004FE0(
              (int)"CT connected, mqtt_err_cnt: %d. Wait for init MQTT......\r\n",
              (unsigned __int8)byte_2000090D);
          }
          else
          {
            byte_2000090C = 0;
          }
          sub_8018928(4, 410);
          if ( byte_200015DE == 1 && byte_20004237 != 2 && sub_801AAF4(algn_2000091A, 0x78u) )
          {
            sub_8007CF8(1);
          }
          else if ( byte_20004237 != 2 && sub_801AAF4(algn_2000091A, 0x78u) )
          {
            sub_8007CF8(0);
          }
          goto LABEL_63;
        case 11:
          if ( sub_801AAF4(algn_2000091E, 0x78u) )
            byte_2000090C = 0;
          goto LABEL_63;
        default:
          goto LABEL_63;
      }
    }
  }
  else
  {
    byte_200036AC = 2;
    return 0;
  }
  return result;
}
// 2000090C: using guessed type char byte_2000090C;
// 2000090D: using guessed type char byte_2000090D;
// 20000916: using guessed type __int16 word_20000916;
// 20000918: using guessed type __int16 word_20000918;
// 2000091A: using guessed type _BYTE[2];
// 2000091C: using guessed type __int16 word_2000091C;
// 2000091E: using guessed type _BYTE[2];
// 20000928: using guessed type char byte_20000928;
// 200015A7: using guessed type char byte_200015A7;
// 200015AC: using guessed type char byte_200015AC;
// 200015DE: using guessed type char byte_200015DE;
// 20002E38: using guessed type char byte_20002E38;
// 20002EA9: using guessed type char byte_20002EA9;
// 200036AC: using guessed type char byte_200036AC;
// 200036AE: using guessed type char byte_200036AE;
// 20004237: using guessed type char byte_20004237;
// 20004245: using guessed type char byte_20004245;
// 20004246: using guessed type char byte_20004246;

//----- (0800A46C) --------------------------------------------------------
int sub_800A46C()
{
  unsigned int v0; // r4
  int result; // r0

  LOBYTE(v0) = 0;
  while ( 1 )
  {
    if ( byte_200036AE == 1 )
    {
      sub_8004FE0((int)"[MQTT] Wait for urc, don't check mqtt state!\r\n");
      return 1;
    }
    if ( sub_800DAC0("AT+QMTCONN?", (unsigned __int8 *)&dword_800A4D8, 0, 900)
      && (strstr((unsigned __int8 *)byte_200038FC, "+QMTCONN: 0,3") || byte_20004246 == 1) )
    {
      break;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(200);
    if ( v0 >= 9 )
    {
      sub_8004FE0((int)"[MQTT] State disconnected!\r\n");
      byte_20004245 = 0;
      return 0;
    }
  }
  result = 1;
  byte_20004245 = 1;
  byte_20004246 = 0;
  return result;
}
// 800A4D8: using guessed type int dword_800A4D8;
// 200036AE: using guessed type char byte_200036AE;
// 20004245: using guessed type char byte_20004245;
// 20004246: using guessed type char byte_20004246;

//----- (0800A54C) --------------------------------------------------------
int __fastcall sub_800A54C(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"datatype\",%d,%d", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"datatype\",%d", a2);
      if ( sub_800DAC0(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800A604) --------------------------------------------------------
int sub_800A604()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_80077D0();
  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sprintf(
      (int)byte_2000484A,
      "\",\"https://eu.hamedata.com/external-services/api/v1/electrics/prices/current?zone=%d\"",
      (unsigned __int8)byte_20003AFE);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 20003AFE: using guessed type char byte_20003AFE;
// 20003AFF: using guessed type __int16 word_20003AFF;
// 20003B01: using guessed type __int16 word_20003B01;
// 20003B03: using guessed type __int16 word_20003B03;
// 20003B05: using guessed type __int16 word_20003B05;
// 20003B07: using guessed type __int16 word_20003B07;
// 20003B09: using guessed type __int16 word_20003B09;
// 20003B0B: using guessed type __int16 word_20003B0B;
// 20003B0D: using guessed type __int16 word_20003B0D;
// 20003B0F: using guessed type __int16 word_20003B0F;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800A6E0) --------------------------------------------------------
int sub_800A6E0()
{
  int v0; // r5
  int result; // r0
  unsigned int i; // r4
  unsigned __int16 *v3; // r3
  unsigned __int16 v4; // r11
  int v5; // r4
  unsigned __int8 v6[88]; // [sp+18h] [bp-58h] BYREF

  v0 = 0;
  sub_8002364(v6, 52);
  sub_800F8D8();
  sub_8002364(byte_2000484A, 1024);
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v3 = (unsigned __int16 *)&dword_20003C59 + 7 * i;
      sprintf(
        (int)v6,
        "err%d=%d|%d|%d|%d|%d|%lld.",
        i,
        *v3,
        *((unsigned __int8 *)v3 + 2),
        *((unsigned __int8 *)v3 + 3),
        *((unsigned __int8 *)v3 + 4),
        *((unsigned __int8 *)v3 + 5),
        *(_QWORD *)(v3 + 3));
      v4 = (unsigned __int16)sub_80023E2(v6);
      qmemcpy((unsigned int)&byte_20004245[v0 + 1541], (unsigned int)v6, v4);
      v0 = (unsigned __int16)(v0 + v4);
      sub_8002364(v6, 52);
    }
    v5 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sub_8002364(byte_2000444A, 1024);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v5,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 20003C59: using guessed type int dword_20003C59;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800A824) --------------------------------------------------------
int sub_800A824()
{
  int v0; // r5
  int result; // r0
  unsigned int i; // r4
  unsigned __int16 *v3; // r3
  unsigned __int16 v4; // r11
  int v5; // r4
  unsigned __int8 v6[88]; // [sp+18h] [bp-58h] BYREF

  v0 = 0;
  sub_8002364(v6, 52);
  sub_800F8D8();
  sub_8002364(byte_2000484A, 1024);
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v3 = (unsigned __int16 *)&byte_20003D71[9 * i];
      sprintf(
        (int)v6,
        "event%d=%d|%d|%d|%d|%d|%d|%d.",
        i,
        *v3,
        *((unsigned __int8 *)v3 + 2),
        *((unsigned __int8 *)v3 + 3),
        *((unsigned __int8 *)v3 + 4),
        *((unsigned __int8 *)v3 + 5),
        *((unsigned __int8 *)v3 + 6),
        *(unsigned __int16 *)((char *)v3 + 7));
      v4 = (unsigned __int16)sub_80023E2(v6);
      qmemcpy((unsigned int)&byte_20004245[v0 + 1541], (unsigned int)v6, v4);
      v0 = (unsigned __int16)(v0 + v4);
      sub_8002364(v6, 52);
    }
    v5 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sub_8002364(byte_2000444A, 1024);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v5,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 20003D71: using guessed type _BYTE byte_20003D71[180];
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800A96C) --------------------------------------------------------
int sub_800A96C()
{
  int result; // r0

  if ( (unsigned __int8)byte_2000090F <= 0xCu )
  {
    switch ( byte_2000090E )
    {
      case 0:
        if ( sub_800E07C(1, 0, 2) )
        {
          byte_2000090E = 1;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 1:
        if ( sub_800DD3C(1, 0, "0xffff") )
        {
          byte_2000090E = 2;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 2:
        if ( sub_800E128(1, 0, 4) )
        {
          byte_2000090E = 3;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 3:
        if ( sub_800C4B8(1, 0, 1, 0) )
        {
          byte_2000090E = 4;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 4:
        if ( sub_800C7A8(1, 0, 3) )
        {
          byte_2000090E = 5;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 5:
        if ( sub_800A54C(1, 0, 0) )
        {
          byte_2000090E = 6;
          byte_2000090F = 0;
        }
        else
        {
          ++byte_2000090F;
        }
        goto LABEL_24;
      case 6:
        if ( !sub_800AA90(1, 0, 400) )
          goto LABEL_24;
        byte_2000090E = 0;
        byte_2000090F = 0;
        result = 1;
        break;
      default:
LABEL_24:
        result = 0;
        break;
    }
  }
  else
  {
    sub_8004FE0((int)dword_800AA6C);
    sub_8009FA0(0);
    sub_80232B4(300);
    byte_2000090F = 0;
    return 0;
  }
  return result;
}
// 800AA6C: using guessed type int dword_800AA6C[7];
// 2000090E: using guessed type char byte_2000090E;
// 2000090F: using guessed type char byte_2000090F;

//----- (0800AA90) --------------------------------------------------------
int __fastcall sub_800AA90(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"keepalive\",%d,%d", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"keepalive\",%d", a2);
      if ( sub_800DAC0(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800AB4C) --------------------------------------------------------
int sub_800AB4C()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DAC0("AT+QMTOPEN?", "+QMTOPEN: 0", 0, 600) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  while ( v0 < 3 );
  return 0;
}

//----- (0800AB90) --------------------------------------------------------
int __fastcall sub_800AB90(int a1, int a2, const char *a3, const char *a4, const char *a5)
{
  unsigned int v9; // r4
  unsigned __int8 v11[100]; // [sp+Ch] [bp-64h] BYREF

  sub_8002364(v11, 64);
  v9 = 0;
  if ( !a3 )
    return 0;
  while ( v9 < 3 )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        if ( !a4 || !a5 )
          return 0;
        sprintf((int)v11, "AT+QMTCONN=%d,\"%s\",\"%s\",\"%s\"", a2, a3, a4, a5);
        if ( sub_800DAC0(v11, "OK", 0, 300) && sub_800C6A0(5, 0x3A98u, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v11, "AT+QMTCONN=%d,\"hm_%s\"", a2, a3);
      if ( sub_800DAC0(v11, "OK", 0, 300) && sub_800C6A0(5, 0x3A98u, 300) )
        return 1;
    }
    v9 = (unsigned __int8)(v9 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (0800AC78) --------------------------------------------------------
int sub_800AC78()
{
  int result; // r0
  unsigned __int8 v1; // r0

  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sprintf((int)byte_2000484A, "c_top = %d.\r\n", (unsigned __int8)byte_20002EA9);
    v1 = (unsigned __int8)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20002EA9: using guessed type char byte_20002EA9;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];
// 200050F0: using guessed type int dword_200050F0;
// 200050F4: using guessed type int dword_200050F4;
// 200050FC: using guessed type int dword_200050FC;

//----- (0800AD3C) --------------------------------------------------------
int __fastcall sub_800AD3C(int result, unsigned int a2)
{
  unsigned int v2; // r1
  bool v3; // zf
  int v4; // r2
  char *v5; // r4
  unsigned __int16 v6; // r0
  unsigned __int8 *v7; // r4
  unsigned int v8; // r6
  int v9; // r5
  int v10; // r7
  unsigned __int8 v11; // r0
  char *v12; // r4
  int v13; // r5
  int v14; // r7
  unsigned __int8 v15; // r0
  unsigned __int8 *v16; // r5
  unsigned __int8 *v17; // r5
  unsigned __int16 v18; // r0
  int v19; // r5
  unsigned __int16 v20; // r0
  unsigned __int8 *v21; // r0
  unsigned __int8 *v22; // r4
  unsigned __int16 v23; // r0
  bool v24; // zf
  bool v25; // zf
  unsigned __int8 *v26; // r4
  int v27; // r4
  int v28; // r0
  int v29; // r0
  bool v30; // zf
  int v31; // r4
  unsigned __int8 *v32; // r0
  int v33; // r4
  int v34; // r1
  int v35; // r2
  unsigned __int8 *v36; // r0
  unsigned int v37; // r4
  int v38; // r1
  int v39; // r2
  unsigned __int8 *v40; // r0
  unsigned int v41; // r4
  int v42; // r1
  int v43; // r2
  int v44; // r1
  int v45; // r2
  int v46; // r6
  bool v47; // zf
  int v48; // r4
  int v49; // r1
  int v50; // r2
  unsigned __int8 *v51; // r6
  unsigned __int8 *v52; // r0
  int v53; // r5
  unsigned int v54; // r1
  unsigned int v55; // r1
  unsigned __int16 v56; // r0
  int v57; // r5
  unsigned __int16 v58; // r0
  unsigned __int16 v59; // r0
  unsigned __int16 v60; // r0
  unsigned __int16 v61; // r0
  unsigned __int8 *v62; // r6
  unsigned int v63; // r4
  unsigned __int8 *v64; // r6
  unsigned __int16 v65; // r0
  int v66; // r7
  unsigned __int16 v67; // r0
  unsigned __int8 v68[24]; // [sp+8h] [bp-50h] BYREF
  __int16 v69; // [sp+20h] [bp-38h]
  unsigned __int8 v70; // [sp+22h] [bp-36h]
  unsigned __int8 v71; // [sp+23h] [bp-35h]
  int v72; // [sp+24h] [bp-34h] BYREF
  unsigned __int8 *v73; // [sp+28h] [bp-30h]

  if ( result && a2 >= 3 )
  {
    v2 = a2 + result;
    v3 = *(_BYTE *)(v2 - 1) == 10;
    while ( 1 )
    {
      if ( !v3 )
        return result;
      v4 = *(unsigned __int8 *)(v2 - 2);
      v3 = v4 == 13;
      if ( v4 == 13 )
      {
        v2 = *(unsigned __int8 *)(v2 - 3);
        v3 = v2 == 34;
        if ( v2 == 34 )
          break;
      }
    }
    result = (int)strstr((unsigned __int8 *)(result + 15), (unsigned __int8 *)&loc_800B164);
    if ( result )
    {
      v73 = (unsigned __int8 *)(result + 3);
      result = (unsigned __int8)sub_8002644((char *)(result + 3));
      v5 = byte_20002E37;
      switch ( (char)result )
      {
        case 1:
          sub_8004FE0((int)"[MQTT] Get work data...\r\n");
          return sub_800C860();
        case 2:
          sub_8002364(v68, 32);
          if ( strstr(v73, "md=0") )
          {
            byte_20002E38 = 0;
            sub_80055F0(0x301u, &byte_20002E38, 1u);
          }
          else if ( strstr(v73, "md=1") )
          {
            byte_20002E38 = 1;
            sub_80055F0(0x301u, &byte_20002E38, 1u);
          }
          else if ( strstr(v73, "md=5") )
          {
            byte_20002E38 = 5;
            sub_80055F0(0x301u, &byte_20002E38, 1u);
          }
          sub_8004FE0((int)"[MQTT] Set work mode : %d.\r\n", (unsigned __int8)byte_20002E38);
          sprintf((int)v68, "cd=%d,md=%d", 2, (unsigned __int8)byte_20002E38);
          v6 = (unsigned __int16)sub_80023E2(v68);
          return sub_800C418((int)v68, v6);
        case 3:
          sub_8002364(v68, 32);
          sub_8004FE0((int)"[MQTT] Set manual mode or economy mode info...\r\n");
          if ( strstr(v73, "md=1") )
          {
            byte_20002E38 = 1;
            sub_80055F0(0x301u, &byte_20002E38, 1u);
            sub_8004FE0((int)"[MQTT] user_work_mode = %d\r\n", (unsigned __int8)byte_20002E38);
            result = (int)strstr(v73, "nm");
            v7 = (unsigned __int8 *)result;
            if ( result )
            {
              v8 = (unsigned __int8)sub_8002644((char *)(result + 3));
              result = sub_8004FE0((int)"[MQTT] time_num = %d\r\n", v8);
              if ( v8 < 0xA )
              {
                result = (int)strstr(v7, "bt");
                v9 = result;
                if ( result )
                {
                  v10 = (unsigned __int8)sub_8002644((char *)(result + 3));
                  v11 = sub_8002644((char *)(v9 + 6));
                  v12 = &byte_20002E37[10 * v8];
                  *((_WORD *)v12 + 3) = v11 | (unsigned __int16)((_WORD)v10 << 8);
                  sub_8004FE0((int)"[MQTT] start_time = %d:%d\r\n", v10, v11);
                  result = (int)strstr((unsigned __int8 *)v9, "et");
                  v13 = result;
                  if ( result )
                  {
                    v14 = (unsigned __int8)sub_8002644((char *)(result + 3));
                    v15 = sub_8002644((char *)(v13 + 6));
                    *((_WORD *)v12 + 4) = v15 | (unsigned __int16)((_WORD)v14 << 8);
                    sub_8004FE0((int)"[MQTT] end_time = %d:%d\r\n", v14, v15);
                    result = (int)strstr((unsigned __int8 *)v13, "wk");
                    v16 = (unsigned __int8 *)result;
                    if ( result )
                    {
                      v12[2] = sub_8002644((char *)(result + 3));
                      result = (int)strstr(v16, "vv");
                      v17 = (unsigned __int8 *)result;
                      if ( result )
                      {
                        *((_WORD *)v12 + 2) = sub_8002644((char *)(result + 3));
                        result = (int)strstr(v17, "as");
                        if ( result )
                        {
                          v12[3] = sub_8002644((char *)(result + 3));
                          sub_80055B4(v8);
                          sub_8004FE0(
                            (int)"[MQTT] grid_power = %d, grid_state = %d\r\n",
                            *((__int16 *)v12 + 2),
                            (unsigned __int8)v12[3]);
                          sprintf((int)v68, "cd=%d,md=%d", 3, (unsigned __int8)byte_20002E38);
                          v18 = (unsigned __int16)sub_80023E2(v68);
                          return sub_800C418((int)v68, v18);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            result = (int)strstr(v73, "md=5");
            if ( result )
            {
              byte_20002E38 = 5;
              sub_80055F0(0x301u, &byte_20002E38, 1u);
              byte_2000159E = 1;
              sub_8004FE0((int)"[MQTT] user_work_mode = %d\r\n", (unsigned __int8)byte_20002E38);
              result = (int)strstr(v73, "nl");
              if ( result )
              {
                v19 = (unsigned __int8)sub_8002644((char *)(result + 3));
                sub_8004FE0((int)"[MQTT] cur_protect_en = %d\r\n", v19);
                sprintf((int)v68, "cd=%d,md=%d,nl=%d", 3, (unsigned __int8)byte_20002E38, v19);
                v20 = (unsigned __int16)sub_80023E2(v68);
                return sub_800C418((int)v68, v20);
              }
            }
          }
          return result;
        case 4:
          sub_8004FE0((int)"[MQTT] Set local time...\r\n");
          v21 = strstr(v73, "yy");
          v22 = v21;
          if ( !v21 )
            goto LABEL_43;
          v23 = sub_8002644((char *)v21 + 3);
          v69 = v23 - 2000;
          sub_8004FE0((int)"[MQTT] Set local time : year = %d\r\n", v23);
          result = (int)strstr(v22, "mm");
          v5 = (char *)result;
          v24 = result == 0;
          goto LABEL_37;
        case 5:
          sub_8004FE0((int)"[MQTT] Set reset...\r\n");
          if ( strstr(v73, "rs=1") )
            return sub_800786C(1);
          result = (int)strstr(v73, "rs=2");
          v24 = result == 0;
          if ( result )
            return sub_800786C(2);
LABEL_37:
          if ( !v24 )
          {
            v70 = sub_8002644(v5 + 3);
            sub_8004FE0((int)"[MQTT] Set local time : month = %d.\r\n", v70);
            result = (int)strstr((unsigned __int8 *)v5, "rr");
            v5 = (char *)result;
            v25 = result == 0;
LABEL_39:
            if ( !v25 )
            {
              v71 = sub_8002644(v5 + 3);
              sub_8004FE0((int)"[MQTT] Set local time : day = %d.\r\n", v71);
              result = (int)strstr((unsigned __int8 *)v5, "hh");
              v26 = (unsigned __int8 *)result;
              if ( result )
              {
                BYTE1(v72) = sub_8002644((char *)(result + 3));
                sub_8004FE0((int)"[MQTT] Set local time : hour = %d.\r\n", BYTE1(v72));
                result = (int)strstr(v26, "mn");
                if ( result )
                {
                  BYTE2(v72) = sub_8002644((char *)(result + 3));
                  sub_8004FE0((int)"[MQTT] Set local time : min = %d.\r\n", BYTE2(v72));
LABEL_43:
                  sub_80200DC((unsigned __int8)v69, v70, v71);
                  sub_8020108(BYTE1(v72), BYTE2(v72), HIBYTE(v72));
                  return sub_800C334(1);
                }
              }
            }
          }
          return result;
        case 6:
          sub_8004FE0((int)"[MQTT] Get developer mode data...\r\n");
          return sub_800A604();
        case 7:
          sub_8004FE0((int)"[MQTT] Set developer mode data...\r\n");
          result = (int)strstr(v73, "dm");
          v25 = result == 0;
          if ( !result )
            goto LABEL_39;
          v27 = (unsigned __int8)sub_8002644((char *)(result + 3));
          result = sub_8004FE0((int)"[MQTT] Set develop mode = %d.\r\n", v27);
          switch ( v27 )
          {
            case 0:
              return sub_8007CF8(0);
            case 1:
              sub_80031E4();
              sub_801EE84(v29);
              sub_801E298();
            case 2:
              sub_8007788();
              sub_80031E4();
              sub_801EE84(v28);
              sub_801E298();
          }
          return result;
        case 8:
          sub_8004FE0((int)"[MQTT] Set mode auto change...\r\n");
          if ( strstr(v73, "dt=1") )
          {
            if ( byte_200015DE == 1 )
            {
              byte_20002E38 = 0;
            }
            else if ( !byte_200015DE || byte_200015DE == 2 )
            {
              byte_20002E38 = 1;
            }
            byte_20002EA7 = 1;
            sub_80055F0(0x370u, &byte_20002EA7, 1u);
            sub_800C334(1);
            return sub_8004FE0((int)"\n", (unsigned __int8)byte_20002E38, (unsigned __int8)byte_20002EA7);
          }
          else
          {
            if ( !strstr(v73, "dt=0") )
              return sub_800C334(0);
            byte_20002EA7 = 0;
            sub_80055F0(0x370u, &byte_20002EA7, 1u);
            sub_800C334(1);
            return sub_8004FE0(
                     (int)"[MQTT] Set mode auto change close, g_work_mode_change = %d.\r\n",
                     (unsigned __int8)byte_20002EA7);
          }
        case 9:
          if ( strstr(v73, "ot=0") )
          {
            sub_8004FE0((int)"[MQTT] Set fc41d ota, ot = 0.\r\n");
            sub_8007880(0);
          }
          result = (int)strstr(v73, "ot=1");
          v30 = result == 0;
          goto LABEL_70;
        case 10:
          sub_8004FE0((int)"[MQTT] Get fc41d version...\r\n");
          return sub_800C6F0();
        case 11:
          if ( strstr(v73, "bc=1") )
          {
            sub_8004FE0((int)"[MQTT] Set eps enable.\r\n");
            sub_80031EE();
            if ( byte_20002E37[0] == 1 )
              return sub_800C334(1);
            return sub_800C334(0);
          }
          result = (int)strstr(v73, "bc=0");
          v30 = result == 0;
          if ( result )
          {
            sub_8004FE0((int)"[MQTT] Set eps disable.\r\n");
            sub_80031EE();
            if ( !byte_20002E37[0] )
              return sub_800C334(1);
            return sub_800C334(0);
          }
LABEL_70:
          if ( !v30 )
          {
            sub_8004FE0((int)"[MQTT] Set fc41d ota, ot = 1.\r\n");
            sub_8007880(1);
          }
          return result;
        case 12:
          v31 = 0;
          v72 = 0;
          if ( !strstr(v73, "ht=0") )
          {
            if ( strstr(v73, "ht=1") )
            {
              v31 = 1;
            }
            else if ( strstr(v73, "ht=2") )
            {
              v31 = 2;
            }
          }
          sub_8005498(0x441u, (int)&v72, 1);
          if ( (unsigned __int8)v72 != v31 || (unsigned __int8)v72 == 255 )
          {
            byte_20002F11 = v31;
            sub_80055F0(0x441u, &byte_20002F11, 1u);
          }
          return sub_8004FE0((int)"[MQTT] Set http server type : %d.\r\n", (unsigned __int8)byte_20002F11);
        case 13:
          sub_8004FE0((int)"[MQTT] Get err code info...\r\n");
          return sub_800A6E0();
        case 14:
          sub_8004FE0((int)"[MQTT] Get bms data info...\r\n");
          return sub_8009E38();
        case 15:
          sub_8004FE0((int)"[MQTT] Set version num...\r\n");
          v32 = strstr(v73, "vs");
          if ( v32 )
          {
            v33 = (unsigned __int16)sub_8002644((char *)v32 + 3);
            if ( byte_20000507 == 2 )
            {
              sub_800C334(1);
            }
            else if ( v33 == 800 )
            {
              byte_20000507 = 1;
              word_20000515 = 800;
              sub_80055F0(0x204u, &word_20000515, 2u);
              sub_80055F0(0x90u, &byte_20000507, 1u);
              sub_800C334(1);
              sub_800E36C();
            }
            else if ( v33 == 2500 )
            {
              byte_20000507 = 0;
              word_20000515 = 2500;
              sub_80055F0(0x204u, &word_20000515, 2u);
              sub_80055F0(0x90u, &byte_20000507, 1u);
              sub_800C334(1);
            }
            else
            {
              sub_800C334(0);
              sub_8004FE0((int)"[MQTT] Set version value err.\r\n");
            }
            return sub_8004FE0(
                     (int)"[MQTT] Set version = %d, real version = %d.\r\n",
                     v33,
                     (unsigned __int8)byte_20000507);
          }
          else
          {
            sub_800C334(0);
            return sub_8004FE0((int)"[MQTT] Set version err.\r\n", v34, v35);
          }
        case 16:
          v36 = strstr(v73, "cp");
          if ( v36 )
          {
            v37 = (unsigned __int16)sub_8002644((char *)v36 + 3);
            if ( v37 > 0x9C4 )
            {
              sub_800C334(0);
              sub_8004FE0((int)"[MQTT] Set max charge power value err.\r\n");
            }
            else
            {
              word_20000513 = v37;
              sub_80055F0(0x202u, &word_20000513, 2u);
              sub_800C334(1);
            }
            return sub_8004FE0(
                     (int)"[MQTT] Set max charge power = %d, real max charge power = %d.\r\n",
                     v37,
                     (unsigned __int16)word_20000513);
          }
          else
          {
            sub_800C334(0);
            return sub_8004FE0((int)"[MQTT] Set max charge power err.\r\n", v38, v39);
          }
        case 17:
          v40 = strstr(v73, "dp");
          if ( v40 )
          {
            v41 = (unsigned __int16)sub_8002644((char *)v40 + 3);
            if ( v41 > 0x9C4 )
            {
              sub_800C334(0);
              sub_8004FE0((int)"[MQTT] Set max discharge power value err.\r\n");
            }
            else
            {
              if ( byte_20000507 == 1 && v41 > 0x320 )
              {
                sub_800C334(0);
                return sub_8004FE0((int)"[MQTT] Set max discharge power value err, over 800W.\r\n", v42, v43);
              }
              word_20000515 = v41;
              sub_80055F0(0x204u, &word_20000515, 2u);
              sub_800C334(1);
            }
            return sub_8004FE0((int)".\r\n", v41, (unsigned __int16)word_20000515);
          }
          else
          {
            sub_800C334(0);
            return sub_8004FE0((int)"[MQTT] Set max discharge power err.\r\n", v44, v45);
          }
        case 18:
          return sub_800D758((int)v73);
        case 19:
          sub_800D640();
          result = (int)strstr(v73, "meter_data");
          if ( result )
            return sub_800AC78();
          return result;
        case 20:
          sub_8004FE0((int)"[MQTT] Set FC41D URL OTA...\r\n");
          result = (int)strstr(v73, "len");
          v46 = result;
          v47 = result == 0;
          while ( !v47 )
          {
            v48 = (unsigned __int8)sub_8002644((char *)(v46 + 4));
            if ( v48 == 255 )
            {
              sub_800C334(0);
              return sub_8004FE0((int)"[MQTT] Set FC41D URL OTA length err.\r\n", v49, v50);
            }
            result = (int)strstr((unsigned __int8 *)v46, "url=");
            v47 = result == 0;
            if ( result )
            {
              v51 = (unsigned __int8 *)(result + 4);
              sub_800C334(1);
              sub_8002364(byte_200037E2, 256);
              sub_80023B6(byte_200037E2, v51, v48);
              byte_200036AC[v48 + 310] = 0;
              v52 = strstr(v51, "port=");
              if ( v52 )
              {
                v53 = (unsigned __int16)sub_8002644((char *)v52 + 5);
                sub_8004FE0(
                  (int)"[MQTT] Receive ota url: %s, url_len = %d, url_port = %d.\r\n",
                  byte_200037E2,
                  v48,
                  v53);
                v54 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_200037E2);
                return sub_8007A40(byte_200037E2, v54, v53);
              }
              else
              {
                sub_8004FE0((int)"[MQTT] Receive ota url: %s, url_len = %d.\r\n", byte_200037E2, v48);
                v55 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_200037E2);
                return sub_8007A40(byte_200037E2, v55, 0);
              }
            }
          }
          return result;
        case 21:
          sub_8004FE0((int)"[MQTT] Get event log info...\r\n");
          return sub_800A824();
        case 22:
          sub_8002364(v68, 32);
          sub_8004FE0((int)"[MQTT] Info active upgrade...\r\n");
          byte_2000159F = 1;
          sprintf((int)v68, "cd=%d,ret=%d", 22, 1);
          v56 = (unsigned __int16)sub_80023E2(v68);
          return sub_800C418((int)v68, v56);
        case 23:
          sub_8002364(v68, 32);
          result = (int)strstr(v73, "pm");
          if ( !result )
            return result;
          v57 = (unsigned __int8)sub_8002644((char *)(result + 3));
          sub_8004FE0((int)"[MQTT] Set parallel machine enable = %d.\r\n", v57);
          switch ( v57 )
          {
            case 2:
              if ( byte_20002EAB != 1 )
              {
                sub_8004FE0((int)"[MQTT] !!! Parallel machine Not ready.\r\n");
                sprintf((int)v68, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002EAB);
                v58 = (unsigned __int16)sub_80023E2(v68);
                return sub_800C418((int)v68, v58);
              }
              sub_8004FE0((int)"[MQTT] Parallel machine ON.\r\n");
              sub_80031F8();
              break;
            case 1:
              sub_8004FE0((int)"[MQTT] Parallel machine Ready.\r\n");
              sub_80031F8();
              break;
            case 0:
              if ( byte_20002EAB != 1 )
              {
                sub_8004FE0((int)"[MQTT] !!! Parallel machine not ready.\r\n");
                sprintf((int)v68, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002EAB);
                v59 = (unsigned __int16)sub_80023E2(v68);
                return sub_800C418((int)v68, v59);
              }
              sub_8004FE0((int)"[MQTT] Parallel machine OFF.\r\n");
              sub_80031F8();
              break;
          }
          sprintf((int)v68, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002EAB);
          v60 = (unsigned __int16)sub_80023E2(v68);
          return sub_800C418((int)v68, v60);
        case 24:
          sub_8002364(v68, 32);
          if ( strstr(v73, "ip?") )
          {
            sub_8004FE0((int)"[MQTT] Get meter ip info...\r\n");
            sub_8005498(0x3500u, (int)byte_200038EB, 16);
            sprintf((int)v68, "cd=%d,ip=%s", 24, byte_200038EB);
            v61 = (unsigned __int16)sub_80023E2(v68);
            return sub_800C418((int)v68, v61);
          }
          else
          {
            sub_8004FE0((int)"[MQTT] Set P1 IP...\r\n");
            result = (int)strstr(v73, "len");
            v62 = (unsigned __int8 *)result;
            if ( result )
            {
              v63 = (unsigned __int8)sub_8002644((char *)(result + 4));
              if ( v63 <= 0x10 )
              {
                result = (int)strstr(v62, "ip=");
                if ( result )
                {
                  v64 = (unsigned __int8 *)(result + 3);
                  sub_8002364(byte_200038EB, 16);
                  sub_80023B6(byte_200038EB, v64, v63);
                  byte_200036AC[v63 + 575] = 0;
                  sub_8005498(0x3500u, (int)v68, 16);
                  if ( sub_80023F0((int)byte_200038EB, (int)v68) )
                  {
                    sub_8004FE0((int)"[MQTT] *** Receive ip: %s, read ip: %s.\r\n", byte_200038EB, (const char *)v68);
                    sub_80055F0(0x3500u, byte_200038EB, 0x10u);
                  }
                  sub_8004FE0(
                    (int)"[MQTT] Receive ip_len = %d, ip: %s, read ip: %s.\r\n",
                    v63,
                    byte_200038EB,
                    (const char *)v68);
                  sub_8002364(v68, 32);
                  sprintf((int)v68, "cd=%d,ip=%s", 24, byte_200038EB);
                  v65 = (unsigned __int16)sub_80023E2(v68);
                  return sub_800C418((int)v68, v65);
                }
              }
              else
              {
                sub_800C334(0);
                return sub_8004FE0((int)"[MQTT] Set P1 IP len err.\r\n");
              }
            }
          }
          return result;
        case 25:
          sub_8002364(v68, 32);
          result = (int)strstr(v73, "gen");
          if ( result )
          {
            v66 = (unsigned __int8)sub_8002644((char *)(result + 4));
            sub_8004FE0((int)"[MQTT] Set generator enable = %d.\r\n", v66);
            if ( v66 == 1 )
            {
              sub_8004FE0((int)"[MQTT] Generator enable.\r\n");
              byte_20002EAD = 1;
            }
            else if ( !v66 )
            {
              sub_8004FE0((int)"[MQTT] Generator disable.\r\n");
              byte_20002EAD = 0;
            }
            sprintf((int)v68, "cd=%d,ret=%d", 25, (unsigned __int8)byte_20002EAD);
            v67 = (unsigned __int16)sub_80023E2(v68);
            return sub_800C418((int)v68, v67);
          }
          return result;
        case 26:
          return sub_8007BB8();
        default:
          return result;
      }
    }
  }
  return result;
}
// 800B48A: variable 'v28' is possibly undefined
// 800B4B0: variable 'v29' is possibly undefined
// 800B762: variable 'v34' is possibly undefined
// 800B762: variable 'v35' is possibly undefined
// 800B7C6: variable 'v38' is possibly undefined
// 800B7C6: variable 'v39' is possibly undefined
// 800B800: variable 'v42' is possibly undefined
// 800B800: variable 'v43' is possibly undefined
// 800B84E: variable 'v44' is possibly undefined
// 800B84E: variable 'v45' is possibly undefined
// 800BC34: variable 'v49' is possibly undefined
// 800BC34: variable 'v50' is possibly undefined
// 801EE84: using guessed type int __fastcall sub_801EE84(_DWORD);
// 20000507: using guessed type char byte_20000507;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 2000159E: using guessed type char byte_2000159E;
// 2000159F: using guessed type char byte_2000159F;
// 200015DE: using guessed type char byte_200015DE;
// 20002E38: using guessed type char byte_20002E38;
// 20002EA7: using guessed type char byte_20002EA7;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002EAD: using guessed type char byte_20002EAD;
// 20002F11: using guessed type char byte_20002F11;

//----- (0800C26C) --------------------------------------------------------
int __fastcall sub_800C26C(int a1, int a2, int a3, int a4, const char *a5, int a6, const char *a7)
{
  unsigned int v11; // r4
  unsigned __int8 v13[164]; // [sp+1Ch] [bp-A4h] BYREF

  sub_8002364(v13, 128);
  v11 = 0;
  if ( !a5 || !a7 )
    return 0;
  sub_800F8D8();
  sprintf(
    (int)v13,
    "AT+QMTPUB=%d,%d,%d,%d,\"hame_energy/%s/App/%s/ctrl\",%d,\"%s\"",
    a1,
    a2,
    a3,
    a4,
    (const char *)&dword_200038E3,
    a5,
    a6,
    a7);
  while ( v11 < 3 )
  {
    if ( sub_800DAC0(v13, "OK", 0, 300) && sub_800C6A0(8, 0x3A98u, 300) )
      return 1;
    v11 = (unsigned __int8)(v11 + 1);
    sub_80232B4(100);
  }
  return 0;
}
// 200038E3: using guessed type int dword_200038E3;

//----- (0800C334) --------------------------------------------------------
int __fastcall sub_800C334(int a1)
{
  int result; // r0

  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    if ( a1 == 1 )
    {
      sprintf(
        (int)byte_2000444A,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",5,\"ret=1\"\r\n",
        (const char *)&dword_200038E3,
        byte_200037BB);
    }
    else if ( !a1 )
    {
      sprintf(
        (int)byte_2000444A,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",5,\"ret=0\"\r\n",
        (const char *)&dword_200038E3,
        byte_200037BB);
    }
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800C418) --------------------------------------------------------
int __fastcall sub_800C418(int result, unsigned int a2)
{
  const char *v2; // r5

  v2 = (const char *)result;
  if ( result && a2 && a2 <= 0x39C )
  {
    sub_800F8D8();
    result = sub_8024F80(dword_20000458, 500);
    if ( result )
    {
      sprintf(
        (int)byte_2000444A,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
        (const char *)&dword_200038E3,
        byte_200037BB,
        a2,
        v2);
      sub_800E28A(byte_2000444A);
      return sub_8024A40(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800C4B8) --------------------------------------------------------
int __fastcall sub_800C4B8(int a1, int a2, int a3, int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[92]; // [sp+4h] [bp-5Ch] BYREF

  sub_8002364(v10, 64);
  LOBYTE(v8) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v10, "AT+QMTCFG=\"ssl\",%d,%d,%d", a2, a3, a4);
        if ( sub_800DAC0(v10, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v10, "AT+QMTCFG=\"ssl\",%d", a2);
      if ( sub_800DAC0(v10, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v8 = (unsigned __int8)(v8 + 1);
    sub_80232B4(100);
  }
  while ( v8 < 3 );
  return 0;
}

//----- (0800C570) --------------------------------------------------------
int __fastcall sub_800C570(int a1, int a2, const char *a3, int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[152]; // [sp+10h] [bp-98h] BYREF

  sub_8002364(v10, 128);
  v8 = 0;
  if ( !a3 )
    return 0;
  sub_800F8D8();
  sprintf((int)v10, "AT+QMTSUB=%d,%d,\"hame_energy/%s/App/%s/ctrl\",%d", a1, a2, (const char *)&dword_200038E3, a3, a4);
  while ( v8 < 3 )
  {
    if ( sub_800DAC0(v10, "OK", 0, 300) && sub_800C6A0(7, 0x3A98u, 300) )
      return 1;
    v8 = (unsigned __int8)(v8 + 1);
    sub_80232B4(100);
  }
  return 0;
}
// 200038E3: using guessed type int dword_200038E3;

//----- (0800C61C) --------------------------------------------------------
int sub_800C61C()
{
  int result; // r0

  result = (unsigned __int8)byte_200015AC;
  if ( !byte_200015AC )
  {
    if ( byte_20004245 && !byte_200036AE )
    {
      if ( sub_801AAF4(word_20000910, 0x3Cu) )
        sub_800A46C();
      if ( sub_801AAF4(&word_20000910[1], 0x258u) )
        sub_800C860();
    }
    if ( word_200036B5 != 15 && byte_20004245 && sub_801AAF4(&word_20000914, 0x708u) )
    {
      result = 15;
      word_200036B5 = 15;
    }
    else
    {
      result = (unsigned __int8)byte_20004245;
      if ( !byte_20004245 )
      {
        result = (unsigned __int8)byte_20000928;
        if ( byte_20000928 )
        {
          result = 0;
          word_20000914 = 0;
        }
      }
    }
  }
  return result;
}
// 20000910: using guessed type _WORD word_20000910[2];
// 20000914: using guessed type __int16 word_20000914;
// 20000928: using guessed type char byte_20000928;
// 200015AC: using guessed type char byte_200015AC;
// 200036AE: using guessed type char byte_200036AE;
// 200036B5: using guessed type __int16 word_200036B5;
// 20004245: using guessed type char byte_20004245;

//----- (0800C6A0) --------------------------------------------------------
int __fastcall sub_800C6A0(int a1, unsigned int a2, int a3)
{
  int v6; // r6
  unsigned int v7; // r0
  unsigned int v8; // r4

  v6 = sub_80253E8();
  v7 = 0;
  if ( !a2 || !a3 )
    return 0;
  v8 = 1000 * a3;
  while ( v7 < a2 )
  {
    if ( (unsigned __int8)byte_20004246 == a1 )
    {
      byte_20004246 = 0;
      return 1;
    }
    sub_80232B4(v8 / 0x3E8);
    v7 = sub_80253E8() - v6;
  }
  return 0;
}
// 20004246: using guessed type char byte_20004246;

//----- (0800C6F0) --------------------------------------------------------
int sub_800C6F0()
{
  int result; // r0
  unsigned __int8 v1; // r0

  sub_8007C6C();
  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sprintf((int)byte_2000484A, "wifi_v=%s", (const char *)&dword_200037D5);
    v1 = (unsigned __int8)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200037D5: using guessed type int dword_200037D5;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800C7A8) --------------------------------------------------------
int __fastcall sub_800C7A8(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"version\",%d,%d", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"version\",%d", a2);
      if ( sub_800DAC0(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800C860) --------------------------------------------------------
int sub_800C860()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_800F228();
  sub_800F8D8();
  result = sub_8024F80(dword_20000458, 500);
  if ( result )
  {
    sub_8005188();
    sub_800F638();
    sprintf(
      (int)byte_2000484A,
      "CFG=\"url\",\"http://%s.hamedata.com/app/neng/getWeatherInfo.php\"",
      (const char *)dword_20003B57);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
    sprintf(
      (int)byte_2000444A,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_200038E3,
      byte_200037BB,
      v1,
      byte_2000484A);
    sub_800E28A(byte_2000444A);
    return sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200004AC: using guessed type char byte_200004AC;
// 200015A6: using guessed type char byte_200015A6;
// 200015DC: using guessed type char byte_200015DC;
// 20002E39: using guessed type char byte_20002E39;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002EAD: using guessed type char byte_20002EAD;
// 20002F11: using guessed type char byte_20002F11;
// 200038E3: using guessed type int dword_200038E3;
// 20003B11: using guessed type char byte_20003B11;
// 20003B12: using guessed type char byte_20003B12;
// 20003B13: using guessed type char byte_20003B13;
// 20003B14: using guessed type char byte_20003B14;
// 20003B15: using guessed type char byte_20003B15;
// 20003B16: using guessed type char byte_20003B16;
// 20003B17: using guessed type char byte_20003B17;
// 20003B18: using guessed type char byte_20003B18;
// 20003B1A: using guessed type char byte_20003B1A;
// 20003B1B: using guessed type __int16 word_20003B1B;
// 20003B1D: using guessed type __int16 word_20003B1D;
// 20003B1F: using guessed type __int16 word_20003B1F;
// 20003B21: using guessed type __int16 word_20003B21;
// 20003B31: using guessed type __int16 word_20003B31;
// 20003B33: using guessed type __int16 word_20003B33;
// 20003B39: using guessed type __int16 word_20003B39;
// 20003B3B: using guessed type int dword_20003B3B;
// 20003B3F: using guessed type int dword_20003B3F;
// 20003B43: using guessed type int dword_20003B43;
// 20003B47: using guessed type int dword_20003B47;
// 20003B4B: using guessed type int dword_20003B4B;
// 20003B4F: using guessed type int dword_20003B4F;
// 20003B53: using guessed type int dword_20003B53;
// 20003B57: using guessed type int dword_20003B57;
// 20003B5B: using guessed type int dword_20003B5B;
// 20003B5F: using guessed type int dword_20003B5F;
// 20003B63: using guessed type int dword_20003B63;
// 20003B67: using guessed type int dword_20003B67;
// 20003C10: using guessed type __int16 word_20003C10;
// 20003C12: using guessed type __int16 word_20003C12;
// 20003C1C: using guessed type __int16 word_20003C1C;
// 20004237: using guessed type char byte_20004237;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800CB88) --------------------------------------------------------
unsigned int __fastcall sub_800CB88(unsigned int result, int a2)
{
  unsigned int i; // r2

  if ( a2 )
  {
    for ( i = 0; i < result; ++i )
      dword_200015BC += *(unsigned __int8 *)(a2 + i);
    result = (unsigned __int8)byte_200015AA;
    if ( byte_200015AA == 1 )
    {
      sub_8004FE0((int)dword_800CBBC);
      dword_200015C0 = dword_200015BC;
      result = ~dword_200015BC;
      dword_200015BC = ~dword_200015BC;
    }
  }
  return result;
}
// 800CBBC: using guessed type int dword_800CBBC[9];
// 200015AA: using guessed type char byte_200015AA;
// 200015BC: using guessed type int dword_200015BC;
// 200015C0: using guessed type int dword_200015C0;

//----- (0800CBE0) --------------------------------------------------------
int __fastcall sub_800CBE0(int a1)
{
  int result; // r0
  int v3; // r1
  unsigned int v5; // r1
  int v6; // r0

  if ( byte_200015A8 != 1 )
    sub_801803C((char *)a1);
  result = (unsigned __int8)byte_200015A8;
  if ( byte_200015A8 != 2 )
  {
    if ( a1 )
    {
      result = (unsigned __int16)word_200015B0;
      if ( (unsigned __int16)word_200015B0 >= 2u )
      {
        result = (unsigned __int16)word_200015B0;
        if ( word_200015B0 == word_200015AE )
        {
          v3 = *(unsigned __int8 *)(a1 + 2);
          _R7 = 1;
          switch ( v3 )
          {
            case ':':
              result = *(unsigned __int8 *)(a1 + 1);
              if ( result == 5 )
              {
                result = *(unsigned __int8 *)(a1 + 3);
                if ( result == 3 )
                {
                  result = *(unsigned __int8 *)(a1 + 4);
                  if ( result == 2 )
                  {
                    byte_200036AF = 1;
                    word_200036B7 = 0;
                    dword_200015C8 = 0;
                    dword_200015CC = 0;
                    byte_200015B2 = 1;
                    sub_8004FE0((int)sub_800CEC8);
                    sub_800CF80((_BYTE *)0x3A, (unsigned int)&byte_200015B2, 2);
                    byte_200015AC = 1;
                    byte_200015A8 = 1;
                    return sub_801F7E0();
                  }
                }
              }
              break;
            case 'P':
              result = (unsigned __int8)byte_200015AC;
              if ( byte_200015AC == 1 )
              {
                byte_200036AF = 1;
                word_200036B7 = 0;
                byte_200015AC = 2;
                dword_200015C8 |= *(unsigned __int8 *)(a1 + 3)
                                | (*(unsigned __int8 *)(a1 + 4) << 8)
                                | (*(unsigned __int8 *)(a1 + 5) << 16)
                                | (*(unsigned __int8 *)(a1 + 6) << 24);
                dword_200015CC |= *(unsigned __int8 *)(a1 + 7)
                                | (*(unsigned __int8 *)(a1 + 8) << 8)
                                | (*(unsigned __int8 *)(a1 + 9) << 16)
                                | (*(unsigned __int8 *)(a1 + 10) << 24);
                dword_200015C4 = 0;
                dword_200015BC = 0;
                byte_200015AA = 0;
                sub_8004FE0((int)dword_80291AC);
                if ( MEMORY[0x1FFF75E0] == 0xFFFF )
                  v5 = 0x80000;
                else
                  v5 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
                sub_800F4F4(0x8040000u, (v5 >> 1) + 134479872);
                return (int)sub_800CF80((_BYTE *)0x50, 0x8027AB2u, 2);
              }
              break;
            case 'Q':
              result = (unsigned __int8)byte_200015AC;
              if ( byte_200015AC == 2 || byte_200015AC == 3 )
              {
                byte_200036AF = 1;
                word_200036B7 = 0;
                byte_200015AC = 3;
                sub_8004FE0(
                  (int)dword_80291F0,
                  *(unsigned __int8 *)(a1 + 2),
                  *(unsigned __int8 *)(a1 + 3),
                  *(unsigned __int8 *)(a1 + 4),
                  *(unsigned __int8 *)(a1 + 5),
                  *(unsigned __int8 *)(a1 + 6));
                dword_200015C4 = *(unsigned __int8 *)(a1 + 3)
                               | (*(unsigned __int8 *)(a1 + 4) << 8)
                               | (*(unsigned __int8 *)(a1 + 5) << 16)
                               | (*(unsigned __int8 *)(a1 + 6) << 24);
                sub_8004FE0((int)sub_800CF08);
                sub_800F558((_DWORD *)(dword_200015C4 + 134490112), a1 + 7, 0x10u);
                if ( dword_200015C4 + 128 == dword_200015C8 )
                {
                  sub_8004FE0((int)sub_800CF40);
                  byte_200015AA = 1;
                }
                sub_8004FE0((int)sub_8029114, dword_200015C4 + 128, dword_200015C8);
                sub_800CB88(0x80u, a1 + 7);
                return (int)sub_800CF80((_BYTE *)0x51, a1 + 3, 4);
              }
              break;
            case 'R':
              sub_8004FE0(
                (int)"*** case 0x52: buf[2] = %#x, g_bin_crc = %#x, bin_crc = %#x.\r\n",
                82,
                dword_200015BC,
                dword_200015CC);
              result = (unsigned __int8)byte_200015AC;
              if ( byte_200015AC == 3 )
              {
                byte_200036AF = 1;
                word_200036B7 = 0;
                byte_200015AC = 4;
                if ( dword_200015BC == dword_200015CC )
                {
                  if ( MEMORY[0x8050004] == -805230336 )
                  {
                    sub_8004FE0((int)dword_800CEA4);
                    byte_200015B2 = 1;
                    sub_800CF80((_BYTE *)0x52, (unsigned int)&byte_200015B2, 2);
                    sub_8004FE0((int)dword_800CEB0);
                    dword_20010F60 = 134479872;
                    dword_20010F68 = 1;
                    dword_20010F64 = dword_200015C8;
                    dword_20010F6C = (unsigned __int16)dword_200015C0;
                    sub_800F558((_DWORD *)0x8040000, (int)&dword_20010F60, 2u);
                  }
                  else
                  {
                    sub_8004FE0((int)sub_800CF5C);
                    byte_200015B2 = 0;
                    sub_800CF80((_BYTE *)0x52, (unsigned int)&byte_200015B2, 2);
                  }
                }
                else
                {
                  sub_8004FE0((int)dword_800CF68);
                  byte_200015B2 = 0;
                  sub_800CF80((_BYTE *)0x52, (unsigned int)&byte_200015B2, 2);
                }
                sub_800CF80((_BYTE *)0x52, (unsigned int)&byte_200015B2, 2);
                byte_200015AC = 0;
                sub_80031E4();
                sub_801EE84(v6);
                __asm { MSR.W           FAULTMASK, R7 }
                sub_8013324();
              }
              break;
          }
        }
      }
    }
  }
  return result;
}
// 800CE3C: variable 'v6' is possibly undefined
// 800CEA4: using guessed type int dword_800CEA4[3];
// 800CEB0: using guessed type int dword_800CEB0[5];
// 800CEC8: using guessed type int sub_800CEC8();
// 800CF08: using guessed type int sub_800CF08();
// 800CF40: using guessed type int sub_800CF40();
// 800CF5C: using guessed type int sub_800CF5C();
// 800CF68: using guessed type int dword_800CF68[5];
// 801EE84: using guessed type __int64 __fastcall sub_801EE84(_DWORD);
// 8029114: using guessed type int sub_8029114();
// 80291AC: using guessed type int dword_80291AC[17];
// 80291F0: using guessed type int dword_80291F0[22];
// 200015A8: using guessed type char byte_200015A8;
// 200015AA: using guessed type char byte_200015AA;
// 200015AC: using guessed type char byte_200015AC;
// 200015AE: using guessed type __int16 word_200015AE;
// 200015B0: using guessed type __int16 word_200015B0;
// 200015B2: using guessed type char byte_200015B2;
// 200015BC: using guessed type int dword_200015BC;
// 200015C0: using guessed type int dword_200015C0;
// 200015C4: using guessed type int dword_200015C4;
// 200015C8: using guessed type int dword_200015C8;
// 200015CC: using guessed type int dword_200015CC;
// 200036AF: using guessed type char byte_200036AF;
// 200036B7: using guessed type __int16 word_200036B7;
// 20010F60: using guessed type int dword_20010F60;
// 20010F64: using guessed type int dword_20010F64;
// 20010F68: using guessed type int dword_20010F68;
// 20010F6C: using guessed type int dword_20010F6C;

//----- (0800CF80) --------------------------------------------------------
_BYTE *__fastcall sub_800CF80(_BYTE *result, unsigned int a2, signed int a3)
{
  char v3; // r7
  int v6; // r5
  unsigned int i; // r4
  int v8; // r2
  int v9; // r2

  v3 = (char)result;
  if ( a2 )
  {
    v6 = a3 + 6;
    sub_8002364(byte_200038FC, 512);
    byte_200038FC[0] = 115;
    byte_200038FD = (unsigned __int16)(a3 + 6) >> 8;
    byte_200038FE = a3 + 6;
    byte_200038FF = v3;
    byte_20003900 = 0;
    if ( a3 > 0 )
      qmemcpy((unsigned int)&unk_20003901, a2, a3);
    byte_200015AD = 0;
    for ( i = 0; i < v6 - 1; ++i )
    {
      v8 = (unsigned __int8)byte_200038FC[i];
      byte_200015AD ^= v8;
      sub_8004FE0((int)"### OTA send data buf[%d] = %#x\r\n", i, v8);
    }
    v9 = (unsigned __int8)byte_200015AD;
    byte_200038FC[v6 - 1] = byte_200015AD;
    sub_8004FE0((int)"### OTA send data buf[%d] = %#x\r\n", v6 - 1, v9);
    return sub_80073DC((unsigned __int8 *)byte_200038FC, v6);
  }
  return result;
}
// 200015AD: using guessed type char byte_200015AD;
// 200038FD: using guessed type char byte_200038FD;
// 200038FE: using guessed type char byte_200038FE;
// 200038FF: using guessed type char byte_200038FF;
// 20003900: using guessed type char byte_20003900;

//----- (0800D030) --------------------------------------------------------
unsigned __int8 *sub_800D030()
{
  unsigned __int8 v0; // r0
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r4
  int v6; // [sp+0h] [bp-28h]
  int v7; // [sp+4h] [bp-24h]
  int v8; // [sp+8h] [bp-20h]
  int v9; // [sp+Ch] [bp-1Ch]
  int v10; // [sp+10h] [bp-18h]
  int v11; // [sp+14h] [bp-14h]
  int v12; // [sp+18h] [bp-10h]
  int v13; // [sp+1Ch] [bp-Ch]
  int v14; // [sp+20h] [bp-8h]

  v0 = sub_8022C24(0, 0, 300);
  v4 = v0;
  if ( v0 )
  {
    if ( v0 == 1 && (unsigned __int8)byte_200036B2 > 2u )
    {
      sub_8005CA0((int)byte_2000373B, v1, v2, v3, v6, v7, v8, v9, v10, v11, v12, v13, v14);
      byte_200036B2 = 0;
      byte_200036B3 = 0;
      sub_8002364(byte_2000373B, 128);
    }
    if ( v4 == 2 && (unsigned __int8)byte_20004247 > 1u && !byte_200015AC )
    {
      sub_8004FE0((int)"\r\n### Mqtt recv: %s\r\n", byte_2000424A);
      word_200036B9 = 0;
      byte_200036B0 = 1;
      sub_800AD3C((int)byte_2000424A, (unsigned __int16)word_20004248);
      word_20004248 = 0;
      byte_20004247 = 0;
      sub_8002364(byte_2000424A, 512);
    }
    if ( v4 == 3 && (unsigned __int16)word_200015AE >= 2u )
    {
      sub_800CBE0((int)&byte_20010F70);
      word_200015AE = 0;
      word_200015B0 = 0;
      sub_8002364(&byte_20010F70, 256);
    }
  }
  else
  {
    if ( byte_200036B2 )
    {
      byte_200036B2 = 0;
      byte_200036B3 = 0;
      sub_8002364(byte_2000373B, 128);
    }
    if ( byte_20004247 )
    {
      word_20004248 = 0;
      byte_20004247 = 0;
      sub_8002364(byte_2000424A, 512);
    }
    if ( word_200015AE )
    {
      word_200015AE = 0;
      word_200015B0 = 0;
      sub_8002364(&byte_20010F70, 256);
    }
    if ( sub_801AAF4(&word_200036B9, 0x3Cu) )
      byte_200036B0 = 0;
  }
  if ( byte_200036AF && sub_801AAF4(&word_200036B7, 0x3Cu) )
    byte_200036AF = 0;
  if ( byte_200015AC )
    return (unsigned __int8 *)sub_8018A74();
  else
    return sub_800E554();
}
// 800D068: variable 'v1' is possibly undefined
// 800D068: variable 'v2' is possibly undefined
// 800D068: variable 'v3' is possibly undefined
// 800D068: variable 'v6' is possibly undefined
// 800D068: variable 'v7' is possibly undefined
// 800D068: variable 'v8' is possibly undefined
// 800D068: variable 'v9' is possibly undefined
// 800D068: variable 'v10' is possibly undefined
// 800D068: variable 'v11' is possibly undefined
// 800D068: variable 'v12' is possibly undefined
// 800D068: variable 'v13' is possibly undefined
// 800D068: variable 'v14' is possibly undefined
// 200015AC: using guessed type char byte_200015AC;
// 200015AE: using guessed type __int16 word_200015AE;
// 200015B0: using guessed type __int16 word_200015B0;
// 200036AF: using guessed type char byte_200036AF;
// 200036B0: using guessed type char byte_200036B0;
// 200036B2: using guessed type char byte_200036B2;
// 200036B3: using guessed type char byte_200036B3;
// 200036B7: using guessed type __int16 word_200036B7;
// 200036B9: using guessed type __int16 word_200036B9;
// 2000373B: using guessed type _BYTE[128];
// 20004247: using guessed type char byte_20004247;
// 20004248: using guessed type __int16 word_20004248;
// 20010F70: using guessed type char byte_20010F70;

//----- (0800D184) --------------------------------------------------------
int __fastcall sub_800D184(int a1)
{
  int v1; // r0
  int v2; // r2
  unsigned int v3; // r1
  int v4; // r1
  int v5; // r3
  int v6; // r1
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int result; // r0
  int v13; // [sp+Ch] [bp-2Ch] BYREF
  int v14; // [sp+10h] [bp-28h] BYREF

  v14 = a1;
  v13 = 0;
  if ( !byte_200015AC )
  {
    v1 = (unsigned __int8)v14;
    switch ( byte_200036B1 )
    {
      case 1:
        if ( (word_20003AFC & 0x7FFFu) <= 0x1FE )
        {
          byte_200038FC[word_20003AFC & 0x7FFF] = v14;
          word_20003AFC = word_20003AFC & 0x8000 | (word_20003AFC + 1) & 0x7FFF;
          if ( (word_20003AFC & 0x7FFFu) > 3 && v1 == 10 && byte_200038FC[(word_20003AFC & 0x7FFF) - 2] == 13 )
            sub_8025224((_DWORD *)dword_20000008, 0, 1, 3, 0, &v13);
        }
        else
        {
          word_20003AFC &= 0x8000u;
          sub_8002364(byte_200038FC, 512);
        }
        break;
      case 2:
        if ( byte_20002EA9 )
        {
          if ( !sub_8024DD8(dword_20000440) )
            sub_8024BE4(dword_20000440, (unsigned int)&v14, &v13, 0);
        }
        else
        {
          v2 = (unsigned __int16)word_200008F4++;
          v3 = (unsigned __int16)word_200008F4;
          byte_20003E75[v2] = v14;
          if ( v3 < 0x7F )
          {
            if ( v3 > 3 && v1 == 10 && byte_20003E75[v3 - 2] == 13 )
            {
              sub_8024BE4(dword_20000430, (unsigned int)byte_20003E75, &v13, 0);
              sub_8002364(byte_20003E75, 128);
              word_200008F4 = 0;
            }
          }
          else
          {
            sub_8002364(byte_20003E75, 128);
            word_200008F4 = 0;
          }
        }
        break;
      case 3:
        if ( (unsigned __int16)word_20000992 < 0x7FFu )
        {
          v4 = (unsigned __int16)word_20000992++;
          byte_2000098D[v4 + 15] = v14;
          if ( (unsigned __int16)word_20000992 > 3u
            && v1 == 10
            && *((_BYTE *)&dword_20000998 + (unsigned __int16)word_20000992 + 2) == 13 )
          {
            sub_8025224((_DWORD *)dword_20000010, 0, 1, 3, 0, &v13);
          }
        }
        else
        {
          word_20000992 = 0;
          sub_8002364(byte_2000099C, 2048);
        }
        break;
    }
  }
  v5 = (unsigned __int16)word_200015AE;
  if ( (unsigned __int16)word_200015AE > 0xFFu )
  {
    word_200015AE = 0;
    word_200015B0 = 0;
    sub_8002364(byte_20010F70, 256);
  }
  else if ( word_200015AE )
  {
    if ( word_200015AE == 1 )
    {
      if ( (_BYTE)v14 )
      {
        word_200015B0 = (unsigned __int8)v14;
        word_200015AE = 2;
        byte_20010F71 = v14;
      }
      else
      {
        word_200015AE = 2;
        byte_20010F71 = 0;
      }
    }
    else if ( word_200015AE == 2 )
    {
      if ( !byte_20010F71 )
        word_200015B0 = (unsigned __int8)v14;
      word_200015AE = 3;
      byte_20010F72 = v14;
    }
    else
    {
      v6 = (unsigned __int16)word_200015B0;
      if ( (unsigned __int16)word_200015AE < (unsigned int)(unsigned __int16)word_200015B0 )
      {
        ++word_200015AE;
        byte_20010F70[v5] = v14;
      }
      if ( v6 == (unsigned __int16)word_200015AE )
        sub_8025224((_DWORD *)dword_2000000C, 0, 3, 3, 0, &v13);
    }
  }
  else if ( (unsigned __int8)v14 == 115 )
  {
    word_200015AE = 1;
    byte_20010F70[0] = 115;
  }
  if ( (unsigned __int8)byte_200036B3 >= 0x80u || byte_200015AC )
  {
LABEL_48:
    byte_200036B3 = 0;
    byte_200036B2 = 0;
    sub_8002364(byte_2000373B, 128);
    goto LABEL_49;
  }
  switch ( byte_200036B3 )
  {
    case 0:
      if ( (unsigned __int8)v14 == 115 )
      {
        v8 = (unsigned __int8)byte_200036B3++;
        byte_200036AC[v8 + 143] = 115;
        byte_200036B2 = 0x80;
        goto LABEL_49;
      }
      goto LABEL_48;
    case 1:
      if ( (unsigned __int8)v14 < 0x80u )
      {
        byte_200036B2 = v14;
        v9 = (unsigned __int8)byte_200036B3++;
        byte_200036AC[v9 + 143] = v14;
        goto LABEL_49;
      }
      goto LABEL_48;
    case 2:
      if ( (unsigned __int8)v14 == 35 )
      {
        v10 = (unsigned __int8)byte_200036B3++;
        byte_200036AC[v10 + 143] = 35;
        goto LABEL_49;
      }
      goto LABEL_48;
  }
  if ( (unsigned __int8)byte_200036B3 < (unsigned int)(unsigned __int8)byte_200036B2
    && (unsigned __int8)byte_200036B3 < 0x80u )
  {
    v7 = (unsigned __int8)byte_200036B3++;
    byte_200036AC[v7 + 143] = v14;
  }
  if ( byte_200036B3 == byte_200036B2 )
    sub_8025224((_DWORD *)dword_2000000C, 0, 1, 3, 0, &v13);
LABEL_49:
  if ( byte_20004245[0] && !byte_200015AC )
  {
    if ( (unsigned __int8)byte_20004247 < 2u && (unsigned __int16)word_20004248 < 0x200u )
    {
      v11 = (unsigned __int16)word_20004248++;
      byte_20004245[v11 + 5] = v14;
    }
    if ( (unsigned __int16)word_20004248 > 0x1FEu )
    {
      word_20004248 = 0;
      sub_8002364(byte_2000424A, 512);
    }
    if ( byte_20004247 )
    {
      if ( byte_20004247 == 1 )
      {
        if ( (unsigned __int8)v14 == 10 && *((_BYTE *)&word_20004248 + (unsigned __int16)word_20004248) == 13 )
        {
          sub_8025224((_DWORD *)dword_2000000C, 0, 2, 3, 0, &v13);
          byte_20004247 = 2;
        }
      }
      else if ( byte_20004247 != 2 )
      {
        byte_20004247 = 0;
      }
    }
    else if ( word_20004248
           && (unsigned __int16)word_20004248 <= 9u
           && aV1rzima0gcsqgs[(unsigned __int16)word_20004248 + 711] == *((_BYTE *)&word_20004248
                                                                        + (unsigned __int16)word_20004248
                                                                        + 1) )
    {
      byte_20004247 = word_20004248 == 9;
    }
    else
    {
      word_20004248 = 0;
      sub_8002364(byte_2000424A, 512);
    }
  }
  if ( (byte_20004237 || byte_20000928) && !byte_200015AC && sub_800E458((unsigned __int8)v14) )
  {
    sub_8024BE4(dword_20000450, (unsigned int)&byte_200036BB, 0, 0);
    sub_8002364(&byte_200036BB, 256);
  }
  result = (unsigned __int8)byte_200015DD;
  if ( byte_200015DD == 1 )
  {
    result = (unsigned __int8)byte_200015AC;
    if ( !byte_200015AC )
    {
      result = sub_80044EC((unsigned __int8)v14);
      if ( result )
      {
        byte_200015DD = result;
        return sub_8024CF0(dword_2000042C, 0);
      }
    }
  }
  return result;
}
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 20000010: using guessed type int dword_20000010;
// 2000042C: using guessed type int dword_2000042C;
// 20000430: using guessed type int dword_20000430;
// 20000440: using guessed type int dword_20000440;
// 20000450: using guessed type int dword_20000450;
// 200008F4: using guessed type __int16 word_200008F4;
// 20000928: using guessed type char byte_20000928;
// 20000992: using guessed type __int16 word_20000992;
// 20000998: using guessed type int dword_20000998;
// 2000099C: using guessed type unsigned __int8 byte_2000099C[2048];
// 200015AC: using guessed type char byte_200015AC;
// 200015AE: using guessed type __int16 word_200015AE;
// 200015B0: using guessed type __int16 word_200015B0;
// 200015DD: using guessed type char byte_200015DD;
// 20002EA9: using guessed type char byte_20002EA9;
// 200036B1: using guessed type char byte_200036B1;
// 200036B2: using guessed type char byte_200036B2;
// 200036B3: using guessed type char byte_200036B3;
// 200036BB: using guessed type char byte_200036BB;
// 2000373B: using guessed type _BYTE byte_2000373B[128];
// 20003AFC: using guessed type __int16 word_20003AFC;
// 20003E75: using guessed type _BYTE byte_20003E75[128];
// 20004237: using guessed type char byte_20004237;
// 20004247: using guessed type char byte_20004247;
// 20004248: using guessed type __int16 word_20004248;
// 20010F71: using guessed type char byte_20010F71;
// 20010F72: using guessed type char byte_20010F72;

//----- (0800D640) --------------------------------------------------------
int sub_800D640()
{
  int result; // r0
  int v1; // r4

  if ( !word_20000920 || (result = sub_801AAF4(&word_20000920, 5u)) != 0 )
  {
    sub_801AAF4(&word_20000920, 5u);
    sub_800F8D8();
    result = sub_8024F80(dword_20000458, 500);
    if ( result )
    {
      sub_8002364(byte_2000484A, 1024);
      sprintf(
        (int)byte_2000484A,
        "get_power=%d|%d|%d|%d|%d",
        dword_20002D9C,
        dword_20002DA0,
        dword_20002DA4,
        dword_20002DA8,
        (int)*(float *)&dword_20002798);
      v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000484A);
      sub_8002364(byte_2000444A, 1024);
      sprintf(
        (int)byte_2000444A,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
        (const char *)&dword_200038E3,
        byte_200037BB,
        v1,
        byte_2000484A);
      sub_800E28A(byte_2000444A);
      return sub_8024A40(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20000920: using guessed type __int16 word_20000920;
// 20002798: using guessed type int dword_20002798;
// 20002D9C: using guessed type int dword_20002D9C;
// 20002DA0: using guessed type int dword_20002DA0;
// 20002DA4: using guessed type int dword_20002DA4;
// 20002DA8: using guessed type int dword_20002DA8;
// 200038E3: using guessed type int dword_200038E3;
// 2000444A: using guessed type unsigned __int8 byte_2000444A[1024];

//----- (0800D758) --------------------------------------------------------
int __fastcall sub_800D758(int result)
{
  unsigned __int8 *v1; // r6
  unsigned __int8 *v2; // r0
  bool v3; // zf
  unsigned int v4; // r5
  int v5; // r0
  unsigned int v6; // r2
  unsigned __int8 *v7; // r0
  unsigned int v8; // r5
  unsigned __int8 *v9; // r0
  int *v10; // r4
  unsigned __int8 *v11; // r0
  unsigned int v12; // r0
  unsigned __int8 *v13; // r0
  unsigned __int8 v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 v16; // r0
  unsigned __int8 *v17; // r0
  __int16 v18; // r0
  unsigned __int16 v19; // r0
  unsigned __int16 v20; // r0
  char v21[32]; // [sp+0h] [bp-88h] BYREF
  unsigned __int8 v22[64]; // [sp+20h] [bp-68h] BYREF
  int v23; // [sp+60h] [bp-28h] BYREF
  int v24; // [sp+64h] [bp-24h]
  int v25; // [sp+68h] [bp-20h]
  int v26; // [sp+6Ch] [bp-1Ch]

  v1 = (unsigned __int8 *)result;
  if ( result )
  {
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    sub_8002364(v22, 64);
    sub_8002364(v21, 32);
    v2 = (unsigned __int8 *)sub_80023CE((int)v1, 0x2Cu);
    v3 = v2 == 0;
    do
    {
      if ( v3 )
        goto LABEL_19;
      v4 = (unsigned int)(v2 + 1);
      v5 = sub_80023CE((int)v1, 0x3Du);
      if ( v5 )
        goto LABEL_7;
      v2 = strstr(v1, "seq_check");
      v3 = v2 == 0;
    }
    while ( !v2 );
    LOBYTE(v5) = sub_80023CE((int)v1, 0x6Bu) + 1;
LABEL_7:
    v6 = (unsigned __int8)(v5 - v4);
    if ( v6 > 0x20 )
    {
LABEL_19:
      sprintf((int)v22, "cd=%d,err_cmd", 18);
      v20 = (unsigned __int16)sub_80023E2(v22);
      return sub_800C418((int)v22, v20);
    }
    qmemcpy((unsigned int)v21, v4, v6);
    if ( strstr(v1, "meter=") )
    {
      v7 = strstr(v1, "meter=");
      v8 = (unsigned __int8)sub_8002644((char *)v7 + 6);
      sub_8004FE0((int)"[MQTT] Set meter type = %d.\r\n", v8);
      if ( (unsigned __int8)byte_20002EA9 != v8 && v8 < 8 )
      {
        sub_8018B78();
        byte_20002EA9 = v8;
        byte_200015D6 = 1;
      }
      if ( byte_20002EA9 == 2 )
      {
        byte_200015A4 = 1;
        byte_200015A5 = 0;
      }
      else if ( byte_20002EA9 == 7 )
      {
        byte_200015A5 = 1;
        byte_200015A4 = 0;
      }
      else
      {
        byte_200015A4 = 0;
        byte_200015A5 = 0;
      }
      byte_200015A6 = 0;
      if ( strstr(v1, "mac=") )
      {
        v9 = strstr(v1, "mac=");
        v10 = (int *)(v9 + 4);
        v23 = *((_DWORD *)v9 + 1);
        v24 = *((_DWORD *)v9 + 2);
        v25 = *((_DWORD *)v9 + 3);
        if ( sub_80023F0((int)&v23, (int)&dword_20004238) )
        {
          dword_20004238 = *v10;
          dword_2000423C = v10[1];
          dword_20004240 = v10[2];
          sub_8018B78();
        }
      }
    }
    else if ( strstr(v1, "dchrg=") )
    {
      v11 = strstr(v1, "dchrg=");
      v12 = (unsigned __int8)sub_8002644((char *)v11 + 6);
      if ( (unsigned __int8)byte_20002EA8 != (unsigned __int8)v12 && (unsigned __int8)v12 <= 1u )
        sub_8005850(v12);
    }
    else if ( strstr(v1, "seq_check") )
    {
      sub_8018B78();
    }
    else if ( strstr(v1, "rechrg_seq") )
    {
      v13 = strstr(v1, "rechrg_seq=");
      v14 = sub_8002644((char *)v13 + 11);
      sub_8005744(v14);
    }
    else if ( strstr(v1, "ctrl_rate=") )
    {
      v15 = strstr(v1, "ctrl_rate=");
      v16 = sub_8002644((char *)v15 + 10);
      sub_8005728(v16);
    }
    else if ( strstr(v1, "shelly_port=") )
    {
      v17 = strstr(v1, "shelly_port=");
      v18 = sub_8002644((char *)v17 + 12);
      sub_800586C(v18);
    }
    sprintf((int)v22, "cd=%d,%s", 18, v21);
    v19 = (unsigned __int16)sub_80023E2(v22);
    return sub_800C418((int)v22, v19);
  }
  return result;
}
// 200015A4: using guessed type char byte_200015A4;
// 200015A5: using guessed type char byte_200015A5;
// 200015A6: using guessed type char byte_200015A6;
// 200015D6: using guessed type char byte_200015D6;
// 20002EA8: using guessed type char byte_20002EA8;
// 20002EA9: using guessed type char byte_20002EA9;
// 20004238: using guessed type int dword_20004238;
// 2000423C: using guessed type int dword_2000423C;
// 20004240: using guessed type int dword_20004240;

//----- (0800D9EC) --------------------------------------------------------
int sub_800D9EC()
{
  unsigned int v0; // r4
  unsigned __int8 *v2; // r7
  unsigned __int8 *v3; // r0

  v0 = 0;
  sub_8018928(4, 411);
  while ( 1 )
  {
    if ( v0 >= 3 )
      return 0;
    if ( byte_20004236 )
      return 0;
    v2 = sub_80023E2((unsigned __int8 *)byte_20002ED1);
    v3 = sub_80023E2((unsigned __int8 *)byte_20002EB1);
    if ( sub_800EF54(byte_20002EB1, byte_20002ED1, (int)v3, (unsigned int)v2) )
      break;
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  if ( !sub_800F058(2) )
    return 0;
  sub_8004FE0((int)"Set wifi success! ### wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002EB1, byte_20002ED1);
  sub_80055F0(0x400u, byte_20002EB1, 0x20u);
  sub_80055F0(0x420u, byte_20002ED1, 0x40u);
  byte_20004245 = 0;
  sub_8009FA0(0);
  return 1;
}
// 20004236: using guessed type char byte_20004236;
// 20004245: using guessed type char byte_20004245;

//----- (0800DAC0) --------------------------------------------------------
int __fastcall sub_800DAC0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v8; // r4

  v8 = 0;
  if ( !a1 )
    return 0;
  if ( sub_8024F80(dword_20000458, 500) )
  {
    sub_8002364(byte_200038FC, 512);
    word_20003AFC &= 0x8000u;
    sub_800ECDC(a1);
    byte_200036B1 = 1;
    sub_8004FE0((int)dword_800DBB0, a1);
    if ( sub_8022C24(0, 0, a4) == 1 )
    {
      sub_80232B4(a4);
      byte_200038FC[word_20003AFC & 0x7FFF] = 0;
      sub_8004FE0((int)sub_800DBD0, byte_200038FC);
      if ( (unsigned int)a2 | (unsigned int)a3 )
      {
        if ( a2 && a3 && strstr((unsigned __int8 *)byte_200038FC, a2) && strstr((unsigned __int8 *)byte_200038FC, a3) )
        {
          v8 = 1;
        }
        else if ( a2 && strstr((unsigned __int8 *)byte_200038FC, a2) )
        {
          v8 = 1;
        }
        else if ( strstr((unsigned __int8 *)byte_200038FC, a3) )
        {
          v8 = 1;
        }
      }
      else
      {
        sub_8004FE0((int)"Set expected reply content error!\r\n");
      }
    }
    byte_200036B1 = 0;
    sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return v8;
}
// 800DBB0: using guessed type int dword_800DBB0[8];
// 800DBD0: using guessed type int sub_800DBD0();
// 20000458: using guessed type int dword_20000458;
// 200036B1: using guessed type char byte_200036B1;
// 20003AFC: using guessed type __int16 word_20003AFC;

//----- (0800DC14) --------------------------------------------------------
BOOL __fastcall sub_800DC14(int a1, const char *a2, int a3)
{
  unsigned int v6; // r5
  BOOL result; // r0
  unsigned __int8 v8[88]; // [sp+8h] [bp-58h] BYREF

  v6 = 0;
  sub_8002364(v8, 64);
  while ( v6 < 3 )
  {
    if ( a1 )
    {
      switch ( a1 )
      {
        case 1:
          sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d", a2, 1);
          result = sub_800DAC0(v8, 0, "OK", 300) != 0;
          break;
        case 2:
          sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d,%d", a2, 2, a3);
          if ( sub_800DAC0(v8, "CONNECT", 0, 300) )
          {
            sub_8004FE0((int)"UPLOAD CONNECT...\r\n");
            result = 1;
          }
          else
          {
            result = 0;
          }
          break;
        case 3:
          result = sub_800DAC0("AT+QSSLCERT?", 0, "OK", 300) != 0;
          break;
        default:
          result = 0;
          break;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d", a2, 0);
      result = sub_800DAC0(v8, "OK", 0, 300) != 0;
    }
    if ( result )
      return result;
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (0800DD3C) --------------------------------------------------------
int __fastcall sub_800DD3C(int a1, int a2, const char *a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"ciphersuite\",%d,%s", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"ciphersuite\",%d", a2);
      if ( sub_800DAC0(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800DDF0) --------------------------------------------------------
int sub_800DDF0()
{
  switch ( byte_20000922 )
  {
    case 0:
      sub_8004FE0((int)"Check certificate...\r\n");
      if ( !sub_800DC14(3, 0, 0) )
        goto LABEL_10;
      if ( strstr((unsigned __int8 *)byte_200038FC, "\"CA\",1") )
        byte_200036B4 |= 1u;
      if ( strstr((unsigned __int8 *)byte_200038FC, "\"User Cert\",1") )
        byte_200036B4 |= 2u;
      if ( strstr((unsigned __int8 *)byte_200038FC, "\"User Key\",1") )
        byte_200036B4 |= 4u;
      if ( byte_200036B4 != 7 )
      {
LABEL_10:
        byte_20000922 = 1;
        return 0;
      }
      sub_8004FE0((int)"Certificates are completed!\r\n");
      return 1;
    case 1:
      if ( (unsigned __int8)byte_200036B4 << 31 )
        byte_20000922 = 4;
      else
        byte_20000922 = 2;
      return 0;
    case 2:
      if ( sub_800DC14(2, "CA", 1187) )
        byte_20000922 = 3;
      else
        byte_20000922 = 1;
      return 0;
    case 3:
      sub_8004FE0((int)"Uploading CA certificate...\r\n");
      sub_800E28A((unsigned __int8 *)"fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n");
      byte_20000922 = 10;
      return 0;
    case 4:
      sub_8004FE0((int)"Checking User Cert...\r\n");
      if ( (byte_200036B4 & 2) != 0 )
        byte_20000922 = 7;
      else
        byte_20000922 = 5;
      return 0;
    case 5:
      if ( sub_800DC14(2, "User Cert", 1224) )
        byte_20000922 = 6;
      else
        byte_20000922 = 4;
      return 0;
    case 6:
      sub_8004FE0((int)"Uploading User Cert certificate...\r\n");
      sub_800E28A((unsigned __int8 *)dword_8026F58 + 1);
      byte_20000922 = 10;
      return 0;
    case 7:
      sub_8004FE0((int)"Checking User Key...\r\n");
      if ( (byte_200036B4 & 4) != 0 )
        byte_20000922 = 10;
      else
        byte_20000922 = 8;
      return 0;
    case 8:
      if ( sub_800DC14(2, "User Key", 1679) )
        byte_20000922 = 9;
      else
        byte_20000922 = 7;
      return 0;
    case 9:
      sub_8004FE0((int)"Uploading User Key certificate...\r\n");
      sub_800E28A((_BYTE *)&dword_80273EC[13] + 2);
      byte_20000922 = 10;
      return 0;
    case 10:
      if ( sub_801AACC(&word_20000924, 0x4E20u) )
        byte_20000922 = 0;
      return 0;
    default:
      return 0;
  }
}
// 8026F58: using guessed type int dword_8026F58[3];
// 80273EC: using guessed type int[52];
// 20000922: using guessed type char byte_20000922;
// 20000924: using guessed type _WORD;
// 200036B4: using guessed type char byte_200036B4;

//----- (0800E07C) --------------------------------------------------------
int __fastcall sub_800E07C(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"verify\",%d,%d", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"verify\",%d", a2);
      if ( sub_800DAC0(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800E128) --------------------------------------------------------
int __fastcall sub_800E128(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"version\",%d,%d", a2, a3);
        if ( sub_800DAC0(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"version\",%d", a2);
      if ( sub_800DAC0(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_80232B4(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800E1D4) --------------------------------------------------------
int sub_800E1D4()
{
  unsigned int v0; // r4

  v0 = 0;
  sub_801227E(1207962624, 1024, 1);
  sub_80232B4(1000);
  while ( v0 < 3 )
  {
    if ( sub_800DAC0("AT+QRST", (unsigned __int8 *)&dword_800E240, 0, 300) )
    {
      sub_80232B4(1000);
      if ( sub_800DAC0("AT", (unsigned __int8 *)&dword_800E240, 0, 300) )
      {
        sub_8004FE0((int)"Fc41d start!\r\n");
        return 1;
      }
    }
    sub_8007CF8(0);
    v0 = (unsigned __int8)(v0 + 1);
    sub_80232B4(100);
  }
  sub_8004FE0((int)"Fc41d start err!\r\n");
  return 0;
}
// 800E240: using guessed type int dword_800E240;

//----- (0800E274) --------------------------------------------------------
int __fastcall sub_800E274(int a1, int a2)
{
  if ( !a1 )
    return 0;
  sub_801CF8C(a1, a2);
  return a2;
}

//----- (0800E28A) --------------------------------------------------------
int __fastcall sub_800E28A(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !a1 )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  if ( !v2 )
    return 0;
  sub_801CF8C((int)a1, v2);
  return 1;
}

//----- (0800E2B0) --------------------------------------------------------
int __fastcall sub_800E2B0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v8; // r4
  unsigned __int16 v9; // r0
  unsigned __int8 v11[156]; // [sp+4h] [bp-9Ch] BYREF

  v8 = 0;
  sub_8002364(v11, 128);
  if ( !a1 )
    return 0;
  if ( sub_8024F80(dword_20000458, 400) )
  {
    v9 = (unsigned __int16)sub_80023E2(a1);
    sub_800E274((int)a1, (unsigned __int16)(v9 - 1));
    byte_200036B1 = 2;
    if ( sub_8024E28(dword_20000430, (unsigned int)v11, a4) && (unsigned int)a2 | (unsigned int)a3 )
    {
      if ( a2 && a3 && strstr(v11, a2) && strstr(v11, a3) )
      {
        v8 = 1;
      }
      else if ( a2 && strstr(v11, a2) )
      {
        v8 = 1;
      }
      else if ( strstr(v11, a3) )
      {
        v8 = 1;
      }
    }
    byte_200036B1 = 0;
    sub_8024A40(dword_20000458, 0, 0, 0);
  }
  return v8;
}
// 20000430: using guessed type int dword_20000430;
// 20000458: using guessed type int dword_20000458;
// 200036B1: using guessed type char byte_200036B1;

//----- (0800E36C) --------------------------------------------------------
int sub_800E36C()
{
  int result; // r0
  unsigned int i; // r4

  result = (unsigned __int8)byte_20000507;
  if ( byte_20000507 == 1 )
  {
    for ( i = 0; i < 0xA; i = (unsigned __int8)(i + 1) )
    {
      result = (int)&byte_20002E37[10 * i];
      if ( *(__int16 *)(result + 4) > 800 )
      {
        *(_WORD *)(result + 4) = 800;
        result = sub_80055B4(i);
      }
    }
  }
  return result;
}
// 20000507: using guessed type char byte_20000507;

//----- (0800E3A8) --------------------------------------------------------
int __fastcall sub_800E3A8(int result)
{
  if ( result )
  {
    if ( result == 1 )
    {
      if ( sub_800DC14(2, "User Cert", 1224) )
        return sub_800E28A((unsigned __int8 *)dword_8026F58 + 1);
    }
    else
    {
      if ( result != 2 )
        return result;
      if ( sub_800DC14(2, "User Key", 1679) )
        return sub_800E28A((_BYTE *)&dword_80273EC[13] + 2);
    }
  }
  else if ( sub_800DC14(2, (const char *)&dword_800E42C, 1187) )
  {
    return sub_800E28A((unsigned __int8 *)"fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n");
  }
  return sub_8004FE0((int)"\r\nUploading err!\r\n");
}
// 800E42C: using guessed type int dword_800E42C;
// 8026F58: using guessed type int dword_8026F58[3];
// 80273EC: using guessed type int dword_80273EC[52];

//----- (0800E458) --------------------------------------------------------
int __fastcall sub_800E458(int a1)
{
  char *v2; // r1

  if ( (unsigned __int8)byte_200008F0 >= 0x7Fu )
  {
    sub_8002364(&byte_200036BB, 128);
    byte_200008F0 = 0;
    return 0;
  }
  switch ( byte_200008F0 )
  {
    case 0:
      if ( a1 == 43 )
      {
        byte_200008F0 = 1;
        byte_200036BB = 43;
      }
      return 0;
    case 1:
      if ( a1 == 81 )
      {
        byte_200008F0 = 2;
        byte_200036BC = 81;
        return 0;
      }
      goto LABEL_12;
    case 2:
      if ( a1 != 73 && a1 != 87 && a1 != 71 )
      {
        byte_200008F0 = 3;
        byte_200036BD = a1;
        return 0;
      }
LABEL_12:
      sub_8002364(&byte_200036BB, 128);
      byte_200008F0 = 0;
      return 0;
  }
  if ( a1 != 10 )
  {
    v2 = &byte_200036AC[(unsigned __int8)byte_200008F0++];
    v2[15] = a1;
    return 0;
  }
  byte_200036AC[(unsigned __int8)byte_200008F0 + 15] = 10;
  byte_200008F0 = 0;
  return 1;
}
// 200008F0: using guessed type char byte_200008F0;
// 200036BB: using guessed type char byte_200036BB;
// 200036BC: using guessed type char byte_200036BC;
// 200036BD: using guessed type char byte_200036BD;

//----- (0800E4F8) --------------------------------------------------------
int __fastcall sub_800E4F8(int a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  sprintf((int)v4, "AT+QURCCFG=%d", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DAC0(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_80232B4(100);
  }
  return 0;
}

//----- (0800E554) --------------------------------------------------------
unsigned __int8 *sub_800E554()
{
  unsigned __int8 *result; // r0
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // [sp+0h] [bp-128h]
  int v12; // [sp+4h] [bp-124h] BYREF
  const char *v13; // [sp+8h] [bp-120h]
  const char *v14; // [sp+Ch] [bp-11Ch]
  int v15; // [sp+10h] [bp-118h]
  int v16; // [sp+14h] [bp-114h]
  int v17; // [sp+18h] [bp-110h]
  int v18; // [sp+1Ch] [bp-10Ch]
  int v19; // [sp+20h] [bp-108h]
  int v20; // [sp+24h] [bp-104h]
  const char *v21; // [sp+28h] [bp-100h]
  const char *v22; // [sp+2Ch] [bp-FCh]
  int v23; // [sp+30h] [bp-F8h]
  int v24; // [sp+34h] [bp-F4h]
  int v25; // [sp+38h] [bp-F0h]
  int v26; // [sp+3Ch] [bp-ECh]
  int v27; // [sp+40h] [bp-E8h]
  int v28; // [sp+44h] [bp-E4h]

  sub_8002364(&v12, 256);
  sub_8002364(&v12, 256);
  result = (unsigned __int8 *)sub_8024E28(dword_20000450, (unsigned int)&v12, 0);
  if ( result == (unsigned __int8 *)1 )
  {
    sub_8004FE0((int)&loc_800E7A8, &v12);
    if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: ") )
    {
      if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 0") )
      {
        byte_2000098E = 1;
        sub_8004FE0((int)&loc_800E7E8);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 4") )
      {
        sub_8004FE0((int)&loc_800E828);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 9") )
      {
        byte_2000098E = 4;
        sub_8004FE0((int)"ar=%d,gen=%d,ble=%d,shelly_p=%d", v1, v2, v3, v11);
      }
      return sub_8002364(&v12, 256);
    }
    if ( strstr((unsigned __int8 *)&v12, "+QMT") )
    {
      if ( strstr((unsigned __int8 *)&v12, "+QMTCONN: 0,3") )
      {
        sub_8004FE0((int)&loc_800E8A0);
        byte_20004245[0] = 1;
        byte_20004246 = 1;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTCONN: 0,0,0") )
      {
        sub_8004FE0((int)&loc_800E8E4);
        byte_20004246 = 5;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTSUB: 0,1,0,0") )
      {
        sub_8004FE0((int)&loc_800E930);
        byte_20004246 = 7;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTPUB: 0,0,0") )
      {
        sub_8004FE0((int)&loc_800E974);
        byte_20004246 = 8;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTCLOSE: 0,0") )
      {
        sub_8004FE0((int)&loc_800E974);
        byte_20004246 = 9;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,0") )
      {
        sub_8004FE0((int)&loc_800E9C8);
        byte_20004246 = 6;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,2") )
      {
        sub_8004FE0(
          (int)"p_w=%d,ct_t=%d,phase_t=%d,dchrg_t=%d,bms_v=%d,fc_v=%s,wifi_n=%s,seq_s=%d,ctrl_r=%d,par=%d,gen=%d,ble=%d,shelly_p=%d",
          v4,
          v5,
          v6,
          v11,
          v12,
          v13,
          v14,
          v15,
          v16,
          v17,
          v18,
          v19,
          v20);
        byte_20004245[0] = 0;
        byte_20004246 = 4;
        sub_8018928(4, 408);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,-1") )
      {
        sub_8004FE0((int)"ter_disconnect_cnt = %d!\r\n", v7);
        byte_20004245[0] = 0;
        byte_20004246 = 3;
        sub_8018928(4, 409);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTSTAT:") )
      {
        sub_8004FE0((int)&loc_800EA2C);
        sub_8018928(4, 410);
        if ( byte_20000928 )
          byte_20004245[0] = 0;
        else
          byte_200036AC[0] = 2;
      }
      return sub_8002364(&v12, 256);
    }
    else
    {
      if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:") )
      {
        if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:WLAN_CONNECTED")
          || strstr((unsigned __int8 *)&v12, "+QSTASTAT:GOT_IP") )
        {
          sub_8004FE0((int)&loc_800EAA8);
          byte_20000928 = 1;
          sub_8018928(4, 404);
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:WLAN DISCONNECTED")
               || strstr((unsigned __int8 *)&v12, "+QSTASTAT:SCAN_NO_AP") )
        {
          sub_8004FE0(
            (int)"%d,htt_p=%d,prc_c=%d,prc_d=%d,wif_s=%d,inc_a=%d,set_v=%d,mcp_w=%d,mdp_w=%d,ct_t=%d,phase_t=%d,dchrg_t=%d,bms_v=%d,fc_v=%s,wifi_n=%s,seq_s=%d,ctrl_r=%d,par=%d,gen=%d,ble=%d,shelly_p=%d",
            v8,
            v9,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19,
            v20,
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v28);
          byte_20000928 = 0;
          byte_200036AC[0] = 2;
          sub_8018928(4, 405);
        }
        return sub_8002364(&v12, 256);
      }
      result = strstr((unsigned __int8 *)&v12, "+QBLESTAT:");
      if ( result )
      {
        if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:ADVERTISING") )
        {
          sub_8004FE0((int)&loc_800EB3C);
          byte_20004237 = 1;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:CONNECTED") )
        {
          sub_8004FE0((int)sub_800EBEC);
          byte_20004237 = 2;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:DISCONNECTED") )
        {
          sub_8004FE0((int)dword_800EC34);
          byte_20004237 = 3;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:NOINIT")
               || strstr((unsigned __int8 *)&v12, "+QBLESTAT:INIT") )
        {
          sub_8004FE0((int)&dword_800EC98);
          byte_20004237 = 0;
          sub_8018928(4, 406);
          if ( byte_20000506 == 1 )
            byte_200036AC[0] = 2;
          else
            byte_200036AC[0] = 0;
        }
        return sub_8002364(&v12, 256);
      }
    }
  }
  return result;
}
// 800E5D0: variable 'v1' is possibly undefined
// 800E5D0: variable 'v2' is possibly undefined
// 800E5D0: variable 'v3' is possibly undefined
// 800E5D0: variable 'v11' is possibly undefined
// 800E692: variable 'v4' is possibly undefined
// 800E692: variable 'v5' is possibly undefined
// 800E692: variable 'v6' is possibly undefined
// 800E6B4: variable 'v7' is possibly undefined
// 800E74E: variable 'v8' is possibly undefined
// 800E74E: variable 'v9' is possibly undefined
// 800E74E: variable 'v10' is possibly undefined
// 800EC34: using guessed type int dword_800EC34[9];
// 800EC98: using guessed type int dword_800EC98;
// 20000450: using guessed type int dword_20000450;
// 20000506: using guessed type char byte_20000506;
// 20000928: using guessed type char byte_20000928;
// 2000098E: using guessed type char byte_2000098E;
// 20004237: using guessed type char byte_20004237;
// 20004246: using guessed type char byte_20004246;

//----- (0800EBEC) --------------------------------------------------------
void __fastcall sub_800EBEC(int a1, int a2, int a3, int a4)
{
  *(_WORD *)(a4 + a2) = a4;
  JUMPOUT(0x800F0E2);
}
// 800EBEE: control flows out of bounds to 800F0E2

//----- (0800ECDC) --------------------------------------------------------
int __fastcall sub_800ECDC(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !a1 )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  if ( !v2 )
    return 0;
  sub_801CF8C((int)a1, v2);
  sub_801CF8C((int)&dword_800ED08, 2);
  return 1;
}
// 800ED08: using guessed type int dword_800ED08;

//----- (0800ED0C) --------------------------------------------------------
int sub_800ED0C()
{
  unsigned __int8 *v1; // r6
  unsigned __int8 *v2; // r0

  if ( byte_200015AC )
    return 0;
  if ( (unsigned __int8)byte_20000927 > 0xAu )
  {
    byte_20000927 = 0;
    byte_20000926 = 2;
    if ( byte_20004237 != 2 && !byte_200036B0 )
      sub_8007CF8(1);
  }
  if ( byte_20000928 )
  {
    byte_20000927 = 0;
    byte_20000926 = 0;
    return 1;
  }
  if ( byte_20000926 )
  {
    switch ( byte_20000926 )
    {
      case 1:
        if ( sub_801AAF4(&word_2000092E, 0x14u) )
        {
          word_2000092E = 0;
          ++byte_20000927;
          byte_20000926 = 2;
        }
        break;
      case 2:
        if ( sub_801AACC(&word_2000092E, 0x12Cu) )
        {
          word_2000092E = 0;
          sub_8002364(byte_20002EB1, 32);
          sub_8002364(byte_20002ED1, 64);
          sub_8005498(0x400u, (int)byte_20002EB1, 32);
          sub_8005498(0x420u, (int)byte_20002ED1, 64);
          sub_8004FE0((int)"### Auto set wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002EB1, byte_20002ED1);
          if ( (unsigned __int8)byte_20002EB1[0] == 255 || (unsigned __int8)byte_20002ED1[0] == 255 )
          {
            sub_800240C(byte_20002EB1, "SM471");
            sub_800240C(byte_20002ED1, "Hame147258");
            sub_8004FE0((int)"**** wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002EB1, byte_20002ED1);
          }
          byte_20000926 = 3;
        }
        break;
      case 3:
        v1 = sub_80023E2((unsigned __int8 *)byte_20002ED1);
        v2 = sub_80023E2((unsigned __int8 *)byte_20002EB1);
        sub_800EF54(byte_20002EB1, byte_20002ED1, (int)v2, (unsigned int)v1);
        byte_20000926 = 0;
        byte_200036AE = 0;
        break;
      default:
        byte_20000926 = 2;
        break;
    }
    return 0;
  }
  if ( !sub_800F058(1) && !byte_20000928 )
  {
    byte_20000926 = 1;
    sub_8004FE0((int)"Wait for wifi link, check cnt = %d.\r\n", (unsigned __int8)byte_20000927);
    return 0;
  }
  sub_8004FE0((int)"Wifi connected! ### wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002EB1, byte_20002ED1);
  sub_80055F0(0x400u, byte_20002EB1, 0x20u);
  sub_80055F0(0x420u, byte_20002ED1, 0x40u);
  byte_20000927 = 0;
  byte_20004245 = 0;
  return 1;
}
// 20000926: using guessed type char byte_20000926;
// 20000927: using guessed type char byte_20000927;
// 20000928: using guessed type char byte_20000928;
// 2000092E: using guessed type __int16 word_2000092E;
// 200015AC: using guessed type char byte_200015AC;
// 200036AE: using guessed type char byte_200036AE;
// 200036B0: using guessed type char byte_200036B0;
// 20004237: using guessed type char byte_20004237;
// 20004245: using guessed type char byte_20004245;

//----- (0800EF54) --------------------------------------------------------
int __fastcall sub_800EF54(const char *a1, const char *a2, int a3, unsigned int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[152]; // [sp+8h] [bp-98h] BYREF

  sub_8002364(v10, 128);
  v8 = 0;
  if ( !a1 || !a2 )
    return 0;
  sub_8004FE0((int)"Set Wifi ssid:%s, key:%s, ssid_len:%d, key_len:%d.\r\n", a1, a2, a3, a4);
  if ( (unsigned int)(a3 - 1) < 0x20 && a4 >= 8 && a4 <= 0x40 )
  {
    sprintf((int)v10, "AT+QSTAAPINFODEF=%s,%s", a1, a2);
    while ( v8 < 3 )
    {
      if ( sub_800DAC0(v10, "OK", 0, 600) )
      {
        byte_20000928 = 0;
        return 1;
      }
      sub_80232B4(200);
      v8 = (unsigned __int8)(v8 + 1);
    }
    return 0;
  }
  else
  {
    sub_8004FE0((int)"Warning : WiFi set oversize!\r\n");
    return 0;
  }
}
// 20000928: using guessed type char byte_20000928;

//----- (0800F058) --------------------------------------------------------
int __fastcall sub_800F058(int a1)
{
  int v1; // r5
  unsigned int v2; // r4
  unsigned int v4; // r4
  unsigned __int8 *v5; // r0

  v1 = a1;
  v2 = 0;
  if ( a1 == 2 )
  {
    while ( !byte_20000928 && v2 <= 6 )
    {
      if ( byte_20004236 )
        return 0;
      v2 = (unsigned __int8)(v2 + 1);
      sub_80232B4(300);
    }
  }
  v4 = 0;
  if ( !byte_20000928 && v1 == 3 )
  {
    v1 = 1;
    v4 = 2;
  }
  while ( 1 )
  {
    if ( 3 * v1 <= v4 )
    {
      byte_20000928 = 0;
      sub_8004FE0((int)"[WIFI] State disconnected!\r\n");
      return 0;
    }
    if ( byte_200036AE == 1 && v1 == 3 )
    {
      sub_8004FE0((int)"[WIFI] Wait for urc, don't check wifi state!\r\n");
      return 1;
    }
    if ( sub_800DAC0("AT+QGETWIFISTATE", 0, (unsigned __int8 *)&dword_800F124, 600) )
      break;
    sub_80232B4(200);
    v4 = (unsigned __int8)(v4 + 1);
  }
  sub_8004FE0((int)"WiFi link ok!\r\n");
  byte_20000928 = 1;
  v5 = strstr((unsigned __int8 *)byte_200038FC, "rssi=");
  if ( v5 )
  {
    byte_20000929 = sub_8002644((char *)v5 + 6);
    sub_8004FE0((int)"WiFi signal strength:%d.\r\n", (unsigned __int8)byte_20000929);
  }
  return 1;
}
// 800F124: using guessed type int dword_800F124;
// 20000928: using guessed type char byte_20000928;
// 20000929: using guessed type char byte_20000929;
// 200036AE: using guessed type char byte_200036AE;
// 20004236: using guessed type char byte_20004236;

//----- (0800F1C4) --------------------------------------------------------
int sub_800F1C4()
{
  int result; // r0

  result = (unsigned __int8)byte_200015AC;
  if ( !byte_200015AC )
  {
    if ( byte_20004236 )
    {
      byte_20004236 = 0;
      sub_800D9EC();
    }
    result = (int)&byte_20000926;
    if ( byte_200036B0 )
      word_2000092C = 10;
    else
      word_2000092C = 60;
    if ( byte_200036B4 == 7 && !byte_200036AE )
    {
      result = sub_801AAF4(algn_2000092A, (unsigned __int16)word_2000092C);
      if ( result )
        return sub_800F058(3);
    }
  }
  return result;
}
// 20000926: using guessed type char byte_20000926;
// 2000092A: using guessed type _BYTE[2];
// 2000092C: using guessed type __int16 word_2000092C;
// 200015AC: using guessed type char byte_200015AC;
// 200036AE: using guessed type char byte_200036AE;
// 200036B0: using guessed type char byte_200036B0;
// 200036B4: using guessed type char byte_200036B4;
// 20004236: using guessed type char byte_20004236;

//----- (0800F228) --------------------------------------------------------
int sub_800F228()
{
  int result; // r0

  dword_20003B57 = dword_20002F16 / 0xAu;
  dword_20003B5B = dword_20002F1A / 0xAu;
  dword_20003B3B = dword_20002F2E / 0xAu;
  dword_20003B3F = dword_20002F22 / 0xAu;
  dword_20003B43 = dword_20002F32 / 0xAu;
  dword_20003B47 = dword_20002F26 / 0xAu;
  dword_20003B4B = dword_20002F36 / 100000;
  dword_20003B4F = dword_20002F2A / 100000;
  dword_20003B53 = dword_20002F1E / 100000;
  byte_20003B18 = byte_20000929;
  word_20003B1D = (unsigned int)*(float *)&dword_20002770;
  if ( !byte_200002AB && byte_20002E37[0] == 1 )
    word_20003B1F = (int)*(float *)&dword_20002770;
  else
    word_20003B1F = (int)*(float *)&dword_20002798;
  byte_20003B11 = byte_200004AD;
  byte_20003B12 = byte_200015DE;
  byte_20003B13 = sub_801CBF8();
  word_20003B21 = (unsigned __int16)word_20002D56 * (unsigned __int16)dword_20002D52 / 1000;
  byte_20003B14 = dword_20002D52;
  word_20003B31 = 0;
  word_20003B33 = 0;
  word_20003B35 = dword_20002D60;
  word_20003B37 = dword_20002D64;
  word_20003B1B = word_20002E32;
  byte_20003B17 = 0;
  byte_20003B15 = byte_20002E38;
  byte_20003B16 = byte_20002EA7;
  word_20003B39 = (unsigned __int8)byte_20002E37[0];
  dword_20003B5F = (unsigned __int16)word_20002E9D;
  dword_20003B63 = dword_20002E9F;
  dword_20003B67 = dword_20002EA3;
  dword_20003C08 = (unsigned __int8)byte_200015A6;
  dword_20003C0C = (unsigned __int8)byte_20002EA9;
  word_20003B23 = (unsigned int)flt_200002F4;
  word_20003B25 = (unsigned int)*(float *)&dword_2000278C;
  word_20003B27 = (int)*(float *)&dword_20001C20;
  word_20003B29 = (int)*(float *)&dword_20001C24;
  word_20003B2B = (int)*(float *)&dword_20001C28;
  word_20003B2D = word_20002D5E;
  word_20003B2F = sub_800F7D0((__int16 *)&dword_20002D6F, 4u);
  byte_20003B19 = byte_20002F11;
  byte_20003B1A = byte_20000507;
  word_20003C10 = word_20000513;
  word_20003C12 = word_20000515;
  word_20003C14 = HIWORD(dword_20002D4C);
  word_20003C16 = word_20002D50;
  word_20003C18 = (unsigned int)(float)(*(float *)&dword_20001C08 * 10.0);
  word_20003C1A = (int)(float)(*(float *)&dword_20001C0C * 10.0);
  word_20003C1C = (unsigned __int8)byte_20002D58;
  word_20003C1E = (int)(float)(flt_20001BF8 * 10.0);
  byte_20003C20 = byte_20000512;
  byte_20003C21 = byte_200004AC;
  byte_20003C22 = byte_20004237;
  byte_20003C23 = byte_20004245;
  byte_20003C24 = byte_200015DC;
  byte_20003C25 = byte_2001110C;
  if ( sub_80023E2(&byte_200110C0[8]) )
    qmemcpy((unsigned int)byte_20003C26, (unsigned int)&byte_200110C0[8], sizeof(byte_20003C26));
  else
    strcpy(byte_20003C26, "000000000000");
  *(_QWORD *)&off_20003BF8 = *(_QWORD *)&dword_200028B4;
  dword_20003C00 = dword_200028BC;
  dword_20003C04 = dword_200028C0;
  sub_801CC20();
  byte_20003C57 = byte_20002EAB;
  result = (unsigned __int8)byte_20002EAD;
  byte_20003C58 = byte_20002EAD;
  return result;
}
// 200002AB: using guessed type char byte_200002AB;
// 200002F4: using guessed type float flt_200002F4;
// 200004AC: using guessed type char byte_200004AC;
// 200004AD: using guessed type char byte_200004AD;
// 20000507: using guessed type char byte_20000507;
// 20000512: using guessed type char byte_20000512;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 20000929: using guessed type char byte_20000929;
// 200015A6: using guessed type char byte_200015A6;
// 200015DC: using guessed type char byte_200015DC;
// 200015DE: using guessed type char byte_200015DE;
// 20001BF8: using guessed type float flt_20001BF8;
// 20001C08: using guessed type int dword_20001C08;
// 20001C0C: using guessed type int dword_20001C0C;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 20002770: using guessed type int dword_20002770;
// 2000278C: using guessed type int dword_2000278C;
// 20002798: using guessed type int dword_20002798;
// 200028B4: using guessed type int dword_200028B4;
// 200028BC: using guessed type int dword_200028BC;
// 200028C0: using guessed type int dword_200028C0;
// 20002D4C: using guessed type int dword_20002D4C;
// 20002D50: using guessed type __int16 word_20002D50;
// 20002D52: using guessed type int dword_20002D52;
// 20002D56: using guessed type __int16 word_20002D56;
// 20002D58: using guessed type char byte_20002D58;
// 20002D5E: using guessed type __int16 word_20002D5E;
// 20002D60: using guessed type int dword_20002D60;
// 20002D64: using guessed type int dword_20002D64;
// 20002D6F: using guessed type int dword_20002D6F;
// 20002E32: using guessed type __int16 word_20002E32;
// 20002E38: using guessed type char byte_20002E38;
// 20002E9D: using guessed type __int16 word_20002E9D;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EA3: using guessed type int dword_20002EA3;
// 20002EA7: using guessed type char byte_20002EA7;
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002EAD: using guessed type char byte_20002EAD;
// 20002F11: using guessed type char byte_20002F11;
// 20002F16: using guessed type int dword_20002F16;
// 20002F1A: using guessed type int dword_20002F1A;
// 20002F1E: using guessed type int dword_20002F1E;
// 20002F22: using guessed type int dword_20002F22;
// 20002F26: using guessed type int dword_20002F26;
// 20002F2A: using guessed type int dword_20002F2A;
// 20002F2E: using guessed type int dword_20002F2E;
// 20002F32: using guessed type int dword_20002F32;
// 20002F36: using guessed type int dword_20002F36;
// 20003B11: using guessed type char byte_20003B11;
// 20003B12: using guessed type char byte_20003B12;
// 20003B13: using guessed type char byte_20003B13;
// 20003B14: using guessed type char byte_20003B14;
// 20003B15: using guessed type char byte_20003B15;
// 20003B16: using guessed type char byte_20003B16;
// 20003B17: using guessed type char byte_20003B17;
// 20003B18: using guessed type char byte_20003B18;
// 20003B19: using guessed type char byte_20003B19;
// 20003B1A: using guessed type char byte_20003B1A;
// 20003B1B: using guessed type __int16 word_20003B1B;
// 20003B1D: using guessed type __int16 word_20003B1D;
// 20003B1F: using guessed type __int16 word_20003B1F;
// 20003B21: using guessed type __int16 word_20003B21;
// 20003B23: using guessed type __int16 word_20003B23;
// 20003B25: using guessed type __int16 word_20003B25;
// 20003B27: using guessed type __int16 word_20003B27;
// 20003B29: using guessed type __int16 word_20003B29;
// 20003B2B: using guessed type __int16 word_20003B2B;
// 20003B2D: using guessed type __int16 word_20003B2D;
// 20003B2F: using guessed type __int16 word_20003B2F;
// 20003B31: using guessed type __int16 word_20003B31;
// 20003B33: using guessed type __int16 word_20003B33;
// 20003B35: using guessed type __int16 word_20003B35;
// 20003B37: using guessed type __int16 word_20003B37;
// 20003B39: using guessed type __int16 word_20003B39;
// 20003B3B: using guessed type int dword_20003B3B;
// 20003B3F: using guessed type int dword_20003B3F;
// 20003B43: using guessed type int dword_20003B43;
// 20003B47: using guessed type int dword_20003B47;
// 20003B4B: using guessed type int dword_20003B4B;
// 20003B4F: using guessed type int dword_20003B4F;
// 20003B53: using guessed type int dword_20003B53;
// 20003B57: using guessed type int dword_20003B57;
// 20003B5B: using guessed type int dword_20003B5B;
// 20003B5F: using guessed type int dword_20003B5F;
// 20003B63: using guessed type int dword_20003B63;
// 20003B67: using guessed type int dword_20003B67;
// 20003BF8: using guessed type _UNKNOWN *off_20003BF8;
// 20003C00: using guessed type int dword_20003C00;
// 20003C04: using guessed type int dword_20003C04;
// 20003C08: using guessed type int dword_20003C08;
// 20003C0C: using guessed type int dword_20003C0C;
// 20003C10: using guessed type __int16 word_20003C10;
// 20003C12: using guessed type __int16 word_20003C12;
// 20003C14: using guessed type __int16 word_20003C14;
// 20003C16: using guessed type __int16 word_20003C16;
// 20003C18: using guessed type __int16 word_20003C18;
// 20003C1A: using guessed type __int16 word_20003C1A;
// 20003C1C: using guessed type __int16 word_20003C1C;
// 20003C1E: using guessed type __int16 word_20003C1E;
// 20003C20: using guessed type char byte_20003C20;
// 20003C21: using guessed type char byte_20003C21;
// 20003C22: using guessed type char byte_20003C22;
// 20003C23: using guessed type char byte_20003C23;
// 20003C24: using guessed type char byte_20003C24;
// 20003C25: using guessed type char byte_20003C25;
// 20003C57: using guessed type char byte_20003C57;
// 20003C58: using guessed type char byte_20003C58;
// 20004237: using guessed type char byte_20004237;
// 20004245: using guessed type char byte_20004245;
// 200110C0: using guessed type unsigned __int8 byte_200110C0[44];
// 2001110C: using guessed type char byte_2001110C;

//----- (0800F4F4) --------------------------------------------------------
BOOL __fastcall sub_800F4F4(unsigned int a1, int a2)
{
  int v4; // r4
  int v6; // [sp+4h] [bp-24h] BYREF
  int v7; // [sp+8h] [bp-20h]
  unsigned int v8; // [sp+Ch] [bp-1Ch]
  unsigned int v9; // [sp+10h] [bp-18h]
  unsigned int v10; // [sp+14h] [bp-14h] BYREF

  v10 = 0;
  sub_8012014();
  MEMORY[0x40022010] = 178;
  if ( a1 < 0x8040000 )
  {
    v7 = 1;
    v8 = (a1 - 0x8000000) >> 11;
  }
  else
  {
    v7 = 2;
    v8 = (a1 - 134479872) >> 11;
  }
  v6 = 0;
  v8 = (a1 - 0x8000000) >> 11;
  v9 = (a2 - a1) >> 11;
  v4 = sub_8011E80(&v6, &v10);
  sub_8011F78();
  return v4 != 0;
}

//----- (0800F558) --------------------------------------------------------
int __fastcall sub_800F558(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v6; // r4
  unsigned int v8; // r0

  v6 = 0;
  sub_8012014();
  MEMORY[0x40022010] = 186;
  while ( v6 < a3 )
  {
    v8 = MEMORY[0x1FFF75E0] == 0xFFFF ? 0x80000 : (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
    if ( (v8 >> 1) + 134479864 < (unsigned int)a1 )
      break;
    if ( sub_8011F94(0, a1, *(int **)(a2 + 8 * v6), *(_DWORD *)(a2 + 8 * v6 + 4)) )
      return 3;
    a1 += 2;
    ++v6;
  }
  sub_8011F78();
  return 0;
}

//----- (0800F5D0) --------------------------------------------------------
unsigned int sub_800F5D0()
{
  unsigned int v0; // r4
  unsigned int result; // r0
  int i; // r0

  v0 = 0;
  result = sub_8012298() - dword_2000005C;
  if ( result <= 0x46 )
  {
    for ( i = 0; i < 4; ++i )
      v0 += dword_200019F8[i];
    return 2 * (v0 >> 2);
  }
  return result;
}
// 2000005C: using guessed type int dword_2000005C;
// 200019F8: using guessed type _DWORD dword_200019F8[4];

//----- (0800F61C) --------------------------------------------------------
int __fastcall sub_800F61C(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int i; // r2

  result = 0;
  if ( a1 )
  {
    for ( i = 0; i < a2; ++i )
      result = (unsigned __int16)(result + *(unsigned __int8 *)(a1 + i));
  }
  return result;
}

//----- (0800F638) --------------------------------------------------------
int sub_800F638()
{
  int result; // r0

  LOBYTE(result) = 1;
  if ( (unsigned __int8)byte_20002EAC >= 3u )
  {
    if ( byte_20002EA9 == 4 )
      LOBYTE(result) = 2;
  }
  else
  {
    LOBYTE(result) = byte_20002EAC;
  }
  return (unsigned __int8)result;
}
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAC: using guessed type char byte_20002EAC;

//----- (0800F65C) --------------------------------------------------------
int sub_800F65C()
{
  int result; // r0

  result = 5;
  if ( (unsigned __int8)byte_20002EAC < 3u )
    return *(unsigned __int16 *)&aV1rzima0gcsqgs[4 * (unsigned __int8)byte_20002EAC + 62];
  if ( byte_20002EA9 == 4 )
    return 10;
  return result;
}
// 20002EA9: using guessed type char byte_20002EA9;
// 20002EAC: using guessed type char byte_20002EAC;

//----- (0800F688) --------------------------------------------------------
unsigned __int8 *sub_800F688()
{
  unsigned __int8 *result; // r0
  unsigned int v1; // r4
  unsigned int v2; // r5

  result = (unsigned __int8 *)(unsigned __int8)byte_20011138[0];
  if ( !byte_20011138[0] )
  {
    result = (unsigned __int8 *)sub_8018560("AT+QGETIP=station\r\n", "QGETIP", 300);
    if ( result )
    {
      result = strstr(byte_200111B8, "ip:");
      v1 = (unsigned int)result;
      if ( result )
      {
        result = (unsigned __int8 *)result[3];
        if ( result != (unsigned __int8 *)48 )
        {
          result = strstr(byte_200111B8, "dns:");
          if ( result )
          {
            result = (unsigned __int8 *)result[4];
            if ( result != (unsigned __int8 *)48 )
            {
              result = strstr(byte_200111B8, "\r\n");
              if ( result )
              {
                v2 = (unsigned int)&result[-v1];
                if ( (unsigned int)&result[-v1] < 0x80 )
                {
                  sub_8002364(byte_20011138, 128);
                  return (unsigned __int8 *)qmemcpy((unsigned int)byte_20011138, v1, v2);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 200111B8: using guessed type _BYTE byte_200111B8[952];

//----- (0800F728) --------------------------------------------------------
_BYTE *sub_800F728()
{
  unsigned int i; // r4
  _BYTE *result; // r0

  sub_8005498(0x1100u, (int)&dword_20003C59, 280);
  for ( i = 0; i < 0x14; ++i )
  {
    result = (char *)&dword_20003C59 + 14 * i;
    if ( (unsigned int)*(unsigned __int16 *)result - 2000 >= 0xC9 || (unsigned __int8)result[2] > 0xCu || !result[2] )
      result = sub_8002364(result, 14);
  }
  return result;
}
// 20003C59: using guessed type int dword_20003C59;

//----- (0800F768) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
unsigned int __fastcall sub_800F768(unsigned __int8 *a1, int a2, int a3, int a4)
{
  unsigned __int8 *v4; // r0
  int v5; // r6
  int v6; // r0
  unsigned int v7; // r5
  unsigned __int8 *v9; // [sp+0h] [bp-20h] BYREF
  int v10; // [sp+4h] [bp-1Ch]
  int v11; // [sp+8h] [bp-18h]
  int v12; // [sp+Ch] [bp-14h]

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  if ( !a1 )
    return (unsigned int)v9;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v4 = strstr(a1, "QIRD:");
  if ( !v4 )
    return (unsigned int)v9;
  v5 = sub_80023CE((int)v4, 0x2Cu) + 2;
  v6 = sub_80023CE(v5, 0x22u);
  if ( !v6 )
    return (unsigned int)v9;
  v7 = v6 - v5;
  if ( v6 - v5 > 16 )
    return (unsigned int)v9;
  dword_200115B8 = 0;
  dword_200115BC = 0;
  dword_200115C0 = 0;
  dword_200115C4 = 0;
  qmemcpy((unsigned int)&v9, v5, v6 - v5);
  return qmemcpy((unsigned int)&dword_200115B8, (unsigned int)&v9, v7);
}
// 800F7BE: bad sp value at call
// 200115B8: using guessed type int dword_200115B8;
// 200115BC: using guessed type int dword_200115BC;
// 200115C0: using guessed type int dword_200115C0;
// 200115C4: using guessed type int dword_200115C4;

//----- (0800F7D0) --------------------------------------------------------
int __fastcall sub_800F7D0(__int16 *a1, unsigned int a2)
{
  int v2; // r3
  unsigned int i; // r2

  if ( !a1 || !a2 )
    return 0;
  v2 = *a1;
  for ( i = 1; i < a2; i = (unsigned __int8)(i + 1) )
  {
    if ( a1[i] < v2 )
      v2 = a1[i];
  }
  return (__int16)v2;
}

//----- (0800F808) --------------------------------------------------------
__int64 __fastcall sub_800F808(__int64 a1)
{
  unsigned int i; // r0
  unsigned __int16 *v2; // r2
  unsigned int j; // r7
  unsigned int k; // r4
  char *v5; // r6
  char *v6; // r5
  unsigned int m; // r4
  int v10; // [sp+8h] [bp-28h]
  char v11; // [sp+Ch] [bp-24h]

  sub_8005498(0x2000u, (int)byte_20003D71, 180);
  for ( i = 0; i < 0x14; ++i )
  {
    v2 = (unsigned __int16 *)&byte_20003D71[9 * i];
    if ( (unsigned int)*v2 - 2000 >= 0xC9 || *((unsigned __int8 *)v2 + 2) > 0xCu || !*((_BYTE *)v2 + 2) )
    {
      *(_DWORD *)v2 = 0;
      *((_DWORD *)v2 + 1) = 0;
      *((_BYTE *)v2 + 8) = 0;
    }
  }
  for ( j = 0; j < 0x13; ++j )
  {
    for ( k = 0; 19 - j > k; ++k )
    {
      v5 = &byte_20003D71[9 * k + 9];
      v6 = &byte_20003D71[9 * k];
      LODWORD(a1) = *(_DWORD *)v6;
      WORD2(a1) = *((_WORD *)v6 + 2);
      if ( sub_8004C6E(*(_DWORD *)v6, SWORD2(a1), *(_DWORD *)v5, *((_WORD *)v5 + 2)) > 0 )
      {
        HIDWORD(a1) = *(_DWORD *)v6;
        v10 = *((_DWORD *)v6 + 1);
        v11 = v6[8];
        *(_DWORD *)v6 = *(_DWORD *)v5;
        *((_DWORD *)v6 + 1) = *((_DWORD *)v5 + 1);
        v6[8] = v5[8];
        *(_DWORD *)v5 = HIDWORD(a1);
        *((_DWORD *)v5 + 1) = v10;
        v5[8] = v11;
      }
    }
  }
  for ( m = 0; m < 0x14; ++m )
    sub_80055F0(9 * m + 0x2000, &byte_20003D71[9 * m], 9u);
  return a1;
}
// 20003D71: using guessed type _BYTE byte_20003D71[180];

//----- (0800F8D8) --------------------------------------------------------
int sub_800F8D8()
{
  sub_8005498(0x3000u, (int)&dword_200038E3, 8);
  if ( !sub_80023F0((int)&dword_200038E3, (int)"HMG-50") && (unsigned __int16)word_20002D56 > 0xBB8u
    || !sub_80023F0((int)&dword_200038E3, (int)"HMG-25") && word_20002D56 && (unsigned __int16)word_20002D56 <= 0xBB8u )
  {
    return sub_8004FE0(
             (int)"*** Device type [AC Couple]: %s, BMS capacity: %d.\r\n",
             &dword_200038E3,
             (unsigned __int16)word_20002D56);
  }
  if ( (unsigned int)(unsigned __int16)word_20002D56 - 3001 >= 0xBB7 )
  {
    if ( (unsigned int)(unsigned __int16)word_20002D56 - 1 >= 0xBB7 )
    {
      strcpy((char *)&dword_200038E3, "HMG-1");
      return sub_8004FE0((int)"Device type [AC Couple]: %s, size: %d, BMS capacity: %d.\r\n", &dword_200038E3, 6);
    }
    else
    {
      dword_200038E3 = *(_DWORD *)"HMG-25";
      dword_200038E7 = *(unsigned __int16 *)"25";
      BYTE2(dword_200038E7) = 0;
      sub_80055F0(0x3000u, &dword_200038E3, 8u);
      return sub_8004FE0((int)"Device type [AC Couple 2.5]: %s, size: %d, BMS capacity: %d.\r\n", &dword_200038E3, 7);
    }
  }
  else
  {
    dword_200038E3 = *(_DWORD *)"HMG-50";
    dword_200038E7 = *(unsigned __int16 *)"50";
    BYTE2(dword_200038E7) = 0;
    sub_80055F0(0x3000u, &dword_200038E3, 8u);
    return sub_8004FE0((int)"Device type [AC Couple 5.0]: %s, size: %d, BMS capacity: %d.\r\n", &dword_200038E3, 7);
  }
}
// 20002D56: using guessed type __int16 word_20002D56;
// 200038E3: using guessed type int dword_200038E3;
// 200038E7: using guessed type int dword_200038E7;

//----- (0800FAC4) --------------------------------------------------------
int __fastcall sub_800FAC4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r5
  _BYTE *v5; // r0
  unsigned int v6; // r4
  char v8[84]; // [sp+4h] [bp-54h] BYREF

  if ( a1 && a2 )
  {
    v3 = strstr(a1, a2);
    if ( v3 )
    {
      v4 = &v3[(_DWORD)sub_80023E2(a2) + 2];
      v5 = sub_80024A0(v4, &dword_800FB48);
      if ( v5 )
      {
        v6 = v5 - v4;
        sub_8002364(v8, 64);
        if ( v6 >= 0x40 )
          v6 = 63;
        sub_80023B6(v8, v4, v6);
        v8[v6] = 0;
        sub_8004FE0((int)"Get meter data info, \"%s\" = %s.\r\n", (const char *)a2, v8);
        return sub_8002644(v8);
      }
      else
      {
        sub_8004FE0((int)"Get meter data info failed, end position not found.\r\n");
        return 0xFFFF;
      }
    }
    else
    {
      sub_8004FE0((int)"Get meter data info failed, key not found.\r\n");
      return 0xFFFF;
    }
  }
  else
  {
    sub_8004FE0((int)"Get meter data info failed, input is null.\r\n");
    return 0xFFFF;
  }
}
// 800FB48: using guessed type int dword_800FB48;

//----- (0800FC08) --------------------------------------------------------
int sub_800FC08()
{
  unsigned int v0; // r4
  int i; // r0
  char *v2; // r1
  BOOL v3; // r2

  v0 = (unsigned __int8)byte_20002DF5 | ((unsigned __int8)byte_20002DF4 << 8);
  for ( i = 0; i < 10; ++i )
  {
    v2 = &byte_20002E37[10 * i];
    if ( v2[3] && v2[2] )
    {
      v3 = 0;
      if ( *((unsigned __int16 *)v2 + 3) <= v0 )
        v3 = *((unsigned __int16 *)v2 + 4) > v0;
      if ( ((1 << (byte_200004FC - 1)) & (unsigned int)(unsigned __int8)v2[2]) >> (byte_200004FC - 1) && v3 )
        return *(__int16 *)&byte_20002E37[10 * i + 4];
    }
  }
  return 0;
}
// 200004FC: using guessed type char byte_200004FC;
// 20002DF4: using guessed type char byte_20002DF4;
// 20002DF5: using guessed type char byte_20002DF5;

//----- (0800FC70) --------------------------------------------------------
int __fastcall sub_800FC70(int result)
{
  int v1; // r4
  _BYTE v2[2]; // [sp+0h] [bp-20h] BYREF
  unsigned __int8 v3; // [sp+2h] [bp-1Eh]
  _BYTE v4[12]; // [sp+14h] [bp-Ch] BYREF

  v1 = result;
  if ( result )
  {
    sub_8018E88(v4, (int)v2);
    *(_WORD *)v1 = v4[3] + 2000;
    *(_BYTE *)(v1 + 2) = v4[1];
    *(_BYTE *)(v1 + 3) = v4[2];
    *(_BYTE *)(v1 + 4) = v4[0];
    *(_BYTE *)(v1 + 5) = v2[0];
    *(_BYTE *)(v1 + 6) = v2[1];
    result = v3;
    *(_BYTE *)(v1 + 7) = v3;
  }
  return result;
}

//----- (0800FCB4) --------------------------------------------------------
int __fastcall sub_800FCB4(int a1, __int16 a2)
{
  float v2; // s0
  int result; // r0
  int v4; // r3
  float v5; // s0
  __int16 v6; // [sp+Ah] [bp-Ah]
  unsigned __int8 v7; // [sp+Dh] [bp-7h]

  v6 = HIWORD(a1);
  v7 = HIBYTE(a2);
  result = (int)v2;
  v4 = (unsigned __int8)a2;
  if ( (_BYTE)a2 )
  {
    LOBYTE(a2) = HIBYTE(a2);
    if ( HIBYTE(a2) <= (unsigned int)(unsigned __int8)byte_20000512 )
      LOBYTE(a2) = byte_20000512;
    v7 = a2;
  }
  if ( v4 )
  {
    v5 = 0.1;
    if ( v6 <= 0 )
    {
      if ( v6 < 0 )
      {
        if ( v7 < (unsigned int)(unsigned __int16)dword_20002D52 )
        {
          if ( v7 >= (unsigned __int16)dword_20002D52 - 5 )
          {
            if ( result < 0 )
              return (int)(float)result;
            return (int)v5;
          }
        }
        else if ( v6 <= result )
        {
          return v6;
        }
      }
      else
      {
        return 0;
      }
    }
    else if ( v7 > (unsigned int)(unsigned __int16)dword_20002D52 )
    {
      if ( v7 <= (unsigned int)(unsigned __int16)dword_20002D52 + 5 )
      {
        if ( result >= 0 )
          return (int)(float)result;
        return (int)v5;
      }
    }
    else if ( v6 > result )
    {
      return v6;
    }
  }
  else if ( v6 <= 0 )
  {
    if ( v6 < 0 && v7 >= (unsigned int)(unsigned __int16)dword_20002D52 && v6 > result )
      return v6;
  }
  else if ( v7 <= (unsigned int)(unsigned __int16)dword_20002D52 && v6 <= result )
  {
    return v6;
  }
  return result;
}
// 800FCBE: variable 'v2' is possibly undefined
// 20000512: using guessed type char byte_20000512;
// 20002D52: using guessed type int dword_20002D52;

//----- (0800FD84) --------------------------------------------------------
int sub_800FD84()
{
  int v0; // r4
  int result; // r0
  int v2; // r1
  int v3; // [sp+0h] [bp-20h] BYREF
  int v4; // [sp+4h] [bp-1Ch] BYREF

  v4 = 0;
  v3 = 0;
  v0 = 1;
  byte_200036B1 = 0;
  result = sub_8024A40(dword_20000458, 0, 0, 0);
  while ( v0 )
  {
    result = sub_801AACC(&v3, 0xAu);
    if ( result )
      break;
    result = sub_8024E28(dword_20000440, (unsigned int)&v4, 0);
    v0 = result;
    if ( result )
    {
      v2 = (unsigned __int16)word_200015EC;
      result = (unsigned __int8)v4;
      ++word_200015EC;
      byte_200111B8[v2] = v4;
      if ( (unsigned __int16)(v2 + 1) >= 0x3FFu )
        break;
    }
  }
  return result;
}
// 20000440: using guessed type int dword_20000440;
// 20000458: using guessed type int dword_20000458;
// 200015EC: using guessed type __int16 word_200015EC;
// 200036B1: using guessed type char byte_200036B1;
// 200111B8: using guessed type _BYTE byte_200111B8[952];

//----- (0800FDF8) --------------------------------------------------------
unsigned int __fastcall sub_800FDF8(int a1)
{
  if ( a1 )
    return (*(unsigned __int8 *)(a1 + 6) + 60 * (unsigned int)*(unsigned __int8 *)(a1 + 5)) / 0xA;
  else
    return 0;
}

//----- (0800FE14) --------------------------------------------------------
int __fastcall sub_800FE14(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int i; // r2

  result = 0;
  if ( !a1 )
    return 0;
  for ( i = 0; i < a2; ++i )
    result ^= *(unsigned __int8 *)(a1 + i);
  return result;
}

//----- (0800FE34) --------------------------------------------------------
int sub_800FE34()
{
  MEMORY[0x4002104C] |= 1u;
  MEMORY[0x4002104C] |= 2u;
  MEMORY[0x4002104C] |= 4u;
  MEMORY[0x4002104C] |= 8u;
  MEMORY[0x4002104C] |= 0x10u;
  MEMORY[0x4002104C] |= 0x20u;
  sub_8004188((int *)0x48001000, 4096, 2);
  sub_8004188((int *)0x48001400, 4, 2);
  sub_8004188((int *)0x48000C00, 4, 2);
  sub_80041AE((int *)0x48001000, 128, 2);
  sub_80041AE((int *)0x48001000, 256, 2);
  sub_80041AE((int *)0x48001000, 1024, 2);
  sub_80041AE((int *)0x48001000, 2048, 2);
  sub_80041D6((int *)0x48001000, 64);
  sub_80041D6((int *)0x48000800, 2048);
  sub_80041D6((int *)0x48000000, 16);
  sub_80041D6((int *)0x48001000, 4);
  sub_80041D6((int *)0x48001000, 8);
  sub_80041D6((int *)0x48001000, 16);
  sub_80041D6((int *)0x48001000, 32);
  sub_80041D6((int *)0x48000000, 32);
  sub_80041D6((int *)0x48000800, 16);
  sub_80041D6((int *)0x48000800, 32);
  sub_80041D6((int *)0x48000400, 4);
  sub_80041D6((int *)0x48000400, 0x8000);
  sub_80041D6((int *)0x48000C00, 2);
  sub_80041D6((int *)0x48000C00, 1);
  sub_80041D6((int *)0x48001000, 1);
  sub_80041D6((int *)0x48001000, 2);
  sub_80041D6((int *)0x48000C00, 2048);
  sub_80041D6((int *)0x48000C00, 1024);
  sub_80041D6((int *)0x48000800, 4096);
  sub_80041D6((int *)0x48000C00, 8);
  sub_80041D6((int *)0x48000C00, 128);
  sub_80041D6((int *)0x48000400, 8);
  sub_80041D6((int *)0x48000000, 4096);
  sub_80041D6((int *)0x48000800, 1024);
  sub_801227E(1207961600, 4096, 1);
  sub_80132C0(23, 8u, 0);
  sub_80132C0(40, 8u, 0);
  sub_80132A4(23);
  return sub_80132A4(40);
}

//----- (08010014) --------------------------------------------------------
int __fastcall sub_8010014(int a1, int a2)
{
  int result; // r0
  int v4; // r2
  int v5; // r1

  result = 1207963648;
  if ( byte_20000002 )
  {
    switch ( a1 )
    {
      case 0:
        goto LABEL_10;
      case 1:
        goto LABEL_9;
      case 2:
        goto LABEL_8;
      case 3:
        return sub_801227E(1207959552, 16, a2);
      case 4:
        return sub_801227E(1207961600, 2048, a2);
      case 5:
        goto LABEL_4;
      case 7:
        goto LABEL_12;
      case 8:
        goto LABEL_11;
      case 9:
        if ( a2 )
          result = sub_801AA6C(0x2710u);
        else
          result = sub_801AA6C(0);
        break;
      default:
        return result;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
LABEL_4:
        v4 = a2;
        v5 = 64;
        goto LABEL_5;
      case 1:
        return sub_801227E(1207961600, 2048, a2);
      case 2:
        return sub_801227E(1207959552, 16, a2);
      case 3:
LABEL_8:
        v4 = a2;
        v5 = 4;
        goto LABEL_5;
      case 4:
LABEL_9:
        v4 = a2;
        v5 = 8;
        goto LABEL_5;
      case 5:
LABEL_10:
        v4 = a2;
        v5 = 16;
        goto LABEL_5;
      case 7:
LABEL_11:
        v4 = a2;
        v5 = 32;
LABEL_5:
        result = sub_801227E(1207963648, v5, v4);
        break;
      case 8:
LABEL_12:
        result = sub_801227E(1207959552, 32, a2);
        break;
      case 9:
        if ( a2 )
          result = sub_801AA84(0x2710u);
        else
          result = sub_801AA84(0);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 20000002: using guessed type char byte_20000002;

//----- (08010134) --------------------------------------------------------
int __fastcall sub_8010134(int a1, int a2)
{
  int v4; // r3
  int v6; // [sp+0h] [bp-18h]

  v6 = 0;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  v4 = sub_8003358((int *)a1);
  if ( v4 )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFEEFD | 2;
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x3FFFFFC0 | a2 & 0x40000000 | 0x80000000;
    while ( *(int *)(*(_DWORD *)a1 + 8) < 0 )
    {
      if ( (unsigned int)++v6 >= 0x4DE02 )
      {
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFED | 0x10;
        *(_BYTE *)(a1 + 88) = 0;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFFC | 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  return v4;
}

//----- (080101D0) --------------------------------------------------------
int __fastcall sub_80101D0(int a1, int a2)
{
  int v4; // r6
  __int16 v6; // r0
  int v7; // r10
  int v8; // r2
  int v9; // r0
  int v10; // r1
  int v11; // r0
  int v12; // r1
  int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r0
  int v16; // r0
  unsigned int v17; // r1
  unsigned int v18; // r0
  int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // r0
  int v22; // r0
  unsigned int v23; // r1
  unsigned int v24; // r0
  int v25; // r0
  int v26; // r0
  unsigned int v27; // r1
  unsigned int v28; // r0
  int v29; // r1
  int v30; // r1
  int v31; // r8
  int v32; // r1
  int v33; // r1
  unsigned int v34; // r1
  int v35; // r1
  int v36; // r8
  int v37; // r1
  int v38; // r1
  unsigned int v39; // r2
  int v40; // r0
  int v41; // r3
  int v42; // r1
  int v43; // r1
  unsigned int i; // [sp+0h] [bp-28h]

  v4 = 0;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  if ( sub_8016CC4(*(_DWORD *)a1) )
  {
    *(_DWORD *)(a1 + 92) |= 0x20u;
    v4 = 1;
  }
  else
  {
    v6 = *(_WORD *)(a2 + 4);
    *(_DWORD *)(*(_DWORD *)a1 + ((unsigned __int16)(v6 & 0x300) >> 6) + 48) = *(_DWORD *)(*(_DWORD *)a1
                                                                                        + ((unsigned __int16)(v6 & 0x300) >> 6)
                                                                                        + 48)
                                                                            & ~(31 << (v6 & 0x1F))
                                                                            | (((*(_DWORD *)a2 >> 26) & 0x1F) << (v6 & 0x1F));
    v7 = sub_8016CC4(*(_DWORD *)a1);
    if ( !(v7 | sub_8016CB4(*(_DWORD *)a1)) )
    {
      v8 = *(_DWORD *)(a2 + 8);
      if ( v8 == 0x80000000 )
      {
        sub_8016CDC(*(_DWORD *)a1, *(_DWORD *)a2, 0);
        *(_DWORD *)(*(_DWORD *)a1 + 20) |= 0x80000000;
      }
      else
      {
        sub_8016CDC(*(_DWORD *)a1, *(_DWORD *)a2, v8);
        *(_DWORD *)(*(_DWORD *)a1 + 20) &= ~0x80000000;
      }
      v9 = *(_DWORD *)a1;
      v10 = *(_DWORD *)(a2 + 16);
      if ( v10 == 4 )
      {
        if ( sub_8016CA8(v9, 0) << 13 )
          v14 = __clz(__rbit32(sub_8016CA8(*(_DWORD *)a1, 0)));
        else
          v14 = ((unsigned int)sub_8016CA8(*(_DWORD *)a1, 0) >> 26) & 0x1F;
        v15 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v16 = __clz(__rbit32(v15));
        else
          v16 = (v15 >> 26) & 0x1F;
        if ( v14 == v16 )
          sub_8016CFA(*(_DWORD *)a1, 0, 0);
        if ( sub_8016CA8(*(_DWORD *)a1, 1) << 13 )
          v17 = __clz(__rbit32(sub_8016CA8(*(_DWORD *)a1, 1)));
        else
          v17 = ((unsigned int)sub_8016CA8(*(_DWORD *)a1, 1) >> 26) & 0x1F;
        v18 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v19 = __clz(__rbit32(v18));
        else
          v19 = (v18 >> 26) & 0x1F;
        if ( v17 == v19 )
          sub_8016CFA(*(_DWORD *)a1, 1, 0);
        if ( sub_8016CA8(*(_DWORD *)a1, 2) << 13 )
          v20 = __clz(__rbit32(sub_8016CA8(*(_DWORD *)a1, 2)));
        else
          v20 = ((unsigned int)sub_8016CA8(*(_DWORD *)a1, 2) >> 26) & 0x1F;
        v21 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v22 = __clz(__rbit32(v21));
        else
          v22 = (v21 >> 26) & 0x1F;
        if ( v20 == v22 )
          sub_8016CFA(*(_DWORD *)a1, 2, 0);
        if ( sub_8016CA8(*(_DWORD *)a1, 3) << 13 )
          v23 = __clz(__rbit32(sub_8016CA8(*(_DWORD *)a1, 3)));
        else
          v23 = ((unsigned int)sub_8016CA8(*(_DWORD *)a1, 3) >> 26) & 0x1F;
        v24 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v25 = __clz(__rbit32(v24));
        else
          v25 = (v24 >> 26) & 0x1F;
        if ( v23 == v25 )
          sub_8016CFA(*(_DWORD *)a1, 3, 0);
      }
      else
      {
        *(_DWORD *)(v9 + 4 * v10 + 96) = *(_DWORD *)(v9 + 4 * v10 + 96) & 0x3FFF000
                                       | *(_DWORD *)a2 & 0x7C000000
                                       | (*(_DWORD *)(a2 + 20) << (2 * ((*(_DWORD *)(*(_DWORD *)a1 + 12) >> 3) & 3)))
                                       | 0x80000000;
        v11 = *(_DWORD *)a1 + 4 * *(_DWORD *)(a2 + 16);
        *(_DWORD *)(v11 + 96) = *(_DWORD *)(v11 + 96) & 0xFEFFFFFF | *(_DWORD *)(a2 + 24);
        if ( *(_BYTE *)(a2 + 28) == 1 )
          v12 = 0x2000000;
        else
          v12 = 0;
        v13 = *(_DWORD *)a1 + 4 * *(_DWORD *)(a2 + 16);
        *(_DWORD *)(v13 + 96) = *(_DWORD *)(v13 + 96) & 0xFDFFFFFF | v12;
      }
    }
    if ( !sub_8016CBC(*(_DWORD *)a1) )
    {
      v26 = *(_DWORD *)a1;
      v27 = *(_DWORD *)a2;
      if ( *(_DWORD *)(a2 + 12) == 1082064896 )
        *(_DWORD *)(v26 + 176) |= v27 & 0x7FFFF;
      else
        *(_DWORD *)(v26 + 176) &= ~(v27 & 0x7FFFF);
      if ( *(_DWORD *)(a2 + 12) == 1082064896 )
      {
        v28 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          LOBYTE(v29) = __clz(__rbit32(v28));
        else
          v29 = (v28 >> 26) & 0x1F;
        if ( (((_BYTE)v29 + 1) & 0x1Fu) > 9 )
        {
          if ( v28 << 13 )
            LOBYTE(v35) = __clz(__rbit32(v28));
          else
            v35 = (v28 >> 26) & 0x1F;
          v36 = 1 << ((v35 + 1) & 0x1F);
          if ( v28 << 13 )
            LOBYTE(v37) = __clz(__rbit32(v28));
          else
            v37 = (v28 >> 26) & 0x1F;
          v38 = v36 | ((((_BYTE)v37 + 1) & 0x1F) << 26);
          if ( v28 << 13 )
            LOBYTE(v28) = __clz(__rbit32(v28));
          else
            v28 = (v28 >> 26) & 0x1F;
          v34 = v38 | (3145728 * ((((_BYTE)v28 + 1) & 0x1F) - 10)) | 0x2000000;
        }
        else
        {
          if ( v28 << 13 )
            LOBYTE(v30) = __clz(__rbit32(v28));
          else
            v30 = (v28 >> 26) & 0x1F;
          v31 = 1 << ((v30 + 1) & 0x1F);
          if ( v28 << 13 )
            LOBYTE(v32) = __clz(__rbit32(v28));
          else
            v32 = (v28 >> 26) & 0x1F;
          v33 = v31 | ((((_BYTE)v32 + 1) & 0x1F) << 26);
          if ( v28 << 13 )
            LOBYTE(v28) = __clz(__rbit32(v28));
          else
            v28 = (v28 >> 26) & 0x1F;
          v34 = v33 | (3145728 * (((_BYTE)v28 + 1) & 0x1F));
        }
        sub_8016CDC(*(_DWORD *)a1, v34, *(_DWORD *)(a2 + 8));
      }
    }
    v39 = *(_DWORD *)a2;
    if ( (*(_DWORD *)a2 & 0x80080000) != 0 )
    {
      v40 = *(_DWORD *)a1;
      v41 = 1342178048;
      if ( *(_DWORD *)a1 == 1342177280 || v40 == 1342177536 )
        v42 = 1342178048;
      else
        v42 = 1342179072;
      v43 = *(_DWORD *)(v42 + 8) & 0x1C00000;
      if ( (v39 == -1021247488 || v39 == -1866465264) && (v43 & 0x800000) == 0 )
      {
        if ( v40 == 1342177280 || v40 == 1342178816 )
        {
          if ( v40 != 1342177280 )
            v41 = 1342179072;
          *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x800000;
          for ( i = 12 * (dword_20000290 / 0x30D40u + 1); i; --i )
            ;
        }
      }
      else if ( v39 != -950927360 || (v43 & 0x1000000) != 0 )
      {
        if ( v39 == -880541696 && (v43 & 0x400000) == 0 && v40 != 1342177536 )
        {
          if ( v40 != 1342177280 )
            v41 = 1342179072;
          *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x400000;
        }
      }
      else
      {
        if ( v40 != 1342177280 && v40 != 1342177536 )
          v41 = 1342179072;
        *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x1000000;
      }
    }
  }
  *(_BYTE *)(a1 + 88) = 0;
  return v4;
}
// 8010588: conditional instruction was optimized away because r0.4==50000600
// 80105D4: conditional instruction was optimized away because r0.4==50000100
// 20000290: using guessed type int dword_20000290;

//----- (08010650) --------------------------------------------------------
int __fastcall sub_8010650(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1342177280 )
  {
    sub_801227E(1207963648, 1, 1);
    sub_800320C();
    return sub_801227E(1207963648, 1, 0);
  }
  return result;
}

//----- (08010680) --------------------------------------------------------
int __fastcall sub_8010680(int a1)
{
  int v2; // r5
  int v4; // r0
  int v5; // r0
  int v6; // r1
  int v7; // r0
  int v8; // r1
  int v9; // r0
  int v10; // r6
  unsigned int i; // [sp+0h] [bp-18h]

  v2 = 0;
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 92) )
  {
    sub_80108D0((int *)a1);
    *(_DWORD *)(a1 + 96) = 0;
    *(_BYTE *)(a1 + 88) = 0;
  }
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 29) & 1) != 0 )
    *(_DWORD *)(*(_DWORD *)a1 + 8) &= 0x5FFFFFC0u;
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 28) & 1) == 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x6FFFFFC0 | 0x10000000;
    for ( i = 2 * (dword_20000290 / 0x30D40u + 1); i; --i )
      ;
  }
  v4 = *(_DWORD *)a1;
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 28) & 1) == 0 )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
    *(_DWORD *)(a1 + 96) |= 1u;
    v2 = 1;
  }
  if ( *(_DWORD *)(a1 + 92) & 0x10 | sub_8016CC4(v4) )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFEFD | 2;
    if ( !sub_8016CBC(*(_DWORD *)a1) )
    {
      v5 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 == 1342177280 || v5 == 1342177536 )
        v6 = MEMORY[0x50000008] & 1 | MEMORY[0x50000108] & 1;
      else
        v6 = MEMORY[0x50000408] & 1 | MEMORY[0x50000508] & 1 | MEMORY[0x50000608] & 1;
      if ( !v6 )
      {
        if ( v5 == 1342177280 || v5 == 1342177536 )
          v7 = 1342178048;
        else
          v7 = 1342179072;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 8) & 0xFFC0FFFF | *(_DWORD *)(a1 + 4);
      }
    }
    v8 = *(unsigned __int8 *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 60)
       | *(_DWORD *)(a1 + 12)
       | *(_DWORD *)(a1 + 8)
       | (*(unsigned __int8 *)(a1 + 29) << 13)
       | (v8 << 16);
    if ( v8 == 1 )
      v9 |= (*(unsigned __int16 *)(a1 + 40) - 1) << 17;
    if ( *(_DWORD *)(a1 + 44) )
      v9 |= *(_DWORD *)(a1 + 48) | *(_DWORD *)(a1 + 44) & 0x3E0;
    *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(*(_DWORD *)a1 + 12) & 0xFFF04007 | v9;
    *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(*(_DWORD *)a1 + 16) & 0xF3FFFFFF | *(_DWORD *)(a1 + 52);
    v10 = sub_8016CC4(*(_DWORD *)a1);
    if ( !(v10 | sub_8016CB4(*(_DWORD *)a1)) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(*(_DWORD *)a1 + 12) & 0xFFFFBFFD
                                      | (*(unsigned __int8 *)(a1 + 28) << 14)
                                      | (2 * *(unsigned __int8 *)(a1 + 56));
      if ( *(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 16) |= 0x10000u;
        *(_DWORD *)(*(_DWORD *)a1 + 192) = *(_DWORD *)(*(_DWORD *)a1 + 192) & 0xFFFFC000 | *(_DWORD *)(a1 + 16);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~0x10000u;
        *(_DWORD *)(*(_DWORD *)a1 + 192) &= 0xFFFFC000;
      }
      if ( *(_BYTE *)(a1 + 64) == 1 )
        *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 68)
                                        | *(_DWORD *)(a1 + 72)
                                        | *(_DWORD *)(a1 + 76)
                                        | *(_DWORD *)(a1 + 80)
                                        | *(_DWORD *)(*(_DWORD *)a1 + 16) & 0xFFFFF803
                                        | 1;
      else
        *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~1u;
    }
    if ( *(_DWORD *)(a1 + 20) == 1 )
      *(_DWORD *)(*(_DWORD *)a1 + 48) = *(_DWORD *)(*(_DWORD *)a1 + 48) & 0xFFFFFFF0 | (*(_DWORD *)(a1 + 32) - 1);
    else
      *(_DWORD *)(*(_DWORD *)a1 + 48) &= 0xFFFFFFF0;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFFC | 1;
  }
  return v2;
}
// 20000290: using guessed type int dword_20000290;

//----- (080108D0) --------------------------------------------------------
int *__fastcall sub_80108D0(int *a1)
{
  int v2; // r1
  int *result; // r0
  _DWORD v4[17]; // [sp+4h] [bp-84h] BYREF
  int v5; // [sp+48h] [bp-40h]
  unsigned int v6; // [sp+4Ch] [bp-3Ch]
  int v7; // [sp+58h] [bp-30h] BYREF
  int v8; // [sp+5Ch] [bp-2Ch]
  int v9; // [sp+60h] [bp-28h]

  sub_8002364(v4, 84);
  v2 = *a1;
  if ( *a1 == 1342177280 )
  {
    v4[0] = 0x8000;
    v5 = 0x20000000;
    sub_8013424(v4);
    if ( ++dword_2000006C == 1 )
      MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 1u;
    v7 = 12;
    v8 = 3;
    v9 = 0;
    sub_80120B0((int *)0x48000800, (int)&v7);
    v7 = 4;
    v8 = 3;
    v9 = 0;
    return sub_80120B0((int *)0x48000000, (int)&v7);
  }
  else if ( v2 == 1342177536 )
  {
    v4[0] = 0x8000;
    v5 = 0x20000000;
    if ( sub_8013424(v4) )
      sub_80058BC();
    if ( ++dword_2000006C == 1 )
      MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 1u;
    v7 = 129;
    v8 = 3;
    v9 = 0;
    return sub_80120B0((int *)0x48000000, (int)&v7);
  }
  else
  {
    result = (int *)0x10000;
    switch ( v2 )
    {
      case 1342178304:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013424(v4) )
          sub_80058BC();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 2u;
        MEMORY[0x4002104C] |= 0x10u;
        v7 = 2;
        v8 = 3;
        v9 = 0;
        sub_80120B0((int *)0x48000400, (int)&v7);
        v7 = 8704;
        v8 = 3;
        v9 = 0;
        return sub_80120B0((int *)0x48001000, (int)&v7);
      case 1342178560:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013424(v4) )
          sub_80058BC();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 0x10u;
        MEMORY[0x4002104C] |= 2u;
        v7 = 49152;
        v8 = 3;
        v9 = 0;
        sub_80120B0((int *)0x48001000, (int)&v7);
        v7 = 0x4000;
        v8 = 3;
        v9 = 0;
        return sub_80120B0((int *)0x48000400, (int)&v7);
      case 1342178816:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013424(v4) )
          sub_80058BC();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 8u;
        v7 = 8960;
        v8 = 3;
        v9 = 0;
        return sub_80120B0((int *)0x48000C00, (int)&v7);
    }
  }
  return result;
}
// 2000006C: using guessed type int dword_2000006C;
// 20000070: using guessed type int dword_20000070;

//----- (08010B40) --------------------------------------------------------
int __fastcall sub_8010B40(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r8
  int v8; // r1
  int v9; // r5
  int result; // r0
  int v11; // r0

  v6 = *(_DWORD *)a1;
  v7 = 1342177280;
  if ( v6 == 1342177280 || v6 == 1342177536 )
    v8 = 1342178048;
  else
    v8 = 1342179072;
  v9 = *(_DWORD *)(v8 + 8) & 0x1F;
  if ( sub_8016CC4(v6) )
    return 2;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  if ( (*(_DWORD *)a1 == 1342178816 ? 0 : v9) == 0 || v9 == 5 || v9 == 9 )
  {
    result = sub_80033DC((int *)a1);
    if ( result )
    {
      *(_BYTE *)(a1 + 88) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF0FE | 0x100;
      v11 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 != 1342177536 )
      {
        if ( v11 == 1342178560 )
          v7 = 1342178304;
        else
          v7 = *(_DWORD *)a1;
      }
      if ( v7 == v11 || !v9 )
        *(_DWORD *)(a1 + 92) &= ~0x100000u;
      if ( (*(_DWORD *)(a1 + 92) & 0x1000) != 0 )
        *(_DWORD *)(a1 + 96) &= 0xFFFFFFF9;
      else
        *(_DWORD *)(a1 + 96) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 44) = 134232759;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 48) = 134232911;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 52) = 134232885;
      **(_DWORD **)a1 = 28;
      *(_BYTE *)(a1 + 88) = 0;
      *(_DWORD *)(*(_DWORD *)a1 + 4) |= 0x10u;
      *(_DWORD *)(*(_DWORD *)a1 + 12) |= 1u;
      result = sub_8011610(*(_DWORD *)(a1 + 84), *(_DWORD *)a1 + 64, a2, a3);
      *(_DWORD *)(*(_DWORD *)a1 + 8) = (*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x7FFFFFC0) + 4;
    }
  }
  else
  {
    result = 1;
    *(_BYTE *)(a1 + 88) = 0;
  }
  return result;
}

//----- (08010C70) --------------------------------------------------------
int __fastcall sub_8010C70(int a1)
{
  int v2; // r5
  int v3; // r2
  int *v4; // r1
  int v5; // r0
  int v6; // r6
  unsigned int i; // [sp+0h] [bp-28h]

  v2 = 0;
  if ( !a1 )
    return 1;
  if ( **(int **)a1 < 0 )
    return 1;
  if ( !*(_BYTE *)(a1 + 29) )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    sub_8010EF0((int **)a1);
  }
  v3 = **(_DWORD **)a1 & 0x800000;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFF007E0F
                  | *(_DWORD *)(a1 + 8)
                  | *(_DWORD *)(a1 + 4)
                  | *(_DWORD *)(a1 + 20)
                  | *(_DWORD *)(a1 + 12)
                  | *(_DWORD *)(a1 + 16);
  v4 = *(int **)a1;
  if ( (**(_DWORD **)a1 & 0x800000) != 0 && !v3 )
  {
    for ( i = 20 * (dword_20000290 / 0x30D40u + 1); i; --i )
      ;
  }
  if ( v4 == (int *)1073807872 )
  {
    v5 = 0x200000;
  }
  else if ( v4 == (int *)1073807876 )
  {
    v5 = 0x400000;
  }
  else if ( v4 == (int *)1073807880 )
  {
    v5 = 0x20000000;
  }
  else if ( v4 == (int *)1073807884 )
  {
    v5 = 0x40000000;
  }
  else if ( v4 == (int *)1073807888 )
  {
    v5 = 0x80000000;
  }
  else if ( v4 == (int *)1073807892 )
  {
    v5 = 1;
  }
  else
  {
    v5 = 2;
  }
  v6 = *(_DWORD *)(a1 + 24);
  if ( v6 << 30 )
  {
    if ( (v6 & 0x10) != 0 )
    {
      if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
        MEMORY[0x40010428] |= v5;
      else
        MEMORY[0x40010408] |= v5;
    }
    else if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
    {
      MEMORY[0x40010428] &= ~v5;
    }
    else
    {
      MEMORY[0x40010408] &= ~v5;
    }
    if ( (*(_BYTE *)(a1 + 24) & 0x20) != 0 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x4001042C] |= v5;
      else
        MEMORY[0x4001040C] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x4001042C] &= ~v5;
    }
    else
    {
      MEMORY[0x4001040C] &= ~v5;
    }
    if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
      MEMORY[0x40010434] = v5;
    else
      MEMORY[0x40010414] = v5;
    if ( (*(_BYTE *)(a1 + 24) & 2) != 0 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x40010424] |= v5;
      else
        MEMORY[0x40010404] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x40010424] &= ~v5;
    }
    else
    {
      MEMORY[0x40010404] &= ~v5;
    }
    if ( *(unsigned __int8 *)(a1 + 24) << 31 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x40010420] |= v5;
      else
        MEMORY[0x40010400] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x40010420] &= ~v5;
    }
    else
    {
      MEMORY[0x40010400] &= ~v5;
    }
  }
  else
  {
    if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
      MEMORY[0x40010424] &= ~v5;
    else
      MEMORY[0x40010404] &= ~v5;
    if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
      MEMORY[0x40010420] &= ~v5;
    else
      MEMORY[0x40010400] &= ~v5;
  }
  if ( !*(_BYTE *)(a1 + 29) )
    *(_BYTE *)(a1 + 29) = 1;
  return v2;
}
// 20000290: using guessed type int dword_20000290;

//----- (08010EF0) --------------------------------------------------------
int *__fastcall sub_8010EF0(int **a1)
{
  int *result; // r0
  int v3; // [sp+4h] [bp-1Ch] BYREF
  int v4; // [sp+8h] [bp-18h]
  int v5; // [sp+Ch] [bp-14h]

  sub_8002364(&v3, 20);
  result = *a1;
  if ( *a1 == (int *)1073807872 )
  {
    MEMORY[0x4002104C] |= 1u;
    v3 = 2;
    v4 = 3;
    v5 = 0;
    return sub_80120B0((int *)0x48000000, (int)&v3);
  }
  else if ( result == (int *)1073807884 )
  {
    MEMORY[0x4002104C] |= 2u;
    v3 = 1;
    v4 = 3;
    v5 = 0;
    return sub_80120B0((int *)0x48000400, (int)&v3);
  }
  else if ( result == (int *)1073807880 )
  {
    MEMORY[0x4002104C] |= 4u;
    v3 = 3;
    v4 = 3;
    v5 = 0;
    return sub_80120B0((int *)0x48000800, (int)&v3);
  }
  return result;
}

//----- (08010F94) --------------------------------------------------------
int __fastcall sub_8010F94(int a1)
{
  int result; // r0
  unsigned int i; // [sp+0h] [bp-8h]

  result = 0;
  if ( !a1 )
    return 1;
  if ( **(int **)a1 < 0 )
    return 1;
  if ( *(_BYTE *)(a1 + 29) != 1 )
    return 1;
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 29) = 2;
  for ( i = 5 * (dword_20000290 / 0x1E8480u); i; --i )
    ;
  return result;
}
// 20000290: using guessed type int dword_20000290;

//----- (08010FF0) --------------------------------------------------------
int __fastcall sub_8010FF0(int a1, _DWORD *a2)
{
  int v2; // r2

  v2 = 0;
  if ( *(_BYTE *)(a1 + 33) == 1 )
  {
    **(_DWORD **)a1 = *a2 | a2[6] | a2[1] | a2[4] | a2[5] | a2[2] | a2[3] | **(_DWORD **)a1 & 0xFF87F800;
  }
  else
  {
    *(_DWORD *)(a1 + 36) |= 2u;
    return 1;
  }
  return v2;
}

//----- (08011038) --------------------------------------------------------
int __fastcall sub_8011038(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 33) )
  {
    *(_BYTE *)(a1 + 32) = 0;
    sub_8003216();
  }
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)(a1 + 33) = 1;
  return 0;
}

//----- (08011070) --------------------------------------------------------
int __fastcall sub_8011070(int a1, int a2, int a3)
{
  char v6; // r6
  int result; // r0
  int v8; // r7
  int v9; // r0
  BOOL v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r0
  int v14; // r9
  int v15; // r9
  unsigned int v16; // r7
  unsigned int v17; // r0

  if ( *(_BYTE *)(a1 + 5) == 1 )
    return 2;
  *(_BYTE *)(a1 + 5) = 1;
  *(_BYTE *)(a1 + 4) = 2;
  v6 = a3 & 0x10;
  if ( *(_DWORD *)(a2 + 8) == 4 )
  {
    v8 = sub_8012298();
    if ( a3 )
    {
      while ( *(int *)(*(_DWORD *)a1 + 52) < 0 )
      {
        if ( (unsigned int)(sub_8012298() - v8) > 1 )
        {
          *(_DWORD *)(a1 + 16) |= 8u;
          *(_BYTE *)(a1 + 4) = 3;
          return 3;
        }
      }
      sub_80116A0(1u);
      *(_DWORD *)(*(_DWORD *)a1 + 68) = *(_DWORD *)(a2 + 36);
    }
    else
    {
      while ( (*(_DWORD *)(*(_DWORD *)a1 + 52) & 0x8000) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v8) > 1 )
        {
          *(_DWORD *)(a1 + 16) |= 8u;
          *(_BYTE *)(a1 + 4) = 3;
          return 3;
        }
      }
      sub_80116A0(1u);
      *(_DWORD *)(*(_DWORD *)a1 + 64) = *(_DWORD *)(a2 + 36);
    }
    *(_DWORD *)(*(_DWORD *)a1 + 72) = *(_DWORD *)(*(_DWORD *)a1 + 72) & ~(1023 << v6) | (*(_DWORD *)(a2 + 40) << v6);
    *(_DWORD *)(*(_DWORD *)a1 + 76) = *(_DWORD *)(*(_DWORD *)a1 + 76) & ~(255 << v6) | (*(_DWORD *)(a2 + 44) << v6);
  }
  if ( *(_DWORD *)(a2 + 28) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 56) = (*(_DWORD *)(a2 + 32) << v6) | *(_DWORD *)(*(_DWORD *)a1 + 56) & ~(31 << v6);
  v9 = *(_DWORD *)(a2 + 24);
  if ( v9 == 1 )
    v10 = 0;
  else
    v10 = v9 == 2 || *(_DWORD *)(a2 + 20) == 0;
  v11 = *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 20) | v10;
  v12 = 256;
  if ( *(_BYTE *)(a2 + 4) != 1 )
    v12 = 0;
  v13 = v12 | v11;
  v14 = 512;
  if ( *(_BYTE *)(a2 + 5) != 1 )
    v14 = 0;
  v15 = v14 | v13;
  v16 = *(_DWORD *)(*(_DWORD *)a1 + 60) & ~(7 << v6) & ~(256 << v6) & ~(512 << v6) & 0xFFFF3FFF;
  if ( *(_DWORD *)a2 == 2 )
  {
    v17 = sub_80138FC();
    if ( v17 <= 0x9896800 )
    {
      if ( v17 > 0x4C4B400 )
        v16 |= 0x4000u;
    }
    else
    {
      v16 |= 0x8000u;
    }
  }
  else
  {
    v16 |= *(_DWORD *)a2;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 60) = (v15 << v6) | v16;
  **(_DWORD **)a1 &= ~(0x4000 << v6);
  **(_DWORD **)a1 = (*(_DWORD *)(a2 + 12) << v6) | **(_DWORD **)a1 & ~(4094 << v6);
  **(_DWORD **)a1 &= ~(192 << v6);
  *(_DWORD *)(*(_DWORD *)a1 + 96) = *(_DWORD *)(*(_DWORD *)a1 + 96) & ~(3855 << v6)
                                  | (((*(unsigned __int8 *)(a2 + 12) >> 2) & 0xF | ((*(_BYTE *)(a2 + 16) & 0x3C) << 6)) << v6);
  *(_BYTE *)(a1 + 4) = 1;
  result = 0;
  *(_BYTE *)(a1 + 5) = 0;
  return result;
}

//----- (08011244) --------------------------------------------------------
int __fastcall sub_8011244(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 4) )
  {
    *(_BYTE *)(a1 + 5) = 0;
    sub_8011270((int *)a1);
  }
  *(_BYTE *)(a1 + 4) = 2;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 4) = 1;
  return 0;
}

//----- (08011270) --------------------------------------------------------
int __fastcall sub_8011270(int *a1)
{
  int v2; // r1
  int result; // r0
  _DWORD v4[7]; // [sp+4h] [bp-1Ch] BYREF

  sub_8002364(v4, 20);
  v2 = *a1;
  result = 1073876992;
  if ( *a1 == 1342179328 )
  {
    MEMORY[0x4002104C] |= 0x10000u;
    return MEMORY[0x4002104C] & 0x10000;
  }
  else if ( v2 == 1342180352 )
  {
    MEMORY[0x4002104C] |= 0x20000u;
    MEMORY[0x4002104C] |= 1u;
    v4[0] = 64;
    v4[1] = 3;
    v4[2] = 2;
    return (int)sub_80120B0((int *)0x48000000, (int)v4);
  }
  else if ( v2 == 1342181376 )
  {
    MEMORY[0x4002104C] |= 0x40000u;
    return MEMORY[0x4002104C] & 0x40000;
  }
  return result;
}

//----- (08011304) --------------------------------------------------------
int __fastcall sub_8011304(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // r0
  _DWORD *v6; // [sp+0h] [bp-18h]

  v4 = *a1 + a3;
  if ( a2 )
    v6 = (_DWORD *)(v4 + 20);
  else
    v6 = (_DWORD *)(v4 + 8);
  *v6 = a4;
  return 0;
}

//----- (08011336) --------------------------------------------------------
int __fastcall sub_8011336(_BYTE *a1, int a2)
{
  char v4; // r5
  int result; // r0

  if ( a1[5] == 1 )
    return 2;
  a1[5] = 1;
  a1[4] = 2;
  v4 = a2 & 0x10;
  **(_DWORD **)a1 |= 1 << (a2 & 0x10);
  sub_80116A0(1u);
  if ( a2 )
  {
    if ( (**(_DWORD **)a1 & 0x3E0000) == 2 << v4 )
      *(_DWORD *)(*(_DWORD *)a1 + 4) |= 2u;
  }
  else if ( ((**(_DWORD **)a1 >> 1) & 0x1F) == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 4) |= 1u;
  }
  a1[4] = 1;
  result = 0;
  a1[5] = 0;
  return result;
}

//----- (080113A4) --------------------------------------------------------
int __fastcall sub_80113A4(int a1)
{
  int v1; // r1
  _DWORD *v2; // r2
  _BYTE *v3; // r0

  v1 = 0;
  if ( *(_BYTE *)(a1 + 37) == 2 )
  {
    **(_DWORD **)a1 &= 0xFFFFFFF1;
    **(_DWORD **)(a1 + 72) &= ~0x100u;
    **(_DWORD **)a1 &= ~1u;
    *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4) = 1 << (*(_BYTE *)(a1 + 68) & 0x1F);
    *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
    v2 = *(_DWORD **)(a1 + 84);
    if ( v2 )
    {
      *v2 &= ~0x100u;
      *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 60) = 4;
    v1 = 1;
  }
  v3 = (_BYTE *)(a1 + 36);
  v3[1] = 1;
  *v3 = 0;
  return v1;
}

//----- (0801140C) --------------------------------------------------------
int __fastcall sub_801140C(int a1)
{
  int v1; // r4
  int v2; // r0
  _DWORD *v3; // r1
  void (*v4)(void); // r1

  v1 = 0;
  if ( *(_BYTE *)(a1 + 37) == 2 )
  {
    **(_DWORD **)a1 &= 0xFFFFFFF1;
    **(_DWORD **)a1 &= ~1u;
    **(_DWORD **)(a1 + 72) &= ~0x100u;
    *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4) = 1 << (*(_BYTE *)(a1 + 68) & 0x1F);
    *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
    v3 = *(_DWORD **)(a1 + 84);
    if ( v3 )
    {
      *v3 &= ~0x100u;
      *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
    }
    *(_BYTE *)(a1 + 37) = 1;
    *(_BYTE *)(a1 + 36) = 0;
    v4 = *(void (**)(void))(a1 + 56);
    if ( v4 )
      v4();
  }
  else
  {
    v2 = a1 + 36;
    *(_DWORD *)(v2 + 24) = 4;
    *(_BYTE *)(v2 + 1) = 1;
    *(_BYTE *)v2 = 0;
    return 1;
  }
  return v1;
}

//----- (08011550) --------------------------------------------------------
int __fastcall sub_8011550(int a1)
{
  unsigned int *v2; // r0
  int v4; // r4

  if ( !a1 )
    return 1;
  v2 = *(unsigned int **)a1;
  if ( *(_DWORD *)a1 >= 0x40020408u )
  {
    *(_DWORD *)(a1 + 68) = 4 * ((unsigned int)(v2 - 268468482) / 0x14);
    *(_DWORD *)(a1 + 64) = 1073873920;
  }
  else
  {
    *(_DWORD *)(a1 + 68) = 4 * ((unsigned int)(v2 - 268468226) / 0x14);
    *(_DWORD *)(a1 + 64) = 1073872896;
  }
  *(_BYTE *)(a1 + 37) = 2;
  *v2 = *(_DWORD *)(a1 + 8)
      | *(_DWORD *)(a1 + 12)
      | *(_DWORD *)(a1 + 16)
      | *(_DWORD *)(a1 + 20)
      | *(_DWORD *)(a1 + 24)
      | *(_DWORD *)(a1 + 28)
      | *(_DWORD *)(a1 + 32)
      | *v2 & 0xFFFF800F;
  sub_8004DAC((int *)a1);
  if ( *(_DWORD *)(a1 + 8) == 0x4000 )
    *(_DWORD *)(a1 + 4) = 0;
  **(_DWORD **)(a1 + 72) = *(unsigned __int8 *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) > 3 )
  {
    *(_DWORD *)(a1 + 84) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 92) = 0;
  }
  else
  {
    sub_8004DEC(a1);
    **(_DWORD **)(a1 + 84) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
  }
  v4 = a1 + 36;
  *(_DWORD *)(v4 + 24) = 0;
  *(_BYTE *)(v4 + 1) = 1;
  *(_BYTE *)v4 = 0;
  return 0;
}

//----- (08011610) --------------------------------------------------------
int __fastcall sub_8011610(int a1, int a2, int a3, int a4)
{
  int v5; // r5
  int v7; // r1
  _DWORD *v8; // r0
  _DWORD *v9; // r0

  v5 = 0;
  if ( *(_BYTE *)(a1 + 36) == 1 )
    return 2;
  *(_BYTE *)(a1 + 36) = 1;
  if ( *(_BYTE *)(a1 + 37) == 1 )
  {
    *(_BYTE *)(a1 + 37) = 2;
    *(_DWORD *)(a1 + 60) = 0;
    **(_DWORD **)a1 &= ~1u;
    sub_8004E10((int *)a1, a2, a3, a4);
    if ( *(_DWORD *)(a1 + 48) )
    {
      v7 = **(_DWORD **)a1 | 0xE;
    }
    else
    {
      **(_DWORD **)a1 &= ~4u;
      v7 = **(_DWORD **)a1 | 0xA;
    }
    **(_DWORD **)a1 = v7;
    v8 = *(_DWORD **)(a1 + 72);
    if ( (*v8 & 0x10000) != 0 )
      *v8 |= 0x100u;
    v9 = *(_DWORD **)(a1 + 84);
    if ( v9 )
      *v9 |= 0x100u;
    **(_DWORD **)a1 |= 1u;
  }
  else
  {
    *(_BYTE *)(a1 + 36) = 0;
    return 2;
  }
  return v5;
}

//----- (080116A0) --------------------------------------------------------
unsigned int __fastcall sub_80116A0(unsigned int a1)
{
  int v2; // r5
  unsigned int result; // r0

  v2 = sub_8012298();
  if ( a1 != -1 )
    a1 += dword_20000268;
  do
    result = sub_8012298() - v2;
  while ( result < a1 );
  return result;
}
// 20000268: using guessed type int dword_20000268;

//----- (080116C4) --------------------------------------------------------
int __fastcall sub_80116C4(unsigned __int8 *a1, int a2, int a3)
{
  int v3; // r3
  int v5; // r3

  v3 = a1[92];
  if ( v3 == 1 || v3 == 2 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 88);
    if ( a2 << 29 && !(v5 << 31)
      || (a2 & 0x38) != 0 && (v5 & 2) == 0
      || (a2 & 0x1C0) != 0 && (v5 & 4) == 0
      || (a2 & 0x1E00) != 0 && (v5 & 8) == 0
      || (a2 & 0xE000) != 0 && (v5 & 0x10) == 0
      || (a2 & 0x30000) != 0 && (v5 & 0x20) == 0
      || (a2 & 0xFC0000) != 0 && (v5 & 0x40) == 0 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 92) |= 1u;
    }
    if ( a2 << 29 && v5 << 31
      || (a2 & 0x38) != 0 && (v5 & 2) != 0
      || (a2 & 0x1C0) != 0 && (v5 & 4) != 0
      || (a2 & 0x1E00) != 0 && (v5 & 8) != 0
      || (a2 & 0xE000) != 0 && (v5 & 0x10) != 0
      || (a2 & 0x30000) != 0 && (v5 & 0x20) != 0
      || (a2 & 0xFC0000) != 0 && (v5 & 0x40) != 0 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 92) |= 2u;
    }
    if ( (a2 & 0x80) != 0 )
      *(_DWORD *)(*(_DWORD *)a1 + 220) |= a3;
    if ( (a2 & 0x100) != 0 )
      *(_DWORD *)(*(_DWORD *)a1 + 224) |= a3;
    *(_DWORD *)(*(_DWORD *)a1 + 84) |= a2;
    return 0;
  }
  else
  {
    *((_DWORD *)a1 + 24) |= 2u;
    return 1;
  }
}

//----- (080117A4) --------------------------------------------------------
int __fastcall sub_80117A4(_DWORD *a1, int *a2, int a3)
{
  int v5; // r0
  int v6; // r5

  if ( *((_BYTE *)a1 + 92) == 2 )
  {
    v5 = *a1;
    if ( (*(_DWORD *)(*a1 + 196) & 0x200000) != 0 )
    {
      a1[24] |= 0x200u;
      return 1;
    }
    else
    {
      v6 = HIWORD(*(_DWORD *)(v5 + 196)) & 3;
      sub_80059B8((int)a1, a2, a3, v6);
      *(_DWORD *)(*a1 + 204) = 1 << v6;
      a1[22] = 1 << v6;
      return 0;
    }
  }
  else
  {
    a1[24] |= 8u;
    return 1;
  }
}

//----- (080117F2) --------------------------------------------------------
int __fastcall sub_80117F2(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int *v5; // r0

  v2 = *(unsigned __int8 *)(a1 + 92);
  if ( v2 == 1 || v2 == 2 )
  {
    if ( *(_DWORD *)a2 )
    {
      v4 = *(_DWORD *)(a2 + 20) | (*(unsigned __int8 *)(a2 + 8) << 30);
      v5 = (int *)(*(_DWORD *)(a1 + 68) + 8 * *(_DWORD *)(a2 + 4));
      *v5 = *(_DWORD *)(a2 + 16) | (*(unsigned __int8 *)(a2 + 12) << 29);
      v5[1] = v4;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4 * *(_DWORD *)(a2 + 4)) = *(_DWORD *)(a2 + 20)
                                                                  | (*(unsigned __int8 *)(a2 + 8) << 30)
                                                                  | (*(unsigned __int8 *)(a2 + 12) << 27)
                                                                  | (*(unsigned __int16 *)(a2 + 16) << 16);
    }
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 2u;
    return 1;
  }
}

//----- (08011850) --------------------------------------------------------
int __fastcall sub_8011850(int a1, int a2, int a3, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 92) == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 128) = (16 * a2)
                                     | (4 * a3)
                                     | (2 * a4)
                                     | a5
                                     | *(_DWORD *)(*(_DWORD *)a1 + 128) & 0xFFFFFFC0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    return 1;
  }
}

//----- (08011886) --------------------------------------------------------
int __fastcall sub_8011886(int a1)
{
  int result; // r0

  if ( !a1 )
    return 1;
  sub_8011DEE((int *)a1);
  *(_DWORD *)(*(_DWORD *)a1 + 92) &= 0xFFFFFFFC;
  nullsub_2(a1);
  result = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 92) = 0;
  return result;
}
// 8011CFC: using guessed type int __fastcall nullsub_2(_DWORD);

//----- (080118B4) --------------------------------------------------------
int __fastcall sub_80118B4(int a1, int a2, int *a3, int a4)
{
  int v5; // r6
  int v6; // r5
  int v7; // r4
  unsigned int v8; // r4
  int v9; // r5
  unsigned int i; // r4

  if ( *(_BYTE *)(a1 + 92) != 2 )
  {
    *(_DWORD *)(a1 + 96) |= 8u;
    return 1;
  }
  if ( a2 == 64 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 144) << 28 )
    {
      v5 = (*(_DWORD *)(*(_DWORD *)a1 + 144) >> 8) & 3;
      v6 = *(_DWORD *)(a1 + 72) + 72 * v5;
      goto LABEL_6;
    }
LABEL_12:
    *(_DWORD *)(a1 + 96) |= 0x100u;
    return 1;
  }
  if ( !(*(_DWORD *)(*(_DWORD *)a1 + 152) << 28) )
    goto LABEL_12;
  v5 = (*(_DWORD *)(*(_DWORD *)a1 + 152) >> 8) & 3;
  v6 = *(_DWORD *)(a1 + 76) + 72 * v5;
LABEL_6:
  v7 = *(_DWORD *)v6 & 0x40000000;
  a3[1] = v7;
  if ( v7 )
    *a3 = *(_DWORD *)v6 & 0x1FFFFFFF;
  else
    *a3 = (*(_DWORD *)v6 >> 18) & 0x7FF;
  a3[2] = *(_DWORD *)v6 & 0x20000000;
  a3[4] = *(_DWORD *)v6 & 0x80000000;
  a3[7] = *(unsigned __int16 *)(v6 + 4);
  a3[3] = *(_DWORD *)(v6 + 4) & 0xF0000;
  a3[5] = *(_DWORD *)(v6 + 4) & 0x100000;
  a3[6] = *(_DWORD *)(v6 + 4) & 0x200000;
  a3[8] = HIBYTE(*(_DWORD *)(v6 + 4)) & 0x7F;
  v8 = *(_DWORD *)(v6 + 4);
  v9 = v6 + 8;
  a3[9] = v8 >> 31;
  for ( i = 0; *((unsigned __int8 *)dword_802616C + HIWORD(a3[3])) > i; ++i )
    *(_BYTE *)(a4 + i) = *(_BYTE *)(v9 + i);
  if ( a2 == 64 )
    *(_DWORD *)(*(_DWORD *)a1 + 148) = v5;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 156) = v5;
  return 0;
}
// 802616C: using guessed type int dword_802616C[4];

//----- (08011B20) --------------------------------------------------------
int __fastcall sub_8011B20(int a1)
{
  int v3; // r5
  int v4; // r5
  int v5; // r0

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 92) )
  {
    *(_BYTE *)(a1 + 93) = 0;
    sub_8011D00((int *)a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x10u;
  v3 = sub_8012298();
  while ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 8) != 0 )
  {
    if ( (unsigned int)(sub_8012298() - v3) > 0xA )
    {
      *(_DWORD *)(a1 + 96) |= 1u;
      *(_BYTE *)(a1 + 92) = 3;
      return 1;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) |= 1u;
  v4 = sub_8012298();
  while ( !(*(_DWORD *)(*(_DWORD *)a1 + 24) << 31) )
  {
    if ( (unsigned int)(sub_8012298() - v4) > 0xA )
    {
      *(_DWORD *)(a1 + 96) |= 1u;
      *(_BYTE *)(a1 + 92) = 3;
      return 1;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) |= 2u;
  if ( *(_DWORD *)a1 == 1073767424 )
    MEMORY[0x40006500] = *(_DWORD *)(a1 + 4);
  if ( *(_BYTE *)(a1 + 16) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x40u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x40u;
  if ( *(_BYTE *)(a1 + 17) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x4000u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x4000u;
  if ( *(_BYTE *)(a1 + 18) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x1000u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x1000u;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(*(_DWORD *)a1 + 24) & 0xFFFFFCFF | *(_DWORD *)(a1 + 8);
  *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFFF5B;
  *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~0x10u;
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 4u;
  }
  else if ( v5 )
  {
    if ( v5 == 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x80u;
      *(_DWORD *)(*(_DWORD *)a1 + 16) |= 0x10u;
      if ( *(_DWORD *)(a1 + 12) == 3 )
        *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 28) = ((*(unsigned __int8 *)(a1 + 24) - 1) << 25)
                                  | ((*(_DWORD *)(a1 + 28) - 1) << 8)
                                  | (*(_DWORD *)(a1 + 32) - 1)
                                  | ((*(unsigned __int16 *)(a1 + 20) - 1) << 16);
  if ( *(_DWORD *)(a1 + 8) == 768 )
    *(_DWORD *)(*(_DWORD *)a1 + 12) = (*(_DWORD *)(a1 + 40) - 1)
                                    | ((*(_DWORD *)(a1 + 44) - 1) << 8)
                                    | (16 * (*(_DWORD *)(a1 + 48) - 1))
                                    | ((*(unsigned __int16 *)(a1 + 36) - 1) << 16);
  *(_DWORD *)(*(_DWORD *)a1 + 192) |= *(_DWORD *)(a1 + 60);
  sub_8005944((int *)a1);
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 92) = 1;
  return 0;
}

//----- (08011D00) --------------------------------------------------------
int __fastcall sub_8011D00(int *a1)
{
  int result; // r0
  _DWORD v3[21]; // [sp+8h] [bp-70h] BYREF
  _DWORD v4[7]; // [sp+5Ch] [bp-1Ch] BYREF

  sub_8002364(v4, 20);
  sub_8002364(v3, 84);
  result = *a1;
  if ( *a1 == 1073768448 )
  {
    v3[0] = 4096;
    v3[14] = 0x2000000;
    sub_8013424(v3);
    MEMORY[0x4002104C] |= 2u;
    MEMORY[0x40021058] |= 0x2000000u;
    v4[0] = 96;
    v4[1] = 2;
    v4[2] = 1;
    v4[3] = 2;
    v4[4] = 9;
    sub_80120B0((int *)0x48000400, (int)v4);
    sub_80132C0(86, 0xDu, 0);
    return sub_80132A4(86);
  }
  return result;
}

//----- (08011D88) --------------------------------------------------------
int __fastcall sub_8011D88(unsigned __int8 *a1, int a2)
{
  int result; // r0

  result = a2 << 31;
  if ( a2 << 31 )
  {
    sub_80118B4((int)a1, 64, &dword_200020D8, (int)&unk_2000025A);
    sub_80046BC(dword_200020D8, (int *)&unk_2000025A);
    return sub_80116C4(a1, 1, 0);
  }
  return result;
}
// 200020D8: using guessed type int dword_200020D8;

//----- (08011DC2) --------------------------------------------------------
int __fastcall sub_8011DC2(int a1)
{
  if ( *(_BYTE *)(a1 + 92) == 1 )
  {
    *(_BYTE *)(a1 + 92) = 2;
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~1u;
    *(_DWORD *)(a1 + 96) = 0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    return 1;
  }
}

//----- (08011DEE) --------------------------------------------------------
int __fastcall sub_8011DEE(int *a1)
{
  unsigned int v1; // r1
  int v3; // r2
  unsigned int v4; // r1
  int v5; // r2

  v1 = 0;
  if ( *((_BYTE *)a1 + 92) == 2 )
  {
    *(_DWORD *)(*a1 + 24) |= 1u;
    v3 = *a1;
    while ( !(*(_DWORD *)(v3 + 24) << 31) )
    {
      if ( v1 > 0xA )
      {
        a1[24] |= 1u;
        *((_BYTE *)a1 + 92) = 3;
        return 1;
      }
      ++v1;
    }
    v4 = 0;
    *(_DWORD *)(v3 + 24) &= ~0x10u;
    v5 = *a1;
    while ( (*(_DWORD *)(v5 + 24) & 8) != 0 )
    {
      if ( v4 > 0xA )
      {
        a1[24] |= 1u;
        *((_BYTE *)a1 + 92) = 3;
        return 1;
      }
      ++v4;
    }
    *(_DWORD *)(v5 + 24) |= 2u;
    a1[22] = 0;
    *((_BYTE *)a1 + 92) = 1;
    return 0;
  }
  else
  {
    a1[24] |= 8u;
    return 1;
  }
}

//----- (08011E80) --------------------------------------------------------
int __fastcall sub_8011E80(_DWORD *a1, unsigned int *a2)
{
  int v4; // r6
  unsigned int i; // r5

  if ( byte_20000270 == 1 )
    return 2;
  byte_20000270 = 1;
  v4 = sub_8005B58(0x3E8u);
  if ( !v4 )
  {
    dword_20000274 = 0;
    if ( (MEMORY[0x40022000] & 0x200) != 0 )
    {
      if ( (MEMORY[0x40022000] & 0x400) != 0 )
      {
        MEMORY[0x40022000] &= ~0x400u;
        byte_2000028C = 3;
      }
      else
      {
        byte_2000028C = 1;
      }
    }
    else if ( (MEMORY[0x40022000] & 0x400) != 0 )
    {
      MEMORY[0x40022000] &= ~0x400u;
      byte_2000028C = 2;
    }
    else
    {
      byte_2000028C = 0;
    }
    if ( *a1 == 1 )
    {
      sub_8005A88(a1[1]);
      v4 = sub_8005B58(0x3E8u);
      MEMORY[0x40022014] &= 0xFFFF7FFB;
    }
    else
    {
      *a2 = -1;
      for ( i = a1[2]; a1[2] + a1[3] > i; ++i )
      {
        sub_8005AC4(i, a1[1]);
        v4 = sub_8005B58(0x3E8u);
        MEMORY[0x40022014] &= 0xFFFFFC05;
        if ( v4 )
        {
          *a2 = i;
          break;
        }
      }
    }
    sub_8005A2C();
  }
  byte_20000270 = 0;
  return v4;
}
// 20000270: using guessed type char byte_20000270;
// 20000274: using guessed type int dword_20000274;
// 2000028C: using guessed type char byte_2000028C;

//----- (08011F78) --------------------------------------------------------
BOOL sub_8011F78()
{
  MEMORY[0x40022014] |= 0x80000000;
  return MEMORY[0x40022014] >= 0;
}

//----- (08011F94) --------------------------------------------------------
int __fastcall sub_8011F94(int a1, _DWORD *a2, int *a3, int a4)
{
  int v8; // r6
  int result; // r0
  int v10; // r1

  v8 = 0;
  if ( byte_20000270 == 1 )
    return 2;
  byte_20000270 = 1;
  result = sub_8005B58(0x3E8u);
  if ( !result )
  {
    dword_20000274 = 0;
    if ( a1 )
    {
      if ( a1 == 1 || a1 == 2 )
      {
        sub_8005B2C(a2, a3);
        if ( a1 == 2 )
          v8 = 0x40000;
      }
    }
    else
    {
      sub_8005B10(a2, v10, (int)a3, a4);
      v8 = 1;
    }
    result = sub_8005B58(0x3E8u);
    if ( v8 )
      MEMORY[0x40022014] &= ~v8;
  }
  byte_20000270 = 0;
  return result;
}
// 8011FE0: variable 'v10' is possibly undefined
// 20000270: using guessed type char byte_20000270;
// 20000274: using guessed type int dword_20000274;

//----- (08012014) --------------------------------------------------------
int sub_8012014()
{
  int result; // r0

  result = 0;
  if ( MEMORY[0x40022014] < 0 )
  {
    MEMORY[0x40022008] = -839939669;
    return 1;
  }
  return result;
}

//----- (0801203C) --------------------------------------------------------
int __fastcall sub_801203C(int result)
{
  unsigned int v1; // r0
  int v2; // r1

  if ( result == 128 || result == 256 )
  {
    sub_8003220();
    v1 = 23;
    goto LABEL_10;
  }
  if ( result == 1024 || result == 2048 )
  {
    sub_8003220();
    v1 = 40;
LABEL_10:
    v2 = 1 << (v1 & 0x1F);
    result = 4 * (v1 >> 5) - 536813568;
    *(_DWORD *)(result + 384) = v2;
    __dsb(0xFu);
    __isb(0xFu);
  }
  return result;
}
// 801E232: conditional instruction was optimized away because r0.4 is in (==17|==28)

//----- (08012098) --------------------------------------------------------
int __fastcall sub_8012098(int result)
{
  if ( (MEMORY[0x40010414] & result) != 0 )
  {
    MEMORY[0x40010414] = result;
    return sub_801203C(result);
  }
  return result;
}

//----- (080120B0) --------------------------------------------------------
int *__fastcall sub_80120B0(int *result, int a2)
{
  unsigned int i; // r2
  int v3; // r3
  int v4; // r4
  int v5; // r4
  int v6; // r4
  int v7; // r4
  int v8; // r4
  int v9; // r4

  for ( i = 0; *(_DWORD *)a2 >> i; ++i )
  {
    v3 = *(_DWORD *)a2 & (1 << i);
    if ( v3 )
    {
      v4 = *(_BYTE *)(a2 + 4) & 3;
      if ( v4 == 1 || v4 == 2 )
      {
        result[2] = (*(_DWORD *)(a2 + 12) << (2 * i)) | result[2] & ~(3 << (2 * i));
        result[1] = (((*(unsigned __int8 *)(a2 + 4) >> 4) & 1) << i) | result[1] & ~(1 << i);
      }
      if ( ~*(unsigned __int8 *)(a2 + 4) << 30 )
        result[3] = (*(_DWORD *)(a2 + 8) << (2 * i)) | result[3] & ~(3 << (2 * i));
      if ( (*(_BYTE *)(a2 + 4) & 3) == 2 )
        result[(i >> 3) + 8] = (*(_DWORD *)(a2 + 16) << ((4 * i) & 0x1F))
                             | result[(i >> 3) + 8] & ~(15 << ((4 * i) & 0x1F));
      *result = ((*(_BYTE *)(a2 + 4) & 3) << (2 * i)) | *result & ~(3 << (2 * i));
      if ( (*(_DWORD *)(a2 + 4) & 0x30000) != 0 )
      {
        MEMORY[0x40021060] |= 1u;
        if ( result == (int *)1207959552 )
        {
          v5 = 0;
        }
        else if ( result == (int *)1207960576 )
        {
          v5 = 1;
        }
        else if ( result == (int *)1207961600 )
        {
          v5 = 2;
        }
        else if ( result == (int *)1207962624 )
        {
          v5 = 3;
        }
        else if ( result == (int *)1207963648 )
        {
          v5 = 4;
        }
        else if ( result == (int *)1207964672 )
        {
          v5 = 5;
        }
        else
        {
          v5 = 6;
        }
        *(_DWORD *)((i & 0xFFFFFFFC) + 1073807368) = (v5 << ((4 * i) & 0xF))
                                                   | *(_DWORD *)((i & 0xFFFFFFFC) + 1073807368)
                                                   & ~(15 << ((4 * i) & 0xF));
        v6 = MEMORY[0x40010408] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x100000) != 0 )
          v6 |= v3;
        MEMORY[0x40010408] = v6;
        v7 = MEMORY[0x4001040C] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x200000) != 0 )
          v7 |= v3;
        MEMORY[0x4001040C] = v7;
        v8 = MEMORY[0x40010404] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x20000) != 0 )
          v8 |= v3;
        MEMORY[0x40010404] = v8;
        v9 = MEMORY[0x40010400] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x10000) != 0 )
          v9 |= v3;
        MEMORY[0x40010400] = v9;
      }
    }
  }
  return result;
}

//----- (08012260) --------------------------------------------------------
BOOL __fastcall sub_8012260(int a1, int a2)
{
  return (*(_DWORD *)(a1 + 16) & a2) != 0;
}

//----- (0801226E) --------------------------------------------------------
int __fastcall sub_801226E(int result, int a2)
{
  *(_DWORD *)(result + 24) = a2 & ~*(_DWORD *)(result + 20) | ((*(_DWORD *)(result + 20) & a2) << 16);
  return result;
}

//----- (0801227E) --------------------------------------------------------
int __fastcall sub_801227E(int result, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)(result + 24) = a2;
  else
    *(_DWORD *)(result + 40) = a2;
  return result;
}

//----- (0801228C) --------------------------------------------------------
unsigned int sub_801228C()
{
  return HIWORD(dword_E0042000);
}
// E0042000: using guessed type int dword_E0042000;

//----- (08012298) --------------------------------------------------------
int sub_8012298()
{
  return dword_2000026C;
}
// 2000026C: using guessed type int dword_2000026C;

//----- (080122A4) --------------------------------------------------------
int __fastcall sub_80122A4(_BYTE *a1, int a2, char a3)
{
  _BYTE *v4; // r0

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == 32 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFFFFE0 | a3 & 0x1F;
  }
  else if ( a2 > 32 )
  {
    switch ( a2 )
    {
      case 64:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFFF83F | ((a3 & 0x1F) << 6);
        break;
      case 128:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFE0FFF | ((a3 & 0x1F) << 12);
        break;
      case 256:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFF83FFFF | ((a3 & 0x1F) << 18);
        break;
      case 512:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xE0FFFFFF | ((a3 & 0x1F) << 24);
        break;
      default:
LABEL_19:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
  }
  else if ( a2 == 4 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFE0FFF | ((a3 & 0x1F) << 12);
  }
  else if ( a2 > 4 )
  {
    if ( a2 != 8 )
    {
      if ( a2 == 16 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xE0FFFFFF | ((a3 & 0x1F) << 24);
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFF83FFFF | ((a3 & 0x1F) << 18);
  }
  else
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFFF83F | ((a3 & 0x1F) << 6);
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFFFFE0 | a3 & 0x1F;
  }
LABEL_20:
  if ( a1[221] == 7 )
    return 1;
  v4 = a1 + 220;
  v4[1] = 1;
  *v4 = 0;
  return 0;
}

//----- (080123C0) --------------------------------------------------------
int __fastcall sub_80123C0(_BYTE *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r3
  unsigned int v4; // r5
  unsigned int v5; // r4
  _BYTE *v7; // r0

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  v3 = *(_DWORD **)a1;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 896);
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 1020);
  if ( a2 == 32 )
  {
    v5 = (*a3 >> 12) & 0x70 | v5 & 0xFFFFFF8F;
    v3[254] &= 0xFFFFFC1F;
    *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (32 * a3[1]) & 0x3E0;
  }
  else if ( a2 > 32 )
  {
    switch ( a2 )
    {
      case 64:
        v5 = (*a3 >> 8) & 0x700 | v5 & 0xFFFFF8FF;
        v3[254] &= 0xFFFF83FF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (a3[1] << 10) & 0x7C00;
        break;
      case 128:
        v5 = (*a3 >> 4) & 0x7000 | v5 & 0xFFFF8FFF;
        v3[254] &= 0xFFE0FFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int16 *)a3 + 2) << 16) & 0x1F0000;
        break;
      case 256:
        v5 = *a3 & 0x70000 | v5 & 0xFFF8FFFF;
        v3[254] &= 0xFC1FFFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int16 *)a3 + 2) << 21) & 0x3E00000;
        break;
      case 512:
        v5 = (16 * *a3) & 0x700000 | v5 & 0xFF8FFFFF;
        v3[254] &= 0x83FFFFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int8 *)a3 + 4) << 26) & 0x7C000000;
        break;
      default:
LABEL_19:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
  }
  else if ( a2 == 4 )
  {
    v4 = (*a3 << 6) & 0x1C00000 | v4 & 0xFE3FFFFF;
    v3[241] = a3[1];
  }
  else if ( a2 > 4 )
  {
    if ( a2 != 8 )
    {
      if ( a2 == 16 )
      {
        v5 = HIWORD(*a3) & 7 | v5 & 0xFFFFFFF8;
        v3[254] &= 0xFFFFFFE0;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= a3[1] & 0x1F;
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    v4 = (*a3 << 9) & 0xE000000 | v4 & 0xF1FFFFFF;
    v3[242] = a3[1];
  }
  else
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
      {
        v4 = (8 * *a3) & 0x380000 | v4 & 0xFFC7FFFF;
        v3[240] = a3[1];
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    v4 = *a3 & 0x70000 | v4 & 0xFFF8FFFF;
    v3[239] = a3[1];
  }
LABEL_20:
  if ( a1[221] == 7 )
    return 1;
  if ( (unsigned int)a2 >= 0x10 )
    *(_DWORD *)(*(_DWORD *)a1 + 1020) = v5;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 896) = v4;
  v7 = a1 + 220;
  v7[1] = 1;
  *v7 = 0;
  return 0;
}

//----- (08012612) --------------------------------------------------------
int __fastcall sub_8012612(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 928) = *(_DWORD *)(*((_DWORD *)v2 - 55) + 928) & 0xFFFFFFFE | a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08012652) --------------------------------------------------------
int __fastcall sub_8012652(_BYTE *a1, int a2)
{
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == -1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 972) &= ~2u;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 972) |= 2u;
    *(_DWORD *)(*(_DWORD *)a1 + 972) = *(_DWORD *)(*(_DWORD *)a1 + 972) & 0xFFFFFFF3 | a2;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 972) |= 1u;
  a1[221] = 1;
  return 0;
}

//----- (080126C4) --------------------------------------------------------
int __fastcall sub_80126C4(int a1, int a2, int a3)
{
  _BYTE *v3; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v3 = (_BYTE *)(a1 + 220);
  v3[1] = 2;
  *(_DWORD *)(*((_DWORD *)v3 - 55) + (a2 << 7) + 184) = *(_DWORD *)(*((_DWORD *)v3 - 55) + (a2 << 7) + 184) & 0x3C002000
                                                      | *(_DWORD *)(a3 + 28) & 0x80000000
                                                      | *(_DWORD *)(a3 + 32) & 0x40000000
                                                      | *(_DWORD *)(a3 + 24) & 0x2000000
                                                      | (*(unsigned __int16 *)(a3 + 20) << 16) & 0x1FFFFFF
                                                      | *(_WORD *)(a3 + 12) & 0x8000
                                                      | *(_WORD *)(a3 + 16) & 0x4000
                                                      | *(_WORD *)(a3 + 8) & 0x200
                                                      | *(_WORD *)(a3 + 4) & 0x1FF
                                                      | *(_WORD *)a3 & 0x1C00;
  v3[1] = 1;
  *v3 = 0;
  return 0;
}

//----- (08012754) --------------------------------------------------------
int __fastcall sub_8012754(int a1, int a2, _BYTE *a3)
{
  _BYTE *v4; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_8015B60((_DWORD *)a1, a2, a3);
  v4 = (_BYTE *)(a1 + 220);
  v4[1] = 1;
  result = 0;
  *v4 = 0;
  return result;
}

//----- (0801278C) --------------------------------------------------------
int __fastcall sub_801278C(int a1)
{
  unsigned int i; // r1
  _DWORD *v3; // r0

  if ( !a1 )
    return 1;
  *(_BYTE *)(a1 + 221) = 2;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 236) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  if ( *(unsigned __int8 *)(a1 + 8) << 31 )
  {
    if ( *(_DWORD *)a1 == 1073833984 )
      MEMORY[0x40021060] |= 0x4000000u;
    **(_DWORD **)a1 = *(_WORD *)(a1 + 20) & 0x3000 | *(_WORD *)(a1 + 16) & 0xC000 | **(_DWORD **)a1 & 0xFFFF0FFF;
  }
  sub_8012844((int *)a1);
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    **(_DWORD **)a1 = *(_WORD *)(a1 + 12) & 0x300 | **(_DWORD **)a1 & 0xFFFFFCFF;
  *(_BYTE *)(a1 + 221) = 1;
  *(_BYTE *)(a1 + 220) = 0;
  for ( i = 0; i <= 6; i = (unsigned __int8)(i + 1) )
  {
    v3 = (_DWORD *)(a1 + 28 * i);
    v3[6] = 0;
    v3[7] = 0;
    v3[8] = 0;
    v3[9] = 0;
    v3[10] = 0;
    v3[12] = 0;
  }
  return 0;
}

//----- (08012844) --------------------------------------------------------
int __fastcall sub_8012844(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073833984 )
  {
    MEMORY[0x40021060] |= 0x4000000u;
    return MEMORY[0x40021060] & 0x4000000;
  }
  return result;
}

//----- (0801286C) --------------------------------------------------------
int *__fastcall sub_801286C(int **a1)
{
  int *result; // r0
  int v3; // [sp+4h] [bp-2Ch] BYREF
  int v4; // [sp+8h] [bp-28h]
  int v5; // [sp+Ch] [bp-24h]
  int v6; // [sp+10h] [bp-20h]
  int v7; // [sp+14h] [bp-1Ch]

  sub_8002364(&v3, 20);
  result = *a1;
  if ( *a1 == (int *)1073833984 )
  {
    MEMORY[0x4002104C] |= 2u;
    MEMORY[0x4002104C] |= 4u;
    MEMORY[0x4002104C] |= 1u;
    v3 = 12288;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    sub_80120B0((int *)0x48000400, (int)&v3);
    v3 = 192;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    sub_80120B0((int *)0x48000800, (int)&v3);
    v3 = 768;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 3;
    sub_80120B0((int *)0x48000800, (int)&v3);
    v3 = 3840;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    return sub_80120B0((int *)0x48000000, (int)&v3);
  }
  return result;
}

//----- (08012930) --------------------------------------------------------
int __fastcall sub_8012930(_BYTE *a1, unsigned int a2)
{
  int v4; // r6
  _BYTE *v5; // r5
  int result; // r0

  v4 = sub_8012298();
  do
  {
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 904) & 0x10000) == 0 )
    {
      v5 = a1 + 220;
      v5[1] = 1;
      result = 0;
      *v5 = 0;
      return result;
    }
  }
  while ( a2 == -1 || sub_8012298() - v4 <= a2 && a2 );
  a1[221] = 7;
  return 3;
}

//----- (08012970) --------------------------------------------------------
int __fastcall sub_8012970(int a1, int a2, _DWORD *a3)
{
  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  *(_BYTE *)(a1 + 221) = 2;
  if ( a2 == 6 )
    sub_8015E74((int *)a1, a3);
  else
    sub_801600C((int *)a1, a2, a3);
  *(_BYTE *)(a1 + 221) = 1;
  return 0;
}

//----- (080129A4) --------------------------------------------------------
int __fastcall sub_80129A4(_BYTE *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r5
  int v5; // r6
  int v6; // r4
  int v8; // r1
  int v9; // r1

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == 6 )
  {
    switch ( a3 )
    {
      case 1:
        *(_DWORD *)(*(_DWORD *)a1 + 28) = *a4;
        break;
      case 2:
        *(_DWORD *)(*(_DWORD *)a1 + 36) = *a4;
        break;
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 40) = *a4;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 44) = *a4;
        break;
      default:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
    if ( a1[221] != 7 )
    {
LABEL_19:
      a1[221] = 1;
      a1[220] = 0;
      return 0;
    }
    return 1;
  }
  else
  {
    v4 = (a2 << 7) + 156;
    if ( a3 == 1 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + v4) = *a4;
    }
    else
    {
      v5 = (a2 << 7) + 168;
      v6 = (a2 << 7) + 128;
      switch ( a3 )
      {
        case 2:
          *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 164) = *a4;
          if ( a4[1] )
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFFCFFF;
            *(_DWORD *)(*(_DWORD *)a1 + v6) |= a4[1];
            v8 = a4[1];
            if ( v8 == 0x2000 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v4) = a4[2];
            }
            else if ( v8 == 12288 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v5) = a4[2];
            }
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFFCFFF;
          }
          break;
        case 4:
          *(_DWORD *)(*(_DWORD *)a1 + v5) = *a4;
          break;
        case 8:
          *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 172) = *a4;
          if ( a4[1] )
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFF3FFF;
            *(_DWORD *)(*(_DWORD *)a1 + v6) |= 4 * a4[1];
            v9 = a4[1];
            if ( v9 == 0x2000 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v4) = a4[2];
            }
            else if ( v9 == 12288 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v5) = a4[2];
            }
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFF3FFF;
          }
          break;
        default:
          a1[221] = 7;
          a1[220] = 0;
          break;
      }
    }
    if ( a1[221] != 7 )
      goto LABEL_19;
    return 1;
  }
}

//----- (08012B26) --------------------------------------------------------
int __fastcall sub_8012B26(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  **((_DWORD **)v2 - 55) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08012B52) --------------------------------------------------------
int __fastcall sub_8012B52(int a1, int a2, int a3, _DWORD *a4)
{
  _BYTE *v5; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_8015F2E((int *)a1, a2, a3, a4);
  v5 = (_BYTE *)(a1 + 220);
  v5[1] = 1;
  result = 0;
  *v5 = 0;
  return result;
}

//----- (08012B8A) --------------------------------------------------------
int __fastcall sub_8012B8A(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 916) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08012BBA) --------------------------------------------------------
int __fastcall sub_8012BBA(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 920) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08012BEA) --------------------------------------------------------
int __fastcall sub_8012BEA(int a1, int a2, _DWORD *a3)
{
  _DWORD *v6; // r0
  int result; // r0
  _BYTE *v8; // r4

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  if ( a2 == 6 )
    sub_8015E9A((int *)a1, a3);
  else
    ((void (__fastcall *)(int, int, _DWORD *))loc_8016044)(a1, a2, a3);
  v6 = (_DWORD *)(a1 + 28 * a2);
  v6[8] = *a3;
  v6[9] = a3[1];
  v6[10] = a3[2];
  v6[11] = a3[3];
  v6[12] = a3[4];
  sub_8015DF4((_DWORD *)a1, a2);
  if ( a2 != 6 && !a3[11] )
    *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 128) = *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 128) & 0xFFFFFDFF
                                                 | (a3[23] << 9);
  v8 = (_BYTE *)(a1 + 220);
  v8[1] = 1;
  result = 0;
  *v8 = 0;
  return result;
}

//----- (08012C80) --------------------------------------------------------
int __fastcall sub_8012C80(int a1, int a2, _DWORD *a3)
{
  _BYTE *v5; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_8016200((int *)a1, a2, a3);
  sub_8015DF4((_DWORD *)a1, a2);
  v5 = (_BYTE *)(a1 + 220);
  v5[1] = 1;
  result = 0;
  *v5 = 0;
  return result;
}

//----- (08012CC4) --------------------------------------------------------
int __fastcall sub_8012CC4(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  **(_DWORD **)a1 &= ~0x1000u;
  **(_DWORD **)a1 |= a2;
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (08012D1E) --------------------------------------------------------
int __fastcall sub_8012D1E(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFFFFF0FF | (a2 << 8);
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (08012D74) --------------------------------------------------------
int __fastcall sub_8012D74(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 65) )
  {
    *(_BYTE *)(a1 + 64) = 0;
    sub_80130CC((int *)a1);
  }
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 4) & 0xF0FFFFFF;
  *(_DWORD *)(*(_DWORD *)a1 + 8) &= ~0x8000u;
  if ( *(_DWORD *)(a1 + 12) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(a1 + 8) | 0x8000;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(a1 + 8) | 0x8400;
  if ( *(_DWORD *)(a1 + 12) == 2 )
    *(_DWORD *)(*(_DWORD *)a1 + 4) = 2048;
  *(_DWORD *)(*(_DWORD *)a1 + 4) |= 0x2008000u;
  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x8000u;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(a1 + 16) | *(_DWORD *)(a1 + 20) | (*(_DWORD *)(a1 + 24) << 8);
  **(_DWORD **)a1 = *(_DWORD *)(a1 + 28) | *(_DWORD *)(a1 + 32);
  **(_DWORD **)a1 |= 1u;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 65) = 32;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 66) = 0;
  return 0;
}

//----- (08012E34) --------------------------------------------------------
int __fastcall sub_8012E34(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5)
{
  int v10; // r6
  int v11; // r0

  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  v10 = sub_8012298();
  if ( sub_8016A6C(a1, 0x8000, 1, 0x19u, v10) )
    return 1;
  *(_BYTE *)(a1 + 65) = 34;
  *(_BYTE *)(a1 + 66) = 16;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 36) = a3;
  *(_WORD *)(a1 + 42) = a4;
  *(_DWORD *)(a1 + 52) = 0;
  if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
    sub_8016A3C(a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, -2147474432);
  }
  else
  {
    *(_WORD *)(a1 + 40) = 255;
    sub_8016A3C(a1, a2, 255, 0x1000000, -2147474432);
  }
  while ( *(_WORD *)(a1 + 42) )
  {
    if ( sub_8016AC4(a1, a5, v10) )
      return 1;
    *(_BYTE *)(*(_DWORD *)(a1 + 36))++ = *(_DWORD *)(*(_DWORD *)a1 + 36);
    v11 = (unsigned __int16)(*(_WORD *)(a1 + 40) - 1);
    *(_WORD *)(a1 + 40) = v11;
    if ( --*(_WORD *)(a1 + 42) && !v11 )
    {
      if ( sub_8016A6C(a1, 128, 0, a5, v10) )
        return 1;
      if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
      {
        *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
        sub_8016A3C(a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0);
      }
      else
      {
        *(_WORD *)(a1 + 40) = 255;
        sub_8016A3C(a1, a2, 255, 0x1000000, 0);
      }
    }
  }
  if ( sub_8016B6C((int *)a1, a5, v10) )
    return 1;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (08012F80) --------------------------------------------------------
int __fastcall sub_8012F80(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5)
{
  int v10; // r6
  __int16 v11; // r0

  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  v10 = sub_8012298();
  if ( sub_8016A6C(a1, 0x8000, 1, 0x19u, v10) )
    return 1;
  *(_BYTE *)(a1 + 65) = 33;
  *(_BYTE *)(a1 + 66) = 16;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 36) = a3;
  *(_WORD *)(a1 + 42) = a4;
  *(_DWORD *)(a1 + 52) = 0;
  if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
    sub_8016A3C(a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, -2147475456);
  }
  else
  {
    *(_WORD *)(a1 + 40) = 255;
    sub_8016A3C(a1, a2, 255, 0x1000000, -2147475456);
  }
  while ( *(_WORD *)(a1 + 42) )
  {
    if ( sub_8016BB8((int *)a1, a5, v10) )
      return 1;
    *(_DWORD *)(*(_DWORD *)a1 + 40) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 36))++;
    --*(_WORD *)(a1 + 42);
    v11 = *(_WORD *)(a1 + 40) - 1;
    *(_WORD *)(a1 + 40) = v11;
    if ( *(_WORD *)(a1 + 42) && !v11 )
    {
      if ( sub_8016A6C(a1, 128, 0, a5, v10) )
        return 1;
      if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
      {
        *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
        sub_8016A3C(a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0);
      }
      else
      {
        *(_WORD *)(a1 + 40) = 255;
        sub_8016A3C(a1, a2, 255, 0x1000000, 0);
      }
    }
  }
  if ( sub_8016B6C((int *)a1, a5, v10) )
    return 1;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (080130CC) --------------------------------------------------------
int __fastcall sub_80130CC(int *a1)
{
  int result; // r0
  _DWORD v3[21]; // [sp+8h] [bp-80h] BYREF
  int v4; // [sp+5Ch] [bp-2Ch] BYREF
  int v5; // [sp+60h] [bp-28h]
  int v6; // [sp+64h] [bp-24h]
  int v7; // [sp+68h] [bp-20h]
  int v8; // [sp+6Ch] [bp-1Ch]

  sub_8002364(&v4, 20);
  sub_8002364(v3, 84);
  result = *a1;
  if ( *a1 == 1073763328 )
  {
    v3[0] = 64;
    v3[7] = 0;
    if ( sub_8013424(v3) )
      sub_80058BC();
    MEMORY[0x4002104C] |= 1u;
    MEMORY[0x4002104C] |= 2u;
    v4 = 0x8000;
    v5 = 18;
    v6 = 0;
    v7 = 2;
    v8 = 4;
    sub_80120B0((int *)0x48000000, (int)&v4);
    v4 = 512;
    v5 = 18;
    v6 = 0;
    v7 = 2;
    v8 = 4;
    sub_80120B0((int *)0x48000400, (int)&v4);
    MEMORY[0x40021058] |= 0x200000u;
    return MEMORY[0x40021058] & 0x200000;
  }
  return result;
}

//----- (0801317C) --------------------------------------------------------
int __fastcall sub_801317C(_DWORD *a1)
{
  int v2; // r5
  _DWORD *v4; // r0
  int v5; // r1

  if ( !a1 )
    return 1;
  *(_DWORD *)*a1 = 52428;
  *(_DWORD *)*a1 = 21845;
  *(_DWORD *)(*a1 + 4) = a1[1];
  *(_DWORD *)(*a1 + 8) = a1[2];
  v2 = sub_8012298();
  while ( *(_DWORD *)(*a1 + 12) << 29 )
  {
    if ( (unsigned int)(sub_8012298() - v2) > 0x31 && *(_DWORD *)(*a1 + 12) << 29 )
      return 3;
  }
  v4 = (_DWORD *)*a1;
  v5 = a1[3];
  if ( *(_DWORD *)(*a1 + 16) == v5 )
    *v4 = 43690;
  else
    v4[4] = v5;
  return 0;
}

//----- (080131F0) --------------------------------------------------------
int *sub_80131F0()
{
  int *result; // r0

  result = &dword_20000264;
  dword_2000026C += dword_20000268;
  return result;
}
// 20000264: using guessed type int dword_20000264;
// 20000268: using guessed type int dword_20000268;
// 2000026C: using guessed type int dword_2000026C;

//----- (08013200) --------------------------------------------------------
int sub_8013200()
{
  int v0; // r4

  v0 = 0;
  sub_8013300(3);
  if ( sub_8013220(0) )
    return 1;
  sub_801326C();
  return v0;
}

//----- (08013220) --------------------------------------------------------
int __fastcall sub_8013220(unsigned int a1)
{
  int v2; // r4

  v2 = 0;
  if ( !dword_20000268 )
    return 1;
  if ( HAL_SYSTICK_Config(dword_20000290 / (0x3E8u / dword_20000268)) )
    return 1;
  if ( a1 >= 0x10 )
    return 1;
  sub_80132C0(-1, a1, 0);
  dword_20000264 = a1;
  return v2;
}
// 20000264: using guessed type int dword_20000264;
// 20000268: using guessed type int dword_20000268;
// 20000290: using guessed type int dword_20000290;

//----- (0801326C) --------------------------------------------------------
int sub_801326C()
{
  int result; // r0

  MEMORY[0x40021060] |= 1u;
  MEMORY[0x40021058] |= 0x10000000u;
  sub_80141D4();
  result = 2;
  MEMORY[0x40010030] = MEMORY[0x40010030] & 0xFFFFFFFD | 2;
  return result;
}

//----- (080132A4) --------------------------------------------------------
int __fastcall sub_80132A4(int result)
{
  int v1; // r1

  if ( result >= 0 )
  {
    v1 = 1 << (result & 0x1F);
    result = 4 * ((unsigned int)result >> 5) - 536813568;
    *(_DWORD *)(result + 256) = v1;
  }
  return result;
}

//----- (080132C0) --------------------------------------------------------
int __fastcall sub_80132C0(int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // r3
  char v4; // r4
  char v5; // r3

  v3 = ((unsigned int)AIRCR >> 8) & 7;
  v4 = 7 - v3;
  if ( 7 - v3 > 4 )
    v4 = 4;
  if ( v3 + 4 >= 7 )
    v5 = v3 - 3;
  else
    v5 = 0;
  return _NVIC_SetPriority(a1, (((unsigned __int8)((1 << v4) - 1) & a2) << v5) | ((1 << v5) - 1) & a3);
}
// E000ED0C: using guessed type int AIRCR;

//----- (08013300) --------------------------------------------------------
int __fastcall sub_8013300(char a1)
{
  int result; // r0

  result = AIRCR & 0xF8FF | ((a1 & 7) << 8) | 0x5FA0000;
  AIRCR = result;
  return result;
}
// E000ED0C: using guessed type int AIRCR;

//----- (08013324) --------------------------------------------------------
void __noreturn sub_8013324()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (08013348) --------------------------------------------------------
int __fastcall sub_8013348(int a1)
{
  unsigned int v1; // r2
  unsigned int j; // r0
  unsigned int i; // r0

  v1 = 50 * dword_20000290;
  if ( a1 )
  {
    if ( a1 != 512 )
    {
      MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x400;
      return 0;
    }
    if ( ((MEMORY[0x40007000] >> 9) & 3) != 2 )
    {
      MEMORY[0x40007080] |= 0x100u;
      return 0;
    }
    MEMORY[0x40007080] |= 0x100u;
    MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x200;
    for ( i = v1 / 0xF4240 + 1; (MEMORY[0x40007014] & 0x400) != 0 && i; --i )
      ;
    if ( (MEMORY[0x40007014] & 0x400) == 0 )
      return 0;
    return 3;
  }
  else
  {
    if ( ((MEMORY[0x40007000] >> 9) & 3) != 2 )
    {
      MEMORY[0x40007080] &= ~0x100u;
      return 0;
    }
    MEMORY[0x40007080] &= ~0x100u;
    MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x200;
    for ( j = v1 / 0xF4240 + 1; (MEMORY[0x40007014] & 0x400) != 0 && j; --j )
      ;
    if ( (MEMORY[0x40007014] & 0x400) == 0 )
      return 0;
    return 3;
  }
}
// 20000290: using guessed type int dword_20000290;

//----- (08013414) --------------------------------------------------------
int sub_8013414()
{
  int result; // r0

  result = 1073770496;
  MEMORY[0x40007000] |= 0x100u;
  return result;
}

//----- (08013424) --------------------------------------------------------
int __fastcall sub_8013424(_DWORD *a1)
{
  int v2; // r6
  int v3; // r7
  int v4; // r8
  int v5; // r9
  unsigned int v6; // r0
  int v7; // r9

  v2 = 0;
  v3 = 0;
  if ( (*a1 & 0x80000) != 0 )
  {
    v4 = 0;
    if ( (MEMORY[0x40021058] & 0x10000000) == 0 )
    {
      MEMORY[0x40021058] |= 0x10000000u;
      v4 = 1;
    }
    MEMORY[0x40007000] |= 0x100u;
    v5 = sub_8012298();
    while ( (MEMORY[0x40007000] & 0x100) == 0 )
    {
      if ( (unsigned int)(sub_8012298() - v5) > 2 )
      {
        v2 = 3;
        break;
      }
    }
    if ( v2 )
    {
      v3 = v2;
    }
    else
    {
      v6 = MEMORY[0x40021090] & 0x300;
      if ( (MEMORY[0x40021090] & 0x300) != 0 && a1[20] != v6 )
      {
        v6 = MEMORY[0x40021090] & 0xFFFFFCFF;
        MEMORY[0x40021090] &= 0xFFFFFCFF;
      }
      if ( v6 << 31 )
      {
        v7 = sub_8012298();
        while ( (MEMORY[0x40021090] & 2) == 0 )
        {
          if ( (unsigned int)(sub_8012298() - v7) > 0x1388 )
          {
            v2 = 3;
            break;
          }
        }
      }
      if ( v2 )
        v3 = v2;
      else
        MEMORY[0x40021090] = MEMORY[0x40021090] & 0xFFFFFCFF | a1[20];
    }
    if ( v4 == 1 )
      MEMORY[0x40021058] &= ~0x10000000u;
  }
  if ( *(unsigned __int8 *)a1 << 31 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFFC | a1[1];
  if ( (*(_BYTE *)a1 & 2) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFF3 | a1[2];
  if ( (*(_BYTE *)a1 & 4) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFCF | a1[3];
  if ( (*(_BYTE *)a1 & 8) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFF3F | a1[4];
  if ( (*(_BYTE *)a1 & 0x10) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFCFF | a1[5];
  if ( (*(_BYTE *)a1 & 0x20) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFF3FF | a1[6];
  if ( (*(_BYTE *)a1 & 0x40) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFCFFF | a1[7];
  if ( (*(_BYTE *)a1 & 0x80) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFF3FFF | a1[8];
  if ( (*(_WORD *)a1 & 0x100) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFCFFFF | a1[9];
  if ( (*a1 & 0x20000) != 0 )
    MEMORY[0x4002109C] = MEMORY[0x4002109C] & 0xFFFFFFFC | a1[10];
  if ( (*(_WORD *)a1 & 0x200) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFF3FFFF | a1[11];
  if ( (*(_WORD *)a1 & 0x400) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFCFFFFF | a1[12];
    if ( a1[12] == 0x100000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x800) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFF3FFFFF | a1[13];
    if ( a1[13] == 0x400000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x1000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFCFFFFFF | a1[14];
    if ( a1[14] == 0x1000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x2000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xF3FFFFFF | a1[15];
    if ( a1[15] == 0x8000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x4000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xF3FFFFFF | a1[16];
    if ( a1[16] == 0x8000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x8000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xCFFFFFFF | a1[17];
    if ( a1[17] == 0x10000000 )
      MEMORY[0x4002100C] |= 0x10000u;
  }
  if ( (*a1 & 0x10000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0x3FFFFFFF | a1[18];
    if ( a1[18] == 0x40000000 )
      MEMORY[0x4002100C] |= 0x10000u;
  }
  if ( (*a1 & 0x40000) != 0 )
  {
    MEMORY[0x4002109C] = MEMORY[0x4002109C] & 0xFFCFFFFF | a1[19];
    if ( a1[19] == 0x200000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  return v3;
}

//----- (08013734) --------------------------------------------------------
int __fastcall sub_8013734(unsigned __int8 *a1, unsigned int a2)
{
  int v4; // r7
  int v6; // r0
  int v7; // r8
  int v8; // r7

  v4 = 0;
  if ( !a1 )
    return 1;
  if ( (MEMORY[0x40022000] & 0xFu) < a2 )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF0 | a2;
    if ( (MEMORY[0x40022000] & 0xF) != a2 )
      return 1;
  }
  if ( *a1 << 31 )
  {
    v6 = *((_DWORD *)a1 + 1);
    if ( v6 == 3 )
    {
      if ( (MEMORY[0x40021000] & 0x2000000) == 0 )
        return 1;
      if ( sub_8018634() > 0x4C4B400 && ((MEMORY[0x40021008] & 0xF0) == 0 || (*a1 & 2) != 0 && !*((_DWORD *)a1 + 2)) )
      {
        MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | 0x80;
        v4 = 128;
      }
    }
    else
    {
      if ( v6 == 2 )
      {
        if ( (MEMORY[0x40021000] & 0x20000) == 0 )
          return 1;
      }
      else if ( (MEMORY[0x40021000] & 0x400) == 0 )
      {
        return 1;
      }
      if ( sub_8013950() > 0x4C4B400 )
      {
        MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | 0x80;
        v4 = 128;
      }
    }
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFFFC | *((_DWORD *)a1 + 1);
    v7 = sub_8012298();
    while ( (MEMORY[0x40021008] & 0xC) != 4 * *((_DWORD *)a1 + 1) )
    {
      if ( (unsigned int)(sub_8012298() - v7) > 0x1388 )
        return 3;
    }
  }
  if ( (*(_DWORD *)a1 & 2) != 0 )
  {
    if ( (*(_DWORD *)a1 & 4) != 0 )
      MEMORY[0x40021008] |= 0x700u;
    if ( (*a1 & 8) != 0 )
      MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFC0FF | 0x700;
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | *((_DWORD *)a1 + 2);
  }
  else if ( v4 == 128 )
  {
    MEMORY[0x40021008] &= 0xFFFFFF0F;
  }
  if ( (MEMORY[0x40022000] & 0xFu) > a2 )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF0 | a2;
    v8 = sub_8012298();
    while ( (MEMORY[0x40022000] & 0xF) != a2 )
    {
      if ( (unsigned int)(sub_8012298() - v8) > 0x1388 )
        return 3;
    }
  }
  if ( (*a1 & 4) != 0 )
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFF8FF | *((_DWORD *)a1 + 3);
  if ( (*a1 & 8) != 0 )
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFC7FF | (8 * *((_DWORD *)a1 + 4));
  dword_20000290 = sub_8013950() >> (*((_BYTE *)dword_802617C + (MEMORY[0x40021008] >> 4)) & 0x1F);
  return sub_8013220(dword_20000264);
}
// 802617C: using guessed type int dword_802617C[4];
// 20000264: using guessed type int dword_20000264;
// 20000290: using guessed type int dword_20000290;

//----- (080138FC) --------------------------------------------------------
int sub_80138FC()
{
  return dword_20000290;
}
// 20000290: using guessed type int dword_20000290;

//----- (08013908) --------------------------------------------------------
unsigned int sub_8013908()
{
  return (unsigned int)sub_80138FC() >> (*((_BYTE *)&unk_802618C + ((MEMORY[0x40021008] >> 8) & 7)) & 0x1F);
}

//----- (0801392C) --------------------------------------------------------
unsigned int sub_801392C()
{
  return (unsigned int)sub_80138FC() >> (*((_BYTE *)&unk_802618C + ((MEMORY[0x40021008] >> 11) & 7)) & 0x1F);
}

//----- (08013950) --------------------------------------------------------
unsigned int sub_8013950()
{
  unsigned int result; // r0
  unsigned int v1; // r1
  unsigned int v2; // r0

  result = 16000000;
  if ( ((MEMORY[0x40021008] >> 2) & 3) != 1 )
  {
    if ( ((MEMORY[0x40021008] >> 2) & 3) == 2 )
    {
      return 8000000;
    }
    else if ( ((MEMORY[0x40021008] >> 2) & 3) == 3 )
    {
      v1 = (MEMORY[0x4002100C] >> 4) + 1;
      if ( (MEMORY[0x4002100C] & 3) == 3 )
        v2 = 0x7A1200 / v1 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
      else
        v2 = 0xF42400 / v1 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
      return v2 / (2 * (((MEMORY[0x4002100C] >> 25) & 3u) + 1));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (080139C4) --------------------------------------------------------
int __fastcall sub_80139C4(unsigned __int8 *a1)
{
  int v3; // r0
  int v4; // r6
  int v5; // r6
  int v6; // r6
  int v7; // r6
  int v8; // r6
  int v9; // r6
  int v10; // r8
  int v11; // r7
  int v12; // r0
  int v13; // r7
  int v14; // r7
  int v15; // r6
  int v16; // r6
  int v17; // r0
  int v18; // r4
  int v19; // r6
  unsigned __int8 *v20; // r4
  int v21; // t1
  int v22; // r4

  if ( !a1 )
    return 1;
  if ( *a1 << 31 )
  {
    if ( (MEMORY[0x40021008] & 0xC) == 0xC && (MEMORY[0x4002100C] & 3) == 3 || (MEMORY[0x40021008] & 0xC) == 8 )
    {
      if ( (MEMORY[0x40021000] & 0x20000) != 0 && !*((_DWORD *)a1 + 1) )
        return 1;
    }
    else
    {
      v3 = *((_DWORD *)a1 + 1);
      if ( v3 == 0x10000 )
      {
        MEMORY[0x40021000] |= 0x10000u;
      }
      else if ( v3 == 327680 )
      {
        MEMORY[0x40021000] |= 0x40000u;
        MEMORY[0x40021000] |= 0x10000u;
      }
      else
      {
        MEMORY[0x40021000] &= ~0x10000u;
        MEMORY[0x40021000] &= ~0x40000u;
      }
      if ( *((_DWORD *)a1 + 1) )
      {
        v4 = sub_8012298();
        while ( (MEMORY[0x40021000] & 0x20000) == 0 )
        {
          if ( (unsigned int)(sub_8012298() - v4) > 0x64 )
            return 3;
        }
      }
      else
      {
        v5 = sub_8012298();
        while ( (MEMORY[0x40021000] & 0x20000) != 0 )
        {
          if ( (unsigned int)(sub_8012298() - v5) > 0x64 )
            return 3;
        }
      }
    }
  }
  if ( (*a1 & 2) != 0 )
  {
    if ( (MEMORY[0x40021008] & 0xC) == 0xC && (MEMORY[0x4002100C] & 3) == 2 || (MEMORY[0x40021008] & 0xC) == 4 )
    {
      if ( (MEMORY[0x40021000] & 0x400) != 0 && !*((_DWORD *)a1 + 3) )
        return 1;
      MEMORY[0x40021004] = MEMORY[0x40021004] & 0x80FFFFFF | (a1[16] << 24);
      if ( sub_8013220(dword_20000264) )
        return 1;
    }
    else if ( *((_DWORD *)a1 + 3) )
    {
      MEMORY[0x40021000] |= 0x100u;
      v6 = sub_8012298();
      while ( (MEMORY[0x40021000] & 0x400) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v6) > 2 )
          return 3;
      }
      MEMORY[0x40021004] = MEMORY[0x40021004] & 0x80FFFFFF | (a1[16] << 24);
    }
    else
    {
      MEMORY[0x40021000] &= ~0x100u;
      v7 = sub_8012298();
      while ( (MEMORY[0x40021000] & 0x400) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v7) > 2 )
          return 3;
      }
    }
  }
  if ( (*a1 & 8) != 0 )
  {
    if ( *((_DWORD *)a1 + 5) )
    {
      MEMORY[0x40021094] |= 1u;
      v8 = sub_8012298();
      while ( (MEMORY[0x40021094] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v8) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021094] &= ~1u;
      v9 = sub_8012298();
      while ( (MEMORY[0x40021094] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v9) > 2 )
          return 3;
      }
    }
  }
  if ( (*a1 & 4) != 0 )
  {
    v10 = 0;
    if ( (MEMORY[0x40021058] & 0x10000000) == 0 )
    {
      MEMORY[0x40021058] |= 0x10000000u;
      v10 = 1;
    }
    if ( (MEMORY[0x40007000] & 0x100) == 0 )
    {
      MEMORY[0x40007000] |= 0x100u;
      v11 = sub_8012298();
      while ( (MEMORY[0x40007000] & 0x100) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v11) > 2 )
          return 3;
      }
    }
    v12 = *((_DWORD *)a1 + 2);
    if ( v12 == 1 )
    {
      MEMORY[0x40021090] |= 1u;
    }
    else if ( v12 == 5 )
    {
      MEMORY[0x40021090] |= 4u;
      MEMORY[0x40021090] |= 1u;
    }
    else
    {
      MEMORY[0x40021090] &= ~1u;
      MEMORY[0x40021090] &= ~4u;
    }
    if ( *((_DWORD *)a1 + 2) )
    {
      v13 = sub_8012298();
      while ( (MEMORY[0x40021090] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v13) > 0x1388 )
          return 3;
      }
    }
    else
    {
      v14 = sub_8012298();
      while ( (MEMORY[0x40021090] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v14) > 0x1388 )
          return 3;
      }
    }
    if ( v10 == 1 )
      MEMORY[0x40021058] &= ~0x10000000u;
  }
  if ( (*a1 & 0x20) != 0 )
  {
    if ( *((_DWORD *)a1 + 6) )
    {
      MEMORY[0x40021098] |= 1u;
      v15 = sub_8012298();
      while ( (MEMORY[0x40021098] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v15) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021098] &= ~1u;
      v16 = sub_8012298();
      while ( (MEMORY[0x40021098] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v16) > 2 )
          return 3;
      }
    }
  }
  v17 = *((_DWORD *)a1 + 7);
  if ( v17 )
  {
    if ( ((MEMORY[0x40021008] >> 2) & 3) == 3 )
    {
      if ( v17 == 1 )
        return 1;
      if ( (MEMORY[0x4002100C] & 3) != *((_DWORD *)a1 + 8)
        || (MEMORY[0x4002100C] & 0xF0) != 16 * (*((_DWORD *)a1 + 9) - 1)
        || (MEMORY[0x4002100C] & 0x7F00) != *((_DWORD *)a1 + 10) << 8
        || (MEMORY[0x4002100C] & 0xF8000000) != a1[44] << 27
        || (MEMORY[0x4002100C] & 0x600000) != ((*((unsigned __int16 *)a1 + 24) >> 1) - 1) << 21
        || (MEMORY[0x4002100C] & 0x6000000) != ((a1[52] >> 1) - 1) << 25 )
      {
        return 1;
      }
    }
    else if ( v17 == 2 )
    {
      MEMORY[0x40021000] &= ~0x1000000u;
      v19 = sub_8012298();
      while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v19) > 2 )
          return 3;
      }
      v21 = *((_DWORD *)a1 + 8);
      v20 = a1 + 32;
      MEMORY[0x4002100C] = v21
                         | (16 * (*((_DWORD *)v20 + 1) - 1))
                         | (*((_DWORD *)v20 + 2) << 8)
                         | (((*((unsigned __int16 *)v20 + 8) >> 1) - 1) << 21)
                         | (((v20[20] >> 1) - 1) << 25)
                         | (v20[12] << 27)
                         | MEMORY[0x4002100C] & 0x19F800C;
      MEMORY[0x40021000] |= 0x1000000u;
      MEMORY[0x4002100C] |= 0x1000000u;
      v22 = sub_8012298();
      while ( (MEMORY[0x40021000] & 0x2000000) == 0 )
      {
        if ( (unsigned int)(sub_8012298() - v22) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021000] &= ~0x1000000u;
      MEMORY[0x4002100C] &= 0xFFFFFFFC;
      MEMORY[0x4002100C] &= 0xFEEEFFFF;
      v18 = sub_8012298();
      while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
      {
        if ( (unsigned int)(sub_8012298() - v18) > 2 )
          return 3;
      }
    }
  }
  return 0;
}
// 20000264: using guessed type int dword_20000264;

//----- (08013E1C) --------------------------------------------------------
int __fastcall sub_8013E1C(int a1, int a2, int a3, int a4)
{
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 132) )
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_80156AC((int *)a1);
  }
  *(_DWORD *)(a1 + 132) = 36;
  **(_DWORD **)a1 &= ~1u;
  if ( sub_801B294((_DWORD *)a1) == 1 )
    return 1;
  if ( *(_DWORD *)(a1 + 40) )
    sub_801ABC4(a1);
  *(_DWORD *)(*(_DWORD *)a1 + 8) |= 0x4000u;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0xFFFF7FFF | a2;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFC00FFFF | (a3 << 21) | (a4 << 16);
  **(_DWORD **)a1 |= 1u;
  return sub_801AC8C(a1);
}

//----- (08013EB0) --------------------------------------------------------
int __fastcall sub_8013EB0(int a1, _BYTE *a2, int a3)
{
  unsigned int v4; // r1
  char v5; // r0
  int v6; // r3
  char v7; // r0
  int v8; // r3
  char v9; // r0
  int v10; // r3

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4) & 0xFFFF3F;
  a2[3] = BYTE2(v4);
  a2[1] = BYTE1(v4) & 0x1F;
  a2[2] = v4 & 0x3F;
  *a2 = (unsigned __int16)v4 >> 13;
  if ( !a3 )
  {
    v5 = sub_8018684(HIWORD(v4));
    *(_BYTE *)(v6 + 3) = v5;
    v7 = sub_8018684(*(unsigned __int8 *)(v6 + 1));
    *(_BYTE *)(v8 + 1) = v7;
    v9 = sub_8018684(*(unsigned __int8 *)(v8 + 2));
    *(_BYTE *)(v10 + 2) = v9;
  }
  return 0;
}
// 8013EDA: variable 'v6' is possibly undefined
// 8013EE2: variable 'v8' is possibly undefined
// 8013EEA: variable 'v10' is possibly undefined

//----- (08013EF4) --------------------------------------------------------
int __fastcall sub_8013EF4(int a1, int a2, int a3)
{
  unsigned int v4; // r1
  char v5; // r0
  _BYTE *v6; // r3
  char v7; // r0
  int v8; // r3
  char v9; // r0
  int v10; // r3

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 16) & 0x7FFF;
  v4 = **(_DWORD **)a1 & 0x7F7F7F;
  *(_BYTE *)a2 = BYTE2(v4) & 0x3F;
  *(_BYTE *)(a2 + 1) = BYTE1(v4) & 0x7F;
  *(_BYTE *)(a2 + 2) = v4 & 0x7F;
  *(_BYTE *)(a2 + 3) = v4 >> 22;
  if ( !a3 )
  {
    v5 = sub_8018684(HIWORD(v4) & 0x3F);
    *v6 = v5;
    v7 = sub_8018684((unsigned __int8)v6[1]);
    *(_BYTE *)(v8 + 1) = v7;
    v9 = sub_8018684(*(unsigned __int8 *)(v8 + 2));
    *(_BYTE *)(v10 + 2) = v9;
  }
  return 0;
}
// 8013F2E: variable 'v6' is possibly undefined
// 8013F36: variable 'v8' is possibly undefined
// 8013F3E: variable 'v10' is possibly undefined

//----- (08013F48) --------------------------------------------------------
int __fastcall sub_8013F48(int a1)
{
  int result; // r0

  result = 1;
  if ( a1 )
  {
    if ( !*(_BYTE *)(a1 + 37) )
    {
      *(_BYTE *)(a1 + 36) = 0;
      sub_8013FDC((int *)a1);
    }
    *(_BYTE *)(a1 + 37) = 2;
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
    result = sub_80186AC((_BYTE *)a1);
    if ( !result )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFB8FFFBF;
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= *(_DWORD *)(a1 + 4) | *(_DWORD *)(a1 + 16) | *(_DWORD *)(a1 + 24);
      *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 12) | (*(unsigned __int16 *)(a1 + 8) << 16);
      result = sub_80186F4((_BYTE *)a1);
      if ( !result )
        *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32)
                                        | *(_DWORD *)(a1 + 28)
                                        | *(_DWORD *)(a1 + 20)
                                        | *(_DWORD *)(*(_DWORD *)a1 + 24) & 0x1FFFFFFF;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
    if ( !result )
      *(_BYTE *)(a1 + 37) = 1;
  }
  return result;
}

//----- (08013FDC) --------------------------------------------------------
int __fastcall sub_8013FDC(int *a1)
{
  int result; // r0
  _DWORD v3[23]; // [sp+4h] [bp-5Ch] BYREF

  sub_8002364(v3, 84);
  result = *a1;
  if ( *a1 == 1073752064 )
  {
    v3[0] = 0x80000;
    v3[20] = 256;
    if ( sub_8013424(v3) )
      sub_80058BC();
    MEMORY[0x40021090] |= 0x8000u;
    MEMORY[0x40021058] |= 0x400u;
    return MEMORY[0x40021058] & 0x400;
  }
  return result;
}

//----- (08014030) --------------------------------------------------------
int __fastcall sub_8014030(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v5; // r5
  int v6; // r3
  int v7; // r3
  int v8; // r0
  int v9; // r2
  unsigned __int8 *v10; // r3

  if ( a1[36] == 1 )
    return 2;
  a1[36] = 1;
  a1[37] = 2;
  if ( !a3 && (a2[1] & 0x10) != 0 )
    a2[1] = (a2[1] & 0xEF) + 10;
  if ( a3 )
  {
    v5 = a2[2] | (a2[3] << 16) | (a2[1] << 8) | (*a2 << 13);
  }
  else
  {
    sub_8018696(a2[3]);
    sub_8018696(*(unsigned __int8 *)(v6 + 1));
    v8 = sub_8018696(*(unsigned __int8 *)(v7 + 2));
    v5 = v9 | v8 | (*v10 << 13);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
  result = sub_80186AC(a1);
  if ( !result )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 4) = v5 & 0xFFFF3F;
    result = sub_80186F4(a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
  if ( !result )
    a1[37] = 1;
  a1[36] = 0;
  return result;
}
// 8014094: variable 'v6' is possibly undefined
// 801409E: variable 'v7' is possibly undefined
// 80140A4: variable 'v9' is possibly undefined
// 80140A6: variable 'v10' is possibly undefined

//----- (080140D4) --------------------------------------------------------
int __fastcall sub_80140D4(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r2

  if ( a1[36] == 1 )
    return 2;
  a1[36] = 1;
  a1[37] = 2;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
  result = sub_80186AC(a1);
  if ( !result )
  {
    if ( a3 )
    {
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x40) == 0 )
        a2[3] = 0;
      v7 = a2[2] | (*a2 << 16) | (a2[1] << 8) | (a2[3] << 22);
    }
    else
    {
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x40) == 0 )
        a2[3] = 0;
      sub_8018696(*a2);
      sub_8018696(a2[1]);
      v8 = sub_8018696(a2[2]);
      v7 = v9 | v8 | (a2[3] << 22);
    }
    **(_DWORD **)a1 = v7 & 0x7F7F7F;
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x40000u;
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= *((_DWORD *)a2 + 3) | *((_DWORD *)a2 + 4);
    result = sub_80186F4(a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
  if ( !result )
    a1[37] = 1;
  a1[36] = 0;
  return result;
}
// 8014186: variable 'v9' is possibly undefined

//----- (080141A0) --------------------------------------------------------
int __fastcall sub_80141A0(int a1)
{
  int v2; // r4

  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x20u;
  v2 = sub_8012298();
  while ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x20) == 0 )
  {
    if ( (unsigned int)(sub_8012298() - v2) > 0x3E8 )
      return 3;
  }
  return 0;
}

//----- (080141D4) --------------------------------------------------------
int sub_80141D4()
{
  int result; // r0

  result = 1073807360;
  MEMORY[0x40010030] &= ~1u;
  return result;
}

//----- (080141F8) --------------------------------------------------------
int __fastcall HAL_SYSTICK_Config(int a1)
{
  unsigned int v1; // r0

  v1 = a1 - 1;
  if ( v1 >= 0x1000000 )
    return 1;
  SYST_RVR = v1;
  _NVIC_SetPriority(-1, 15);
  SYST_CVR = 0;
  SYST_CSR = 7;
  return 0;
}
// 80141F8: invalid function type 'uint32_t __fastcall HAL_SYSTICK_Config(uint32_t TicksNumb)' has been ignored
// E000E010: using guessed type int SYST_CSR;
// E000E014: using guessed type int SYST_RVR;
// E000E018: using guessed type int SYST_CVR;

//----- (0801422C) --------------------------------------------------------
int __fastcall sub_801422C(int a1, int a2)
{
  int v3; // r0
  _DWORD *v5; // r0
  int v6; // r1

  if ( a2 )
  {
    if ( a2 == 4 )
    {
      v3 = *(unsigned __int8 *)(a1 + 69);
    }
    else if ( a2 == 8 )
    {
      v3 = *(unsigned __int8 *)(a1 + 70);
    }
    else
    {
      v3 = *(unsigned __int8 *)(a1 + 71);
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(a1 + 68);
  }
  if ( v3 != 1 )
    return 1;
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      *(_BYTE *)(a1 + 69) = 2;
    }
    else if ( a2 == 8 )
    {
      *(_BYTE *)(a1 + 70) = 2;
    }
    else
    {
      *(_BYTE *)(a1 + 71) = 2;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 68) = 2;
  }
  sub_801A3C2(*(_DWORD *)a1, a2, 4);
  *(_DWORD *)(*(_DWORD *)a1 + 68) |= 0x8000u;
  v5 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v5 == (_DWORD *)0x40000000
    || v5 == (_DWORD *)1073742848
    || v5 == (_DWORD *)1073743872
    || v5 == (_DWORD *)1073744896
    || v5 == (_DWORD *)1073820672
    || v5 == (_DWORD *)1073823744
    || v5 == (_DWORD *)1073827840 )
  {
    v6 = v5[2] & 0x10007;
    if ( v6 != 6 && v6 != 0x10000 )
      *v5 |= 1u;
  }
  else
  {
    *v5 |= 1u;
  }
  return 0;
}

//----- (08014308) --------------------------------------------------------
int __fastcall sub_8014308(_BYTE *a1, int a2, int a3)
{
  int v3; // r3
  int v5; // r1

  v3 = 0;
  if ( a1[60] == 1 )
    return 2;
  a1[60] = 1;
  if ( a3 )
  {
    switch ( a3 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFFFF0FF | a2;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFF0FFFF | a2;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xF0FFFFFF | a2;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFFFFFF0 | a2;
    v5 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1073824768 || v5 == 1073825792 )
      *(_DWORD *)(v5 + 104) |= 1u;
    else
      *(_DWORD *)(v5 + 104) &= ~1u;
  }
  a1[60] = 0;
  return v3;
}

//----- (0801439A) --------------------------------------------------------
int __fastcall sub_801439A(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_80143E8((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A2D4(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (080143E8) --------------------------------------------------------
int __fastcall sub_80143E8(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073746944 )
  {
    MEMORY[0x40021058] |= 0x20u;
    sub_80132C0(55, 5u, 0);
    return sub_80132A4(55);
  }
  return result;
}

//----- (08014424) --------------------------------------------------------
int __fastcall sub_8014424(_BYTE *a1)
{
  _DWORD *v2; // r0
  int v3; // r1

  if ( a1[61] != 1 )
    return 1;
  a1[61] = 2;
  *(_DWORD *)(*(_DWORD *)a1 + 12) |= 1u;
  v2 = *(_DWORD **)a1;
  if ( v2 == (_DWORD *)1073818624
    || v2 == (_DWORD *)0x40000000
    || v2 == (_DWORD *)1073742848
    || v2 == (_DWORD *)1073743872
    || v2 == (_DWORD *)1073744896
    || v2 == (_DWORD *)1073820672
    || v2 == (_DWORD *)1073823744
    || v2 == (_DWORD *)1073827840 )
  {
    v3 = v2[2] & 0x10007;
    if ( v3 != 6 && v3 != 0x10000 )
      *v2 |= 1u;
  }
  else
  {
    *v2 |= 1u;
  }
  return 0;
}

//----- (080144B8) --------------------------------------------------------
unsigned int __fastcall sub_80144B8(unsigned int *a1)
{
  unsigned int result; // r0
  int v2; // r4
  int v3; // r5
  __int16 v4; // r0

  result = *a1;
  if ( result == 1073827840 )
  {
    v2 = (unsigned __int16)sub_80150F0((int)&dword_20001A08, 0);
    result = v2 - (unsigned __int16)dword_20000060;
    v3 = (unsigned __int16)result;
    if ( (unsigned __int16)result >= 0x7D0u )
    {
      dword_2000005C = sub_8012298();
      v4 = word_20000058;
      dword_200019F8[(unsigned __int16)word_20000058] = v3;
      dword_20000060 = v2;
      result = (unsigned __int16)(v4 + 1);
      word_20000058 = result;
      if ( result >= 4 )
      {
        result = 0;
        word_20000058 = 0;
      }
    }
  }
  return result;
}
// 20000058: using guessed type __int16 word_20000058;
// 2000005C: using guessed type int dword_2000005C;
// 20000060: using guessed type int dword_20000060;
// 200019F8: using guessed type _DWORD dword_200019F8[4];
// 20001A08: using guessed type int dword_20001A08;

//----- (08014508) --------------------------------------------------------
int __fastcall sub_8014508(int a1, int *a2, int a3)
{
  int v5; // r6

  v5 = 0;
  if ( *(_BYTE *)(a1 + 60) == 1 )
    return 2;
  *(_BYTE *)(a1 + 60) = 1;
  if ( a3 )
  {
    switch ( a3 )
    {
      case 4:
        sub_801A7EC(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFF3FF;
        *(_DWORD *)(*(_DWORD *)a1 + 24) |= a2[2] << 8;
        break;
      case 8:
        sub_801A822(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 28) &= 0xFFFFFFF3;
        *(_DWORD *)(*(_DWORD *)a1 + 28) |= a2[2];
        break;
      case 12:
        sub_801A854(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 28) &= 0xFFFFF3FF;
        *(_DWORD *)(*(_DWORD *)a1 + 28) |= a2[2] << 8;
        break;
      default:
        v5 = 1;
        break;
    }
  }
  else
  {
    sub_801A76C(*(_DWORD *)a1, *(_QWORD *)a2, a2[1], a2[3]);
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFFFF3;
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= a2[2];
  }
  *(_BYTE *)(a1 + 60) = 0;
  return v5;
}

//----- (080145C8) --------------------------------------------------------
int __fastcall sub_80145C8(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_8014618((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A2D4(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (08014618) --------------------------------------------------------
int __fastcall sub_8014618(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073827840 )
  {
    MEMORY[0x40021060] |= 0x100000u;
    sub_80132C0(80, 3u, 0);
    return sub_80132A4(80);
  }
  return result;
}

//----- (08014654) --------------------------------------------------------
int __fastcall sub_8014654(unsigned __int8 *a1, int a2)
{
  int v3; // r5
  int v4; // r0
  int v5; // r2
  _DWORD *v7; // r0
  int v8; // r1

  v3 = 0;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v4 = a1[63];
        break;
      case 8:
        v4 = a1[64];
        break;
      case 12:
        v4 = a1[65];
        break;
      case 16:
        v4 = a1[66];
        break;
      default:
        v4 = a1[67];
        break;
    }
  }
  else
  {
    v4 = a1[62];
  }
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      v5 = a1[69];
    }
    else if ( a2 == 8 )
    {
      v5 = a1[70];
    }
    else
    {
      v5 = a1[71];
    }
  }
  else
  {
    v5 = a1[68];
  }
  if ( v4 != 1 || v5 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        a1[63] = 2;
        break;
      case 8:
        a1[64] = 2;
        break;
      case 12:
        a1[65] = 2;
        break;
      case 16:
        a1[66] = 2;
        break;
      default:
        a1[67] = 2;
        break;
    }
  }
  else
  {
    a1[62] = 2;
  }
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      a1[69] = 2;
    }
    else if ( a2 == 8 )
    {
      a1[70] = 2;
    }
    else
    {
      a1[71] = 2;
    }
  }
  else
  {
    a1[68] = 2;
  }
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 4u;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 8u;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 0x10u;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 12) |= 2u;
  }
  if ( !v3 )
  {
    sub_801A3A8(*(_DWORD *)a1, a2, 1);
    v7 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v7 == (_DWORD *)0x40000000
      || v7 == (_DWORD *)1073742848
      || v7 == (_DWORD *)1073743872
      || v7 == (_DWORD *)1073744896
      || v7 == (_DWORD *)1073820672
      || v7 == (_DWORD *)1073823744
      || v7 == (_DWORD *)1073827840 )
    {
      v8 = v7[2] & 0x10007;
      if ( v8 != 6 && v8 != 0x10000 )
        *v7 |= 1u;
    }
    else
    {
      *v7 |= 1u;
    }
  }
  return v3;
}

//----- (080147DC) --------------------------------------------------------
int __fastcall sub_80147DC(int a1)
{
  unsigned int v2; // r0
  unsigned int v3; // r0
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  int result; // r0

  v2 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(v2 + 16) & 2) == 0 && (~*(_DWORD *)(v2 + 12) & 2) == 0 )
  {
    *(_DWORD *)(v2 + 16) = -3;
    *(_BYTE *)(a1 + 28) = 1;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 24) << 30 )
    {
      sub_80144B8((unsigned int *)a1);
    }
    else
    {
      sub_8014A50(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v3 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 4) == 0 && (~*(_DWORD *)(v3 + 12) & 4) == 0 )
  {
    *(_DWORD *)(v3 + 16) = -5;
    *(_BYTE *)(a1 + 28) = 2;
    if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x300) != 0 )
    {
      sub_80144B8((unsigned int *)a1);
    }
    else
    {
      sub_8014A50(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v4 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 8) == 0 && (~*(_DWORD *)(v4 + 12) & 8) == 0 )
  {
    *(_DWORD *)(v4 + 16) = -9;
    *(_BYTE *)(a1 + 28) = 4;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 28) << 30 )
    {
      sub_80144B8((unsigned int *)a1);
    }
    else
    {
      sub_8014A50(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v5 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x10) == 0 && (~*(_DWORD *)(v5 + 12) & 0x10) == 0 )
  {
    *(_DWORD *)(v5 + 16) = -17;
    *(_BYTE *)(a1 + 28) = 8;
    if ( (*(_DWORD *)(*(_DWORD *)a1 + 28) & 0x300) != 0 )
    {
      sub_80144B8((unsigned int *)a1);
    }
    else
    {
      sub_8014A50(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v6 = *(_DWORD *)a1;
  if ( !(~*(_DWORD *)(*(_DWORD *)a1 + 16) << 31) && !(~*(_DWORD *)(v6 + 12) << 31) )
  {
    *(_DWORD *)(v6 + 16) = -2;
    sub_80150BC((int *)a1);
  }
  v7 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x80) == 0 && (~*(_DWORD *)(v7 + 12) & 0x80) == 0 )
  {
    *(_DWORD *)(v7 + 16) = -129;
    nullsub_17(a1);
  }
  v8 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x100) == 0 && (~*(_DWORD *)(v8 + 12) & 0x80) == 0 )
  {
    *(_DWORD *)(v8 + 16) = -257;
    nullsub_16(a1);
  }
  v9 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x40) == 0 && (~*(_DWORD *)(v9 + 12) & 0x40) == 0 )
  {
    *(_DWORD *)(v9 + 16) = -65;
    nullsub_24(a1);
  }
  v10 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x20) == 0 && (~*(_DWORD *)(v10 + 12) & 0x20) == 0 )
  {
    *(_DWORD *)(v10 + 16) = -33;
    nullsub_18(a1);
  }
  v11 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x100000) == 0 && (~*(_DWORD *)(v11 + 12) & 0x100000) == 0 )
  {
    *(_DWORD *)(v11 + 16) = -1048577;
    nullsub_20(a1);
  }
  v12 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x200000) == 0 && (~*(_DWORD *)(v12 + 12) & 0x200000) == 0 )
  {
    *(_DWORD *)(v12 + 16) = -2097153;
    nullsub_19(a1);
  }
  v13 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x400000) == 0 && (~*(_DWORD *)(v13 + 12) & 0x400000) == 0 )
  {
    *(_DWORD *)(v13 + 16) = -4194305;
    nullsub_21(a1);
  }
  result = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x800000) == 0 && (~*(_DWORD *)(result + 12) & 0x800000) == 0 )
  {
    *(_DWORD *)(result + 16) = -8388609;
    return nullsub_22(a1);
  }
  return result;
}
// 8014220: using guessed type int __fastcall nullsub_16(_DWORD);
// 8014222: using guessed type int __fastcall nullsub_17(_DWORD);
// 8014224: using guessed type int __fastcall nullsub_18(_DWORD);
// 8014226: using guessed type int __fastcall nullsub_19(_DWORD);
// 8014228: using guessed type int __fastcall nullsub_20(_DWORD);
// 801422A: using guessed type int __fastcall nullsub_21(_DWORD);
// 8014398: using guessed type int __fastcall nullsub_22(_DWORD);
// 8014ED4: using guessed type int __fastcall nullsub_23(_DWORD);
// 801511C: using guessed type int __fastcall nullsub_24(_DWORD);

//----- (080149E0) --------------------------------------------------------
int __fastcall sub_80149E0(_DWORD **a1, _DWORD *a2, int a3)
{
  int v4; // r5

  v4 = 0;
  if ( *((_BYTE *)a1 + 60) == 1 )
    return 2;
  *((_BYTE *)a1 + 60) = 1;
  if ( a3 == 12 )
  {
    sub_801A5D4(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 > 12 )
  {
    if ( a3 == 16 )
    {
      sub_801A678(*a1, (int)a2);
      goto LABEL_12;
    }
    if ( a3 == 20 )
    {
      sub_801A6F0(*a1, (int)a2);
      goto LABEL_12;
    }
LABEL_11:
    v4 = 1;
    goto LABEL_12;
  }
  if ( !a3 )
  {
    sub_801A3DC(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 == 4 )
  {
    sub_801A48C(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 != 8 )
    goto LABEL_11;
  sub_801A530(*a1, a2);
LABEL_12:
  *((_BYTE *)a1 + 60) = 0;
  return v4;
}

//----- (08014A50) --------------------------------------------------------
int __fastcall sub_8014A50(int result)
{
  int v1; // r1

  if ( *(_DWORD *)result == 1073743872 )
  {
    v1 = *(unsigned __int8 *)(result + 28);
    result = dword_20001AEC;
    if ( v1 == 1 )
    {
      *(_DWORD *)(dword_20001AEC + 12) &= ~2u;
      return off_20000064();
    }
    else if ( v1 == 2 )
    {
      *(_DWORD *)(dword_20001AEC + 12) &= ~4u;
      return off_20000068();
    }
  }
  return result;
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AEC: using guessed type int dword_20001AEC;

//----- (08014A90) --------------------------------------------------------
int __fastcall sub_8014A90(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    nullsub_25(a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A2D4(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}
// 8014ADE: using guessed type int __fastcall nullsub_25(_DWORD);

//----- (08014AE0) --------------------------------------------------------
int __fastcall sub_8014AE0(unsigned __int8 *a1, int a2)
{
  int v3; // r5
  int v4; // r0
  int v6; // r0
  _DWORD *v7; // r0
  int v8; // r1

  v3 = 0;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v4 = a1[63];
        break;
      case 8:
        v4 = a1[64];
        break;
      case 12:
        v4 = a1[65];
        break;
      case 16:
        v4 = a1[66];
        break;
      default:
        v4 = a1[67];
        break;
    }
  }
  else
  {
    v4 = a1[62];
  }
  if ( v4 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        a1[63] = 2;
        break;
      case 8:
        a1[64] = 2;
        break;
      case 12:
        a1[65] = 2;
        break;
      case 16:
        a1[66] = 2;
        break;
      default:
        a1[67] = 2;
        break;
    }
  }
  else
  {
    a1[62] = 2;
  }
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 4u;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 8u;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 0x10u;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 12) |= 2u;
  }
  if ( !v3 )
  {
    sub_801A3A8(*(_DWORD *)a1, a2, 1);
    v6 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v6 == 1073820672
      || v6 == 1073823744
      || v6 == 1073824768
      || v6 == 1073825792
      || v6 == 1073827840 )
    {
      *(_DWORD *)(v6 + 68) |= 0x8000u;
    }
    v7 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v7 == (_DWORD *)0x40000000
      || v7 == (_DWORD *)1073742848
      || v7 == (_DWORD *)1073743872
      || v7 == (_DWORD *)1073744896
      || v7 == (_DWORD *)1073820672
      || v7 == (_DWORD *)1073823744
      || v7 == (_DWORD *)1073827840 )
    {
      v8 = v7[2] & 0x10007;
      if ( v8 != 6 && v8 != 0x10000 )
        *v7 |= 1u;
    }
    else
    {
      *v7 |= 1u;
    }
  }
  return v3;
}

//----- (08014C4C) --------------------------------------------------------
int __fastcall sub_8014C4C(_DWORD **a1, _DWORD *a2, int a3)
{
  int v5; // r6

  v5 = 0;
  if ( *((_BYTE *)a1 + 60) == 1 )
    return 2;
  *((_BYTE *)a1 + 60) = 1;
  if ( a3 == 12 )
  {
    sub_801A5D4(*a1, a2);
    (*a1)[7] |= 0x800u;
    (*a1)[7] &= ~0x400u;
    (*a1)[7] |= a2[4] << 8;
    goto LABEL_12;
  }
  if ( a3 > 12 )
  {
    if ( a3 == 16 )
    {
      sub_801A678(*a1, (int)a2);
      (*a1)[20] |= 8u;
      (*a1)[20] &= ~4u;
      (*a1)[20] |= a2[4];
      goto LABEL_12;
    }
    if ( a3 == 20 )
    {
      sub_801A6F0(*a1, (int)a2);
      (*a1)[20] |= 0x800u;
      (*a1)[20] &= ~0x400u;
      (*a1)[20] |= a2[4] << 8;
      goto LABEL_12;
    }
LABEL_11:
    v5 = 1;
    goto LABEL_12;
  }
  if ( !a3 )
  {
    sub_801A3DC(*a1, a2);
    (*a1)[6] |= 8u;
    (*a1)[6] &= ~4u;
    (*a1)[6] |= a2[4];
    goto LABEL_12;
  }
  if ( a3 == 4 )
  {
    sub_801A48C(*a1, a2);
    (*a1)[6] |= 0x800u;
    (*a1)[6] &= ~0x400u;
    (*a1)[6] |= a2[4] << 8;
    goto LABEL_12;
  }
  if ( a3 != 8 )
    goto LABEL_11;
  sub_801A530(*a1, a2);
  (*a1)[7] |= 8u;
  (*a1)[7] &= ~4u;
  (*a1)[7] |= a2[4];
LABEL_12:
  *((_BYTE *)a1 + 60) = 0;
  return v5;
}

//----- (08014D82) --------------------------------------------------------
int __fastcall sub_8014D82(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_8014DD0((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A2D4(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (08014DD0) --------------------------------------------------------
int *__fastcall sub_8014DD0(int *a1)
{
  int v2; // r1
  int *result; // r0
  int v4; // [sp+8h] [bp-28h] BYREF
  int v5; // [sp+Ch] [bp-24h]
  int v6; // [sp+10h] [bp-20h]
  int v7; // [sp+14h] [bp-1Ch]
  int v8; // [sp+18h] [bp-18h]

  sub_8002364(&v4, 20);
  v2 = *a1;
  result = (int *)1073876992;
  if ( *a1 == 1073818624 )
  {
    MEMORY[0x40021060] |= 0x800u;
    MEMORY[0x4002104C] |= 4u;
    v4 = 0x2000;
    v5 = 2;
    v6 = 2;
    v7 = 2;
    v8 = 4;
    return sub_80120B0((int *)0x48000800, (int)&v4);
  }
  else if ( v2 == 1073742848 )
  {
    MEMORY[0x40021058] |= 2u;
    MEMORY[0x4002104C] |= 2u;
    v4 = 128;
    v5 = 2;
    v6 = 0;
    v7 = 1;
    v8 = 10;
    sub_80120B0((int *)0x48000400, (int)&v4);
    v4 = 16;
    v5 = 2;
    v6 = 0;
    v7 = 1;
    v8 = 2;
    return sub_80120B0((int *)0x48000400, (int)&v4);
  }
  else if ( v2 == 1073823744 )
  {
    MEMORY[0x40021060] |= 0x10000u;
    MEMORY[0x4002104C] |= 1u;
    v4 = 8;
    v5 = 2;
    v6 = 0;
    v7 = 0;
    v8 = 9;
    return sub_80120B0((int *)0x48000000, (int)&v4);
  }
  return result;
}

//----- (08014ED8) --------------------------------------------------------
int __fastcall sub_8014ED8(int a1, int a2)
{
  int v3; // r0
  int v5; // r0
  _DWORD *v6; // r0
  int v7; // r1

  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v3 = *(unsigned __int8 *)(a1 + 63);
        break;
      case 8:
        v3 = *(unsigned __int8 *)(a1 + 64);
        break;
      case 12:
        v3 = *(unsigned __int8 *)(a1 + 65);
        break;
      case 16:
        v3 = *(unsigned __int8 *)(a1 + 66);
        break;
      default:
        v3 = *(unsigned __int8 *)(a1 + 67);
        break;
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(a1 + 62);
  }
  if ( v3 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_BYTE *)(a1 + 63) = 2;
        break;
      case 8:
        *(_BYTE *)(a1 + 64) = 2;
        break;
      case 12:
        *(_BYTE *)(a1 + 65) = 2;
        break;
      case 16:
        *(_BYTE *)(a1 + 66) = 2;
        break;
      default:
        *(_BYTE *)(a1 + 67) = 2;
        break;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 62) = 2;
  }
  sub_801A3A8(*(_DWORD *)a1, a2, 1);
  v5 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v5 == 1073820672
    || v5 == 1073823744
    || v5 == 1073824768
    || v5 == 1073825792
    || v5 == 1073827840 )
  {
    *(_DWORD *)(v5 + 68) |= 0x8000u;
  }
  v6 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v6 == (_DWORD *)0x40000000
    || v6 == (_DWORD *)1073742848
    || v6 == (_DWORD *)1073743872
    || v6 == (_DWORD *)1073744896
    || v6 == (_DWORD *)1073820672
    || v6 == (_DWORD *)1073823744
    || v6 == (_DWORD *)1073827840 )
  {
    v7 = v6[2] & 0x10007;
    if ( v7 != 6 && v7 != 0x10000 )
      *v6 |= 1u;
  }
  else
  {
    *v6 |= 1u;
  }
  return 0;
}

//----- (08015004) --------------------------------------------------------
int __fastcall sub_8015004(int a1, int a2)
{
  int v4; // r2
  _DWORD *v5; // r0

  sub_801A3A8(*(_DWORD *)a1, a2, 0);
  v4 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 == 1073818624
     || v4 == 1073820672
     || v4 == 1073823744
     || v4 == 1073824768
     || v4 == 1073825792
     || v4 == 1073827840)
    && (*(_DWORD *)(v4 + 32) & 0x1111) == 0
    && (*(_DWORD *)(v4 + 32) & 0x4444) == 0 )
  {
    *(_DWORD *)(v4 + 68) &= ~0x8000u;
  }
  v5 = *(_DWORD **)a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 32) & 0x1111) == 0 && (v5[8] & 0x4444) == 0 )
    *v5 &= ~1u;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_BYTE *)(a1 + 63) = 1;
        break;
      case 8:
        *(_BYTE *)(a1 + 64) = 1;
        break;
      case 12:
        *(_BYTE *)(a1 + 65) = 1;
        break;
      case 16:
        *(_BYTE *)(a1 + 66) = 1;
        break;
      default:
        *(_BYTE *)(a1 + 67) = 1;
        break;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 62) = 1;
  }
  return 0;
}

//----- (080150BC) --------------------------------------------------------
int __fastcall sub_80150BC(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073746944 )
  {
    sub_801227E(1207963648, 2, 1);
    sub_800322A();
    return sub_801227E(1207963648, 2, 0);
  }
  return result;
}

//----- (080150F0) --------------------------------------------------------
int __fastcall sub_80150F0(int a1, int a2)
{
  int result; // r0

  result = 0;
  switch ( a2 )
  {
    case 0:
      return *(_DWORD *)(*(_DWORD *)a1 + 52);
    case 4:
      return *(_DWORD *)(*(_DWORD *)a1 + 56);
    case 8:
      return *(_DWORD *)(*(_DWORD *)a1 + 60);
    case 12:
      return *(_DWORD *)(*(_DWORD *)a1 + 64);
  }
  return result;
}

//----- (0801511E) --------------------------------------------------------
int __fastcall sub_801511E(int a1)
{
  int v1; // r0
  int *v2; // r1
  int v3; // r2

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  v1 = a1 + 100;
  *(_BYTE *)(v1 + 28) = 1;
  *(_DWORD *)(v1 + 32) = 36;
  v2 = *(int **)(v1 - 100);
  v3 = *v2;
  *v2 &= ~1u;
  *(_DWORD *)v1 = 0;
  **(_DWORD **)(v1 - 100) = v3 & 0xDFFFFFFF;
  *(_DWORD *)(v1 + 32) = 32;
  *(_BYTE *)(v1 + 28) = 0;
  return 0;
}

//----- (0801515A) --------------------------------------------------------
int __fastcall sub_801515A(int a1)
{
  int v2; // r1
  int v3; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v2 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v2 & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 100) = 0x20000000;
  **(_DWORD **)a1 = v2 | 0x20000000;
  sub_801AB7C(a1);
  v3 = a1 + 128;
  *(_DWORD *)(v3 + 4) = 32;
  result = 0;
  *(_BYTE *)v3 = 0;
  return result;
}

//----- (080151A6) --------------------------------------------------------
int __fastcall sub_80151A6(int a1, int a2)
{
  int v3; // r5
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v3 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v3 & 0xFFFFFFFE;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0xF1FFFFFF | a2;
  sub_801AB7C(a1);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(a1 + 132) = 32;
  result = 0;
  *(_BYTE *)(a1 + 128) = 0;
  return result;
}

//----- (080151F2) --------------------------------------------------------
int __fastcall sub_80151F2(int a1, int a2)
{
  int v3; // r5
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v3 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v3 & 0xFFFFFFFE;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x1FFFFFFF | a2;
  sub_801AB7C(a1);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(a1 + 132) = 32;
  result = 0;
  *(_BYTE *)(a1 + 128) = 0;
  return result;
}

//----- (08015244) --------------------------------------------------------
int __fastcall sub_8015244(int a1)
{
  unsigned int *v2; // r0
  unsigned int v3; // r1
  unsigned int *v4; // r0
  unsigned int v5; // r1
  unsigned int *v6; // r0
  unsigned int v7; // r1
  unsigned int *v8; // r0
  unsigned int *v9; // r0
  unsigned int v10; // r1
  int v11; // r0

  do
  {
    v2 = *(unsigned int **)a1;
    v3 = __ldrex(*(unsigned int **)a1);
  }
  while ( __strex(v3 & 0xFFFFFEDF, v2) );
  do
  {
    v4 = (unsigned int *)(*(_DWORD *)a1 + 8);
    v5 = __ldrex(v4);
  }
  while ( __strex(v5 & 0xEFFFFFFE, v4) );
  if ( *(_DWORD *)(a1 + 108) == 1 )
  {
    do
    {
      v6 = *(unsigned int **)a1;
      v7 = __ldrex(*(unsigned int **)a1);
    }
    while ( __strex(v7 & 0xFFFFFFEF, v6) );
  }
  v8 = *(unsigned int **)a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x40) != 0 )
  {
    do
    {
      v9 = (unsigned int *)(*(_DWORD *)a1 + 8);
      v10 = __ldrex(v9);
    }
    while ( __strex(v10 & 0xFFFFFFBF, v9) );
    v11 = *(_DWORD *)(a1 + 124);
    if ( v11 )
    {
      *(_DWORD *)(v11 + 56) = 134329681;
      if ( sub_801140C(*(_DWORD *)(a1 + 124)) )
        (*(void (**)(void))(*(_DWORD *)(a1 + 124) + 56))();
    }
    else
    {
      *(_WORD *)(a1 + 94) = 0;
      *(_DWORD *)(a1 + 88) = 0;
      *(_DWORD *)(*(_DWORD *)a1 + 32) = 15;
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 8u;
      *(_DWORD *)(a1 + 136) = 32;
      *(_DWORD *)(a1 + 108) = 0;
      nullsub_30(a1);
    }
  }
  else
  {
    *(_WORD *)(a1 + 94) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    v8[8] = 15;
    *(_DWORD *)(a1 + 136) = 32;
    *(_DWORD *)(a1 + 108) = 0;
    nullsub_30(a1);
  }
  return 0;
}
// 8015242: using guessed type int __fastcall nullsub_30(_DWORD);

//----- (08015308) --------------------------------------------------------
int __fastcall sub_8015308(_DWORD *a1)
{
  _DWORD *v2; // r4

  if ( !a1 )
    return 1;
  a1[33] = 36;
  *(_DWORD *)*a1 &= ~1u;
  *(_DWORD *)*a1 = 0;
  *(_DWORD *)(*a1 + 4) = 0;
  *(_DWORD *)(*a1 + 8) = 0;
  nullsub_31(a1);
  v2 = a1 + 27;
  v2[8] = 0;
  v2[6] = 0;
  v2[7] = 0;
  *v2 = 0;
  *((_BYTE *)v2 + 20) = 0;
  return 0;
}
// 80156A8: using guessed type int __fastcall nullsub_31(_DWORD);

//----- (0801534C) --------------------------------------------------------
int __fastcall sub_801534C(_DWORD *a1)
{
  int *v2; // r3
  int result; // r0
  int v4; // r1
  int v5; // r2
  int (__fastcall *v6)(_DWORD *); // r1
  void (__fastcall *v7)(_DWORD *); // r1
  unsigned int *v8; // r0
  unsigned int v9; // r1
  int v10; // r0
  int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int *v14; // r0
  unsigned int v15; // r1
  unsigned int *v16; // r0
  unsigned int v17; // r1
  unsigned int *v18; // r0
  unsigned int v19; // r1
  _DWORD *v20; // r4
  __int16 v21; // t1
  int v22; // r1
  unsigned int **v23; // r4
  unsigned int *v24; // r0
  unsigned int v25; // r2
  unsigned int *v26; // r0
  unsigned int v27; // r2
  unsigned int *v28; // r0
  unsigned int v29; // r2

  v2 = (int *)*a1;
  result = *(_DWORD *)(*a1 + 28);
  v4 = *v2;
  v5 = v2[2];
  if ( (result & 0x80F) == 0 && (result & 0x20) != 0 && *v2 & 0x20 | v5 & 0x10000000 )
  {
    v6 = (int (__fastcall *)(_DWORD *))a1[28];
    if ( v6 )
      return v6(a1);
  }
  else if ( (result & 0x80F) != 0 && v4 & 0x4000120 | v5 & 0x10000001 )
  {
    if ( result << 31 && (v4 & 0x100) != 0 )
    {
      v2[8] = 1;
      a1[35] |= 1u;
    }
    if ( (result & 2) != 0 && v5 << 31 )
    {
      *(_DWORD *)(*a1 + 32) = 2;
      a1[35] |= 4u;
    }
    if ( (result & 4) != 0 && v5 << 31 )
    {
      *(_DWORD *)(*a1 + 32) = 4;
      a1[35] |= 2u;
    }
    if ( (result & 8) != 0 && v4 & 0x20 | v5 & 0x10000001 )
    {
      *(_DWORD *)(*a1 + 32) = 8;
      a1[35] |= 8u;
    }
    if ( (result & 0x800) != 0 && (v4 & 0x4000000) != 0 )
    {
      *(_DWORD *)(*a1 + 32) = 2048;
      a1[35] |= 0x20u;
    }
    if ( a1[35] )
    {
      if ( (result & 0x20) != 0 )
      {
        if ( v4 & 0x20 | v5 & 0x10000000 )
        {
          v7 = (void (__fastcall *)(_DWORD *))a1[28];
          if ( v7 )
            v7(a1);
        }
      }
      if ( (*(_DWORD *)(*a1 + 8) & 0x40) != 0 || (a1[35] & 0x28) != 0 )
      {
        sub_801ADC4((int)a1);
        if ( (*(_DWORD *)(*a1 + 8) & 0x40) == 0 )
          return nullsub_32(a1);
        do
        {
          v8 = (unsigned int *)(*a1 + 8);
          v9 = __ldrex(v8);
        }
        while ( __strex(v9 & 0xFFFFFFBF, v8) );
        v10 = a1[31];
        if ( v10 )
        {
          *(_DWORD *)(v10 + 56) = 134329581;
          result = sub_801140C(a1[31]);
          if ( result )
            return (*(int (**)(void))(a1[31] + 56))();
        }
        else
        {
          return nullsub_32(a1);
        }
      }
      else
      {
        result = nullsub_32(a1);
        a1[35] = 0;
      }
    }
  }
  else if ( a1[27] == 1 && (result & 0x10) != 0 && (v4 & 0x10) != 0 )
  {
    v2[8] = 16;
    if ( (*(_DWORD *)(*a1 + 8) & 0x40) != 0 )
    {
      v11 = a1[31];
      result = (unsigned __int16)*(_DWORD *)(*(_DWORD *)v11 + 4);
      if ( (unsigned __int16)*(_DWORD *)(*(_DWORD *)v11 + 4) && *((unsigned __int16 *)a1 + 46) > (unsigned int)result )
      {
        *((_WORD *)a1 + 47) = result;
        if ( (**(_DWORD **)v11 & 0x20) == 0 )
        {
          do
          {
            v12 = (unsigned int *)*a1;
            v13 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v13 & 0xFFFFFEFF, v12) );
          do
          {
            v14 = (unsigned int *)(*a1 + 8);
            v15 = __ldrex(v14);
          }
          while ( __strex(v15 & 0xFFFFFFFE, v14) );
          do
          {
            v16 = (unsigned int *)(*a1 + 8);
            v17 = __ldrex(v16);
          }
          while ( __strex(v17 & 0xFFFFFFBF, v16) );
          a1[34] = 32;
          a1[27] = 0;
          do
          {
            v18 = (unsigned int *)*a1;
            v19 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v19 & 0xFFFFFFEF, v18) );
          sub_80113A4(a1[31]);
        }
        return nullsub_26(a1, (unsigned __int16)(*((_WORD *)a1 + 46) - *((_WORD *)a1 + 47)));
      }
    }
    else
    {
      v21 = *((_WORD *)a1 + 46);
      v20 = a1 + 23;
      v22 = (unsigned __int16)(v21 - *((_WORD *)v20 + 1));
      result = *((unsigned __int16 *)v20 + 1);
      v23 = (unsigned int **)(v20 - 23);
      if ( result && v22 )
      {
        do
        {
          v24 = *v23;
          v25 = __ldrex(*v23);
        }
        while ( __strex(v25 & 0xFFFFFEDF, v24) );
        do
        {
          v26 = *v23 + 2;
          v27 = __ldrex(v26);
        }
        while ( __strex(v27 & 0xEFFFFFFE, v26) );
        v23[34] = (unsigned int *)32;
        v23[27] = 0;
        v23[28] = 0;
        do
        {
          v28 = *v23;
          v29 = __ldrex(*v23);
        }
        while ( __strex(v29 & 0xFFFFFFEF, v28) );
        return nullsub_26(v23, v22);
      }
    }
  }
  else if ( (result & 0x100000) != 0 && (v5 & 0x400000) != 0 )
  {
    v2[8] = 0x100000;
    return nullsub_29(a1, v4);
  }
  else if ( (result & 0x80) != 0 && *v2 & 0x80 | v5 & 0x800000 )
  {
    v6 = (int (__fastcall *)(_DWORD *))a1[29];
    if ( v6 )
      return v6(a1);
  }
  else if ( (result & 0x40) != 0 && (v4 & 0x40) != 0 )
  {
    return sub_801AE18((int)a1);
  }
  else if ( (result & 0x800000) != 0 && (v4 & 0x40000000) != 0 )
  {
    return nullsub_28(a1);
  }
  else
  {
    result <<= 7;
    if ( result < 0 && v4 < 0 )
      return nullsub_27(a1);
  }
  return result;
}
// 80151A2: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 80151A4: using guessed type int __fastcall nullsub_27(_DWORD);
// 801523E: using guessed type int __fastcall nullsub_28(_DWORD);
// 8015240: using guessed type int __fastcall nullsub_29(_DWORD, _DWORD);
// 8015348: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (08015638) --------------------------------------------------------
int __fastcall sub_8015638(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 132) )
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_80156AC((int *)a1);
  }
  *(_DWORD *)(a1 + 132) = 36;
  **(_DWORD **)a1 &= ~1u;
  if ( sub_801B294((_DWORD *)a1) == 1 )
    return 1;
  if ( *(_DWORD *)(a1 + 40) )
    sub_801ABC4(a1);
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFFFFB7FF;
  *(_DWORD *)(*(_DWORD *)a1 + 8) &= 0xFFFFFFD5;
  **(_DWORD **)a1 |= 1u;
  return sub_801AC8C(a1);
}

//----- (080156AC) --------------------------------------------------------
int __fastcall sub_80156AC(int *a1)
{
  int result; // r0
  int v3; // [sp+4h] [bp-24h] BYREF
  int v4; // [sp+8h] [bp-20h]
  int v5; // [sp+Ch] [bp-1Ch]
  int v6; // [sp+10h] [bp-18h]
  int v7; // [sp+14h] [bp-14h]

  sub_8002364(&v3, 20);
  result = *a1;
  if ( *a1 == 1073759232 )
  {
    MEMORY[0x40021058] |= 0x20000u;
    MEMORY[0x4002104C] |= 8u;
    MEMORY[0x40021048] |= 2u;
    MEMORY[0x40021048] |= 4u;
    v3 = 112;
    v4 = 2;
    v5 = 1;
    v6 = 2;
    v7 = 7;
    sub_80120B0((int *)0x48000C00, (int)&v3);
    dword_200016BC = 1073873948;
    dword_200016C0 = 27;
    dword_200016C4 = 16;
    dword_200016C8 = 0;
    dword_200016CC = 128;
    dword_200016D0 = 0;
    dword_200016D4 = 0;
    dword_200016D8 = 0;
    dword_200016DC = 0;
    if ( sub_8011550((int)&dword_200016BC) )
      sub_80058BC();
    a1[30] = (int)&dword_200016BC;
    dword_200016E4 = (int)a1;
    sub_80132C0(57, 0xBu, 0);
    sub_80132A4(57);
    sub_80132C0(38, 0xAu, 0);
    return sub_80132A4(38);
  }
  else if ( result == 1073774592 )
  {
    MEMORY[0x4002105C] |= 1u;
    MEMORY[0x4002104C] |= 2u;
    v3 = 3072;
    v4 = 2;
    v5 = 1;
    v6 = 0;
    v7 = 8;
    sub_80120B0((int *)0x48000400, (int)&v3);
    sub_80132C0(91, 0xBu, 0);
    return sub_80132A4(91);
  }
  return result;
}
// 200016BC: using guessed type int dword_200016BC;
// 200016C0: using guessed type int dword_200016C0;
// 200016C4: using guessed type int dword_200016C4;
// 200016C8: using guessed type int dword_200016C8;
// 200016CC: using guessed type int dword_200016CC;
// 200016D0: using guessed type int dword_200016D0;
// 200016D4: using guessed type int dword_200016D4;
// 200016D8: using guessed type int dword_200016D8;
// 200016DC: using guessed type int dword_200016DC;
// 200016E4: using guessed type int dword_200016E4;

//----- (080157DC) --------------------------------------------------------
int __fastcall sub_80157DC(int a1, int a2, unsigned int a3)
{
  unsigned int *v4; // r3
  unsigned int v5; // r4

  if ( *(_DWORD *)(a1 + 136) != 32 )
    return 2;
  if ( !a2 || !a3 )
    return 1;
  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 108) = 0;
  if ( *(_DWORD *)a1 != 1073774592 && (*(_DWORD *)(*(_DWORD *)a1 + 4) & 0x800000) != 0 )
  {
    do
    {
      v4 = *(unsigned int **)a1;
      v5 = __ldrex(*(unsigned int **)a1);
    }
    while ( __strex(v5 | 0x4000000, v4) );
  }
  return sub_801B5A4(a1, a2, a3);
}

//----- (08015834) --------------------------------------------------------
int __fastcall sub_8015834(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073759232 )
  {
    byte_20000030 = 1;
    sub_8022F0C();
    if ( byte_20000031 == 3 )
    {
      sub_8024BE4(dword_20000444, (unsigned int)byte_2000303A, 0, 0);
      return sub_80157DC((int)&dword_2000171C, (int)byte_2000303A, 1u);
    }
    else if ( byte_20000031 == 1 )
    {
      sub_8024BE4(dword_2000043C, (unsigned int)byte_2000303A, 0, 0);
      return sub_80157DC((int)&dword_2000171C, (int)byte_2000303A, 1u);
    }
    else if ( byte_20000504 )
    {
      sub_8024BE4(dword_20000448, (unsigned int)byte_2000303A, 0, 0);
      return sub_80157DC((int)&dword_2000171C, (int)byte_2000303A, 1u);
    }
    else
    {
      if ( (unsigned int)++dword_20000034 <= 0xFF )
        sub_80157DC((int)&dword_2000171C, (int)&byte_2000303A[dword_20000034], 1u);
      else
        dword_20000034 = 0;
      return sub_801A028(2, 80, (int (*)(void))((char *)&loc_80187E4 + 1));
    }
  }
  else if ( result == 1073774592 )
  {
    sub_800D184((unsigned __int8)byte_20000032);
    return sub_80157DC((int)&dword_200017AC, (int)&byte_20000032, 1u);
  }
  return result;
}
// 20000030: using guessed type char byte_20000030;
// 20000031: using guessed type char byte_20000031;
// 20000032: using guessed type char byte_20000032;
// 20000034: using guessed type int dword_20000034;
// 2000043C: using guessed type int dword_2000043C;
// 20000444: using guessed type int dword_20000444;
// 20000448: using guessed type int dword_20000448;
// 20000504: using guessed type char byte_20000504;
// 2000171C: using guessed type int dword_2000171C;
// 200017AC: using guessed type int dword_200017AC;

//----- (08015924) --------------------------------------------------------
int __fastcall sub_8015924(int a1, int a2, int a3)
{
  int v4; // r4
  int v5; // r0
  int *v6; // r4
  int *v7; // r4
  unsigned int *v8; // r0
  unsigned int v9; // r1

  if ( *(_DWORD *)(a1 + 132) != 32 )
    return 2;
  if ( !a2 || !a3 )
    return 1;
  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  v4 = a1 + 80;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 80) = a2;
  *(_WORD *)(a1 + 84) = a3;
  *(_WORD *)(a1 + 86) = a3;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 132) = 33;
  v5 = *(_DWORD *)(a1 + 120);
  v6 = (int *)(v4 - 80);
  if ( v5
    && (*(_DWORD *)(v5 + 44) = (char *)&dword_801B578 + 1,
        *(_DWORD *)(v6[30] + 48) = 134329787,
        *(_DWORD *)(v6[30] + 52) = 134329601,
        *(_DWORD *)(v6[30] + 56) = 0,
        sub_8011610(v6[30], v6[20], *v6 + 40, a3)) )
  {
    v7 = v6 + 32;
    v7[3] = 16;
    *(_BYTE *)v7 = 0;
    v7[1] = 32;
    return 1;
  }
  else
  {
    *(_DWORD *)(*v6 + 32) = 64;
    *((_BYTE *)v6 + 128) = 0;
    do
    {
      v8 = (unsigned int *)(*v6 + 8);
      v9 = __ldrex(v8);
    }
    while ( __strex(v9 | 0x80, v8) );
    return 0;
  }
}
// 801B578: using guessed type int dword_801B578;

//----- (080159CC) --------------------------------------------------------
_DWORD *sub_80159CC()
{
  _DWORD *result; // r0
  int v1; // r2
  unsigned int v2; // r1
  int v3; // r5
  unsigned int v4; // r7
  unsigned int v5; // r3

  result = (_DWORD *)dword_2000183C;
  if ( *(_DWORD *)(dword_2000183C + 524) << 31 )
  {
    v1 = dword_20000040;
    dword_20000050 = dword_20000040;
    v2 = (unsigned int)dword_20000040 >> 1;
    dword_20000054 = (unsigned int)dword_20000040 >> 1;
    *(_DWORD *)(dword_2000183C + 520) = 1;
    result[133] = v1;
    if ( dword_2000004C )
      --dword_2000004C;
    v3 = dword_20000044;
    v4 = ((unsigned int)dword_20000040 >> 1) + dword_20000044;
    v5 = ((unsigned int)dword_20000040 >> 1) + 340;
    switch ( byte_2000003D )
    {
      case 1:
        if ( (unsigned int)dword_2000004C <= 1 )
        {
          result[103] = 340;
          result[105] = v5;
          result[106] = v2;
          result[107] = v1;
        }
        else
        {
          result[103] = 0xFFFF;
          result[105] = 0xFFFF;
          result[106] = 0xFFFF;
          result[107] = 0xFFFF;
        }
        break;
      case 2:
        result[103] = 340;
        result[105] = v5;
        result[106] = v3;
        result[107] = v4;
        break;
      case 3:
        result[103] = 340;
        result[105] = v5;
        result[106] = v2 - dword_20000048;
        result[107] = v1 - dword_20000048;
        break;
    }
    switch ( byte_2000003C )
    {
      case 1:
        result += 167;
        if ( (unsigned int)dword_2000004C <= 1 )
        {
          *result = 340;
          result[2] = v5;
          result[3] = v2;
          result[4] = v1;
          result[32] = 340;
          result[34] = v5;
          result[35] = v2;
          result[36] = v1;
        }
        else
        {
          *result = 0xFFFF;
          result[2] = 0xFFFF;
          result[3] = 0xFFFF;
          result[4] = 0xFFFF;
          result[32] = 0xFFFF;
          result[34] = 0xFFFF;
          result[35] = 0xFFFF;
          result[36] = 0xFFFF;
        }
        break;
      case 2:
        result += 167;
        *result = 340;
        result[2] = v5;
        result[3] = v3;
        result[4] = v4;
        result[32] = 340;
        result[34] = v5;
        result[35] = v3;
        result[36] = v4;
        break;
      case 3:
        result += 167;
        *result = dword_20000048 + 340;
        result[2] = dword_20000048 + v2 + 340;
        result[3] = v2;
        result[4] = v1;
        result[32] = dword_20000048 + 340;
        result[34] = dword_20000048 + v2 + 340;
        result[35] = v2;
        result[36] = v1;
        break;
    }
  }
  return result;
}
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 20000048: using guessed type int dword_20000048;
// 2000004C: using guessed type int dword_2000004C;
// 20000050: using guessed type int dword_20000050;
// 20000054: using guessed type int dword_20000054;
// 2000183C: using guessed type int dword_2000183C;

//----- (08015B60) --------------------------------------------------------
_DWORD *__fastcall sub_8015B60(_DWORD *result, int a2, _BYTE *a3)
{
  int v3; // r3
  int v4; // r4
  int v5; // r5
  int v6; // r6
  unsigned int v7; // r1
  unsigned int v8; // r1
  unsigned int v9; // r1
  unsigned int v10; // r1
  unsigned int v11; // r1
  unsigned int v12; // r1
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int v15; // r1
  unsigned int v16; // r1

  v3 = *result;
  v4 = *(_DWORD *)(*result + 944);
  v5 = *(_DWORD *)(*result + 948);
  v6 = *(_DWORD *)(*result + 952);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(v3 + 944) = 0;
      *(_DWORD *)(*result + 948) = 0;
      result = (_DWORD *)*result;
      result[238] = 0;
      break;
    case 1:
      v7 = a3[8] & 0x18 | a3[4] & 4 | *a3 & 3 | v4 & 0xFFFFFFC0;
      *(_DWORD *)(v3 + 944) = v7;
      result = (_DWORD *)*result;
      result[236] = a3[16] & 0x20 | v7;
      break;
    case 2:
      v8 = (*((_DWORD *)a3 + 2) << 6) & 0x600
         | (*((_DWORD *)a3 + 1) << 6) & 0x100
         | v4 & 0xFFFFF03F
         | (unsigned __int8)(*a3 << 6);
      *(_DWORD *)(v3 + 944) = v8;
      result = (_DWORD *)*result;
      result[236] = (*((_DWORD *)a3 + 4) << 6) & 0x800 | v8;
      break;
    case 3:
      v9 = (*((_DWORD *)a3 + 2) << 12) & 0x18000
         | (*((_DWORD *)a3 + 1) << 12) & 0x4000
         | (*(_DWORD *)a3 << 12) & 0x3000
         | v4 & 0xFFFC0FFF;
      *(_DWORD *)(v3 + 944) = v9;
      result = (_DWORD *)*result;
      result[236] = (*((_DWORD *)a3 + 4) << 12) & 0x20000 | v9;
      break;
    case 4:
      v10 = (*((unsigned __int16 *)a3 + 4) << 18) & 0x600000
          | (*((unsigned __int16 *)a3 + 2) << 18) & 0x100000
          | (*(unsigned __int16 *)a3 << 18) & 0xC0000
          | v4 & 0xFF03FFFF;
      *(_DWORD *)(v3 + 944) = v10;
      result = (_DWORD *)*result;
      result[236] = (*((unsigned __int16 *)a3 + 8) << 18) & 0x800000 | v10;
      break;
    case 5:
      v11 = ((unsigned __int8)a3[8] << 24) & 0x18000000
          | ((unsigned __int8)a3[4] << 24) & 0x4000000
          | ((unsigned __int8)*a3 << 24) & 0x3000000
          | v4 & 0xC0FFFFFF;
      *(_DWORD *)(v3 + 944) = v11;
      result = (_DWORD *)*result;
      result[236] = ((unsigned __int8)a3[16] << 24) & 0x20000000 | v11;
      break;
    case 6:
      v12 = a3[12] & 0xF | v6 & 0xFFFFFFF0;
      *(_DWORD *)(v3 + 948) = a3[8] & 0x18 | a3[4] & 4 | *a3 & 3 | v5 & 0xFFFFFFE0;
      result = (_DWORD *)*result;
      result[238] = v12;
      break;
    case 7:
      v13 = (*((_DWORD *)a3 + 3) << 6) & 0x3C0 | v6 & 0xFFFFFC3F;
      *(_DWORD *)(v3 + 948) = (*((_DWORD *)a3 + 2) << 6) & 0x600
                            | (*((_DWORD *)a3 + 1) << 6) & 0x100
                            | v5 & 0xFFFFF83F
                            | (unsigned __int8)(*a3 << 6);
      result = (_DWORD *)*result;
      result[238] = v13;
      break;
    case 8:
      v14 = (unsigned __int16)((unsigned __int16)*((_DWORD *)a3 + 3) << 12) | v6 & 0xFFFF0FFF;
      *(_DWORD *)(v3 + 948) = (*((_DWORD *)a3 + 2) << 12) & 0x18000
                            | (*((_DWORD *)a3 + 1) << 12) & 0x4000
                            | (*(_DWORD *)a3 << 12) & 0x3000
                            | v5 & 0xFFFE0FFF;
      result = (_DWORD *)*result;
      result[238] = v14;
      break;
    case 9:
      v15 = (*((unsigned __int16 *)a3 + 6) << 18) & 0x3C0000 | v6 & 0xFFC3FFFF;
      *(_DWORD *)(v3 + 948) = (*((unsigned __int16 *)a3 + 4) << 18) & 0x600000
                            | (*((unsigned __int16 *)a3 + 2) << 18) & 0x100000
                            | (*(unsigned __int16 *)a3 << 18) & 0xC0000
                            | v5 & 0xFF83FFFF;
      result = (_DWORD *)*result;
      result[238] = v15;
      break;
    case 10:
      v16 = ((unsigned __int8)a3[12] << 24) & 0xF000000 | v6 & 0xF0FFFFFF;
      *(_DWORD *)(v3 + 948) = ((unsigned __int8)a3[8] << 24) & 0x18000000
                            | ((unsigned __int8)a3[4] << 24) & 0x4000000
                            | ((unsigned __int8)*a3 << 24) & 0x3000000
                            | v5 & 0xE0FFFFFF;
      result = (_DWORD *)*result;
      result[238] = v16;
      break;
    default:
      return result;
  }
  return result;
}

//----- (08015DF4) --------------------------------------------------------
_DWORD *__fastcall sub_8015DF4(_DWORD *result, int a2)
{
  switch ( a2 )
  {
    case 0:
      result = (_DWORD *)*result;
      result[225] |= 2u;
      break;
    case 1:
      result = (_DWORD *)*result;
      result[225] |= 4u;
      break;
    case 2:
      result = (_DWORD *)*result;
      result[225] |= 8u;
      break;
    case 3:
      result = (_DWORD *)*result;
      result[225] |= 0x10u;
      break;
    case 4:
      result = (_DWORD *)*result;
      result[225] |= 0x20u;
      break;
    case 5:
      result = (_DWORD *)*result;
      result[225] |= 0x40u;
      break;
    case 6:
      result = (_DWORD *)*result;
      result[225] |= 1u;
      break;
    default:
      return result;
  }
  return result;
}

//----- (08015E74) --------------------------------------------------------
int __fastcall sub_8015E74(int *a1, _DWORD *a2)
{
  int result; // r0

  *(_DWORD *)*a1 = a2[3] | a2[2] & 0xFFFFFFE7 | *(_DWORD *)*a1 & 0xFFFFFFE0;
  *(_DWORD *)(*a1 + 20) = *a2;
  result = *a1;
  *(_DWORD *)(result + 24) = a2[1];
  return result;
}

//----- (08015E9A) --------------------------------------------------------
int __fastcall sub_8015E9A(int *a1, _DWORD *a2)
{
  int v2; // r6
  int v3; // r4
  unsigned int v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r1
  int result; // r0

  v2 = a2[5];
  if ( v2 == 32 || (v3 = a2[6], v3 == 2) )
  {
    v4 = v2 & 0xFFFFFF1F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x20;
  }
  else if ( v3 == 3 )
  {
    v4 = v2 & 0xFFFFFF3F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x40;
  }
  else if ( v3 == 4 )
  {
    v4 = v2 & 0xFFFFFF3F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x80;
  }
  else
  {
    v4 = v2 & 0xFFFFFF1F | *(_DWORD *)*a1 & 0xFFFFFF1F;
  }
  v5 = a2[13]
     | a2[10] & 0x1FFFFFFF
     | a2[9] & 0x17FFFFFF
     | a2[8] & 0x11FFFFFF
     | a2[7] & 0x11FFFBFF
     | v4 & 0x11FFF3FF
     | (4 * a2[11]) & 0xDFFFFFFF;
  v6 = a2[12] | *(_DWORD *)(*a1 + 928) & 0xFFFEFFFF;
  *(_DWORD *)*a1 = v5;
  result = *a1;
  *(_DWORD *)(result + 928) = v6;
  return result;
}

//----- (08015F2E) --------------------------------------------------------
int __fastcall sub_8015F2E(int *a1, int a2, int a3, _DWORD *a4)
{
  char v4; // r4
  int v5; // r5
  int v6; // r7
  int v7; // r12
  int v8; // r6
  int v9; // r2
  int v10; // r1
  int result; // r0

  v4 = 0;
  v5 = *a1;
  v6 = (a2 << 7) + 228;
  v7 = *(_DWORD *)(*a1 + v6);
  v8 = *(_DWORD *)(*a1 + (a2 << 7) + 184);
  if ( a3 == 64 )
    goto LABEL_20;
  if ( a3 > 64 )
  {
    if ( a3 == 512 )
      goto LABEL_21;
    if ( a3 > 512 )
    {
      if ( a3 == 1024 )
        goto LABEL_20;
      if ( a3 != 2048 )
        goto LABEL_22;
    }
    else if ( a3 != 128 )
    {
      if ( a3 == 256 )
        goto LABEL_20;
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if ( a3 == 8 )
    goto LABEL_21;
  if ( a3 > 8 )
  {
    if ( a3 == 16 )
      goto LABEL_20;
    if ( a3 != 32 )
      goto LABEL_22;
LABEL_21:
    *(_DWORD *)(v5 + (a2 << 7) + 196) = a4[1];
    *(_DWORD *)(*a1 + (a2 << 7) + 200) = a4[2];
    v4 = 16;
    goto LABEL_22;
  }
  switch ( a3 )
  {
    case 1:
LABEL_20:
      *(_DWORD *)(v5 + (a2 << 7) + 188) = a4[1];
      *(_DWORD *)(*a1 + (a2 << 7) + 192) = a4[2];
      break;
    case 2:
      goto LABEL_21;
    case 4:
      goto LABEL_20;
  }
LABEL_22:
  v9 = a4[4];
  v10 = (a4[6] << v4) | (a4[5] << v4) | (v9 << v4) | (a4[3] << v4) | (*a4 << v4) | v7 & ~(254 << v4);
  if ( v9 == 8 && (v8 & 0x200) == 0 && (v8 & 0x2000000) == 0 )
    v10 |= a4[7] << v4;
  result = *a1;
  *(_DWORD *)(result + v6) = v10;
  return result;
}

//----- (0801600C) --------------------------------------------------------
int __fastcall sub_801600C(int *a1, int a2, _DWORD *a3)
{
  int result; // r0

  *(_DWORD *)(*a1 + (a2 << 7) + 128) = a3[3] | a3[2] & 0xFFFFFFE7 | *(_DWORD *)(*a1 + (a2 << 7) + 128) & 0xFFFFFFE0;
  *(_DWORD *)(*a1 + (a2 << 7) + 148) = *a3;
  result = *a1;
  *(_DWORD *)(result + (a2 << 7) + 152) = a3[1];
  return result;
}

//----- (080161CC) --------------------------------------------------------
void __fastcall IRQ_71_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4
  int v14; // r5
  int v15; // r6
  int v16; // r7
  int v17; // r8
  int v18; // r11
  int v19; // r12
  int v20; // lr
  int v21; // r0
  int v22; // r3

  v21 = a1 << 14;
  v22 = a4 | (*(_DWORD *)(a3 + 48) << 6);
  *(_DWORD *)(v14 + v15) = v18;
  *(_DWORD *)(*(_DWORD *)v21 + v16) = v20;
  *(_DWORD *)(*(_DWORD *)v21 + v19) = v13;
  *(_DWORD *)(*(_DWORD *)v21 + (a2 << 7) + 212) = v17;
  *(_DWORD *)(*(_DWORD *)v21 + 928) = v22;
  __asm { POP.W           {R4-R11,PC} }
}
// 80161F6: unbalanced stack, ignored a potential tail call
// 80161D4: variable 'v18' is possibly undefined
// 80161D4: variable 'v14' is possibly undefined
// 80161D4: variable 'v15' is possibly undefined
// 80161DA: variable 'v20' is possibly undefined
// 80161DA: variable 'v16' is possibly undefined
// 80161E0: variable 'v13' is possibly undefined
// 80161E0: variable 'v19' is possibly undefined
// 80161EC: variable 'v17' is possibly undefined

//----- (08016200) --------------------------------------------------------
unsigned int __fastcall sub_8016200(int *a1, int a2, _DWORD *a3)
{
  int v3; // r3
  int v4; // r1
  unsigned int result; // r0

  v3 = *a1;
  v4 = (a2 << 7) + 236;
  result = a3[2]
         | a3[3] & 0xFFFDFFFF
         | a3[1] & 0xFFFCFFFF
         | *(_DWORD *)(*a1 + v4) & 0xFFECFFEF
         | (16 * *a3) & 0xFFECFFFF;
  if ( a3[6] == 1 )
    result = a3[5] & 0xFFFFFFFE | a3[4] & 0xFFFFFFFC | result & 0xFFFFFFF8 | 1;
  *(_DWORD *)(v3 + v4) = result;
  return result;
}

//----- (08016254) --------------------------------------------------------
int sub_8016254()
{
  int result; // r0

  result = 0;
  dword_2000004C = 0;
  return result;
}
// 2000004C: using guessed type int dword_2000004C;

//----- (08016260) --------------------------------------------------------
int sub_8016260()
{
  int result; // r0

  result = 2000;
  dword_2000004C = 2000;
  return result;
}
// 2000004C: using guessed type int dword_2000004C;

//----- (08016270) --------------------------------------------------------
int sub_8016270()
{
  byte_2000003C = 1;
  sub_8012B8A((int)&dword_2000183C, 768);
  return sub_8012B8A((int)&dword_2000183C, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 2000183C: using guessed type int dword_2000183C;

//----- (08016298) --------------------------------------------------------
int sub_8016298()
{
  byte_2000003D = 1;
  return sub_8012B8A((int)&dword_2000183C, 48);
}
// 2000003D: using guessed type char byte_2000003D;
// 2000183C: using guessed type int dword_2000183C;

//----- (080162B0) --------------------------------------------------------
int sub_80162B0()
{
  int v1; // [sp+4h] [bp-11Ch] BYREF
  int v2; // [sp+8h] [bp-118h]
  int v3; // [sp+Ch] [bp-114h]
  int v4; // [sp+10h] [bp-110h]
  int v5; // [sp+14h] [bp-10Ch]
  int v6; // [sp+18h] [bp-108h]
  int v7; // [sp+1Ch] [bp-104h]
  int v8; // [sp+20h] [bp-100h]
  _DWORD v9[9]; // [sp+24h] [bp-FCh] BYREF
  _DWORD v10[7]; // [sp+48h] [bp-D8h] BYREF
  _DWORD v11[3]; // [sp+64h] [bp-BCh] BYREF
  int v12; // [sp+70h] [bp-B0h] BYREF
  int v13; // [sp+74h] [bp-ACh]
  int v14; // [sp+78h] [bp-A8h]
  int v15; // [sp+7Ch] [bp-A4h]
  int v16; // [sp+80h] [bp-A0h]
  int v17; // [sp+84h] [bp-9Ch]
  int v18; // [sp+88h] [bp-98h]
  int v19; // [sp+8Ch] [bp-94h]
  int v20; // [sp+90h] [bp-90h]
  int v21; // [sp+94h] [bp-8Ch]
  int v22; // [sp+98h] [bp-88h]
  int v23; // [sp+9Ch] [bp-84h]
  int v24; // [sp+A0h] [bp-80h]
  int v25; // [sp+A4h] [bp-7Ch]
  int v26; // [sp+A8h] [bp-78h]
  int v27; // [sp+ACh] [bp-74h]
  int v28; // [sp+B0h] [bp-70h]
  int v29; // [sp+B4h] [bp-6Ch]
  int v30; // [sp+B8h] [bp-68h]
  int v31; // [sp+C0h] [bp-60h]
  int v32; // [sp+C4h] [bp-5Ch]
  int v33; // [sp+C8h] [bp-58h]
  int v34; // [sp+CCh] [bp-54h]
  int v35; // [sp+D0h] [bp-50h] BYREF
  int v36; // [sp+D4h] [bp-4Ch]
  int v37; // [sp+D8h] [bp-48h]
  int v38; // [sp+DCh] [bp-44h]
  int v39; // [sp+E0h] [bp-40h] BYREF
  int v40; // [sp+E4h] [bp-3Ch]
  int v41; // [sp+E8h] [bp-38h]
  int v42; // [sp+F0h] [bp-30h]
  int v43; // [sp+F4h] [bp-2Ch] BYREF
  int v44; // [sp+F8h] [bp-28h]

  v43 = 0;
  v44 = 0;
  sub_8002364(&v39, 20);
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  sub_8002364(&v12, 96);
  memset(v11, 0, sizeof(v11));
  sub_8002364(v10, 28);
  sub_8002364(v9, 36);
  sub_8002364(&v1, 32);
  dword_2000183C = 1073833984;
  dword_20001840 = 0;
  dword_20001844 = 0;
  sub_801278C((int)&dword_2000183C);
  sub_8012652(&dword_2000183C, 12);
  sub_8012930(&dword_2000183C, 0xAu);
  v35 = 45334;
  v36 = 0;
  v37 = 2;
  v38 = 8;
  sub_8012970((int)&dword_2000183C, 6, &v35);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 1;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0x8000000;
  v23 = 0;
  v24 = 0;
  v25 = 0x20000000;
  v34 = 0;
  sub_8012BEA((int)&dword_2000183C, 6, &v12);
  v41 = 0;
  v42 = 0;
  v40 = 4;
  v39 = 1;
  sub_8012754((int)&dword_2000183C, 2, &v39);
  v40 = 0;
  v39 = 1;
  sub_8012754((int)&dword_2000183C, 4, &v39);
  v11[0] = 50;
  sub_80129A4(&dword_2000183C, 6, 1, v11);
  v11[0] = 50;
  sub_80129A4(&dword_2000183C, 6, 2, v11);
  v43 = 0;
  v44 = 1;
  if ( sub_80123C0(&dword_2000183C, 1, &v43) )
    sub_80058BC();
  if ( sub_80122A4(&dword_2000183C, 1, 0) )
    sub_80058BC();
  v37 = 1;
  v38 = 8;
  sub_8012970((int)&dword_2000183C, 0, &v35);
  sub_8012970((int)&dword_2000183C, 1, &v35);
  v37 = 3;
  v35 = 6800;
  sub_8012970((int)&dword_2000183C, 3, &v35);
  v35 = 60000;
  sub_8012970((int)&dword_2000183C, 2, &v35);
  sub_8012970((int)&dword_2000183C, 4, &v35);
  sub_8012970((int)&dword_2000183C, 5, &v35);
  v10[0] = 1;
  v10[3] = 0;
  v10[6] = 0;
  sub_8012C80((int)&dword_2000183C, 0, v10);
  sub_8012C80((int)&dword_2000183C, 1, v10);
  v10[0] = 0;
  sub_8012C80((int)&dword_2000183C, 3, v10);
  sub_8012C80((int)&dword_2000183C, 2, v10);
  sub_8012C80((int)&dword_2000183C, 4, v10);
  sub_8012C80((int)&dword_2000183C, 5, v10);
  v12 = 0;
  v13 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v22 = 0x8000000;
  v33 = 0x40000;
  v25 = 0x20000000;
  v32 = 32;
  sub_8012BEA((int)&dword_2000183C, 0, &v12);
  v32 = 64;
  sub_8012BEA((int)&dword_2000183C, 1, &v12);
  v12 = 1;
  v32 = 0;
  sub_8012BEA((int)&dword_2000183C, 3, &v12);
  v29 = 0;
  v12 = 0;
  v32 = 0x2000000;
  sub_8012BEA((int)&dword_2000183C, 2, &v12);
  v32 = 0x10000000;
  sub_8012BEA((int)&dword_2000183C, 4, &v12);
  v32 = 0x10000000;
  sub_8012BEA((int)&dword_2000183C, 5, &v12);
  v11[0] = 23007;
  sub_80129A4(&dword_2000183C, 0, 1, v11);
  v11[0] = 22327;
  sub_80129A4(&dword_2000183C, 0, 2, v11);
  v11[0] = 23007;
  sub_80129A4(&dword_2000183C, 1, 1, v11);
  v11[0] = 22327;
  sub_80129A4(&dword_2000183C, 1, 2, v11);
  v11[0] = 2000;
  sub_80129A4(&dword_2000183C, 3, 1, v11);
  v11[0] = 340;
  sub_80129A4(&dword_2000183C, 2, 1, v11);
  sub_80129A4(&dword_2000183C, 4, 1, v11);
  sub_80129A4(&dword_2000183C, 5, 1, v11);
  v11[0] = (unsigned int)dword_20000040 >> 1;
  sub_80129A4(&dword_2000183C, 2, 2, v11);
  sub_80129A4(&dword_2000183C, 4, 2, v11);
  sub_80129A4(&dword_2000183C, 5, 2, v11);
  v11[0] = 1500;
  sub_80129A4(&dword_2000183C, 2, 4, v11);
  sub_80129A4(&dword_2000183C, 4, 4, v11);
  sub_80129A4(&dword_2000183C, 5, 4, v11);
  v11[0] = 4900;
  sub_80129A4(&dword_2000183C, 2, 8, v11);
  sub_80129A4(&dword_2000183C, 4, 8, v11);
  sub_80129A4(&dword_2000183C, 5, 8, v11);
  v9[0] = 3072;
  v9[1] = 85;
  memset(&v9[2], 0, 12);
  v9[5] = 85;
  memset(&v9[6], 0, 12);
  sub_80126C4((int)&dword_2000183C, 0, (int)v9);
  sub_80126C4((int)&dword_2000183C, 1, (int)v9);
  v1 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v2 = 8;
  v3 = 20971520;
  sub_8012B52((int)&dword_2000183C, 0, 1, &v1);
  v2 = 0;
  v3 = 20971536;
  sub_8012B52((int)&dword_2000183C, 0, 2, &v1);
  v2 = 8;
  v3 = 20971520;
  sub_8012B52((int)&dword_2000183C, 1, 4, &v1);
  v2 = 0;
  v3 = 20971536;
  sub_8012B52((int)&dword_2000183C, 1, 8, &v1);
  v4 = 4;
  v2 = 8;
  v3 = 32;
  sub_8012B52((int)&dword_2000183C, 2, 16, &v1);
  v2 = 16;
  v3 = 64;
  sub_8012B52((int)&dword_2000183C, 2, 32, &v1);
  v2 = 8;
  v3 = 32;
  sub_8012B52((int)&dword_2000183C, 4, 256, &v1);
  sub_8012B52((int)&dword_2000183C, 5, 1024, &v1);
  v2 = 16;
  v3 = 64;
  sub_8012B52((int)&dword_2000183C, 4, 512, &v1);
  sub_8012B52((int)&dword_2000183C, 5, 2048, &v1);
  sub_801286C((int **)&dword_2000183C);
  sub_8012612((int)&dword_2000183C, 1);
  sub_8012B26((int)&dword_2000183C, 8323072);
  *(_DWORD *)(dword_2000183C + 524) |= 1u;
  sub_80132C0(71, 1u, 0);
  return sub_80132A4(71);
}
// 20000040: using guessed type int dword_20000040;
// 2000183C: using guessed type int dword_2000183C;
// 20001840: using guessed type int dword_20001840;
// 20001844: using guessed type int dword_20001844;

//----- (08016714) --------------------------------------------------------
char *sub_8016714()
{
  char *result; // r0

  sub_8012BBA((int)&dword_2000183C, 48);
  sub_8012BBA((int)&dword_2000183C, 768);
  sub_8012BBA((int)&dword_2000183C, 3072);
  result = &byte_2000003C;
  byte_2000003D = 0;
  byte_2000003C = 0;
  return result;
}
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 2000183C: using guessed type int dword_2000183C;

//----- (080167E4) --------------------------------------------------------
int sub_80167E4()
{
  byte_2000003C = 2;
  sub_8012B8A((int)&dword_2000183C, 768);
  return sub_8012B8A((int)&dword_2000183C, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 2000183C: using guessed type int dword_2000183C;

//----- (0801680C) --------------------------------------------------------
int sub_801680C()
{
  byte_2000003D = 2;
  return sub_8012B8A((int)&dword_2000183C, 48);
}
// 2000003D: using guessed type char byte_2000003D;
// 2000183C: using guessed type int dword_2000183C;

//----- (08016824) --------------------------------------------------------
unsigned int __fastcall sub_8016824(unsigned int result)
{
  if ( result <= 0x2BC )
    dword_20000048 = result;
  else
    dword_20000048 = 700;
  return result;
}
// 20000048: using guessed type int dword_20000048;

//----- (0801683C) --------------------------------------------------------
int sub_801683C()
{
  byte_2000003D = 3;
  return sub_8012B8A((int)&dword_2000183C, 48);
}
// 2000003D: using guessed type char byte_2000003D;
// 2000183C: using guessed type int dword_2000183C;

//----- (08016854) --------------------------------------------------------
int sub_8016854()
{
  byte_2000003D = 0;
  return sub_8012BBA((int)&dword_2000183C, 48);
}
// 2000003D: using guessed type char byte_2000003D;
// 2000183C: using guessed type int dword_2000183C;

//----- (0801686C) --------------------------------------------------------
int sub_801686C()
{
  byte_2000003C = 3;
  sub_8012B8A((int)&dword_2000183C, 768);
  return sub_8012B8A((int)&dword_2000183C, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 2000183C: using guessed type int dword_2000183C;

//----- (08016894) --------------------------------------------------------
int sub_8016894()
{
  int result; // r0

  sub_8012BBA((int)&dword_2000183C, 768);
  sub_8012BBA((int)&dword_2000183C, 3072);
  result = 0;
  byte_2000003C = 0;
  return result;
}
// 2000003C: using guessed type char byte_2000003C;
// 2000183C: using guessed type int dword_2000183C;

//----- (080168BC) --------------------------------------------------------
int sub_80168BC()
{
  sub_8012B8A((int)&dword_2000183C, 3);
  return sub_8012B8A((int)&dword_2000183C, 12);
}
// 2000183C: using guessed type int dword_2000183C;

//----- (080168D8) --------------------------------------------------------
int sub_80168D8()
{
  return *(_DWORD *)(dword_2000183C + 916) & 1;
}
// 2000183C: using guessed type int dword_2000183C;

//----- (080168EC) --------------------------------------------------------
int sub_80168EC()
{
  sub_8012BBA((int)&dword_2000183C, 3);
  return sub_8012BBA((int)&dword_2000183C, 12);
}
// 2000183C: using guessed type int dword_2000183C;

//----- (08016908) --------------------------------------------------------
int __fastcall I2C_Flush_TXDR(int *a1)
{
  int result; // r0

  if ( (~*(_DWORD *)(*a1 + 24) & 2) == 0 )
    *(_DWORD *)(*a1 + 40) = 0;
  result = *a1;
  if ( ~*(_DWORD *)(result + 24) << 31 )
    *(_DWORD *)(result + 24) |= 1u;
  return result;
}

//----- (0801692C) --------------------------------------------------------
int __fastcall sub_801692C(int *a1, unsigned int a2, int a3)
{
  int v6; // r5
  int v7; // r0
  int v8; // r6
  int v9; // r0

  v6 = 0;
  v7 = *a1;
  v8 = 0;
  if ( (*(_DWORD *)(v7 + 24) & 0x10) != 0 )
  {
    *(_DWORD *)(v7 + 28) = 16;
    while ( !((*(_DWORD *)(*a1 + 24) >> 5) & 1 | v6) )
    {
      if ( a2 != -1 && (sub_8012298() - a3 > a2 || !a2) )
      {
        if ( (~*(_DWORD *)(*a1 + 24) & 0x8000) == 0
          && (*(_DWORD *)(*a1 + 4) & 0x4000) != 0x4000
          && *((_BYTE *)a1 + 66) != 32 )
        {
          *(_DWORD *)(*a1 + 4) |= 0x4000u;
          a3 = sub_8012298();
        }
        while ( (~*(_DWORD *)(*a1 + 24) & 0x20) != 0 )
        {
          if ( (unsigned int)(sub_8012298() - a3) > 0x19 )
          {
            a1[17] |= 0x20u;
            *((_BYTE *)a1 + 65) = 32;
            *((_BYTE *)a1 + 66) = 0;
            *((_BYTE *)a1 + 64) = 0;
            v6 = 1;
          }
        }
      }
    }
    if ( !v6 )
      *(_DWORD *)(*a1 + 28) = 32;
    v8 = 4;
    v6 = 1;
  }
  v9 = *(_DWORD *)(*a1 + 24);
  if ( (v9 & 0x100) != 0 )
  {
    v8 |= 1u;
    *(_DWORD *)(*a1 + 28) = 256;
    v6 = 1;
  }
  if ( (v9 & 0x400) != 0 )
  {
    v8 |= 8u;
    *(_DWORD *)(*a1 + 28) = 1024;
    v6 = 1;
  }
  if ( (v9 & 0x200) != 0 )
  {
    v8 |= 2u;
    *(_DWORD *)(*a1 + 28) = 512;
    v6 = 1;
  }
  if ( v6 )
  {
    I2C_Flush_TXDR(a1);
    *(_DWORD *)(*a1 + 4) &= 0xFE00E800;
    a1[17] |= v8;
    *((_BYTE *)a1 + 65) = 32;
    *((_BYTE *)a1 + 66) = 0;
    *((_BYTE *)a1 + 64) = 0;
  }
  return v6;
}

//----- (08016A3C) --------------------------------------------------------
int __fastcall sub_8016A3C(int a1, __int16 a2, int a3, int a4, int a5)
{
  return HardFault_handler(a1, a2 & 0x3FF | (a3 << 16) & 0x7FFFFFFF | a4 & 0x7FFFFFFF | a5 & 0x7FFFFFFF);
}
// 8016A50: using guessed type int __fastcall HardFault_handler(_DWORD, _DWORD);

//----- (08016A50) --------------------------------------------------------
void __fastcall HardFault_handler(int a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // r4

  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)(*(_DWORD *)a1 + 4) & ~((v6 >> 21) & 0x400 | 0x3FF63FF) | a2;
  __asm { POP             {R4,PC} }
}
// 8016A66: unbalanced stack, ignored a potential tail call
// 8016A58: variable 'v6' is possibly undefined

//----- (08016A6C) --------------------------------------------------------
int __fastcall sub_8016A6C(int a1, int a2, int a3, unsigned int a4, int a5)
{
  int v10; // r4

  do
  {
    if ( ((a2 & ~*(_DWORD *)(*(_DWORD *)a1 + 24)) == 0) != a3 )
      return 0;
  }
  while ( a4 == -1 || sub_8012298() - a5 <= a4 && a4 );
  v10 = a1 + 64;
  *(_DWORD *)(v10 + 4) |= 0x20u;
  *(_BYTE *)(v10 + 1) = 32;
  *(_BYTE *)(v10 + 2) = 0;
  *(_BYTE *)v10 = 0;
  return 1;
}

//----- (08016AC4) --------------------------------------------------------
int __fastcall sub_8016AC4(int a1, unsigned int a2, int a3)
{
  int v7; // r0

  while ( 1 )
  {
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 4) == 0 )
      return 0;
    if ( sub_801692C((int *)a1, a2, a3) )
      return 1;
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x20) == 0 )
      break;
    if ( sub_8012298() - a3 > a2 || !a2 )
    {
      *(_DWORD *)(a1 + 68) |= 0x20u;
      *(_BYTE *)(a1 + 65) = 32;
      *(_BYTE *)(a1 + 64) = 0;
      return 1;
    }
  }
  v7 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 4) == 0 && *(_WORD *)(a1 + 40) )
    return 0;
  if ( (~*(_DWORD *)(v7 + 24) & 0x10) != 0 )
  {
    *(_DWORD *)(a1 + 68) = 0;
  }
  else
  {
    *(_DWORD *)(v7 + 28) = 16;
    *(_DWORD *)(a1 + 68) = 4;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 1;
}

//----- (08016B6C) --------------------------------------------------------
int __fastcall sub_8016B6C(int *a1, unsigned int a2, int a3)
{
  int *v7; // r4

  do
  {
    if ( (~*(_DWORD *)(*a1 + 24) & 0x20) == 0 )
      return 0;
    if ( sub_801692C(a1, a2, a3) )
      return 1;
  }
  while ( sub_8012298() - a3 <= a2 && a2 );
  v7 = a1 + 16;
  v7[1] |= 0x20u;
  *((_BYTE *)v7 + 1) = 32;
  *((_BYTE *)v7 + 2) = 0;
  *(_BYTE *)v7 = 0;
  return 1;
}

//----- (08016BB8) --------------------------------------------------------
int __fastcall sub_8016BB8(int *a1, unsigned int a2, int a3)
{
  int *v7; // r4

  do
  {
    if ( (~*(_DWORD *)(*a1 + 24) & 2) == 0 )
      return 0;
    if ( sub_801692C(a1, a2, a3) )
      return 1;
  }
  while ( a2 == -1 || sub_8012298() - a3 <= a2 && a2 );
  v7 = a1 + 16;
  v7[1] |= 0x20u;
  *((_BYTE *)v7 + 1) = 32;
  *((_BYTE *)v7 + 2) = 0;
  *(_BYTE *)v7 = 0;
  return 1;
}

//----- (08016C08) --------------------------------------------------------
int sub_8016C08()
{
  int result; // r0

  dword_20002164 = 1073763328;
  dword_20002168 = 809542655;
  dword_2000216C = 0;
  dword_20002170 = 1;
  dword_20002174 = 0;
  dword_20002178 = 0;
  dword_2000217C = 0;
  dword_20002180 = 0;
  dword_20002184 = 0;
  if ( sub_8012D74((int)&dword_20002164) )
    sub_80058BC();
  if ( sub_8012CC4((int)&dword_20002164, 0) )
    sub_80058BC();
  result = sub_8012D1E((int)&dword_20002164, 0);
  if ( result )
    sub_80058BC();
  return result;
}
// 20002164: using guessed type int dword_20002164;
// 20002168: using guessed type int dword_20002168;
// 2000216C: using guessed type int dword_2000216C;
// 20002170: using guessed type int dword_20002170;
// 20002174: using guessed type int dword_20002174;
// 20002178: using guessed type int dword_20002178;
// 2000217C: using guessed type int dword_2000217C;
// 20002180: using guessed type int dword_20002180;
// 20002184: using guessed type int dword_20002184;

//----- (08016C60) --------------------------------------------------------
int __fastcall sub_8016C60(int result, unsigned int a2)
{
  unsigned int v2; // r3
  int v3; // r2
  int v4; // r5
  unsigned int v5; // r4
  int v6; // r12

  v2 = 1000000000;
  v3 = 0;
  v4 = 0;
  LOBYTE(v5) = 0;
  do
  {
    v6 = v3++;
    *(_BYTE *)(result + v6) = a2 / v2 + 48;
    a2 %= v2;
    v2 /= 0xAu;
    if ( *(_BYTE *)(result + v3 - 1) == 48 && !v4 )
      v3 = 0;
    else
      ++v4;
    v5 = (unsigned __int8)(v5 + 1);
  }
  while ( v5 < 0xA );
  return result;
}

//----- (08016CA8) --------------------------------------------------------
int __fastcall sub_8016CA8(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 96) & 0x7C000000;
}

//----- (08016CB4) --------------------------------------------------------
int __fastcall sub_8016CB4(int a1)
{
  return (*(_DWORD *)(a1 + 8) >> 3) & 1;
}

//----- (08016CBC) --------------------------------------------------------
int __fastcall sub_8016CBC(int a1)
{
  return *(_DWORD *)(a1 + 8) & 1;
}

//----- (08016CC4) --------------------------------------------------------
int __fastcall sub_8016CC4(int a1)
{
  return (*(_DWORD *)(a1 + 8) >> 2) & 1;
}

//----- (08016CCC) --------------------------------------------------------
BOOL __fastcall sub_8016CCC(int a1)
{
  return (*(_DWORD *)(a1 + 12) & 0xC00) == 0;
}

//----- (08016CDC) --------------------------------------------------------
int __fastcall sub_8016CDC(int a1, unsigned int a2, int a3)
{
  int result; // r0

  result = a1 + ((a2 & 0x2000000) >> 23);
  *(_DWORD *)(result + 20) = *(_DWORD *)(result + 20) & ~(7 << ((a2 >> 20) & 0x1F)) | (a3 << ((a2 >> 20) & 0x1F));
  return result;
}

//----- (08016CFA) --------------------------------------------------------
int __fastcall sub_8016CFA(int a1, int a2, int a3)
{
  int result; // r0

  result = a1 + 4 * a2;
  *(_DWORD *)(result + 96) = *(_DWORD *)(result + 96) & 0x7FFFFFFF | a3;
  return result;
}

//----- (08016D0C) --------------------------------------------------------
int sub_8016D0C()
{
  int result; // r0

  result = 1073774592;
  if ( (MEMORY[0x4000801C] & 0x20) != 0 )
    return sub_800D184(MEMORY[0x40008024]);
  if ( (MEMORY[0x4000801C] & 8) != 0 )
  {
    MEMORY[0x40008020] = 8;
  }
  else if ( (MEMORY[0x4000801C] & 2) != 0 )
  {
    MEMORY[0x40008020] = 2;
  }
  else if ( (MEMORY[0x4000801C] & 4) != 0 )
  {
    MEMORY[0x40008020] = 4;
  }
  else if ( (MEMORY[0x4000801C] & 8) != 0 )
  {
    MEMORY[0x40008020] = 8;
  }
  else if ( (MEMORY[0x4000801C] & 0x800) != 0 )
  {
    MEMORY[0x40008020] = 2048;
  }
  return result;
}

//----- (08016D24) --------------------------------------------------------
int __fastcall sub_8016D24(char a1)
{
  int result; // r0

  byte_200004D0 = a1;
  byte_200004D1 = byte_200050ED;
  result = (unsigned __int8)byte_200050EE;
  byte_200004D2 = byte_200050EE;
  return result;
}
// 200004D0: using guessed type char byte_200004D0;
// 200004D1: using guessed type char byte_200004D1;
// 200004D2: using guessed type char byte_200004D2;
// 200050ED: using guessed type char byte_200050ED;
// 200050EE: using guessed type char byte_200050EE;

//----- (08016D3C) --------------------------------------------------------
int sub_8016D3C()
{
  int result; // r0
  unsigned __int8 v1[144]; // [sp+0h] [bp-90h] BYREF

  byte_200015D4 = 0;
  byte_200015E4 = 0;
  byte_200015D5 = 0;
  byte_200015DA = 0;
  byte_200015DB = 0;
  sub_8002364(v1, 128);
  byte_200015D9 = 0;
  word_20011072 = 12345;
  if ( (unsigned __int8)byte_200015E7 != 255 )
  {
    sprintf((int)v1, "AT+QICLOSE=%d\r\n", (unsigned __int8)byte_200015E7);
    sub_800E2B0(v1, "OK", 0, 400);
    byte_200015E7 = -1;
  }
  result = (unsigned __int8)byte_200015E6;
  if ( (unsigned __int8)byte_200015E6 != 255 )
  {
    sub_80232B4(3000);
    sub_8002364(v1, 128);
    sprintf((int)v1, "AT+QICLOSE=%d\r\n", (unsigned __int8)byte_200015E6);
    result = sub_800E2B0(v1, "OK", 0, 400);
    byte_200015E6 = -1;
  }
  return result;
}
// 200015D4: using guessed type char byte_200015D4;
// 200015D5: using guessed type char byte_200015D5;
// 200015D9: using guessed type char byte_200015D9;
// 200015DA: using guessed type char byte_200015DA;
// 200015DB: using guessed type char byte_200015DB;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 20011072: using guessed type __int16 word_20011072;

//----- (08016E38) --------------------------------------------------------
unsigned int sub_8016E38()
{
  unsigned int result; // r0

  result = dword_20000470;
  if ( dword_20000470 != dword_20000468 )
  {
    sub_8016E90(&dword_200028EC[5 * dword_20000470]);
    result = dword_20000470 + 1;
    dword_20000470 = result;
    if ( result >= 0x32 )
    {
      result = 0;
      dword_20000470 = 0;
    }
  }
  return result;
}
// 8016E90: using guessed type int __fastcall sub_8016E90(_DWORD);
// 20000468: using guessed type int dword_20000468;
// 20000470: using guessed type int dword_20000470;
// 200028EC: using guessed type _DWORD dword_200028EC[250];

//----- (08016E6C) --------------------------------------------------------
_DWORD *sub_8016E6C()
{
  int i; // r4
  _DWORD *result; // r0

  for ( i = 0; i < 50; ++i )
  {
    result = &dword_200028EC[5 * i];
    if ( !result[1] )
      break;
    result = (_DWORD *)sub_8016E90();
  }
  return result;
}
// 8016E90: using guessed type int sub_8016E90(void);
// 200028EC: using guessed type _DWORD dword_200028EC[250];

//----- (08016E90) --------------------------------------------------------
#error "8017882: call analysis failed (funcsize=533)"

//----- (0801750C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
int __fastcall IRQ_91_handler(int a1, int a2, int a3, int a4)
{
  int v5; // r2
  unsigned int v6; // r4
  int v7; // r5
  int v8; // r6
  char v9; // r7
  unsigned int v10; // r10
  int v11; // r1 OVERLAPPED
  int v12; // r5
  double v14; // [sp-24h] [bp-24h]

  v11 = a2 * a1;
  *(_BYTE *)(a4 + 9) = v9;
  *(_BYTE *)(v7 + 13) = v7;
  v12 = v7 + 5;
  *(_DWORD *)(v12 + 48) = v6;
  *(_BYTE *)(v12 + 21) = v9;
  *(_BYTE *)(v12 + 17) = v8;
  *(_DWORD *)(v6 + 96) = 102;
  *(_BYTE *)(v6 + 5) = 32;
  STACK[0x374] = v6;
  STACK[0x374] = v6;
  __strex(v10, (unsigned int *)(a4 + 756));
  __ldrex((unsigned int *)a4);
  if ( v8 )
    return sub_8016D3C();
  v5 = 61;
  sub_801E1B0((int)"    data1 =  %6.3f | data2 =  %6.3f | data3 = %6.3f ", *(double *)&v11, *(double *)&a4, v14);
  return sub_801E1B0((int)"\r\n");
}
// 8017CCA: positive sp value 28 has been found
// 801750C: could not find valid save-restore pair for r8
// 801750C: variables would overlap: r1.4 and r1.8
// 801750C: fragmented variable at r3.4 may be wrong

//----- (08017540) --------------------------------------------------------
void sub_8017540()
{
  JUMPOUT(0x801705E);
}
// 8017544: control flows out of bounds to 801705E

//----- (08017D28) --------------------------------------------------------
float *__fastcall sub_8017D28(int a1)
{
  int j; // r4
  int v2; // r0
  float *result; // r0
  int v4; // r4
  int v5; // r0
  int i; // r4
  int v7; // r0

  if ( a1 == 1 )
  {
    v4 = 0;
    while ( 1 )
    {
      v5 = dword_2000046C + 2 * v4;
      if ( v5 >= 30 )
        v5 -= 30;
      result = (float *)((char *)&unk_20002CD4 + 4 * v5);
      if ( *result == 0.0 )
        break;
      sub_801E1B0((int)"%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*result)), *result);
      if ( ++v4 >= 15 )
      {
        for ( i = 0; i < 15; ++i )
        {
          v7 = dword_2000046C + 2 * i + 1;
          if ( v7 >= 30 )
            v7 = dword_2000046C + 2 * i - 29;
          result = (float *)((char *)&unk_20002CD4 + 4 * v7);
          if ( *result == 0.0 )
            break;
          result = (float *)sub_801E1B0((int)"%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*result)), *result);
        }
        return result;
      }
    }
  }
  else
  {
    for ( j = 0; j < 30; ++j )
    {
      v2 = dword_2000046C + j;
      if ( dword_2000046C + j >= 30 )
        v2 -= 30;
      result = (float *)((char *)&unk_20002CD4 + 4 * v2);
      if ( *result == 0.0 )
        break;
      result = (float *)sub_801E1B0((int)"%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*result)), *result);
    }
  }
  return result;
}
// 2000046C: using guessed type int dword_2000046C;

//----- (08017DFC) --------------------------------------------------------
_DWORD *__fastcall sub_8017DFC(int a1, int a2, int a3, int a4)
{
  int v7; // r0
  int v8; // r4
  int v9; // r1
  _DWORD *result; // r0

  dword_200028EC[5 * dword_20000468 + 1] = a1;
  v7 = sub_8012298();
  v8 = dword_20000468;
  v9 = 5 * dword_20000468;
  dword_200028EC[5 * dword_20000468] = v7;
  result = &dword_200028EC[v9];
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  dword_20000468 = v8 + 1;
  if ( (unsigned int)(v8 + 1) >= 0x32 )
  {
    result = 0;
    dword_20000468 = 0;
  }
  return result;
}
// 20000468: using guessed type int dword_20000468;
// 200028EC: using guessed type _DWORD dword_200028EC[250];

//----- (08017E4C) --------------------------------------------------------
int sub_8017E4C()
{
  dword_200017AC = 1073774592;
  dword_200017B0 = 115200;
  dword_200017B4 = 0;
  dword_200017B8 = 0;
  dword_200017BC = 0;
  dword_200017C4 = 0;
  dword_200017C0 = 12;
  dword_200017C8 = 0;
  sub_8015638((int)&dword_200017AC);
  sub_80151F2((int)&dword_200017AC, 0);
  sub_80151A6((int)&dword_200017AC, 0);
  sub_801515A((int)&dword_200017AC);
  return sub_80157DC((int)&dword_200017AC, (int)&byte_20000032, 1u);
}
// 20000032: using guessed type char byte_20000032;
// 200017AC: using guessed type int dword_200017AC;
// 200017B0: using guessed type int dword_200017B0;
// 200017B4: using guessed type int dword_200017B4;
// 200017B8: using guessed type int dword_200017B8;
// 200017BC: using guessed type int dword_200017BC;
// 200017C0: using guessed type int dword_200017C0;
// 200017C4: using guessed type int dword_200017C4;
// 200017C8: using guessed type int dword_200017C8;

//----- (08017EA2) --------------------------------------------------------
unsigned int __fastcall sub_8017EA2(int a1, unsigned int a2)
{
  unsigned int result; // r0
  unsigned int i; // r3
  unsigned int v5; // r2

  result = 0xFFFF;
  for ( i = 0; i < a2; i = (unsigned __int16)(i + 1) )
  {
    result ^= *(unsigned __int8 *)(a1 + i);
    LOBYTE(v5) = 0;
    do
    {
      if ( result << 31 )
        result = (result >> 1) ^ 0xA001;
      else
        result >>= 1;
      v5 = (unsigned __int8)(v5 + 1);
    }
    while ( v5 < 8 );
  }
  return result;
}

//----- (08017ED8) --------------------------------------------------------
int sub_8017ED8()
{
  unsigned int v0; // r0
  int v1; // r1
  int v2; // r2

  if ( sub_8024E28(dword_2000044C, (unsigned int)&dword_20000524, 10000) == 1 )
  {
    if ( !dword_20000524 )
      dword_20000524 = 256;
    if ( (unsigned int)(dword_20000524 - 4) <= 0xFC )
    {
      v0 = sub_8017EA2((int)byte_2000303A, (unsigned __int16)(dword_20000524 - 2));
      word_2000051C = v0;
      v1 = dword_20000524;
      v2 = (unsigned __int8)byte_2000303A[v1 - 2] | ((unsigned __int8)byte_2000303A[v1 - 1] << 8);
      word_2000051E = (unsigned __int8)byte_2000303A[v1 - 2] | ((unsigned __int8)byte_2000303A[v1 - 1] << 8);
      if ( v0 == v2 )
      {
        if ( byte_2000050D == byte_2000303A[0] )
        {
          byte_20002F3A[0] = byte_2000050D;
          byte_20002F3B = byte_2000303B;
          switch ( byte_2000303B )
          {
            case 3:
              byte_20000518 = sub_8018BA8(byte_2000303C, dword_20000524);
              break;
            case 6:
              byte_20000518 = sub_8018C90(byte_2000303C, dword_20000524);
              break;
            case 16:
              byte_20000518 = sub_8018D24(byte_2000303C, dword_20000524, 16, (int)byte_2000303A);
              break;
            default:
              byte_20000518 = 1;
              break;
          }
          if ( byte_20000518 )
          {
            byte_20002F3B += 0x80;
            byte_20002F3C = byte_20000518;
            word_2000051C = sub_8017EA2((int)byte_20002F3A, 3u);
            word_20002F3D = word_2000051C;
            sub_801CEAC((int)byte_20002F3A, 5u);
          }
        }
        else if ( !byte_2000303A[0] )
        {
          if ( byte_2000303B == 6 )
          {
            byte_20000518 = sub_8018CF4(byte_2000303C, dword_20000524);
          }
          else if ( byte_2000303B == 16 )
          {
            byte_20000518 = sub_8018DFC((int)byte_2000303C, dword_20000524, 16, (int)byte_2000303A);
          }
        }
      }
    }
  }
  sub_8002364(byte_2000303A, 256);
  return sub_801ECDC();
}
// 2000044C: using guessed type int dword_2000044C;
// 2000050D: using guessed type char byte_2000050D;
// 20000518: using guessed type char byte_20000518;
// 2000051C: using guessed type __int16 word_2000051C;
// 2000051E: using guessed type __int16 word_2000051E;
// 20000524: using guessed type int dword_20000524;
// 20002F3B: using guessed type char byte_20002F3B;
// 20002F3C: using guessed type char byte_20002F3C;
// 20002F3D: using guessed type __int16 word_20002F3D;
// 2000303B: using guessed type char byte_2000303B;
// 2000303C: using guessed type unsigned __int8 byte_2000303C[254];

//----- (08017FE4) --------------------------------------------------------
int sub_8017FE4()
{
  sub_8015244((int)&dword_2000171C);
  return sub_8024BE4(*loc_8018008, *(unsigned int *)sub_8018004, 0, 0);
}
// 2000171C: using guessed type int dword_2000171C;

//----- (08018004) --------------------------------------------------------
int sub_8018004()
{
  return 0;
}

//----- (08018010) --------------------------------------------------------
BOOL __fastcall sub_8018010(unsigned int a1)
{
  return (a1 >= 0x14 || (int)flt_20002440 > 1) && a1 >= 0xA;
}
// 20002440: using guessed type float flt_20002440;

//----- (0801803C) --------------------------------------------------------
char *__fastcall sub_801803C(char *result)
{
  __int64 v1; // r4
  unsigned int v2; // r3
  int v3; // r2

  LODWORD(v1) = result;
  if ( result )
  {
    HIDWORD(v1) = (unsigned __int16)((unsigned __int8)result[2] + ((unsigned __int8)result[1] << 8));
    result = (char *)sub_8004934(result, HIDWORD(v1));
    if ( result )
    {
      result = byte_200036AC;
      byte_200036AF = 1;
      word_200036B7 = 0;
      v3 = *(unsigned __int8 *)(v1 + 3);
      if ( v3 == 80 )
      {
        return sub_801C8E0((_BYTE *)v1, SHIDWORD(v1), 80, v2);
      }
      else if ( *(unsigned __int8 *)(v1 + 3) > 0x50u )
      {
        if ( v3 == 81 )
        {
          return sub_801C98C((_BYTE *)v1, SHIDWORD(v1), 81, v2);
        }
        else if ( v3 == 82 )
        {
          return sub_801C7C0((_BYTE *)v1);
        }
      }
      else if ( v3 == 35 )
      {
        return sub_801C958((_BYTE *)v1, SHIDWORD(v1), 35, v2);
      }
      else if ( v3 == 58 )
      {
        return (char *)sub_801C864(v1, 58, v2);
      }
    }
  }
  return result;
}
// 801807E: variable 'v2' is possibly undefined
// 200036AF: using guessed type char byte_200036AF;
// 200036B7: using guessed type __int16 word_200036B7;

//----- (080180C0) --------------------------------------------------------
int *__fastcall sub_80180C0(int *result, int a2, unsigned int a3, int a4)
{
  unsigned int i; // r4

  if ( result && a2 )
  {
    for ( i = 0; i < a3; ++i )
      *result += *(unsigned __int8 *)(a2 + i);
    if ( a4 )
      *result = ~*result;
  }
  return result;
}

//----- (080180E8) --------------------------------------------------------
int __fastcall sub_80180E8(_WORD *a1, unsigned int a2)
{
  if ( !*a1 )
    *a1 = word_20000028;
  if ( (unsigned __int16)(word_20000028 - *a1) < a2 )
    return 0;
  *a1 = word_20000028;
  return 1;
}
// 20000028: using guessed type __int16 word_20000028;

//----- (08018114) --------------------------------------------------------
int __fastcall sub_8018114(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( word_2000008A[0] <= result && word_20000170 >= result )
  {
    v1 = 58;
    v2 = 58;
    v3 = 0;
    while ( 1 )
    {
      v2 /= 2;
      if ( !v2 )
        break;
      if ( word_2000008A[v1] >= result )
        v1 -= v2;
      else
        v1 += v2;
      if ( ++v3 >= 116 )
        return result;
    }
    return word_2000008A[v1 + 1] - word_2000008A[v1];
  }
  return result;
}
// 2000008A: using guessed type __int16 word_2000008A[115];
// 20000170: using guessed type __int16 word_20000170;

//----- (080181A0) --------------------------------------------------------
int __fastcall sub_80181A0(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( word_20000172[0] <= result && word_20000258 >= result )
  {
    v1 = 58;
    v2 = 58;
    v3 = 0;
    while ( 1 )
    {
      v2 /= 2;
      if ( !v2 )
        break;
      if ( word_20000172[v1] >= result )
        v1 -= v2;
      else
        v1 += v2;
      if ( ++v3 >= 116 )
        return result;
    }
    return word_20000172[v1 + 1] - word_20000172[v1];
  }
  return result;
}
// 20000172: using guessed type __int16 word_20000172[115];
// 20000258: using guessed type __int16 word_20000258;

//----- (0801822C) --------------------------------------------------------
_BYTE *__fastcall sub_801822C(_BYTE *result, unsigned int a2, unsigned int a3)
{
  unsigned __int8 v3; // r7
  int v6; // r4
  unsigned __int8 v7[5]; // [sp+4h] [bp-114h] BYREF
  _BYTE v8[3]; // [sp+9h] [bp-10Fh] BYREF

  v3 = (unsigned __int8)result;
  if ( a2 )
  {
    sub_8002364(v7, 256);
    v6 = (unsigned __int16)(a3 + 6);
    v7[0] = 115;
    v7[1] = (unsigned __int16)(a3 + 6) >> 8;
    v7[2] = a3 + 6;
    v7[3] = v3;
    v7[4] = 0;
    qmemcpy((unsigned int)v8, a2, a3);
    v7[v6 - 1] = sub_800FE14((int)v7, (unsigned __int8)(a3 + 5));
    return sub_80073DC(v7, v6);
  }
  return result;
}

//----- (0801828C) --------------------------------------------------------
int __fastcall sub_801828C(int result, unsigned int a2, unsigned int a3)
{
  int v3; // r7
  int v6; // r4
  int v7; // r6
  _BYTE v8[156]; // [sp+4h] [bp-9Ch] BYREF

  v3 = result;
  if ( a2 )
  {
    sub_8002364(v8, 128);
    v6 = 6;
    if ( v3 == 3 )
    {
      v6 = 8;
      v8[5] = a3;
    }
    v8[0] = 115;
    v7 = a3 + v6;
    v8[1] = a3 + v6;
    v8[2] = 14;
    v8[3] = -1;
    v8[4] = v3;
    if ( a3 )
      qmemcpy((unsigned int)&v8[v6 - 1], a2, a3);
    v8[v6 - 1 + a3] = sub_800FE14((int)v8, (unsigned __int8)(v7 - 1));
    byte_200015AB = 0;
    sub_8002364(byte_20010F11, 64);
    sub_8024960(dword_20000444, 0);
    sub_801CF08((int)v8, v7);
    if ( sub_801C750(v3) )
    {
      if ( v3 != 2 )
        ++byte_200015A9;
    }
    else
    {
      byte_200015A9 = 6;
    }
    return sub_80232B4(20);
  }
  return result;
}
// 20000444: using guessed type int dword_20000444;
// 200015A9: using guessed type char byte_200015A9;
// 200015AB: using guessed type char byte_200015AB;
// 20010F11: using guessed type unsigned __int8 byte_20010F11[67];

//----- (08018344) --------------------------------------------------------
int __fastcall sub_8018344(int result, int a2)
{
  int v2; // r7
  __int64 v4; // r4
  unsigned int i; // r2
  int v6; // r4
  int v7; // r0

  v2 = result;
  if ( result )
  {
    WORD2(v4) = 0;
    LOWORD(v4) = 0;
    sub_8002364(&dword_20011094, 42);
    dword_20011094 = dword_200038E3;
    word_20011098 = dword_200038E7;
    byte_2001109A = BYTE2(dword_200038E7);
    qmemcpy((unsigned int)&unk_2001109B, (unsigned int)&unk_20004029, 0xDu);
    if ( byte_20002EA9 == 3 )
    {
      strcpy((char *)&dword_200110A8, "HME-4");
    }
    else if ( byte_20002EA9 == 4 )
    {
      strcpy((char *)&dword_200110A8, "HME-3");
    }
    for ( i = 0; i < 3; ++i )
    {
      HIDWORD(v4) = (unsigned __int16)(byte_200110C0[i + 8] + WORD2(v4));
      LODWORD(v4) = (unsigned __int16)(*((unsigned __int8 *)&dword_20004238 + i) + (_WORD)v4);
    }
    if ( (unsigned __int8)dword_20004238 == 48
      && BYTE2(dword_20004238) == 48
      && (unsigned __int8)dword_2000423C == 48
      && HIBYTE(dword_2000423C) == 48 )
    {
      LODWORD(v4) = 0;
    }
    if ( v4 )
    {
      if ( (_DWORD)v4 )
      {
        dword_200110AE = dword_20004238;
        dword_200110B2 = dword_2000423C;
        dword_200110B6 = dword_20004240;
      }
      else
      {
        qmemcpy((unsigned int)&dword_200110AE, (unsigned int)&byte_200110C0[8], 0xDu);
      }
    }
    else
    {
      sub_8002356(&dword_200110AE, 12, 48);
    }
    if ( byte_200004AC )
    {
      switch ( byte_200004AC )
      {
        case 1:
          byte_200110BB = 65;
          break;
        case 2:
          byte_200110BB = 66;
          break;
        case 3:
          byte_200110BB = 67;
          break;
        case 4:
          byte_200110BB = 68;
          break;
        default:
          byte_200110BB = 48;
          break;
      }
    }
    else
    {
      byte_200110BB = 48;
    }
    word_200110BC = (int)*(float *)&dword_2000244C;
    v6 = (unsigned __int16)snprintf(
                             v2,
                             a2,
                             (const char *)dword_8018524,
                             a2,
                             &dword_20011094,
                             &unk_2001109B,
                             &dword_200110A8,
                             &dword_200110AE,
                             (unsigned __int8)byte_200110BB,
                             word_200110BC);
    snprintf(
      v2,
      a2,
      (const char *)dword_8018524,
      v6 + 2,
      &dword_20011094,
      &unk_2001109B,
      &dword_200110A8,
      &dword_200110AE,
      (unsigned __int8)byte_200110BB,
      word_200110BC);
    v7 = sub_800FE14(v2, (unsigned __int8)v6);
    return snprintf(
             v2,
             a2,
             (const char *)dword_8018540,
             v6 + 2,
             &dword_20011094,
             &unk_2001109B,
             &dword_200110A8,
             &dword_200110AE,
             (unsigned __int8)byte_200110BB,
             word_200110BC,
             v7);
  }
  return result;
}
// 8018524: using guessed type int dword_8018524[7];
// 8018540: using guessed type int dword_8018540[8];
// 200004AC: using guessed type char byte_200004AC;
// 2000244C: using guessed type int dword_2000244C;
// 20002EA9: using guessed type char byte_20002EA9;
// 200038E3: using guessed type int dword_200038E3;
// 200038E7: using guessed type int dword_200038E7;
// 20004238: using guessed type int dword_20004238;
// 2000423C: using guessed type int dword_2000423C;
// 20004240: using guessed type int dword_20004240;
// 20011094: using guessed type int dword_20011094;
// 20011098: using guessed type __int16 word_20011098;
// 2001109A: using guessed type char byte_2001109A;
// 200110A8: using guessed type int dword_200110A8;
// 200110AE: using guessed type int dword_200110AE;
// 200110B2: using guessed type int dword_200110B2;
// 200110B6: using guessed type int dword_200110B6;
// 200110BB: using guessed type char byte_200110BB;
// 200110BC: using guessed type __int16 word_200110BC;
// 200110C0: using guessed type unsigned __int8 byte_200110C0[44];

//----- (08018560) --------------------------------------------------------
BOOL __fastcall sub_8018560(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  if ( !a1 )
    return 0;
  sub_8002364(byte_200111B8, 1024);
  word_200015EC = 0;
  sub_8024960(dword_20000440, 0);
  if ( !sub_8004200(a1) )
    return 0;
  sub_80232B4(a3);
  sub_800FD84();
  sub_801A88C((int)"%s %d g_shelly_queue_recv:%s\r\n", ": %s.\r\n", 1251, byte_200111B8);
  return strstr(byte_200111B8, a2) != 0;
}
// 20000440: using guessed type int dword_20000440;
// 200015EC: using guessed type __int16 word_200015EC;
// 200111B8: using guessed type _BYTE byte_200111B8[952];

//----- (080185F0) --------------------------------------------------------
char *__fastcall sub_80185F0(unsigned int a1, int a2, int a3)
{
  char *result; // r0

  if ( a1 >= 3 )
    return (char *)sub_801E1B0((int)"err_num\r\n");
  if ( a2 )
    dword_200021B0[a1] = a2;
  else
    dword_200021B0[a1] = 1000000;
  result = (char *)(a3 - 51);
  if ( (unsigned int)(a3 - 51) < 0x4DED )
  {
    result = &byte_20000294;
    dword_200002A0 = a3;
  }
  return result;
}
// 20000294: using guessed type char byte_20000294;
// 200002A0: using guessed type int dword_200002A0;
// 200021B0: using guessed type int dword_200021B0[];

//----- (08018634) --------------------------------------------------------
unsigned int sub_8018634()
{
  unsigned int v0; // r0
  unsigned int v1; // r0

  v0 = (MEMORY[0x4002100C] >> 4) + 1;
  if ( (MEMORY[0x4002100C] & 3) == 3 )
    v1 = 0x7A1200 / v0 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
  else
    v1 = 0xF42400 / v0 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
  return v1 / (2 * (((MEMORY[0x4002100C] >> 25) & 3u) + 1));
}

//----- (08018684) --------------------------------------------------------
int __fastcall sub_8018684(unsigned int a1)
{
  return (unsigned __int8)((a1 & 0xF) + 10 * (a1 >> 4));
}

//----- (08018696) --------------------------------------------------------
int __fastcall sub_8018696(unsigned int a1)
{
  return MemManage_fault_handler(a1, 0);
}

//----- (080186A0) --------------------------------------------------------
int __fastcall MemManage_fault_handler(unsigned int a1, char a2)
{
  while ( a1 >= 0xA )
  {
    ++a2;
    a1 = (unsigned __int8)(a1 - 10);
  }
  return a1 | (unsigned __int8)(16 * a2);
}

//----- (080186AC) --------------------------------------------------------
int __fastcall sub_80186AC(_BYTE *a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r6

  v2 = 0;
  v3 = *(_DWORD *)a1;
  if ( (*(_DWORD *)(v3 + 12) & 0x40) == 0 )
  {
    *(_DWORD *)(v3 + 12) |= 0x80u;
    v4 = sub_8012298();
    while ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x40) == 0 && v2 != 3 )
    {
      if ( (unsigned int)(sub_8012298() - v4) > 0x3E8 )
      {
        v2 = 3;
        a1[37] = 3;
      }
    }
  }
  return v2;
}

//----- (080186F4) --------------------------------------------------------
int __fastcall sub_80186F4(_BYTE *a1)
{
  int v2; // r5
  int v3; // r0

  v2 = 0;
  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x80u;
  v3 = *(_DWORD *)a1;
  if ( (*(_DWORD *)(v3 + 24) & 0x20) != 0 )
  {
    *(_DWORD *)(v3 + 24) &= ~0x20u;
    if ( sub_80141A0((int)a1) )
    {
      a1[37] = 3;
      v2 = 3;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
  }
  else if ( sub_80141A0((int)a1) )
  {
    a1[37] = 3;
    return 3;
  }
  return v2;
}

//----- (08018744) --------------------------------------------------------
int __fastcall sub_8018744(_BYTE *a1, int *a2, int a3, int a4)
{
  int v7; // r6
  unsigned int i; // r4
  _DWORD v10[10]; // [sp+0h] [bp-28h] BYREF

  v10[0] = a4;
  *a2 = 0;
  if ( !sub_8024E28(dword_2000043C, (unsigned int)v10, a3) )
    return -1;
  if ( LOBYTE(v10[0]) == 24 )
  {
    if ( sub_8024E28(dword_2000043C, (unsigned int)v10, a3) && LOBYTE(v10[0]) == 24 )
    {
      *a2 = -1;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else if ( LOBYTE(v10[0]) > 0x18u )
  {
    if ( LOBYTE(v10[0]) != 65 && LOBYTE(v10[0]) != 97 )
      return -1;
    return 1;
  }
  else
  {
    switch ( LOBYTE(v10[0]) )
    {
      case 1u:
        v7 = 128;
        break;
      case 2u:
        v7 = 1024;
        break;
      case 4u:
        return 0;
      default:
        return -1;
    }
    *a1 = v10[0];
    for ( i = 1; i < v7 + 5; i = (unsigned __int16)(i + 1) )
    {
      if ( !sub_8024E28(dword_2000043C, (unsigned int)&a1[i], a3) )
        return -1;
    }
    if ( (unsigned __int8)a1[1] == ((unsigned __int8)a1[2] ^ 0xFF) )
    {
      *a2 = v7;
      return 0;
    }
    else
    {
      return -1;
    }
  }
}
// 2000043C: using guessed type int dword_2000043C;

//----- (08018804) --------------------------------------------------------
int sub_8018804()
{
  return NMI_handler();
}
// 801880C: using guessed type int NMI_handler(void);

//----- (0801880C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall NMI_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  __int64 v12; // r4
  int v13; // r8
  unsigned int i; // r7
  char *v15; // r6
  int v16; // r0
  _WORD v17[8]; // [sp-20h] [bp-20h] BYREF
  _WORD v18[4]; // [sp-10h] [bp-10h] BYREF
  int v19; // [sp-8h] [bp-8h]
  __int16 v20; // [sp-4h] [bp-4h]

  HIDWORD(v12) = a2;
  if ( (unsigned int)v12 | a2 && qword_20000900 != v12 )
  {
    v13 = 0;
    v19 = dword_20003C59;
    v20 = word_20003C5D;
    sub_800FC70((int)v18);
    v17[0] = v18[0];
    v17[1] = v18[1];
    v17[2] = *(_WORD *)((char *)&v18[2] + 1);
    *(_QWORD *)&v17[3] = v12;
    for ( i = 0; i < 0x14; ++i )
    {
      v15 = (char *)&dword_20003C59 + 14 * i;
      if ( *(_QWORD *)(v15 + 6) == *(_QWORD *)&v17[3]
        && (unsigned __int8)v15[2] == LOBYTE(v17[1])
        && (unsigned __int8)v15[3] == HIBYTE(v17[1]) )
      {
        v16 = HIBYTE(v17[2]) - (unsigned __int8)v15[5] + 60 * (LOBYTE(v17[2]) - (unsigned __int8)v15[4]);
        if ( v16 < 0 )
          v16 = -v16;
        if ( v16 <= 30 )
          goto LABEL_14;
      }
      if ( sub_8004C6E(v19, v20, *(_DWORD *)v15, *((_WORD *)v15 + 2)) > 0 )
      {
        v19 = *(_DWORD *)v15;
        v20 = *((_WORD *)v15 + 2);
        v13 = (unsigned __int8)i;
      }
    }
    qmemcpy((unsigned int)&dword_20003C59 + 14 * v13, (unsigned int)v17, 0xEu);
    qword_20000900 = v12;
    sub_80055F0(14 * v13 + 4352, v17, 0xEu);
  }
LABEL_14:
  __asm { POP.W           {R4-R10,PC} }
}
// 801891C: positive sp value 28 has been found
// 801891C: unbalanced stack, ignored a potential tail call
// 801880E: variable 'v12' is possibly undefined
// 20000900: using guessed type __int64 qword_20000900;
// 20003C59: using guessed type int dword_20003C59;
// 20003C5D: using guessed type __int16 word_20003C5D;

//----- (08018928) --------------------------------------------------------
int __fastcall sub_8018928(int result, int a2)
{
  int v2; // r4
  int v4; // r3
  unsigned __int16 *v5; // r2
  int v6; // r1
  int v7; // r8
  int v8; // r7
  char *v9; // r0
  char *v10; // r0
  int v11; // [sp+10h] [bp-38h] BYREF
  _BYTE v12[5]; // [sp+14h] [bp-34h]
  int v13; // [sp+1Ch] [bp-2Ch] BYREF
  __int16 v14; // [sp+21h] [bp-27h]

  v2 = result;
  if ( result )
  {
    if ( a2 )
    {
      if ( (unsigned __int8)byte_200008F3 != result
        || (result = (unsigned __int16)word_200008F8, (unsigned __int16)word_200008F8 != a2) )
      {
        sub_800FC70((int)&v13);
        v11 = v13;
        result = (unsigned __int8)v14;
        *(_WORD *)v12 = v14;
        v12[2] = v2;
        *(_WORD *)&v12[3] = a2;
        v4 = 0;
        while ( 1 )
        {
          v5 = (unsigned __int16 *)((char *)&unk_20003D71 + 9 * v4);
          if ( *(unsigned __int16 *)((char *)v5 + 7) == a2
            && *((unsigned __int8 *)v5 + 6) == v2
            && *v5 == (unsigned __int16)v13
            && __PAIR64__(*((unsigned __int8 *)v5 + 3), *((unsigned __int8 *)v5 + 2)) == __PAIR64__(
                                                                                           HIBYTE(v13),
                                                                                           BYTE2(v13)) )
          {
            v6 = HIBYTE(v14) - *((unsigned __int8 *)v5 + 5) + 60 * ((unsigned __int8)v14 - *((unsigned __int8 *)v5 + 4));
            if ( v6 < 0 )
              v6 = -v6;
            if ( v6 <= 30 )
              break;
          }
          if ( (unsigned int)++v4 >= 0x14 )
          {
            v7 = 0;
            v8 = 0;
            while ( 1 )
            {
              v9 = (char *)&unk_20003D71 + 9 * v8;
              if ( !*(_WORD *)(v9 + 7) && !v9[6] )
                break;
              if ( sub_8004C6E(
                     *(_DWORD *)v9,
                     *((_WORD *)v9 + 2),
                     *(_DWORD *)((char *)&unk_20003D71 + 9 * v7),
                     *(_WORD *)((char *)&unk_20003D71 + 9 * v7 + 4)) < 0 )
                v7 = v8;
              if ( (unsigned int)++v8 >= 0x14 )
                goto LABEL_20;
            }
            v7 = v8;
LABEL_20:
            v10 = (char *)&unk_20003D71 + 9 * v7;
            *(_DWORD *)v10 = v11;
            *((_DWORD *)v10 + 1) = *(_DWORD *)v12;
            v10[8] = v12[4];
            result = sub_80055F0(9 * v7 + 0x2000, &v11, 9u);
            byte_200008F3 = v2;
            word_200008F8 = a2;
            return result;
          }
        }
      }
    }
  }
  return result;
}
// 200008F3: using guessed type char byte_200008F3;
// 200008F8: using guessed type __int16 word_200008F8;

//----- (08018A5C) --------------------------------------------------------
int sub_8018A5C()
{
  byte_200004AA = 1;
  word_200004B6 = 0;
  return sub_80180E8(&word_200004B6, 0xBB8u);
}
// 200004AA: using guessed type char byte_200004AA;
// 200004B6: using guessed type __int16 word_200004B6;

//----- (08018A74) --------------------------------------------------------
char *sub_8018A74()
{
  char *result; // r0

  result = (char *)(unsigned __int8)byte_20010EEE;
  if ( byte_20010EEE )
  {
    if ( byte_20010EED )
    {
      if ( byte_20010EED == 3 )
      {
        sub_801CB1C(dword_20010F03, dword_20010EF7);
        sub_8002364(&byte_20010EEC, 37);
        sub_8023648((_DWORD *)dword_20000008);
        sub_8023648((_DWORD *)dword_2000000C);
      }
    }
    else
    {
      sub_801EBD0(dword_20010EF7);
      sub_8002364(&byte_20010EEC, 37);
      byte_200036AF = 0;
    }
    result = &byte_200015A8;
    dword_200015B8 = 0;
    byte_20010EEE = 0;
  }
  return result;
}
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 200015A8: using guessed type char byte_200015A8;
// 200015B8: using guessed type int dword_200015B8;
// 200036AF: using guessed type char byte_200036AF;
// 20010EEC: using guessed type char byte_20010EEC;
// 20010EED: using guessed type char byte_20010EED;
// 20010EEE: using guessed type char byte_20010EEE;
// 20010EF7: using guessed type int dword_20010EF7;
// 20010F03: using guessed type int dword_20010F03;

//----- (08018AE4) --------------------------------------------------------
int __fastcall sub_8018AE4(int a1)
{
  int result; // r0

  *(_DWORD *)dword_2000171C &= ~0x20u;
  *(_DWORD *)dword_2000171C &= ~0x80u;
  *(_DWORD *)(dword_2000171C + 8) &= ~1u;
  sub_801511E((int)&dword_2000171C);
  sub_8015308(&dword_2000171C);
  dword_2000171C = 1073759232;
  dword_20001720 = a1;
  dword_20001724 = 0;
  dword_20001728 = 0;
  dword_2000172C = 0;
  dword_20001734 = 0;
  dword_20001730 = 12;
  dword_20001738 = 0;
  sub_8013E1C((int)&dword_2000171C, 0, 2, 2);
  sub_80151A6((int)&dword_2000171C, 0);
  sub_801515A((int)&dword_2000171C);
  sub_80157DC((int)&dword_2000171C, (int)byte_2000303A, 1u);
  result = dword_2000171C;
  *(_DWORD *)(dword_2000171C + 8) &= ~1u;
  return result;
}
// 2000171C: using guessed type int dword_2000171C;
// 20001720: using guessed type int dword_20001720;
// 20001724: using guessed type int dword_20001724;
// 20001728: using guessed type int dword_20001728;
// 2000172C: using guessed type int dword_2000172C;
// 20001730: using guessed type int dword_20001730;
// 20001734: using guessed type int dword_20001734;
// 20001738: using guessed type int dword_20001738;

//----- (08018B68) --------------------------------------------------------
int __fastcall sub_8018B68(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-8h] BYREF

  v5 = a4;
  return sub_801828C(5, (unsigned int)&v5, 0);
}

//----- (08018B78) --------------------------------------------------------
void sub_8018B78()
{
  byte_200004BA = 1;
  byte_200004BB = 1;
  byte_200004A9 = 0;
  flt_200004D4 = 0.0;
  word_200004B8 = 0;
  byte_200004AB = 1;
  byte_200004AC = 0;
  sub_8003234();
}
// 200004A9: using guessed type char byte_200004A9;
// 200004AB: using guessed type char byte_200004AB;
// 200004AC: using guessed type char byte_200004AC;
// 200004B8: using guessed type __int16 word_200004B8;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;
// 200004D4: using guessed type float flt_200004D4;

//----- (08018BA8) --------------------------------------------------------
int __fastcall sub_8018BA8(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r6
  unsigned int v4; // r4
  unsigned int v5; // r5
  unsigned int v6; // r7
  unsigned __int16 *v7; // r3
  unsigned int v8; // r0
  __int16 v9; // r0
  __int16 v10; // r0

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  v4 = a1[3] | (a1[2] << 8);
  if ( !v4 || v4 > 0x7D )
    return 3;
  v5 = 3;
  byte_20002F3C = 2 * a1[3];
  if ( v3 < 0x9C40 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = (unsigned __int16 *)((char *)&unk_20000528 + 12 * v6);
      v8 = *v7;
      if ( v8 + (((*((_BYTE *)v7 + 9) & 0xF) * (unsigned int)*((unsigned __int8 *)v7 + 11)) >> 1) > v3 )
      {
        if ( v8 > v3 )
          return 2;
        v9 = sub_8022CE4((unsigned int)&byte_20002F3A[v5], v3, (unsigned __int8)v4, (int)v7);
        v5 = (unsigned __int16)(v5 + 2 * v9);
        v4 = (unsigned __int16)(v4 - v9);
        v3 = (unsigned __int16)(v9 + v3);
        if ( !v4 )
          goto LABEL_18;
      }
      v6 = (unsigned __int16)(v6 + 1);
      if ( v6 >= 0x4B )
        goto LABEL_18;
    }
  }
  while ( v4 )
  {
    if ( sub_80238FC(&byte_20002F3A[v5], v3, 0, 0) )
      return 2;
    v4 = (unsigned __int16)(v4 - 1);
    v3 = (unsigned __int16)(v3 + 1);
    v5 = (unsigned __int16)(v5 + 2);
  }
LABEL_18:
  if ( v4 )
    return 3;
  v10 = sub_8017EA2((int)byte_20002F3A, v5);
  byte_20002F3A[v5] = v10;
  byte_20002F3A[(unsigned __int16)(v5 + 1)] = HIBYTE(v10);
  sub_801CEAC((int)byte_20002F3A, v5 + 2);
  return 0;
}
// 20002F3C: using guessed type char byte_20002F3C;

//----- (08018C90) --------------------------------------------------------
int __fastcall sub_8018C90(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r1
  int v4; // r5

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  if ( v3 < 0x9C40 )
    return 2;
  v4 = sub_80238FC(byte_20002F3A, v3, 1, a1[3] | (a1[2] << 8));
  if ( !v4 )
  {
    qmemcpy((unsigned int)&byte_20002F3C, (unsigned int)&unk_2000303C, 6u);
    word_20002F40 = sub_8017EA2((int)byte_20002F3A, 6u);
    sub_801CEAC((int)byte_20002F3A, 8u);
  }
  return v4;
}
// 20002F3C: using guessed type char byte_20002F3C;
// 20002F40: using guessed type __int16 word_20002F40;

//----- (08018CF4) --------------------------------------------------------
int __fastcall sub_8018CF4(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r1

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  if ( v3 >= 0x9C40 )
    return sub_80238FC(byte_20002F3A, v3, 1, a1[3] | (a1[2] << 8));
  else
    return 2;
}

//----- (08018D24) --------------------------------------------------------
int __fastcall sub_8018D24(unsigned __int8 *a1, unsigned int a2, int a3, int a4)
{
  int v4; // r9
  __int16 v6; // r10
  int v7; // r4
  int result; // r0
  unsigned int v9; // r5
  int v10; // r8
  int v11; // r0
  int i; // r7
  int v13; // r1
  unsigned __int16 v14; // r10
  __int16 v15; // r0
  int v16; // [sp+0h] [bp-28h] BYREF

  v16 = a4;
  v6 = a2;
  v7 = 5;
  if ( a2 < 0xA )
    return 3;
  v9 = a1[1] | (*a1 << 8);
  v10 = a1[3] | (a1[2] << 8);
  v11 = a1[4];
  if ( v11 != 2 * v10 || v11 + 9 != a2 )
    return 3;
  if ( v9 < 0x9C40 )
    return 2;
  if ( !v10 || (unsigned int)v10 > 0x7D )
    return 3;
  for ( i = 0; i < v10; ++i )
  {
    sub_8004CBE((int)&v16, (int)&a1[v7], 2u);
    v7 = (unsigned __int16)(v7 + 2);
    v13 = v9;
    v9 = (unsigned __int16)(v9 + 1);
    result = sub_80238FC(&byte_20002F3A[v7], v13, 1, (unsigned __int16)v16);
    v4 = result;
    if ( result )
      return result;
  }
  if ( !v4 )
  {
    v14 = v6 - 2;
    qmemcpy((unsigned int)&byte_20002F3C, (unsigned int)&unk_2000303C, v14);
    v15 = sub_8017EA2((int)byte_20002F3A, v14);
    byte_20002F3A[v14] = v15;
    byte_20002F3A[(unsigned __int16)(v14 + 1)] = HIBYTE(v15);
    sub_801CEAC((int)byte_20002F3A, v14 + 2);
  }
  return v4;
}
// 8018DB8: variable 'v4' is possibly undefined
// 20002F3C: using guessed type char byte_20002F3C;

//----- (08018DFC) --------------------------------------------------------
int __fastcall sub_8018DFC(int result, unsigned int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r4
  unsigned int v6; // r5
  int v7; // r8
  int v8; // r2
  int i; // r7
  int v10; // r1
  int v11; // [sp+0h] [bp-20h] BYREF

  v11 = a4;
  v4 = result;
  v5 = 5;
  if ( a2 < 0xA )
    return 3;
  v6 = *(unsigned __int8 *)(result + 1) | (*(unsigned __int8 *)result << 8);
  v7 = *(unsigned __int8 *)(result + 3) | (*(unsigned __int8 *)(result + 2) << 8);
  v8 = *(unsigned __int8 *)(result + 4);
  if ( v8 != 2 * v7 || v8 + 9 != a2 )
    return 3;
  if ( v6 < 0x9C40 )
    return 2;
  if ( !v7 || (unsigned int)v7 > 0x7D )
    return 3;
  for ( i = 0; i < v7; ++i )
  {
    sub_8004CBE((int)&v11, v4 + v5, 2u);
    v5 = (unsigned __int16)(v5 + 2);
    v10 = v6;
    v6 = (unsigned __int16)(v6 + 1);
    result = sub_80238FC(&byte_20002F3A[v5], v10, 1, (unsigned __int16)v11);
    if ( result )
      break;
  }
  return result;
}

//----- (08018E88) --------------------------------------------------------
int __fastcall sub_8018E88(_BYTE *a1, int a2)
{
  sub_8013EF4((int)&dword_2000213C, a2, 0);
  return sub_8013EB0((int)&dword_2000213C, a1, 0);
}
// 2000213C: using guessed type int dword_2000213C;

//----- (08018EA8) --------------------------------------------------------
int sub_8018EA8()
{
  sub_80251BC(134365181, (int)"vtask_led", 128, 0, 0x10u, dword_20000014);
  sub_80251BC(134365405, (int)"vtask_time", 256, 0, 0xFu, &dword_20000020);
  sub_80251BC(134365241, (int)"vtask_modbus", 128, 0, 0xEu, &dword_20000024);
  sub_80251BC(134365277, (int)"vtask_shell", 512, 0, 9u, &dword_20000014[1]);
  sub_80251BC(134365265, (int)"vtask_prt", 256, 0, 8u, &dword_2000001C);
  sub_80251BC(134365149, (int)"vtask_fc41d", 256, 0, 0xBu, &dword_20000008);
  sub_80251BC(134365253, (int)"vtask_parser", 256, 0, 0xDu, &dword_2000000C);
  sub_80251BC(134365165, (int)"vtask_http", 256, 0, 0xAu, &dword_20000010);
  sub_80251BC(134365133, (int)"vtask_ct", 512, 0, 0xCu, &dword_20000004);
  return sub_80235B8();
}
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 20000010: using guessed type int dword_20000010;
// 20000014: using guessed type _DWORD dword_20000014[2];
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 20000024: using guessed type int dword_20000024;

//----- (08019018) --------------------------------------------------------
#error "8019092: call analysis failed (funcsize=262)"

//----- (08019330) --------------------------------------------------------
void __fastcall sub_8019330(int a1)
{
  int v2; // r0
  float v3; // s0
  int v4; // r0

  v2 = (int)*(float *)&dword_20002798;
  if ( (int)*(float *)&dword_20002798 < 0 || a1 <= 10 )
  {
    if ( v2 > 0 || a1 >= -10 )
    {
      if ( v2 * a1 >= 0 )
      {
        if ( v2 < 0 && (unsigned int)a1 >= 0xFFFFFFF6 )
          flt_200004D4 = flt_200004D4 + (float)(a1 - 5);
      }
      else
      {
        flt_200004D4 = flt_200004D4 + (float)a1;
      }
    }
    else
    {
      flt_200004D4 = flt_200004D4 + (float)((float)a1 * 1.0);
    }
  }
  else
  {
    flt_200004D4 = (float)((float)((float)a1 * 1.0) - 5.0) + flt_200004D4;
  }
  sub_8004CE4(&flt_200004D4);
  v3 = flt_200004D4;
  if ( flt_200004D4 > flt_20000310 )
    v3 = flt_20000310;
  flt_200004D4 = v3;
  if ( v3 < flt_20000314 )
    v3 = flt_20000314;
  flt_200004D4 = v3;
  v4 = (int)v3;
  if ( (int)v3 < 0 )
    v4 = -v4;
  if ( v4 <= 30 && a1 <= 30 )
    flt_200004D4 = 0.01;
  sub_8018A5C();
  sub_8003234();
}
// 20000310: using guessed type float flt_20000310;
// 20000314: using guessed type float flt_20000314;
// 200004D4: using guessed type float flt_200004D4;
// 20002798: using guessed type int dword_20002798;

//----- (08019444) --------------------------------------------------------
int __fastcall sub_8019444(int a1)
{
  sub_801CE90(a1);
  return 0;
}

//----- (08019450) --------------------------------------------------------
void sub_8019450()
{
  BOOL v0; // r5
  int v1; // r4
  char v2; // r6
  int v3; // r0
  float v4; // s0
  unsigned int v5; // r3
  int v6; // r2
  int j; // r0
  int v8; // r1
  int v9; // r11
  int v10; // r0
  int i; // r0
  int v12; // r1
  int v13; // r3
  bool v14; // cc
  int v15; // r1
  int v16; // r5
  int v17; // r1
  unsigned int v18; // [sp+0h] [bp-30h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v18 = 20;
  if ( byte_200004AB )
  {
    word_200004C6 = 0;
    word_200004C8 = 0;
    word_200004CA = 0;
    byte_200004B2 = 0;
    byte_200004B3 = 0;
    byte_200004AB = 0;
  }
  if ( byte_200004BA
    && ((unsigned __int16)dword_20002D52 <= 0x32u || word_20002D50)
    && ((unsigned __int16)dword_20002D52 > 0x32u || HIWORD(dword_20002D4C)) )
  {
    if ( byte_200004AC == 5 )
      sub_8003234();
    if ( byte_200004AC == 5 && sub_801AAF4(&word_200004CA, 0x3Cu) )
    {
      if ( (unsigned __int8)++byte_200004A9 >= 0xAu )
      {
        byte_200004BA = 0;
        byte_200004BB = 2;
        byte_200004A9 = 10;
        return;
      }
      byte_200004AC = 0;
    }
    if ( !byte_200004AC && byte_200015DE )
    {
      if ( word_200004B8 )
      {
        if ( !byte_200004B2 && !sub_801AAF4(&word_200004C6, 3u) )
        {
          *(_QWORD *)&dword_20002DB4 = *(_QWORD *)&dword_20002DA4;
          *(_QWORD *)dword_20002DAC = *(_QWORD *)dword_20002D9C;
          *(_QWORD *)dword_20002DBC = *(_QWORD *)dword_20002D9C;
          dword_20002DC4 = dword_20002DA4;
          *(_QWORD *)dword_20002DC8 = *(_QWORD *)dword_20002D9C;
          dword_20002DD0 = dword_20002DA4;
          dword_20002DD4[0] = 0;
          dword_20002DD8 = 0;
          dword_20002DDC = 0;
          sub_8003234();
          byte_200004B2 = 1;
        }
        if ( byte_200004B2 )
        {
          v3 = (int)flt_20000310;
          if ( (int)flt_20000310 < 0 )
            v3 = -v3;
          if ( v3 <= 2000 )
            v4 = flt_20000310;
          else
            v4 = 2000.0;
          v5 = (unsigned __int16)(unsigned int)v4;
          v6 = (unsigned __int8)byte_200015DC;
          if ( byte_200015DC == 1 )
          {
            for ( i = 0; i < 3; ++i )
            {
              v12 = dword_20002D9C[i];
              v13 = dword_20002DAC[i];
              v14 = v12 < v13;
              if ( v12 <= v13 )
                v15 = v13 - v12;
              else
                v15 = v12 - v13;
              if ( v14 && v15 >= 50 && (unsigned int)(v13 - 701) < 0x257 )
              {
                if ( dword_20002DD4[i] >= v15 )
                  v15 = dword_20002DD4[i];
                dword_20002DD4[i] = v15;
              }
              v16 = dword_20002DC8[i];
              if ( v16 <= dword_20002D9C[i] )
                v16 = dword_20002D9C[i];
              dword_20002DC8[i] = v16;
              v17 = dword_20002DBC[i];
              if ( v17 >= dword_20002D9C[i] )
                v17 = dword_20002D9C[i];
              dword_20002DBC[i] = v17;
              if ( (unsigned int)(v16 - v17 + dword_20002DD4[i] - 800) <= 0x6A4 )
              {
                ++byte_200004B3;
                v1 = (unsigned __int8)(v1 + 1);
                v2 = i + 1;
              }
            }
          }
          else
          {
            for ( j = 0; j < 3; ++j )
            {
              v8 = dword_20002D9C[j];
              v9 = v8 - dword_20002DAC[j];
              if ( v9 < 0 )
                v9 = dword_20002DAC[j] - v8;
              if ( !v0 )
                v0 = v8 != 0;
              if ( v9 >= (int)(v5 >> 1) && v9 <= 2500 )
              {
                v0 = 1;
                ++byte_200004B3;
                v1 = (unsigned __int8)(v1 + 1);
                v2 = j + 1;
              }
            }
            if ( (unsigned int)(unsigned __int8)byte_200015DC - 5 <= 4 && !v0 )
            {
              v10 = dword_20002DA8 - dword_20002DB8;
              if ( dword_20002DA8 - dword_20002DB8 < 0 )
                v10 = dword_20002DB8 - dword_20002DA8;
              if ( v10 >= (int)(v5 >> 1) && v10 <= 2500 )
              {
                byte_200004B3 = 2;
                v1 = 1;
                v2 = 4;
              }
            }
          }
          if ( v1 && byte_200004B3 == 2 )
          {
            word_200004B8 = 0;
            byte_200004BA = 0;
            byte_200004BB = 3;
            byte_200004B2 = 0;
            byte_200004B3 = 0;
            word_200004C8 = 0;
            if ( v1 != 1 )
              v2 = 5;
            byte_200004AC = v2;
            sub_8003234();
            sub_8005744((unsigned __int8)byte_200004AC);
            flt_200004D4 = 0.1;
          }
          else
          {
            if ( v6 == 5 || v6 == 9 )
              v18 = 40;
            if ( word_200004B8 )
            {
              if ( sub_801AAF4(&word_200004C8, v18) )
              {
                word_200004B8 = 0;
                byte_200004AC = 5;
                byte_200004B2 = 0;
                byte_200004B3 = 0;
                sub_8003234();
                flt_200004D4 = 0.1;
              }
            }
          }
        }
      }
      else
      {
        sub_8003234();
        word_200004B8 = 1;
      }
    }
  }
}
// 20000310: using guessed type float flt_20000310;
// 200004A9: using guessed type char byte_200004A9;
// 200004AB: using guessed type char byte_200004AB;
// 200004AC: using guessed type char byte_200004AC;
// 200004B2: using guessed type char byte_200004B2;
// 200004B3: using guessed type char byte_200004B3;
// 200004B8: using guessed type __int16 word_200004B8;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;
// 200004C6: using guessed type __int16 word_200004C6;
// 200004C8: using guessed type __int16 word_200004C8;
// 200004CA: using guessed type __int16 word_200004CA;
// 200004D4: using guessed type float flt_200004D4;
// 200015DC: using guessed type char byte_200015DC;
// 200015DE: using guessed type char byte_200015DE;
// 20002D4C: using guessed type int dword_20002D4C;
// 20002D50: using guessed type __int16 word_20002D50;
// 20002D52: using guessed type int dword_20002D52;
// 20002D9C: using guessed type int dword_20002D9C[];
// 20002DA4: using guessed type int dword_20002DA4;
// 20002DA8: using guessed type int dword_20002DA8;
// 20002DAC: using guessed type int dword_20002DAC[];
// 20002DB4: using guessed type int dword_20002DB4;
// 20002DB8: using guessed type int dword_20002DB8;
// 20002DBC: using guessed type int dword_20002DBC[];
// 20002DC4: using guessed type int dword_20002DC4;
// 20002DC8: using guessed type int dword_20002DC8[];
// 20002DD0: using guessed type int dword_20002DD0;
// 20002DD4: using guessed type int dword_20002DD4[];
// 20002DD8: using guessed type int dword_20002DD8;
// 20002DDC: using guessed type int dword_20002DDC;

//----- (08019778) --------------------------------------------------------
#error "80197A0: call analysis failed (funcsize=79)"

//----- (08019988) --------------------------------------------------------
int __fastcall sub_8019988(int a1)
{
  if ( a1 == 27 )
    dword_20000298 = 1;
  return sub_802072C((int)&dword_200021BC, a1);
}
// 20000298: using guessed type int dword_20000298;
// 200021BC: using guessed type int dword_200021BC;

//----- (080199A4) --------------------------------------------------------
int sub_80199A4()
{
  int result; // r0
  int v1; // r6
  int v2; // r7
  unsigned __int8 *v3; // r0
  unsigned int v4; // r7
  int v5; // r0
  unsigned int v6; // r6
  _BYTE *v7; // r0
  unsigned __int8 *v8; // r0
  __int16 v9; // r0
  char v10; // r0
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // r0
  int v13; // r0
  char *v14; // r0
  unsigned __int16 v15; // r0
  char v16; // r0
  unsigned __int8 *v17; // r0
  unsigned __int8 *v18; // r0
  unsigned __int8 *v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r2
  int v22; // r3
  char v23; // r0
  unsigned __int8 *v24; // r0
  __int16 v25; // r0
  unsigned __int8 v26[128]; // [sp+Ch] [bp-F4h] BYREF
  unsigned __int8 v27[64]; // [sp+8Ch] [bp-74h] BYREF
  int v28; // [sp+CCh] [bp-34h] BYREF
  int v29; // [sp+D0h] [bp-30h]
  int v30; // [sp+D4h] [bp-2Ch]
  int v31; // [sp+D8h] [bp-28h]

  result = (unsigned __int8)byte_20000928;
  if ( byte_20000928 )
  {
    sub_801A88C(
      (int)"%s %d g_user_setting.choose_meter:%d\r\n",
      "mode auto change open, g_work_mode = %d, g_work_mode_change = %d.\r\n",
      1271,
      (unsigned __int8)byte_20002EA9);
    v1 = 0;
    v2 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    sub_8002364(v27, 64);
    sub_8002364(v26, 128);
    if ( byte_200015D7 == 5 )
    {
      word_200015F4 = 0;
    }
    else if ( sub_801AAF4(&word_200015F4, 0x19u) && byte_200015DE )
    {
      byte_200015DE = 0;
    }
    switch ( byte_200015D7 )
    {
      case 0:
        sub_8016D3C();
        if ( sub_8018560("AT+QICFG=\"accept/mode\",0\r\n", "OK", 300) )
          byte_200015D7 = 1;
        break;
      case 1:
        if ( sub_8018560("AT+QGETIP=station\r\n", "QGETIP", 300) )
        {
          v3 = strstr(byte_200111B8, "ip:");
          if ( v3 )
          {
            if ( v3[3] == 48 )
            {
              sub_80232B4(2000);
              byte_200015D7 = 0;
            }
            else
            {
              v4 = (unsigned int)(v3 + 3);
              v5 = sub_80023CE((int)(v3 + 3), 0x2Cu);
              if ( v5 )
              {
                v6 = v5 - v4;
                if ( (int)(v5 - v4) <= 16 )
                {
                  sub_8002364(byte_20011074, 32);
                  dword_200115B8 = 0;
                  dword_200115BC = 0;
                  dword_200115C0 = 0;
                  dword_200115C4 = 0;
                  qmemcpy((unsigned int)byte_20011074, v4, v6);
                  qmemcpy((unsigned int)&dword_200115B8, (unsigned int)byte_20011074, v6);
                  v7 = sub_8002480(&dword_200115B8, 46);
                  if ( v7 )
                  {
                    byte_200015D9 = 0;
                    *v7 = 0;
                    sub_800237A((int)&dword_200115B8, ".255");
                  }
                  byte_200015D7 = 2;
                }
              }
            }
          }
          else
          {
            ++byte_200015D9;
          }
        }
        else
        {
          ++byte_200015D9;
        }
        break;
      case 2:
        sub_8002364(v26, 128);
        sprintf(
          (int)v26,
          "AT+QIOPEN=%d,\"UDP SERVICE\",\"%s\",%d,%d,0\r\n",
          (unsigned __int8)byte_200015E2,
          (const char *)&dword_200115B8,
          1010,
          22222);
        if ( sub_8018560(v26, "+QIOPEN", 300) )
        {
          v8 = strstr(byte_200111B8, ",");
          v9 = sub_8002644((char *)v8);
          byte_200015E7 = byte_200015E2;
          if ( v9 )
          {
            v10 = byte_200015E2;
            if ( (unsigned __int8)byte_200015E2 >= 0xBu )
              --byte_200015E2;
            else
              ++byte_200015E2;
            byte_200015E2 = v10;
            byte_200015D7 = 0;
          }
          else
          {
            byte_200015D9 = 0;
            byte_200015D7 = 3;
          }
        }
        else
        {
          ++byte_200015D9;
        }
        break;
      case 3:
        sub_8002364(v27, 64);
        switch ( byte_20002EA9 )
        {
          case 1:
            sprintf(
              (int)v27,
              "{\"id\":%d,\"method\":\"EM.GetStatus\",\"params\":{\"id\":0}}",
              (unsigned __int8)byte_200015D8);
            v2 = sub_8005188();
            break;
          case 3:
          case 4:
            sub_8018344((int)v27, 64);
            v2 = 12345;
            break;
          case 5:
          case 6:
            v2 = sub_8005188();
            sprintf(
              (int)v27,
              "{\"id\":%d,\"method\":\"EM1.GetStatus\",\"params\":{\"id\":0}}",
              (unsigned __int8)byte_200015D8);
            break;
        }
        sub_8002364(v26, 128);
        v11 = sub_80023E2(v27);
        sprintf(
          (int)v26,
          "AT+QISEND=%d,%d,\"%s\",\"%s\",%d\r\n",
          (unsigned __int8)byte_200015E2,
          v11,
          (const char *)v27,
          (const char *)&dword_200115B8,
          v2);
        if ( sub_8018560(v26, "OK", 300) )
          ++byte_200015D9;
        byte_200015D7 = 4;
        break;
      case 4:
        sub_8002364(v26, 128);
        sprintf((int)v26, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015E2);
        if ( sub_8018560(v26, "+QIRD", 300) )
        {
          v12 = strstr(byte_200111B8, "+QIRD");
          if ( v12 )
          {
            v13 = sub_80023CE((int)v12, 0x2Cu);
            if ( v13 )
            {
              v14 = (char *)(sub_80023CE(v13 + 1, 0x2Cu) + 1);
              if ( v14 != (char *)1 )
              {
                v15 = sub_8002644(v14);
                word_200015EA = v15;
                if ( v15 )
                {
                  if ( v15 >= 0x258u && byte_200015DC == 4
                    || v15 >= 0x64u && (byte_200015DC == 3 || byte_200015DC == 6)
                    || v15 >= 0xC8u && (byte_200015DC == 7 || byte_200015DC == 8) )
                  {
                    byte_200015DB = 1;
                  }
                  byte_200015D9 = 0;
                  byte_200015D7 = 5;
                }
                else
                {
                  byte_200015D7 = 3;
                  ++byte_200015D9;
                }
              }
            }
          }
        }
        else
        {
          byte_200015D7 = 3;
          ++byte_200015D9;
        }
        break;
      case 5:
        sub_8002364(v26, 128);
        sprintf((int)v26, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015E2, (unsigned __int16)word_200015EA);
        if ( sub_8018560(v26, "OK", 300) && !byte_200015DB )
        {
          byte_200015DE = 1;
          byte_200015D9 = 0;
          if ( strstr(byte_200111B8, "a_act_power") )
          {
            v17 = strstr(byte_200111B8, "a_act_power");
            if ( v17 )
              v29 = (int)(double)sub_8002644((char *)v17 + 13);
            v18 = strstr(byte_200111B8, "b_act_power");
            if ( v18 )
              v30 = (int)(double)sub_8002644((char *)v18 + 13);
            v19 = strstr(byte_200111B8, "c_act_power");
            if ( v19 )
              v31 = (int)(double)sub_8002644((char *)v19 + 13);
            v20 = strstr(byte_200111B8, "total_act_power");
            if ( v20 )
            {
              v28 = (int)(double)sub_8002644((char *)v20 + 17);
              v1 = 1;
            }
            byte_200015DC = 4;
          }
          else if ( strstr(byte_200111B8, "HME-") )
          {
            v1 = sub_801C2EC(byte_200111B8, 1024, &v28);
          }
          else if ( strstr(byte_200111B8, "shellyemg3") || strstr(byte_200111B8, "shellyproem50") )
          {
            if ( strstr(byte_200111B8, "shellyemg3") )
              v23 = 7;
            else
              v23 = 8;
            byte_200015DC = v23;
            v1 = 1;
            v24 = strstr(byte_200111B8, "act_power");
            v28 = (int)(double)sub_8002644((char *)v24 + 11);
          }
          if ( v1 )
          {
            byte_200015DA = 0;
            sub_800F768(byte_200111B8, 1024, v21, v22);
            sub_8024A40(dword_20000434, (unsigned int)&v28, 0, 2);
            sub_801A88C((int)dword_802929C, 134380291, 1461, v29, v30, v31, v28);
            v25 = sub_800F638();
            sub_80232B4(1200 * v25);
          }
          byte_200015D7 = 3;
        }
        else
        {
          ++byte_200015DA;
          if ( byte_200015DB )
            v16 = 4;
          else
            v16 = 3;
          byte_200015D7 = v16;
        }
        byte_200015DB = 0;
        break;
      default:
        byte_200015D9 = 6;
        break;
    }
    result = (unsigned __int8)byte_200015D9;
    if ( (unsigned __int8)byte_200015D9 > 5u
      || (result = (unsigned __int8)byte_200015DA, (unsigned __int8)byte_200015DA >= 3u) )
    {
      byte_200015DA = 0;
      byte_200015D9 = 0;
      byte_200015D7 = 0;
    }
  }
  else
  {
    byte_200015D7 = 0;
  }
  return result;
}
// 8019FA6: variable 'v21' is possibly undefined
// 8019FA6: variable 'v22' is possibly undefined
// 802929C: using guessed type int dword_802929C[108];
// 20000434: using guessed type int dword_20000434;
// 20000928: using guessed type char byte_20000928;
// 200015D7: using guessed type char byte_200015D7;
// 200015D8: using guessed type char byte_200015D8;
// 200015D9: using guessed type char byte_200015D9;
// 200015DA: using guessed type char byte_200015DA;
// 200015DB: using guessed type char byte_200015DB;
// 200015DC: using guessed type char byte_200015DC;
// 200015DE: using guessed type char byte_200015DE;
// 200015E2: using guessed type char byte_200015E2;
// 200015E7: using guessed type char byte_200015E7;
// 200015EA: using guessed type __int16 word_200015EA;
// 200015F4: using guessed type __int16 word_200015F4;
// 20002EA9: using guessed type char byte_20002EA9;
// 200111B8: using guessed type _BYTE byte_200111B8[952];
// 200115B8: using guessed type int dword_200115B8;
// 200115BC: using guessed type int dword_200115BC;
// 200115C0: using guessed type int dword_200115C0;
// 200115C4: using guessed type int dword_200115C4;

//----- (0801A028) --------------------------------------------------------
int __fastcall sub_801A028(int result, int a2, int (*a3)(void))
{
  if ( result == 1 )
  {
    off_20000064 = a3;
    *(_DWORD *)(dword_20001AEC + 52) = *(_DWORD *)(dword_20001AEC + 36) + a2;
    *(_DWORD *)(dword_20001AEC + 16) = -3;
    result = dword_20001AEC;
    *(_DWORD *)(dword_20001AEC + 12) |= 2u;
  }
  else if ( result == 2 )
  {
    off_20000068 = a3;
    *(_DWORD *)(dword_20001AEC + 56) = *(_DWORD *)(dword_20001AEC + 36) + a2;
    *(_DWORD *)(dword_20001AEC + 16) = -5;
    result = dword_20001AEC;
    *(_DWORD *)(dword_20001AEC + 12) |= 4u;
  }
  return result;
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AEC: using guessed type int dword_20001AEC;

//----- (0801A078) --------------------------------------------------------
int __fastcall sub_801A078(_BYTE *a1, _DWORD *a2)
{
  unsigned int v3; // r3
  int result; // r0
  int v5; // r4
  int v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r2
  int v10; // r2

  v3 = 0;
  result = 0;
  v5 = 0;
  if ( *a1 == 48 && ((v6 = (unsigned __int8)a1[1], v6 == 120) || v6 == 88) )
  {
    if ( a1[2] )
    {
      v7 = 2;
      while ( 1 )
      {
        v8 = (unsigned __int8)a1[v7];
        if ( !a1[v7] )
        {
          *a2 = v5;
          result = 1;
          goto LABEL_21;
        }
        if ( (unsigned int)(v8 - 65) > 5 && (unsigned int)(v8 - 97) > 5 && (unsigned int)(v8 - 48) > 9 )
          break;
        if ( (unsigned int)(v8 - 48) > 9 )
        {
          if ( (unsigned int)(v8 - 65) > 5 )
            v9 = v8 - 87;
          else
            v9 = v8 - 55;
        }
        else
        {
          v9 = v8 - 48;
        }
        v5 = v9 + 16 * v5;
        if ( ++v7 >= 0xB )
          goto LABEL_21;
      }
      result = 0;
LABEL_21:
      if ( v7 >= 0xB )
        return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    while ( 1 )
    {
      v10 = (unsigned __int8)a1[v3];
      if ( !a1[v3] )
      {
        *a2 = v5;
        result = 1;
        goto LABEL_39;
      }
      if ( (v10 == 107 || v10 == 75) && v3 )
      {
        *a2 = v5 << 10;
        result = 1;
        goto LABEL_39;
      }
      if ( (v10 == 109 || v10 == 77) && v3 )
      {
        *a2 = v5 << 20;
        result = 1;
        goto LABEL_39;
      }
      if ( (unsigned int)(v10 - 48) > 9 )
        break;
      v5 = 10 * v5 - 48 + v10;
      if ( ++v3 >= 0xB )
        goto LABEL_39;
    }
    result = 0;
LABEL_39:
    if ( v3 >= 0xB )
      return 0;
  }
  return result;
}

//----- (0801A140) --------------------------------------------------------
int *sub_801A140()
{
  int *result; // r0

  sub_80131F0();
  if ( sub_80253CC() != 1 )
    sub_80248A0();
  result = (int *)(unsigned __int16)++word_20000262;
  ++word_20000028;
  if ( (unsigned __int16)word_20000262 >= 0x3E8u )
  {
    word_20000262 = 0;
    ++word_2000002A;
    result = &dword_2000002C;
    ++dword_2000002C;
  }
  return result;
}
// 20000028: using guessed type __int16 word_20000028;
// 2000002A: using guessed type __int16 word_2000002A;
// 2000002C: using guessed type int dword_2000002C;
// 20000262: using guessed type __int16 word_20000262;

//----- (0801A190) --------------------------------------------------------
int *sub_801A190()
{
  int *result; // r0

  result = &CPACR;
  CPACR |= 0xF00000u;
  return result;
}
// E000ED88: using guessed type int CPACR;

//----- (0801A1A0) --------------------------------------------------------
int __fastcall sub_801A1A0(_BYTE *a1)
{
  _BYTE *v1; // r0
  int v2; // r4
  int v3; // r0
  int v4; // r4
  int v5; // r0
  int v6; // r4
  unsigned __int8 *v7; // r0
  int v8; // r4
  int v9; // r0
  int v11; // [sp+Ch] [bp-1Ch] BYREF
  int v12; // [sp+10h] [bp-18h]
  int v13; // [sp+14h] [bp-14h]
  int v14; // [sp+18h] [bp-10h]

  if ( !a1 )
    return 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v1 = sub_8002480(a1, 72);
  v2 = (int)v1;
  if ( !v1 )
    return 0;
  v12 = sub_8002644(v1 + 3);
  v3 = sub_80023CE(v2, 0x7Cu);
  v4 = v3;
  if ( !v3 )
    return 0;
  v13 = sub_8002644((char *)(v3 + 1));
  v5 = sub_80023CE(v4 + 1, 0x7Cu);
  v6 = v5;
  if ( v5 )
  {
    v14 = sub_8002644((char *)(v5 + 1));
    v7 = strstr((unsigned __int8 *)(v6 + 1), "HME-");
    v8 = (int)v7;
    if ( v7 )
    {
      byte_200015DC = sub_8002644((char *)v7 + 4);
      v9 = sub_80023CE(v8, 0x7Cu);
      if ( v9 )
        v11 = (int)(double)sub_8002644((char *)(v9 + 1));
    }
    else
    {
      byte_200015DC = 1;
    }
  }
  sub_8024A40(dword_20000434, (unsigned int)&v11, 0, 2);
  sub_801A88C(
    (int)"%s %d power1:%d power2:%d power3:%d,total_power:%d\r\n",
    "pe: %s, id: %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
    202,
    v12,
    v13,
    v14,
    v11);
  return 1;
}
// 20000434: using guessed type int dword_20000434;
// 200015DC: using guessed type char byte_200015DC;

//----- (0801A2B0) --------------------------------------------------------
int sub_801A2B0()
{
  return sub_80147DC((int)&dword_20001A08);
}
// 20001A08: using guessed type int dword_20001A08;

//----- (0801A2BC) --------------------------------------------------------
int sub_801A2BC()
{
  return sub_80147DC((int)&dword_20001AEC);
}
// 20001AEC: using guessed type int dword_20001AEC;

//----- (0801A2C8) --------------------------------------------------------
int sub_801A2C8()
{
  return sub_80147DC((int)&dword_20001A54);
}
// 20001A54: using guessed type int dword_20001A54;

//----- (0801A2D4) --------------------------------------------------------
unsigned int *__fastcall sub_801A2D4(unsigned int *result, unsigned int *a2)
{
  unsigned int v2; // r2

  v2 = *result;
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)0x40000000
    || result == (unsigned int *)1073742848
    || result == (unsigned int *)1073743872
    || result == (unsigned int *)1073744896
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073827840 )
  {
    v2 = a2[1] | v2 & 0xFFFFFF8F;
  }
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)0x40000000
    || result == (unsigned int *)1073742848
    || result == (unsigned int *)1073743872
    || result == (unsigned int *)1073744896
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073823744
    || result == (unsigned int *)1073824768
    || result == (unsigned int *)1073825792
    || result == (unsigned int *)1073827840 )
  {
    v2 = a2[3] | v2 & 0xFFFFFCFF;
  }
  *result = v2 & 0xFFFFFF7F | a2[5];
  result[11] = a2[2];
  result[10] = *a2;
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073823744
    || result == (unsigned int *)1073824768
    || result == (unsigned int *)1073825792
    || result == (unsigned int *)1073827840 )
  {
    result[12] = a2[4];
  }
  result[5] = 1;
  return result;
}

//----- (0801A3A8) --------------------------------------------------------
int __fastcall sub_801A3A8(int result, char a2, int a3)
{
  char v3; // r1

  v3 = a2 & 0x1F;
  *(_DWORD *)(result + 32) &= ~(1 << v3);
  *(_DWORD *)(result + 32) |= a3 << v3;
  return result;
}

//----- (0801A3C2) --------------------------------------------------------
int __fastcall sub_801A3C2(int result, char a2, int a3)
{
  char v3; // r1

  v3 = a2 & 0x1F;
  *(_DWORD *)(result + 32) &= ~(4 << v3);
  *(_DWORD *)(result + 32) |= a3 << v3;
  return result;
}

//----- (0801A3DC) --------------------------------------------------------
_DWORD *__fastcall sub_801A3DC(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~1u;
  v2 = result[1];
  v3 = *a2 | result[6] & 0xFFFEFF8C;
  v4 = a2[2] | result[8] & 0xFFFFFFFD;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v4 = a2[3] & 0xFFFFFFFB | a2[2] & 0xFFFFFFF3 | result[8] & 0xFFFFFFF1;
  }
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = a2[6] | a2[5] | v2 & 0xFFFFFCFF;
  }
  result[1] = v2;
  result[6] = v3;
  result[13] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801A48C) --------------------------------------------------------
_DWORD *__fastcall sub_801A48C(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r5
  unsigned int v4; // r3

  result[8] &= ~0x10u;
  v2 = result[1];
  v3 = result[6] & 0xFEFF8CFF | (*a2 << 8);
  v4 = result[8] & 0xFFFFFFDF | (16 * a2[2]);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFFFF1F | (16 * a2[2]) & 0xFFFFFF3F | (16 * a2[3]) & 0xFFFFFFBF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFFF3FF | (4 * a2[5]) | (4 * a2[6]);
  }
  result[1] = v2;
  result[6] = v3;
  result[14] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801A530) --------------------------------------------------------
_DWORD *__fastcall sub_801A530(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x100u;
  v2 = result[1];
  v3 = *a2 | result[7] & 0xFFFEFF8C;
  v4 = result[8] & 0xFFFFFDFF | (a2[2] << 8);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFFF1FF | (a2[2] << 8) & 0xFFFFF3FF | (a2[3] << 8) & 0xFFFFFBFF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFFCFFF | (16 * a2[5]) | (16 * a2[6]);
  }
  result[1] = v2;
  result[7] = v3;
  result[15] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801A5D4) --------------------------------------------------------
_DWORD *__fastcall sub_801A5D4(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r5
  unsigned int v4; // r3

  result[8] &= ~0x1000u;
  v2 = result[1];
  v3 = result[7] & 0xFEFF8CFF | (*a2 << 8);
  v4 = result[8] & 0xFFFFDFFF | (a2[2] << 12);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFF1FFF | (a2[2] << 12) & 0xFFFF3FFF | (a2[3] << 12) & 0xFFFFBFFF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFF3FFF | (a2[5] << 6) | (a2[6] << 6);
  }
  result[1] = v2;
  result[7] = v3;
  result[16] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801A678) --------------------------------------------------------
_DWORD *__fastcall sub_801A678(_DWORD *result, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x10000u;
  v2 = result[1];
  v3 = *(_DWORD *)a2 | result[20] & 0xFFFEFF8F;
  v4 = result[8] & 0xFFFDFFFF | (*(unsigned __int16 *)(a2 + 8) << 16);
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFEFFFF | (*(_DWORD *)(a2 + 20) << 8);
  }
  result[1] = v2;
  result[20] = v3;
  result[18] = *(_DWORD *)(a2 + 4);
  result[8] = v4;
  return result;
}

//----- (0801A6F0) --------------------------------------------------------
_DWORD *__fastcall sub_801A6F0(_DWORD *result, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x100000u;
  v2 = result[1];
  v3 = result[20] & 0xFEFF8FFF | (*(_DWORD *)a2 << 8);
  v4 = result[8] & 0xFFDFFFFF | (*(unsigned __int16 *)(a2 + 8) << 20);
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFBFFFF | (*(_DWORD *)(a2 + 20) << 10);
  }
  result[1] = v2;
  result[20] = v3;
  result[19] = *(_DWORD *)(a2 + 4);
  result[8] = v4;
  return result;
}

//----- (0801A76C) --------------------------------------------------------
int __fastcall sub_801A76C(int result, char a2, int a3, char a4)
{
  int v4; // r4
  int v5; // r5
  unsigned int v6; // r4

  *(_DWORD *)(result + 32) &= ~1u;
  v4 = *(_DWORD *)(result + 24);
  v5 = *(_DWORD *)(result + 32);
  if ( result == 1073818624
    || result == 0x40000000
    || result == 1073742848
    || result == 1073743872
    || result == 1073744896
    || result == 1073820672
    || result == 1073823744
    || result == 1073827840 )
  {
    v6 = v4 & 0xFFFFFFFC | a3;
  }
  else
  {
    v6 = v4 | 1;
  }
  *(_DWORD *)(result + 24) = v6 & 0xFFFFFF0F | (unsigned __int8)(16 * a4);
  *(_DWORD *)(result + 32) = a2 & 0xA | v5 & 0xFFFFFFF5;
  return result;
}

//----- (0801A7EC) --------------------------------------------------------
int __fastcall sub_801A7EC(int result, int a2, int a3, __int16 a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x10u;
  v4 = (16 * a2) & 0xA0 | *(_DWORD *)(result + 32) & 0xFFFFFF5F;
  *(_DWORD *)(result + 24) = (unsigned __int16)(a4 << 12)
                           | *(_DWORD *)(result + 24) & 0xFFFF0CFF
                           | (a3 << 8) & 0xFFFF0FFF;
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801A822) --------------------------------------------------------
int __fastcall sub_801A822(int result, int a2, int a3, char a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x100u;
  v4 = (a2 << 8) & 0xA00 | *(_DWORD *)(result + 32) & 0xFFFFF5FF;
  *(_DWORD *)(result + 28) = *(_DWORD *)(result + 28) & 0xFFFFFF0C | a3 & 0xFFFFFF0F | (unsigned __int8)(16 * a4);
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801A854) --------------------------------------------------------
int __fastcall sub_801A854(int result, int a2, int a3, __int16 a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x1000u;
  v4 = (a2 << 12) & 0xA000 | *(_DWORD *)(result + 32) & 0xFFFF5FFF;
  *(_DWORD *)(result + 28) = (unsigned __int16)(a4 << 12)
                           | *(_DWORD *)(result + 28) & 0xFFFF0CFF
                           | (a3 << 8) & 0xFFFF0FFF;
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801A88C) --------------------------------------------------------
int sub_801A88C(int a1, ...)
{
  int result; // r0
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  result = (unsigned __int8)byte_200036AD;
  if ( byte_200036AD == 2 )
  {
    sub_801E220(a1, (int)varg_r1);
    return 0;
  }
  return result;
}
// 200036AD: using guessed type char byte_200036AD;

//----- (0801A940) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall SysTick_handler(_DWORD **a1, _DWORD *a2, int a3)
{
  char v3; // r4
  int v4; // r5

  *(_BYTE *)(a3 + 3) = v3;
  sub_8014C4C(a1, a2, a3);
  sub_8014ED8((int)&dword_20001B38, 0);
  return sub_8014ED8(v4 + 452, 4);
}
// 801A956: positive sp value 20 has been found
// 801A940: could not find valid save-restore pair for r6
// 801A940: could not find valid save-restore pair for r7
// 801A940: could not find valid save-restore pair for r8
// 801A940: could not find valid save-restore pair for r9
// 801A940: could not find valid save-restore pair for r10
// 801A940: variable 'v3' is possibly undefined
// 801A94E: variable 'v4' is possibly undefined
// 20001B38: using guessed type int dword_20001B38;

//----- (0801A96C) --------------------------------------------------------
int sub_801A96C()
{
  return sub_8015004((int)&dword_20001B38, 12);
}
// 20001B38: using guessed type int dword_20001B38;

//----- (0801A978) --------------------------------------------------------
int sub_801A978()
{
  return sub_8014ED8((int)&dword_20001B38, 12);
}
// 20001B38: using guessed type int dword_20001B38;

//----- (0801A984) --------------------------------------------------------
int sub_801A984()
{
  return sub_801A990();
}
// 801A990: using guessed type int sub_801A990(void);

//----- (0801A990) --------------------------------------------------------
void __fastcall sub_801A990(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // r4
  int i; // r0

  dword_20001A08 = 1073827840;
  dword_20001A0C = 169;
  dword_20001A10 = v10;
  dword_20001A14 = 65534;
  sub_80145C8((int)&dword_20001A08);
  a5 = 10;
  a6 = 1;
  a7 = v10;
  a8 = v10;
  sub_8014508((int)&dword_20001A08, &a5, 0);
  if ( sub_8014308(&dword_20001A08, 3, 0) )
    sub_80058BC();
  for ( i = 0; i < 4; ++i )
    dword_200019F8[i] = 10000;
  sub_8014654((unsigned __int8 *)&dword_20001A08, 0);
  __asm { POP             {R0-R4,PC} }
}
// 801A9E8: unbalanced stack, ignored a potential tail call
// 801A99A: variable 'v10' is possibly undefined
// 200019F8: using guessed type _DWORD dword_200019F8[4];
// 20001A08: using guessed type int dword_20001A08;
// 20001A0C: using guessed type int dword_20001A0C;
// 20001A10: using guessed type int dword_20001A10;
// 20001A14: using guessed type int dword_20001A14;

//----- (0801A9F4) --------------------------------------------------------
int sub_801A9F4()
{
  dword_20001AA0 = 1073818624;
  dword_20001AA4 = 16;
  dword_20001AA8 = 0;
  dword_20001AAC = 399;
  dword_20001AB0 = 0;
  dword_20001AB4 = 0;
  dword_20001AB8 = 128;
  sub_8014D82((int)&dword_20001AA0);
  dword_200019A4 = 96;
  dword_200019A8 = 200;
  dword_200019B0 = 0;
  dword_200019B4 = 0;
  dword_200019BC = 0;
  sub_8014C4C((_DWORD **)&dword_20001AA0, &dword_200019A4, 0);
  sub_801422C((int)&dword_20001AA0, 0);
  return sub_801AA4C(200);
}
// 200019A4: using guessed type int dword_200019A4;
// 200019A8: using guessed type int dword_200019A8;
// 200019B0: using guessed type int dword_200019B0;
// 200019B4: using guessed type int dword_200019B4;
// 200019BC: using guessed type int dword_200019BC;
// 20001AA0: using guessed type int dword_20001AA0;
// 20001AA4: using guessed type int dword_20001AA4;
// 20001AA8: using guessed type int dword_20001AA8;
// 20001AAC: using guessed type int dword_20001AAC;
// 20001AB0: using guessed type int dword_20001AB0;
// 20001AB4: using guessed type int dword_20001AB4;
// 20001AB8: using guessed type int dword_20001AB8;

//----- (0801AA4C) --------------------------------------------------------
int __fastcall sub_801AA4C(int result)
{
  if ( result <= 400 )
  {
    if ( result < 0 )
      result = 0;
  }
  else
  {
    result = 400;
  }
  *(_DWORD *)(dword_20001AA0 + 52) = result;
  return result;
}
// 20001AA0: using guessed type int dword_20001AA0;

//----- (0801AA6C) --------------------------------------------------------
unsigned int __fastcall sub_801AA6C(unsigned int result)
{
  if ( result > 0xE77 )
    result = 3704;
  *(_DWORD *)(dword_20001B38 + 52) = result;
  return result;
}
// 20001B38: using guessed type int dword_20001B38;

//----- (0801AA84) --------------------------------------------------------
unsigned int __fastcall sub_801AA84(unsigned int result)
{
  if ( result > 0xE77 )
    result = 3704;
  *(_DWORD *)(dword_20001B84 + 56) = result;
  return result;
}
// 20001B84: using guessed type int dword_20001B84;

//----- (0801AA9C) --------------------------------------------------------
int sub_801AA9C()
{
  dword_20001A54 = 1073746944;
  dword_20001A58 = 169;
  dword_20001A5C = 0;
  return IRQ_80_handler();
}
// 801AAB0: using guessed type int IRQ_80_handler(void);
// 20001A54: using guessed type int dword_20001A54;
// 20001A58: using guessed type int dword_20001A58;
// 20001A5C: using guessed type int dword_20001A5C;

//----- (0801AAB0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall IRQ_80_handler(int a1, int a2)
{
  *(_DWORD *)(a1 + 12) = a2;
  sub_801439A(a1);
  return IRQ_30_handler(&dword_20001A54);
}
// 801AABA: positive sp value 8 has been found
// 20001A54: using guessed type int dword_20001A54;

//----- (0801AACC) --------------------------------------------------------
int __fastcall sub_801AACC(_WORD *a1, unsigned int a2)
{
  if ( *a1 )
  {
    if ( (unsigned __int16)(word_20000028 - *a1) >= a2 )
    {
      *a1 = 0;
      return 1;
    }
  }
  else
  {
    *a1 = word_20000028;
  }
  return 0;
}
// 20000028: using guessed type __int16 word_20000028;

//----- (0801AAF4) --------------------------------------------------------
int __fastcall sub_801AAF4(_WORD *a1, unsigned int a2)
{
  if ( *a1 )
  {
    if ( (unsigned __int16)(word_2000002A - *a1) >= a2 )
    {
      *a1 = 0;
      return 1;
    }
  }
  else
  {
    *a1 = word_2000002A;
  }
  return 0;
}
// 2000002A: using guessed type __int16 word_2000002A;

//----- (0801AB1C) --------------------------------------------------------
void sub_801AB1C()
{
  if ( dword_20005058 + 20 <= (unsigned int)dword_2000002C || (unsigned int)dword_2000002C <= 0x15 )
  {
    dword_200004F8 = 0;
  }
  else if ( dword_20005050 >= dword_20002E9F )
  {
    if ( dword_20005054 <= dword_20002EA3 )
      dword_200004F8 = 0;
    else
      dword_200004F8 = 2500;
  }
  else
  {
    dword_200004F8 = -2500;
  }
  sub_8003234();
}
// 2000002C: using guessed type int dword_2000002C;
// 200004F8: using guessed type int dword_200004F8;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EA3: using guessed type int dword_20002EA3;
// 20005050: using guessed type int dword_20005050;
// 20005054: using guessed type int dword_20005054;
// 20005058: using guessed type int dword_20005058;

//----- (0801AB7C) --------------------------------------------------------
int __fastcall sub_801AB7C(int result)
{
  int v1; // r1

  if ( *(_DWORD *)(result + 100) )
  {
    v1 = (*(_DWORD *)(*(_DWORD *)result + 8) >> 25) & 7;
    *(_WORD *)(result + 106) = 8
                             * (unsigned int)*((unsigned __int8 *)sub_802615C
                                             + (*(_DWORD *)(*(_DWORD *)result + 8) >> 29))
                             / *((unsigned __int8 *)&dword_8026160[1] + (*(_DWORD *)(*(_DWORD *)result + 8) >> 29));
    *(_WORD *)(result + 104) = 8
                             * (unsigned int)*((unsigned __int8 *)sub_802615C + v1)
                             / *((unsigned __int8 *)&dword_8026160[1] + v1);
  }
  else
  {
    result += 104;
    *(_WORD *)(result + 2) = 1;
    *(_WORD *)result = 1;
  }
  return result;
}
// 802615C: using guessed type int sub_802615C();
// 8026160: using guessed type int[3];

//----- (0801ABC4) --------------------------------------------------------
int __fastcall sub_801ABC4(int result)
{
  int v1; // r1
  int v2; // r2

  if ( *(unsigned __int8 *)(result + 40) << 31 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFDFFFF | *(_DWORD *)(result + 44);
  if ( (*(_BYTE *)(result + 40) & 2) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFEFFFF | *(_DWORD *)(result + 48);
  if ( (*(_BYTE *)(result + 40) & 4) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFBFFFF | *(_DWORD *)(result + 52);
  if ( (*(_BYTE *)(result + 40) & 8) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFF7FFF | *(_DWORD *)(result + 56);
  if ( (*(_BYTE *)(result + 40) & 0x10) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 8) = *(_DWORD *)(*(_DWORD *)result + 8) & 0xFFFFEFFF | *(_DWORD *)(result + 60);
  if ( (*(_BYTE *)(result + 40) & 0x20) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 8) = *(_DWORD *)(*(_DWORD *)result + 8) & 0xFFFFDFFF | *(_DWORD *)(result + 64);
  if ( (*(_BYTE *)(result + 40) & 0x40) != 0 )
  {
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFEFFFFF | *(_DWORD *)(result + 68);
    if ( *(_DWORD *)(result + 68) == 0x100000 )
      *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFF9FFFFF | *(_DWORD *)(result + 72);
  }
  if ( (*(_BYTE *)(result + 40) & 0x80) != 0 )
  {
    v1 = *(_DWORD *)result;
    v2 = *(_DWORD *)(*(_DWORD *)result + 4);
    result = *(_DWORD *)(result + 76);
    *(_DWORD *)(v1 + 4) = v2 & 0xFFF7FFFF | result;
  }
  return result;
}

//----- (0801AC8C) --------------------------------------------------------
int __fastcall sub_801AC8C(int a1)
{
  int v2; // r7
  int v4; // r4

  *(_DWORD *)(a1 + 140) = 0;
  v2 = sub_8012298();
  if ( (**(_DWORD **)a1 & 8) != 0 && sub_801B6D0((unsigned int **)a1, 0x200000, 0, v2, 0x1FFFFFFu)
    || (**(_DWORD **)a1 & 4) != 0 && sub_801B6D0((unsigned int **)a1, 0x400000, 0, v2, 0x1FFFFFFu) )
  {
    return 3;
  }
  v4 = a1 + 108;
  *(_DWORD *)(v4 + 24) = 32;
  *(_DWORD *)(v4 + 28) = 32;
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(v4 + 20) = 0;
  return 0;
}

//----- (0801ACEC) --------------------------------------------------------
int __fastcall sub_801ACEC(int a1)
{
  int v1; // r0

  v1 = *(_DWORD *)(a1 + 40);
  *(_WORD *)(v1 + 94) = 0;
  *(_WORD *)(v1 + 86) = 0;
  return nullsub_32();
}
// 8015348: using guessed type int nullsub_32(void);

//----- (0801AD00) --------------------------------------------------------
int __fastcall sub_801AD00(int a1)
{
  int v1; // r4
  int v2; // r5

  v1 = *(_DWORD *)(a1 + 40);
  v2 = *(_DWORD *)(v1 + 136);
  if ( (*(_DWORD *)(*(_DWORD *)v1 + 8) & 0x80) != 0 && *(_DWORD *)(v1 + 132) == 33 )
  {
    *(_WORD *)(v1 + 86) = 0;
    sub_801AE3C(v1);
  }
  if ( (*(_DWORD *)(*(_DWORD *)v1 + 8) & 0x40) != 0 && v2 == 34 )
  {
    *(_WORD *)(v1 + 94) = 0;
    sub_801ADC4(v1);
  }
  *(_DWORD *)(v1 + 140) |= 0x10u;
  return nullsub_32(v1);
}
// 8015348: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801AD50) --------------------------------------------------------
int __fastcall sub_801AD50(int a1)
{
  _DWORD *v1; // r0

  v1 = *(_DWORD **)(a1 + 40);
  *((_WORD *)v1 + 47) = 0;
  *(_DWORD *)(*v1 + 32) = 15;
  *(_DWORD *)(*v1 + 24) |= 8u;
  v1[34] = 32;
  v1[27] = 0;
  return nullsub_30();
}
// 8015242: using guessed type int nullsub_30(void);

//----- (0801AD78) --------------------------------------------------------
int __fastcall sub_801AD78(int a1)
{
  int result; // r0
  unsigned int *v3; // r1
  unsigned int v4; // r2
  unsigned int *v5; // r1
  unsigned int v6; // r2

  result = *(_DWORD *)(a1 + 40);
  if ( (**(_DWORD **)a1 & 0x20) != 0 )
    return nullsub_33(result);
  *(_WORD *)(result + 86) = 0;
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xFFFFFF7F, v3) );
  do
  {
    v5 = *(unsigned int **)result;
    v6 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v6 | 0x40, v5) );
  return result;
}
// 80159C8: using guessed type int __fastcall nullsub_33(_DWORD);

//----- (0801ADBA) --------------------------------------------------------
int __fastcall sub_801ADBA(int a1)
{
  return nullsub_34(*(_DWORD *)(a1 + 40));
}
// 80159CA: using guessed type int __fastcall nullsub_34(_DWORD);

//----- (0801ADC4) --------------------------------------------------------
int __fastcall sub_801ADC4(int result)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2
  unsigned int *v3; // r1
  unsigned int v4; // r2
  unsigned int *v5; // r1
  unsigned int v6; // r2

  do
  {
    v1 = *(unsigned int **)result;
    v2 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v2 & 0xFFFFFEDF, v1) );
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xEFFFFFFE, v3) );
  if ( *(_DWORD *)(result + 108) == 1 )
  {
    do
    {
      v5 = *(unsigned int **)result;
      v6 = __ldrex(*(unsigned int **)result);
    }
    while ( __strex(v6 & 0xFFFFFFEF, v5) );
  }
  *(_DWORD *)(result + 136) = 32;
  *(_DWORD *)(result + 108) = 0;
  *(_DWORD *)(result + 112) = 0;
  return result;
}

//----- (0801AE18) --------------------------------------------------------
int __fastcall sub_801AE18(int a1)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2

  do
  {
    v1 = *(unsigned int **)a1;
    v2 = __ldrex(*(unsigned int **)a1);
  }
  while ( __strex(v2 & 0xFFFFFFBF, v1) );
  *(_DWORD *)(a1 + 132) = 32;
  *(_DWORD *)(a1 + 116) = 0;
  return nullsub_33(a1);
}
// 80159C8: using guessed type int __fastcall nullsub_33(_DWORD);

//----- (0801AE3C) --------------------------------------------------------
int __fastcall sub_801AE3C(int result)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2
  unsigned int *v3; // r1
  unsigned int v4; // r2

  do
  {
    v1 = *(unsigned int **)result;
    v2 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v2 & 0xFFFFFF3F, v1) );
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xFF7FFFFF, v3) );
  *(_DWORD *)(result + 132) = 32;
  return result;
}

//----- (0801AE6A) --------------------------------------------------------
int __fastcall sub_801AE6A(int *a1)
{
  __int16 v1; // r2
  int v2; // r1
  int result; // r0
  int *v4; // r0
  _WORD *v5; // t1
  int v6; // r1
  unsigned int *v7; // r1
  unsigned int v8; // r2
  unsigned int *v9; // r1
  unsigned int v10; // r2
  unsigned int *v11; // r1
  unsigned int v12; // r2

  v1 = *((_WORD *)a1 + 48);
  v2 = *a1;
  if ( a1[34] == 34 )
  {
    v5 = (_WORD *)a1[22];
    v4 = a1 + 22;
    *v5 = *(_DWORD *)(v2 + 36) & v1;
    *v4 += 2;
    v6 = (unsigned __int16)--*((_WORD *)v4 + 3);
    result = (int)(v4 - 22);
    if ( !v6 )
    {
      do
      {
        v7 = *(unsigned int **)result;
        v8 = __ldrex(*(unsigned int **)result);
      }
      while ( __strex(v8 & 0xFFFFFEDF, v7) );
      do
      {
        v9 = (unsigned int *)(*(_DWORD *)result + 8);
        v10 = __ldrex(v9);
      }
      while ( __strex(v10 & 0xFFFFFFFE, v9) );
      *(_DWORD *)(result + 136) = 32;
      *(_DWORD *)(result + 112) = 0;
      if ( *(_DWORD *)(result + 108) == 1 )
      {
        *(_DWORD *)(result + 108) = 0;
        do
        {
          v11 = *(unsigned int **)result;
          v12 = __ldrex(*(unsigned int **)result);
        }
        while ( __strex(v12 & 0xFFFFFFEF, v11) );
        if ( (~*(_DWORD *)(*(_DWORD *)result + 28) & 0x10) == 0 )
          *(_DWORD *)(*(_DWORD *)result + 32) = 16;
        return nullsub_26(result, *(unsigned __int16 *)(result + 92));
      }
      else
      {
        return sub_8015834((int *)result);
      }
    }
  }
  else
  {
    result = *(_DWORD *)(v2 + 24) | 8;
    *(_DWORD *)(v2 + 24) = result;
  }
  return result;
}
// 80151A2: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);

//----- (0801AF0C) --------------------------------------------------------
unsigned int *__fastcall sub_801AF0C(_DWORD *a1)
{
  __int16 v2; // r7
  unsigned int *result; // r0
  unsigned int v4; // r5
  unsigned int v5; // r9
  unsigned int v6; // r6
  int v7; // r8
  unsigned int *v8; // r0
  unsigned int v9; // r1
  unsigned int *v10; // r0
  unsigned int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int *v15; // r0
  unsigned int v16; // r1

  v2 = *((_WORD *)a1 + 48);
  result = (unsigned int *)*a1;
  v4 = result[7];
  v5 = *result;
  v6 = result[2];
  if ( a1[34] == 34 )
  {
    v7 = *((unsigned __int16 *)a1 + 52);
    while ( v7 && (v4 & 0x20) != 0 )
    {
      *(_WORD *)a1[22] = *(_DWORD *)(*a1 + 36) & v2;
      a1[22] += 2;
      --*((_WORD *)a1 + 47);
      v4 = *(_DWORD *)(*a1 + 28);
      if ( v4 << 29 )
      {
        if ( v4 << 31 && (v5 & 0x100) != 0 )
        {
          *(_DWORD *)(*a1 + 32) = 1;
          a1[35] |= 1u;
        }
        if ( (v4 & 2) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 2;
          a1[35] |= 4u;
        }
        if ( (v4 & 4) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 4;
          a1[35] |= 2u;
        }
        if ( a1[35] )
        {
          nullsub_32(a1);
          a1[35] = 0;
        }
      }
      if ( !*((_WORD *)a1 + 47) )
      {
        do
        {
          v8 = (unsigned int *)*a1;
          v9 = __ldrex((unsigned int *)*a1);
        }
        while ( __strex(v9 & 0xFFFFFEFF, v8) );
        do
        {
          v10 = (unsigned int *)(*a1 + 8);
          v11 = __ldrex(v10);
        }
        while ( __strex(v11 & 0xEFFFFFFE, v10) );
        a1[34] = 32;
        a1[28] = 0;
        if ( a1[27] == 1 )
        {
          a1[27] = 0;
          do
          {
            v15 = (unsigned int *)*a1;
            v16 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v16 & 0xFFFFFFEF, v15) );
          if ( (~*(_DWORD *)(*a1 + 28) & 0x10) == 0 )
            *(_DWORD *)(*a1 + 32) = 16;
          nullsub_26(a1, *((unsigned __int16 *)a1 + 46));
        }
        else
        {
          sub_8015834(a1);
        }
      }
    }
    result = (unsigned int *)*((unsigned __int16 *)a1 + 47);
    if ( *((_WORD *)a1 + 47) && *((unsigned __int16 *)a1 + 52) > (unsigned int)result )
    {
      do
      {
        v12 = (unsigned int *)(*a1 + 8);
        v13 = __ldrex(v12);
      }
      while ( __strex(v13 & 0xEFFFFFFF, v12) );
      a1[28] = 134329963;
      do
      {
        result = (unsigned int *)*a1;
        v14 = __ldrex((unsigned int *)*a1);
      }
      while ( __strex(v14 | 0x20, result) );
    }
  }
  else
  {
    result[6] |= 8u;
  }
  return result;
}
// 80151A2: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 8015348: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801B080) --------------------------------------------------------
int __fastcall sub_801B080(int *a1)
{
  __int16 v1; // r2
  int v2; // r1
  int result; // r0
  int *v4; // r0
  _BYTE *v5; // t1
  int v6; // r1
  unsigned int *v7; // r1
  unsigned int v8; // r2
  unsigned int *v9; // r1
  unsigned int v10; // r2
  unsigned int *v11; // r1
  unsigned int v12; // r2

  v1 = *((_WORD *)a1 + 48);
  v2 = *a1;
  if ( a1[34] == 34 )
  {
    v5 = (_BYTE *)a1[22];
    v4 = a1 + 22;
    *v5 = *(_DWORD *)(v2 + 36) & v1;
    ++*v4;
    v6 = (unsigned __int16)--*((_WORD *)v4 + 3);
    result = (int)(v4 - 22);
    if ( !v6 )
    {
      do
      {
        v7 = *(unsigned int **)result;
        v8 = __ldrex(*(unsigned int **)result);
      }
      while ( __strex(v8 & 0xFFFFFEDF, v7) );
      do
      {
        v9 = (unsigned int *)(*(_DWORD *)result + 8);
        v10 = __ldrex(v9);
      }
      while ( __strex(v10 & 0xFFFFFFFE, v9) );
      *(_DWORD *)(result + 136) = 32;
      *(_DWORD *)(result + 112) = 0;
      if ( *(_DWORD *)(result + 108) == 1 )
      {
        *(_DWORD *)(result + 108) = 0;
        do
        {
          v11 = *(unsigned int **)result;
          v12 = __ldrex(*(unsigned int **)result);
        }
        while ( __strex(v12 & 0xFFFFFFEF, v11) );
        if ( (~*(_DWORD *)(*(_DWORD *)result + 28) & 0x10) == 0 )
          *(_DWORD *)(*(_DWORD *)result + 32) = 16;
        return nullsub_26(result, *(unsigned __int16 *)(result + 92));
      }
      else
      {
        return sub_8015834((int *)result);
      }
    }
  }
  else
  {
    result = *(_DWORD *)(v2 + 24) | 8;
    *(_DWORD *)(v2 + 24) = result;
  }
  return result;
}
// 80151A2: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);

//----- (0801B120) --------------------------------------------------------
unsigned int *__fastcall sub_801B120(_DWORD *a1)
{
  __int16 v2; // r7
  unsigned int *result; // r0
  unsigned int v4; // r5
  unsigned int v5; // r9
  unsigned int v6; // r6
  int v7; // r8
  unsigned int *v8; // r0
  unsigned int v9; // r1
  unsigned int *v10; // r0
  unsigned int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int *v15; // r0
  unsigned int v16; // r1

  v2 = *((_WORD *)a1 + 48);
  result = (unsigned int *)*a1;
  v4 = result[7];
  v5 = *result;
  v6 = result[2];
  if ( a1[34] == 34 )
  {
    v7 = *((unsigned __int16 *)a1 + 52);
    while ( v7 && (v4 & 0x20) != 0 )
    {
      *(_BYTE *)a1[22]++ = *(_DWORD *)(*a1 + 36) & v2;
      --*((_WORD *)a1 + 47);
      v4 = *(_DWORD *)(*a1 + 28);
      if ( v4 << 29 )
      {
        if ( v4 << 31 && (v5 & 0x100) != 0 )
        {
          *(_DWORD *)(*a1 + 32) = 1;
          a1[35] |= 1u;
        }
        if ( (v4 & 2) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 2;
          a1[35] |= 4u;
        }
        if ( (v4 & 4) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 4;
          a1[35] |= 2u;
        }
        if ( a1[35] )
        {
          nullsub_32(a1);
          a1[35] = 0;
        }
      }
      if ( !*((_WORD *)a1 + 47) )
      {
        do
        {
          v8 = (unsigned int *)*a1;
          v9 = __ldrex((unsigned int *)*a1);
        }
        while ( __strex(v9 & 0xFFFFFEFF, v8) );
        do
        {
          v10 = (unsigned int *)(*a1 + 8);
          v11 = __ldrex(v10);
        }
        while ( __strex(v11 & 0xEFFFFFFE, v10) );
        a1[34] = 32;
        a1[28] = 0;
        if ( a1[27] == 1 )
        {
          a1[27] = 0;
          do
          {
            v15 = (unsigned int *)*a1;
            v16 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v16 & 0xFFFFFFEF, v15) );
          if ( (~*(_DWORD *)(*a1 + 28) & 0x10) == 0 )
            *(_DWORD *)(*a1 + 32) = 16;
          nullsub_26(a1, *((unsigned __int16 *)a1 + 46));
        }
        else
        {
          sub_8015834(a1);
        }
      }
    }
    result = (unsigned int *)*((unsigned __int16 *)a1 + 47);
    if ( *((_WORD *)a1 + 47) && *((unsigned __int16 *)a1 + 52) > (unsigned int)result )
    {
      do
      {
        v12 = (unsigned int *)(*a1 + 8);
        v13 = __ldrex(v12);
      }
      while ( __strex(v13 & 0xEFFFFFFF, v12) );
      a1[28] = 134330497;
      do
      {
        result = (unsigned int *)*a1;
        v14 = __ldrex((unsigned int *)*a1);
      }
      while ( __strex(v14 | 0x20, result) );
    }
  }
  else
  {
    result[6] |= 8u;
  }
  return result;
}
// 80151A2: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 8015348: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801B294) --------------------------------------------------------
int __fastcall sub_801B294(_DWORD *a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r2
  int v5; // r0
  int v6; // r1
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r6
  signed __int64 v15; // r0
  unsigned int v16; // r2
  unsigned __int64 v17; // r0
  unsigned int v18; // r0
  unsigned int v19; // r0
  _DWORD *v20; // r4

  v2 = 0;
  *(_DWORD *)*a1 = *(_DWORD *)*a1 & 0xCFFF69F3 | a1[2] | a1[4] | a1[5] | a1[7];
  *(_DWORD *)(*a1 + 4) = *(_DWORD *)(*a1 + 4) & 0xFFFFCFFF | a1[3];
  v3 = a1[6];
  if ( *a1 != 1073774592 )
    v3 |= a1[8];
  *(_DWORD *)(*a1 + 8) = *(_DWORD *)(*a1 + 8) & 0x11FFF4FF | v3;
  *(_DWORD *)(*a1 + 44) = *(_DWORD *)(*a1 + 44) & 0xFFFFFFF0 | a1[9];
  v4 = *a1;
  if ( *a1 == 1073821696 )
  {
    v5 = MEMORY[0x40021088] & 3;
    if ( (MEMORY[0x40021088] & 3) != 0 )
    {
      switch ( v5 )
      {
        case 1:
          v6 = 4;
          break;
        case 2:
          v6 = 2;
          break;
        case 3:
          v6 = 8;
          break;
        default:
          v6 = 16;
          break;
      }
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    switch ( v4 )
    {
      case 1073759232:
        v7 = MEMORY[0x40021088] & 0xC;
        if ( (MEMORY[0x40021088] & 0xC) != 0 )
        {
          switch ( v7 )
          {
            case 4:
              v6 = 4;
              break;
            case 8:
              v6 = 2;
              break;
            case 12:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073760256:
        v8 = MEMORY[0x40021088] & 0x30;
        if ( (MEMORY[0x40021088] & 0x30) != 0 )
        {
          switch ( v8 )
          {
            case 16:
              v6 = 4;
              break;
            case 32:
              v6 = 2;
              break;
            case 48:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073761280:
        v9 = MEMORY[0x40021088] & 0xC0;
        if ( (MEMORY[0x40021088] & 0xC0) != 0 )
        {
          switch ( v9 )
          {
            case 64:
              v6 = 4;
              break;
            case 128:
              v6 = 2;
              break;
            case 192:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073762304:
        v10 = MEMORY[0x40021088] & 0x300;
        if ( (MEMORY[0x40021088] & 0x300) != 0 )
        {
          switch ( v10 )
          {
            case 256:
              v6 = 4;
              break;
            case 512:
              v6 = 2;
              break;
            case 768:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073774592:
        v11 = MEMORY[0x40021088] & 0xC00;
        if ( (MEMORY[0x40021088] & 0xC00) != 0 )
        {
          switch ( v11 )
          {
            case 1024:
              v6 = 4;
              break;
            case 2048:
              v6 = 2;
              break;
            case 3072:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      default:
        v6 = 16;
        break;
    }
  }
  v12 = 16000000;
  if ( v4 == 1073774592 )
  {
    if ( v6 )
    {
      if ( v6 != 2 )
      {
        if ( v6 == 4 )
        {
          v12 = sub_8013950();
        }
        else if ( v6 == 8 )
        {
          v12 = 0x8000;
        }
        else
        {
          v12 = 0;
          v2 = 1;
        }
      }
    }
    else
    {
      v12 = sub_8013908();
    }
    if ( v12 )
    {
      v13 = v12 / *((unsigned __int16 *)dword_8026144 + a1[9]);
      v14 = a1[1];
      if ( 3 * v14 <= v13 && v13 <= v14 << 12 )
      {
        v15 = v12 / (unsigned __int64)*((unsigned __int16 *)dword_8026144 + a1[9]);
        HIDWORD(v15) = v15 >> 24;
        v16 = (_DWORD)v15 << 8;
        LODWORD(v15) = v14 >> 1;
        v17 = ((unsigned __int64)v16 + v15) / v14;
        if ( (unsigned int)(v17 - 768) > 0xFFCFF )
          v2 = 1;
        else
          *(_DWORD *)(*a1 + 12) = v17;
      }
      else
      {
        v2 = 1;
      }
    }
  }
  else if ( a1[7] == 0x8000 )
  {
    switch ( v6 )
    {
      case 0:
        v12 = sub_8013908();
        break;
      case 1:
        v12 = sub_801392C();
        break;
      case 2:
        break;
      case 4:
        v12 = sub_8013950();
        break;
      case 8:
        v12 = 0x8000;
        break;
      default:
        v12 = 0;
        v2 = 1;
        break;
    }
    if ( v12 )
    {
      v18 = (2 * (v12 / *((unsigned __int16 *)dword_8026144 + a1[9])) + (a1[1] >> 1)) / a1[1];
      if ( v18 - 16 > 0xFFEF )
        v2 = 1;
      else
        *(_DWORD *)(*a1 + 12) = v18 & 0xFFF0 | (v18 >> 1) & 7;
    }
  }
  else
  {
    switch ( v6 )
    {
      case 0:
        v12 = sub_8013908();
        break;
      case 1:
        v12 = sub_801392C();
        break;
      case 2:
        break;
      case 4:
        v12 = sub_8013950();
        break;
      case 8:
        v12 = 0x8000;
        break;
      default:
        v12 = 0;
        v2 = 1;
        break;
    }
    if ( v12 )
    {
      v19 = (v12 / *((unsigned __int16 *)dword_8026144 + a1[9]) + (a1[1] >> 1)) / a1[1];
      if ( v19 - 16 > 0xFFEF )
        v2 = 1;
      else
        *(_DWORD *)(*a1 + 12) = (unsigned __int16)v19;
    }
  }
  v20 = a1 + 26;
  *((_WORD *)v20 + 1) = 1;
  *(_WORD *)v20 = 1;
  v20[2] = 0;
  v20[3] = 0;
  return v2;
}
// 801B578: using guessed type int dword_801B578;
// 8026144: using guessed type int dword_8026144[6];

//----- (0801B5A4) --------------------------------------------------------
int __fastcall sub_801B5A4(int a1, int a2, unsigned int a3)
{
  int v3; // r1
  unsigned int *v4; // r1
  unsigned int v5; // r3
  unsigned int *v6; // r1
  unsigned int v7; // r2
  unsigned int *v8; // r1
  unsigned int v9; // r2
  unsigned int *v10; // r1
  unsigned int v11; // r2
  unsigned int *v12; // r1
  unsigned int v13; // r2

  *(_DWORD *)(a1 + 88) = a2;
  *(_WORD *)(a1 + 92) = a3;
  *(_WORD *)(a1 + 94) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 == 4096 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      *(_WORD *)(a1 + 96) = 255;
    else
      *(_WORD *)(a1 + 96) = 511;
  }
  else if ( v3 )
  {
    if ( v3 == 0x10000000 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        *(_WORD *)(a1 + 96) = 63;
      else
        *(_WORD *)(a1 + 96) = 127;
    }
    else
    {
      *(_WORD *)(a1 + 96) = 0;
    }
  }
  else if ( *(_DWORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 96) = 127;
  }
  else
  {
    *(_WORD *)(a1 + 96) = 255;
  }
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 136) = 34;
  do
  {
    v4 = (unsigned int *)(*(_DWORD *)a1 + 8);
    v5 = __ldrex(v4);
  }
  while ( __strex(v5 | 1, v4) );
  if ( *(_DWORD *)(a1 + 100) == 0x20000000 && *(unsigned __int16 *)(a1 + 104) <= a3 )
  {
    if ( *(_DWORD *)(a1 + 8) == 4096 && !*(_DWORD *)(a1 + 16) )
      *(_DWORD *)(a1 + 112) = 134330125;
    else
      *(_DWORD *)(a1 + 112) = 134330657;
    *(_BYTE *)(a1 + 128) = 0;
    if ( *(_DWORD *)(a1 + 16) )
    {
      do
      {
        v6 = *(unsigned int **)a1;
        v7 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v7 | 0x100, v6) );
    }
    do
    {
      v8 = (unsigned int *)(*(_DWORD *)a1 + 8);
      v9 = __ldrex(v8);
    }
    while ( __strex(v9 | 0x10000000, v8) );
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) == 4096 && !*(_DWORD *)(a1 + 16) )
      *(_DWORD *)(a1 + 112) = 134329963;
    else
      *(_DWORD *)(a1 + 112) = 134330497;
    *(_BYTE *)(a1 + 128) = 0;
    if ( *(_DWORD *)(a1 + 16) )
    {
      do
      {
        v10 = *(unsigned int **)a1;
        v11 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v11 | 0x120, v10) );
    }
    else
    {
      do
      {
        v12 = *(unsigned int **)a1;
        v13 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v13 | 0x20, v12) );
    }
  }
  return 0;
}

//----- (0801B6D0) --------------------------------------------------------
int __fastcall sub_801B6D0(unsigned int **a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int *v9; // r0
  unsigned int v10; // r1
  unsigned int *v11; // r0
  unsigned int v12; // r1
  unsigned int **v13; // r4
  unsigned int *v15; // r0
  unsigned int v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r1
  unsigned int **v19; // r4

  while ( 1 )
  {
    do
    {
      if ( ((a2 & ~(*a1)[7]) == 0) != a3 )
        return 0;
    }
    while ( a5 == -1 );
    if ( sub_8012298() - a4 > a5 || !a5 )
      break;
    if ( (**a1 & 4) != 0 && (~(*a1)[7] & 0x800) == 0 )
    {
      (*a1)[8] = 2048;
      do
      {
        v9 = *a1;
        v10 = __ldrex(*a1);
      }
      while ( __strex(v10 & 0xFFFFFE5F, v9) );
      do
      {
        v11 = *a1 + 2;
        v12 = __ldrex(v11);
      }
      while ( __strex(v12 & 0xFFFFFFFE, v11) );
      v13 = a1 + 32;
      v13[1] = (unsigned int *)32;
      v13[2] = (unsigned int *)32;
      v13[3] = (unsigned int *)32;
      *(_BYTE *)v13 = 0;
      return 3;
    }
  }
  do
  {
    v15 = *a1;
    v16 = __ldrex(*a1);
  }
  while ( __strex(v16 & 0xFFFFFE5F, v15) );
  do
  {
    v17 = *a1 + 2;
    v18 = __ldrex(v17);
  }
  while ( __strex(v18 & 0xFFFFFFFE, v17) );
  v19 = a1 + 32;
  v19[1] = (unsigned int *)32;
  v19[2] = (unsigned int *)32;
  *(_BYTE *)v19 = 0;
  return 3;
}

//----- (0801B790) --------------------------------------------------------
BOOL __fastcall sub_801B790(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r0
  int v2; // r0
  unsigned int v3; // r5
  int v4; // r4
  int v5; // r0
  int v6; // r4

  v1 = strstr(a1, "+QIRD:");
  if ( !v1 )
    return 0;
  v2 = sub_80023CE((int)v1, 0x22u);
  if ( !v2 )
    return 0;
  v3 = v2 + 1;
  v4 = sub_80023CE(v2 + 1, 0x22u);
  if ( !v4 )
    return 0;
  dword_200115C8 = 0;
  dword_200115CC = 0;
  dword_200115D0 = 0;
  dword_200115D4 = 0;
  if ( (int)(v4 - v3) > 16 )
    return 0;
  qmemcpy((unsigned int)&dword_200115C8, v3, v4 - v3);
  v5 = sub_80023CE(v4, 0x2Cu);
  if ( !v5 )
    return 0;
  v6 = v5 + 1;
  word_20011072 = sub_8002644((char *)(v5 + 1));
  return sub_80023CE(v6, 0xAu) != 0;
}
// 20011072: using guessed type __int16 word_20011072;
// 200115C8: using guessed type int dword_200115C8;
// 200115CC: using guessed type int dword_200115CC;
// 200115D0: using guessed type int dword_200115D0;
// 200115D4: using guessed type int dword_200115D4;

//----- (0801B818) --------------------------------------------------------
int sub_801B818()
{
  return sub_801534C(&dword_2000171C);
}
// 2000171C: using guessed type int dword_2000171C;

//----- (0801B824) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_801B824(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  unsigned __int8 *v13; // r5
  unsigned int v14; // r7
  int v15; // r0
  unsigned int v16; // r5
  _BYTE *v17; // r0
  unsigned __int8 *v18; // r0
  __int16 v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r0
  char *v22; // r0
  char *v23; // r0
  __int16 v24; // r0
  unsigned __int8 *v25; // r0
  int v26; // r0
  char *v27; // r0
  unsigned __int8 v28[128]; // [sp-100h] [bp-228h] BYREF
  unsigned __int8 v29[132]; // [sp-80h] [bp-1A8h] BYREF

  sub_8002364(v29, 128);
  sub_8002364(v28, 128);
  if ( byte_200015E1 )
LABEL_108:
    __asm { POP.W           {R4-R11,PC} }
  switch ( byte_200015DF )
  {
    case 0:
      sub_801A88C((int)"00000000000000000000000 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801ECA0();
        if ( strstr(v29, "OK") )
        {
          sub_801A88C(
            (int)"%s %d success: %s\r\n",
            ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
            390,
            (const char *)v29);
          byte_200015DF = 1;
        }
        else
        {
          sub_801A88C(
            (int)"%s %d fail: %s\r\n",
            ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
            395,
            (const char *)v29);
        }
      }
      else
      {
        sub_801ECA0();
      }
      goto LABEL_106;
    case 1:
      sub_801A88C((int)"111111111111111111111111111 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ECA0();
      v13 = strstr(v29, "ip:");
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        409,
        (const char *)v29);
      if ( v13[3] == 48 )
      {
        sub_80232B4(2000);
        byte_200015DF = 0;
      }
      else if ( v13 )
      {
        v14 = (unsigned int)(v13 + 3);
        v15 = sub_80023CE((int)(v13 + 3), 0x2Cu);
        if ( v15 )
        {
          v16 = v15 - v14;
          if ( (int)(v15 - v14) <= 16 )
          {
            sub_8002364(byte_20011074, 32);
            dword_200115B8 = 0;
            dword_200115BC = 0;
            dword_200115C0 = 0;
            dword_200115C4 = 0;
            qmemcpy((unsigned int)byte_20011074, v14, v16);
            qmemcpy((unsigned int)&dword_200115B8, (unsigned int)byte_20011074, v16);
            sub_801A88C(
              (int)"ip:%s %d %s",
              ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
              426,
              byte_20011074);
            v17 = sub_8002480(&dword_200115B8, 46);
            if ( v17 )
            {
              *v17 = 0;
              sub_800237A((int)&dword_200115B8, ".255");
            }
            byte_200015DF = 2;
          }
        }
      }
      else
      {
        ++byte_200015E4;
      }
      goto LABEL_106;
    case 2:
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        if ( strstr(v29, "OK") )
        {
          sub_801A88C(
            (int)"%s %d %s\r\n",
            ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
            450,
            (const char *)v29);
          if ( sub_8024E28(dword_20000430, (unsigned int)v28, 400) == 1 )
          {
            sub_801A88C(
              (int)"%s %d %s\r\n",
              ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
              452,
              (const char *)v28);
            if ( strstr(v28, "+QIOPEN") )
            {
              v18 = strstr(v28, ",");
              v19 = sub_8002644((char *)v18);
              byte_200015E7 = byte_200015E2;
              if ( v19 )
              {
                if ( v19 == 553 )
                {
                  if ( (unsigned __int8)byte_200015E2 >= 0xBu )
                    --byte_200015E2;
                  else
                    ++byte_200015E2;
                  byte_200015DF = 0;
                }
              }
              else
              {
                byte_200015DF = 3;
              }
            }
            else
            {
              ++byte_200015E4;
            }
            sub_801ECA0();
            sub_8002364(&byte_20003EF5, 128);
          }
        }
        else
        {
          ++byte_200015E4;
        }
      }
      else
      {
        ++byte_200015E4;
        sub_801ECA0();
      }
      goto LABEL_106;
    case 3:
      sub_801A88C((int)"33333333333333333333333333 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801A88C(
          (int)"\r\n%s %d %s",
          ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
          487,
          (const char *)v29);
        JUMPOUT(0x801BA6C);
      }
      goto LABEL_100;
    case 4:
      sub_801A88C((int)"444444444444444444444444444 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ECA0();
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        518,
        (const char *)v29);
      v20 = strstr(v29, "+QIRD");
      if ( v20
        && (v21 = sub_80023CE((int)v20, 0x2Cu)) != 0
        && (v22 = (char *)(sub_80023CE(v21 + 1, 0x2Cu) + 1), v22 != (char *)1)
        && (word_200015EA = sub_8002644(v22)) != 0 )
      {
        byte_200015DF = 5;
        byte_200015DD = 0;
        byte_200015E4 = 0;
        byte_200015D4 = 0;
      }
      else
      {
        if ( strstr(v29, "ERROR") )
          ++byte_200015E4;
        if ( (unsigned __int8)byte_200015D4 < 5u )
        {
          byte_200015DF = 4;
          ++byte_200015D4;
        }
        else
        {
          byte_200015D4 = 0;
          byte_200015DF = 3;
          ++byte_200015E4;
        }
      }
      goto LABEL_106;
    case 5:
      sub_801A88C((int)"55555555555555555555555555 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        562,
        (const char *)v29);
      if ( sub_801B790(v29) )
      {
        sub_8002364(v29, 128);
        if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
        {
          sub_801ECA0();
          if ( strstr(v29, "ack") )
          {
            byte_200015DF = 6;
            goto LABEL_106;
          }
        }
        else
        {
          sub_801ECA0();
        }
      }
      else
      {
        ++byte_200015D4;
      }
      byte_200015DF = 4;
LABEL_106:
      if ( (unsigned __int8)byte_200015E4 > 5u )
      {
        byte_200015E4 = 0;
        byte_200015DF = 0;
      }
      goto LABEL_108;
    case 6:
      sub_801A88C((int)"6666666666666666666666666 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        592,
        (const char *)v29);
      if ( strstr(v29, "OK") )
      {
        sub_8002364(v29, 128);
        if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
        {
          sub_801ECA0();
          if ( strstr(v29, "ERROR") )
            ++byte_200015E4;
          sub_801A88C(
            (int)"\r\n%s %d %s",
            ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
            602,
            (const char *)v29);
          v23 = (char *)(strstr(v29, ",") + 1);
          v24 = sub_8002644(v23);
          byte_200015E6 = byte_200015E3;
          if ( v24 )
          {
            if ( v24 == 553 )
            {
              if ( (unsigned __int8)byte_200015E3 >= 0xBu )
                --byte_200015E3;
              else
                ++byte_200015E3;
              byte_200015DF = 6;
              goto LABEL_106;
            }
          }
          else
          {
            byte_200015DF = 7;
          }
        }
        else
        {
          sub_801ECA0();
        }
        byte_200015DF = 7;
      }
      else
      {
        ++byte_200015E4;
      }
      goto LABEL_106;
    case 7:
      sub_801A88C((int)"777777777777777777777777777 \r\n");
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ECA0();
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        640,
        (const char *)v29);
      if ( strstr(v29, "+QISEND") )
        byte_200015DF = 8;
      else
        ++byte_200015E4;
      goto LABEL_106;
    case 8:
      sub_801A88C((int)sub_801BF84);
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ECA0();
      sub_801A88C(
        (int)"\r\n%s %d %s",
        ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
        659,
        (const char *)v29);
      v25 = strstr(v29, "+QIRD");
      if ( v25 )
      {
        v26 = sub_80023CE((int)v25, 0x2Cu);
        if ( v26 )
        {
          v27 = (char *)(sub_80023CE(v26 + 1, 0x2Cu) + 1);
          if ( v27 == (char *)1 )
          {
            ++byte_200015E4;
          }
          else
          {
            word_200015EE = sub_8002644(v27);
            if ( word_200015EE )
            {
              if ( (unsigned __int16)word_200015EE > 0x64u )
                word_200015EE = 100;
              byte_200015DF = 9;
              byte_200015DD = 1;
              byte_200015E4 = 0;
              byte_200015D5 = 0;
            }
            else if ( (unsigned __int8)byte_200015D5 >= 5u )
            {
              byte_200015DF = 7;
              byte_200015D5 = 0;
              ++byte_200015E4;
            }
            else
            {
              ++byte_200015D5;
            }
          }
        }
        else
        {
          ++byte_200015E4;
        }
      }
      else
      {
        ++byte_200015E4;
      }
      goto LABEL_106;
    case 9:
      sub_801A88C((int)&loc_801BFA4);
      if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801A88C(
          (int)"\r\n%s %d %s",
          ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
          708,
          (const char *)v29);
        if ( strstr(v29, "+QIRD") )
        {
          sub_8002364(v29, 128);
          if ( sub_8024E28(dword_20000430, (unsigned int)v29, 400) == 1 )
          {
            sub_801ECA0();
            sub_801A88C(
              (int)"\r\n%s %d %s",
              ": %s, mac: %s, dev_ver: %d, bms_ver: %d, fc_ver: %s.\r\n",
              715,
              (const char *)v29);
            if ( sub_801A1A0(v29) )
            {
              byte_200015E4 = 0;
              byte_200015DF = 0;
              sub_801A88C((int)&loc_801BFC4);
              byte_200015DE = 1;
              byte_200015E0 = 0;
            }
            else
            {
              ++byte_200015E4;
            }
          }
          else
          {
LABEL_100:
            sub_801ECA0();
          }
        }
        else
        {
          ++byte_200015E4;
        }
      }
      else
      {
        sub_801ECA0();
        byte_200015DF = 8;
      }
      goto LABEL_106;
    default:
      ++byte_200015E4;
      goto LABEL_106;
  }
}
// 801BF54: positive sp value 104 has been found
// 801BA68: control flows out of bounds to 801BA6C
// 801BF84: using guessed type int sub_801BF84();
// 20000430: using guessed type int dword_20000430;
// 200015D4: using guessed type char byte_200015D4;
// 200015D5: using guessed type char byte_200015D5;
// 200015DD: using guessed type char byte_200015DD;
// 200015DE: using guessed type char byte_200015DE;
// 200015DF: using guessed type char byte_200015DF;
// 200015E0: using guessed type char byte_200015E0;
// 200015E1: using guessed type char byte_200015E1;
// 200015E2: using guessed type char byte_200015E2;
// 200015E3: using guessed type char byte_200015E3;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 200015EA: using guessed type __int16 word_200015EA;
// 200015EE: using guessed type __int16 word_200015EE;
// 20003EF5: using guessed type char byte_20003EF5;
// 200115B8: using guessed type int dword_200115B8;
// 200115BC: using guessed type int dword_200115BC;
// 200115C0: using guessed type int dword_200115C0;
// 200115C4: using guessed type int dword_200115C4;

//----- (0801BFDC) --------------------------------------------------------
void sub_801BFDC()
{
  int v0; // r6
  unsigned __int8 v1[160]; // [sp+10h] [bp-A0h] BYREF

  sub_8002364(v1, 128);
  v0 = (unsigned __int16)word_20011072;
  switch ( byte_200015DF )
  {
    case 0:
      JUMPOUT(0x801C01C);
    case 1:
      if ( byte_200015E1 )
      {
        if ( sub_8004200("AT+QGETIP=station\r\n") )
          byte_200015E1 = 0;
      }
      break;
    case 2:
      if ( byte_200015E1 )
      {
        sub_8002364(v1, 128);
        sprintf(
          (int)v1,
          "AT+QIOPEN=%d,\"UDP SERVICE\",\"%s\",%d,%d,0\r\n",
          (unsigned __int8)byte_200015E2,
          (const char *)&dword_200115B8,
          v0,
          22222);
        if ( sub_8004200(v1) )
          byte_200015E1 = 0;
      }
      break;
    case 3:
      if ( byte_200015E1 )
      {
        sub_8002364(v1, 128);
        sprintf(
          (int)v1,
          "AT+QISEND=%d,%d,\"%s\",\"%s\",%d\r\n",
          (unsigned __int8)byte_200015E2,
          4,
          "hame",
          (const char *)&dword_200115B8,
          12345);
        if ( sub_8004200(v1) )
          byte_200015E1 = 0;
      }
      break;
    case 4:
      if ( sub_8024F80(dword_2000042C, 400) == 1 || sub_801AACC(&word_200015F0, 0x190u) )
      {
        byte_200015DD = 1;
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015E2);
        if ( sub_8004200(v1) )
          byte_200015E1 = 0;
      }
      break;
    case 5:
      if ( byte_200015E1 )
      {
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015E2, (unsigned __int16)word_200015EA);
        if ( sub_8004200(v1) )
          byte_200015E1 = 0;
      }
      break;
    default:
      break;
  }
  JUMPOUT(0x801C032);
}
// 801C00E: control flows out of bounds to 801C01C
// 801C00E: control flows out of bounds to 801C032
// 2000042C: using guessed type int dword_2000042C;
// 200015DD: using guessed type char byte_200015DD;
// 200015DF: using guessed type char byte_200015DF;
// 200015E1: using guessed type char byte_200015E1;
// 200015E2: using guessed type char byte_200015E2;
// 200015EA: using guessed type __int16 word_200015EA;
// 200015F0: using guessed type _WORD;
// 20011072: using guessed type __int16 word_20011072;
// 200115B8: using guessed type int dword_200115B8;

//----- (0801C018) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall IRQ_38_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int *v13; // r5
  int v14; // r4
  char v15; // cf
  char v16; // zf
  int v17; // r4
  char v18; // r5
  char v19; // r6
  int v20; // r7
  char v21; // r8
  char v22; // r10
  unsigned __int8 v23[40]; // [sp-80h] [bp-80h] BYREF

  if ( !(!v16 & v15) )
  {
    v13 = (int *)((unsigned int)(a2 - 684) >> 8);
    v14 = v17 * a2;
    if ( strstr(v23, "QISEND") )
    {
      if ( sub_8024E28(*v13, (unsigned int)v23, v20) == 1 )
      {
        sub_801ECA0();
        if ( strstr(v23, "OK") )
        {
          *(_BYTE *)(v14 + 9) = v21;
          *(_BYTE *)(v14 + 11) = v22;
        }
        else
        {
          *(_BYTE *)(v14 + 9) = v21;
          ++*(_BYTE *)(v14 + 16);
        }
      }
      sub_801ECA0();
    }
    else
    {
      ++*(_BYTE *)(v14 + 16);
    }
    if ( *(unsigned __int8 *)(v14 + 16) > 5u )
    {
      *(_BYTE *)(v14 + 16) = v19;
      *(_BYTE *)(v14 + 11) = v19;
    }
    __asm { POP.W           {R4-R11,PC} }
  }
  sub_8016D3C();
  if ( *(_BYTE *)(v17 + 13) && sub_8004200("AT+QICFG=\"accept/mode\",0\r\n") )
    *(_BYTE *)(v17 + 13) = v18;
  __asm { POP.W           {R4-R10,PC} }
}
// 801BF54: positive sp value 104 has been found
// 801C034: unbalanced stack, ignored a potential tail call
// 801C01A: variable 'v16' is possibly undefined
// 801C01A: variable 'v15' is possibly undefined
// 801BFC6: variable 'v17' is possibly undefined
// 801C030: variable 'v18' is possibly undefined
// 801BA7C: variable 'v20' is possibly undefined
// 801BA92: variable 'v21' is possibly undefined
// 801BA96: variable 'v22' is possibly undefined
// 801BF4E: variable 'v19' is possibly undefined

//----- (0801C2EC) --------------------------------------------------------
int __fastcall sub_801C2EC(unsigned __int8 *a1, int a2, _DWORD *a3)
{
  unsigned int v5; // r4
  unsigned __int8 *v6; // r0
  int v7; // r5
  int v8; // r8
  int v9; // r0
  int v10; // r7
  int v12; // r0
  unsigned __int8 *i; // r0
  unsigned int v14; // r1
  _BYTE v15[256]; // [sp+4h] [bp-19Ch] BYREF
  unsigned __int8 *v16[32]; // [sp+104h] [bp-9Ch] BYREF
  int v17; // [sp+184h] [bp-1Ch] BYREF

  if ( !a1 || !a3 )
    return 0;
  v17 = 0;
  v5 = 0;
  sub_8002364(v16, 128);
  sub_8002364(v15, 256);
  sub_8002364(byte_200110C0, 120);
  v6 = strstr(a1, (unsigned __int8 *)&dword_801C550);
  v7 = (int)v6;
  if ( !v6 )
    return 0;
  v8 = (unsigned __int8)sub_8002644((char *)v6 + 2);
  v9 = sub_80023CE(v7, 3u);
  if ( !v9 )
    return 0;
  v10 = (unsigned __int8)(v9 - v7 + 3);
  if ( v10 != v8 )
    return 0;
  scanf(v9, (int)dword_801C554, &v17);
  v12 = sub_800FE14(v7, (unsigned __int8)(v10 - 2));
  if ( (unsigned __int8)v17 != v12 )
    return 0;
  sub_80023B6(v15, (unsigned __int8 *)(v7 + 4), v10 - 7);
  for ( i = (unsigned __int8 *)sub_800243C(v15, &dword_801C55C);
        i && v5 < 0x20;
        i = (unsigned __int8 *)sub_800243C(0, &dword_801C55C) )
  {
    v14 = v5;
    v5 = (unsigned __int8)(v5 + 1);
    v16[v14] = i;
  }
  sub_80023B6(&byte_200110C0[2], v16[0], 6);
  sub_80023B6(&byte_200110C0[8], v16[1], 13);
  sub_80023B6(&byte_200110C0[21], v16[2], 7);
  sub_80023B6(&byte_200110C0[28], v16[3], 13);
  dword_200110EC = sub_8002644((char *)v16[4]);
  dword_200110F0 = sub_8002644((char *)v16[5]);
  dword_200110F4 = sub_8002644((char *)v16[6]);
  dword_200110F8 = sub_8002644((char *)v16[7]);
  byte_200110FC = sub_8002644((char *)v16[8]);
  dword_20011100 = sub_8002644((char *)v16[9]);
  byte_20011104 = sub_8002644((char *)v16[10]);
  dword_20011108 = sub_8002644((char *)v16[11]);
  byte_2001110C = sub_8002644((char *)v16[12]);
  byte_2001110D = sub_8002644((char *)v16[13]);
  dword_20011110 = sub_8002644((char *)v16[14]);
  dword_20011114 = sub_8002644((char *)v16[15]);
  dword_20011118 = sub_8002644((char *)v16[16]);
  dword_2001111C = sub_8002644((char *)v16[17]);
  dword_20011120 = sub_8002644((char *)v16[18]);
  dword_20011124 = sub_8002644((char *)v16[19]);
  dword_20011128 = sub_8002644((char *)v16[20]);
  dword_2001112C = sub_8002644((char *)v16[21]);
  dword_20011130 = sub_8002644((char *)v16[22]);
  dword_20011134 = sub_8002644((char *)v16[23]);
  sub_801A88C((int)"ct002_get_info.meter_dev_type=%s\r\n", (const char *)&byte_200110C0[2]);
  sub_801A88C((int)"ct002_get_info.meter_mac_code=%s\r\n", (const char *)&byte_200110C0[8]);
  sub_801A88C((int)"ct002_get_info.hhm_dev_type=%s\r\n", (const char *)&byte_200110C0[21]);
  sub_801A88C((int)"ct002_get_info.hhm_mac_code=%s\r\n", (const char *)&byte_200110C0[28]);
  sub_801A88C((int)"ct002_get_info.A_phase_power=%d\r\n", dword_200110EC);
  sub_801A88C((int)"ct002_get_info.B_phase_power=%d\r\n", dword_200110F0);
  sub_801A88C((int)"ct002_get_info.C_phase_power=%d\r\n", dword_200110F4);
  sub_801A88C((int)"ct002_get_info.total_power=%d\r\n", dword_200110F8);
  sub_801A88C((int)"ct002_get_info.A_chrg_nb=%d\r\n", (unsigned __int8)byte_200110FC);
  sub_801A88C((int)"ct002_get_info.B_chrg_nb=%d\r\n", dword_20011100);
  sub_801A88C((int)"ct002_get_info.C_chrg_nb=%d\r\n", (unsigned __int8)byte_20011104);
  sub_801A88C((int)"ct002_get_info.ABC_chrg_nb=%d\r\n", dword_20011108);
  sub_801A88C((int)"ct002_get_info.wifi_rssi=%d\r\n", byte_2001110C);
  sub_801A88C((int)"ct002_get_info.info_idx=%d\r\n", (unsigned __int8)byte_2001110D);
  if ( sub_80023F0((int)&byte_200110C0[2], (int)&dword_200110A8) )
  {
    sub_8002364(byte_200110C0, 120);
    return 0;
  }
  else
  {
    if ( sub_80023F0((int)&byte_200110C0[2], (int)"HME-4") )
    {
      if ( !sub_80023F0((int)&byte_200110C0[2], (int)"HME-3") )
        byte_200015DC = 6;
    }
    else
    {
      byte_200015DC = 3;
    }
    a3[1] = dword_200110EC;
    a3[2] = dword_200110F0;
    a3[3] = dword_200110F4;
    *a3 = dword_200110F8;
    return 1;
  }
}
// 801C550: using guessed type int dword_801C550;
// 801C554: using guessed type int dword_801C554[2];
// 801C55C: using guessed type int dword_801C55C;
// 200015DC: using guessed type char byte_200015DC;
// 200110A8: using guessed type int dword_200110A8;
// 200110C0: using guessed type unsigned __int8 byte_200110C0[44];
// 200110EC: using guessed type int dword_200110EC;
// 200110F0: using guessed type int dword_200110F0;
// 200110F4: using guessed type int dword_200110F4;
// 200110F8: using guessed type int dword_200110F8;
// 200110FC: using guessed type char byte_200110FC;
// 20011100: using guessed type int dword_20011100;
// 20011104: using guessed type char byte_20011104;
// 20011108: using guessed type int dword_20011108;
// 2001110C: using guessed type char byte_2001110C;
// 2001110D: using guessed type char byte_2001110D;
// 20011110: using guessed type int dword_20011110;
// 20011114: using guessed type int dword_20011114;
// 20011118: using guessed type int dword_20011118;
// 2001111C: using guessed type int dword_2001111C;
// 20011120: using guessed type int dword_20011120;
// 20011124: using guessed type int dword_20011124;
// 20011128: using guessed type int dword_20011128;
// 2001112C: using guessed type int dword_2001112C;
// 20011130: using guessed type int dword_20011130;
// 20011134: using guessed type int dword_20011134;

//----- (0801C750) --------------------------------------------------------
BOOL __fastcall sub_801C750(int a1)
{
  int v2; // r0
  unsigned int v3; // r3
  int v4; // [sp+0h] [bp-20h] BYREF
  int v5; // [sp+4h] [bp-1Ch] BYREF

  v5 = 0;
  v4 = 0;
  if ( a1 == 5 )
    return 1;
  do
  {
    if ( sub_801AACC(&v4, 0xBB8u) )
      return 0;
    if ( !sub_8024E28(dword_20000444, (unsigned int)&v5, 300) )
      break;
    v2 = (unsigned __int8)byte_200015AB++;
    v3 = (unsigned __int8)byte_200015AB;
    byte_20010F11[v2] = v5;
  }
  while ( v3 < 7 );
  return sub_80048CC();
}
// 20000444: using guessed type int dword_20000444;
// 200015AB: using guessed type char byte_200015AB;
// 20010F11: using guessed type unsigned __int8 byte_20010F11[67];

//----- (0801C7C0) --------------------------------------------------------
_BYTE *__fastcall sub_801C7C0(_BYTE *result)
{
  int v1; // r0

  if ( result )
  {
    v1 = 0;
    if ( byte_20010EED || word_20010F07 && (unsigned __int16)word_20010F07 != 0xFFFF )
    {
      if ( byte_20010EED == 3 && word_20010F07 == 13107 )
        v1 = 1;
    }
    else
    {
      v1 = 1;
    }
    byte_200015AC = 4;
    byte_20010EEE = dword_20010EF3 == dword_20010F0D
                 && v1
                 && dword_20010EFF + 128 == dword_20010EF7
                 && MEMORY[0x8050004] == -805230336;
    sub_8004FE0((int)"%d,%x,%x\r\n", (unsigned __int8)byte_20010EEE, MEMORY[0x8050004], -805230336);
    return sub_801822C((_BYTE *)0x52, (unsigned int)&byte_20010EEE, 1u);
  }
  return result;
}
// 200015AC: using guessed type char byte_200015AC;
// 20010EED: using guessed type char byte_20010EED;
// 20010EEE: using guessed type char byte_20010EEE;
// 20010EF3: using guessed type int dword_20010EF3;
// 20010EF7: using guessed type int dword_20010EF7;
// 20010EFF: using guessed type int dword_20010EFF;
// 20010F07: using guessed type __int16 word_20010F07;
// 20010F0D: using guessed type int dword_20010F0D;

//----- (0801C864) --------------------------------------------------------
__int64 __fastcall sub_801C864(__int64 a1, int a2, unsigned int a3)
{
  unsigned int v3; // r4
  __int64 v5; // [sp+0h] [bp-20h] BYREF
  int v6; // [sp+8h] [bp-18h]
  unsigned int v7; // [sp+Ch] [bp-14h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  if ( (_DWORD)a1 )
  {
    v6 = 0;
    v5 = 0;
    v6 = *(unsigned __int16 *)(a1 + 5);
    v3 = *(unsigned __int8 *)(a1 + 7);
    v7 = v3;
    if ( (unsigned __int8)byte_20010EED == v3 && (unsigned __int16)word_20010EEF == (unsigned __int16)v6 && !(_WORD)v6 )
    {
      LODWORD(v5) = dword_20010EFF;
    }
    else
    {
      sub_8002364(&byte_20010EEC, 37);
      dword_200015B8 = 0;
      word_20010EF1 = -1;
      dword_20010F09 = 0xFFFF;
    }
    word_20010EEF = v6;
    byte_20010EED = v3;
    if ( v3 <= 3 )
      BYTE4(v5) = 1;
    BYTE5(v5) = -86;
    sub_801822C((_BYTE *)0x3A, (unsigned int)&v5, 6u);
  }
  return v5;
}
// 200015B8: using guessed type int dword_200015B8;
// 20010EEC: using guessed type char byte_20010EEC;
// 20010EED: using guessed type char byte_20010EED;
// 20010EEF: using guessed type __int16 word_20010EEF;
// 20010EF1: using guessed type __int16 word_20010EF1;
// 20010EFF: using guessed type int dword_20010EFF;
// 20010F09: using guessed type int dword_20010F09;

//----- (0801C8E0) --------------------------------------------------------
_BYTE *__fastcall sub_801C8E0(_BYTE *result, int a2, int a3, int a4)
{
  unsigned int v4; // r1
  int v5; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+4h] [bp-Ch]

  v5 = a3;
  v6 = a4;
  if ( result )
  {
    byte_200015AC = 2;
    v6 = 0;
    dword_20010EF7 = *(_DWORD *)(result + 5);
    dword_20010EF3 = *(_DWORD *)(result + 9);
    v5 = *(_DWORD *)(result + 5);
    v6 = *(_DWORD *)(result + 9);
    if ( !dword_20010EFF )
    {
      if ( MEMORY[0x1FFF75E0] == 0xFFFF )
        v4 = 0x80000;
      else
        v4 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
      sub_800F4F4(0x8040000u, (v4 >> 1) + 134479872);
      dword_20010EFB = 134490112;
    }
    return sub_801822C((_BYTE *)0x50, (unsigned int)&v5, 8u);
  }
  return result;
}
// 200015AC: using guessed type char byte_200015AC;
// 20010EF3: using guessed type int dword_20010EF3;
// 20010EF7: using guessed type int dword_20010EF7;
// 20010EFB: using guessed type int dword_20010EFB;
// 20010EFF: using guessed type int dword_20010EFF;

//----- (0801C958) --------------------------------------------------------
_BYTE *__fastcall sub_801C958(_BYTE *result, int a2, int a3, int a4)
{
  int v4; // [sp+0h] [bp-8h] BYREF

  v4 = a4;
  if ( result )
  {
    sub_801F7E0();
    byte_200015AC = 1;
    v4 = 43521;
    byte_200015A8 = 2;
    return sub_801822C((_BYTE *)0x23, (unsigned int)&v4, 2u);
  }
  return result;
}
// 200015A8: using guessed type char byte_200015A8;
// 200015AC: using guessed type char byte_200015AC;

//----- (0801C98C) --------------------------------------------------------
_BYTE *__fastcall sub_801C98C(_BYTE *result, int a2, int a3, int a4)
{
  _BYTE *v4; // r4
  int v5; // r5
  int v6; // r0
  int v7; // [sp+0h] [bp-20h] BYREF

  v7 = a4;
  v4 = result;
  if ( result )
  {
    v5 = 0;
    v7 = 0;
    byte_200015AC = 3;
    v6 = *(_DWORD *)(result + 5);
    dword_20010EFF = v6;
    if ( v6 == dword_200015B8 || !dword_200015B8 )
    {
      if ( v6 + 128 == dword_20010EF7 )
        v5 = 1;
      sub_80180C0(&dword_20010F0D, (int)(v4 + 9), 0x80u, v5);
      if ( v5 )
      {
        word_20010F07 = *(_WORD *)(v4 + 135);
        sub_8002356(v4 + 135, 2, 255);
      }
      sub_80180C0(&dword_20010F03, (int)(v4 + 9), 0x80u, v5);
      sub_800F558((_DWORD *)(dword_20010EFB + dword_20010EFF), (int)(v4 + 9), 0x10u);
      dword_200015B8 += 128;
    }
    byte_20010EEC = 1;
    v7 = dword_20010EFF;
    return sub_801822C((_BYTE *)0x51, (unsigned int)&v7, 4u);
  }
  return result;
}
// 200015AC: using guessed type char byte_200015AC;
// 200015B8: using guessed type int dword_200015B8;
// 20010EEC: using guessed type char byte_20010EEC;
// 20010EF7: using guessed type int dword_20010EF7;
// 20010EFB: using guessed type int dword_20010EFB;
// 20010EFF: using guessed type int dword_20010EFF;
// 20010F03: using guessed type int dword_20010F03;
// 20010F07: using guessed type __int16 word_20010F07;
// 20010F0D: using guessed type int dword_20010F0D;

//----- (0801CA30) --------------------------------------------------------
char *__fastcall sub_801CA30(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  char *result; // r0
  int v6; // r0

  v4 = 0;
  result = &byte_200015A8;
  switch ( byte_200015A9 )
  {
    case 1:
      result = (char *)sub_801CB4C();
      break;
    case 2:
      result = (char *)sub_801CB7C();
      break;
    case 3:
      result = (char *)sub_801CBE0();
      break;
    case 4:
      result = (char *)sub_801CB78((int)&byte_200015A8, (unsigned __int8)byte_200015A9, a3, a4);
      break;
    case 5:
      v4 = 1;
      break;
    default:
      byte_200015A9 = 0;
      v4 = 2;
      break;
  }
  if ( v4 )
  {
    sub_8018AE4(115200);
    sub_80232B4(2000);
    if ( v4 == 2 )
      sub_801E1B0((int)"\r\nBMS upgrade failed, system will reboot!\r\n");
    else
      sub_801E1B0((int)"\r\nBMS upgrade successful, system will reboot!\r\n");
    sub_80031E4();
    sub_801EE84(v6);
    sub_80232B4(300);
    _R0 = 1;
    __asm { MSR.W           FAULTMASK, R0 }
    sub_8013324();
  }
  return result;
}
// 801CA94: variable 'v6' is possibly undefined
// 801EE84: using guessed type __int64 __fastcall sub_801EE84(_DWORD);
// 200015A8: using guessed type char byte_200015A8;
// 200015A9: using guessed type char byte_200015A9;

//----- (0801CB1C) --------------------------------------------------------
int __fastcall sub_801CB1C(int result, int a2)
{
  byte_20000294 = 1;
  byte_20000031 = 3;
  byte_200015A9 = 1;
  byte_20010F54 = 2;
  dword_20010F58 = result;
  dword_20010F5C = a2;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200015A9: using guessed type char byte_200015A9;
// 20010F54: using guessed type char byte_20010F54;
// 20010F58: using guessed type int dword_20010F58;
// 20010F5C: using guessed type int dword_20010F5C;

//----- (0801CB4C) --------------------------------------------------------
int sub_801CB4C()
{
  _DWORD v1[4]; // [sp+0h] [bp-10h] BYREF

  sub_8018AE4(9600);
  sub_80232B4(2000);
  v1[0] = dword_20010F5C;
  v1[1] = dword_20010F58;
  return sub_801828C(1, (unsigned int)v1, 8u);
}
// 20010F58: using guessed type int dword_20010F58;
// 20010F5C: using guessed type int dword_20010F5C;

//----- (0801CB7C) --------------------------------------------------------
int sub_801CB7C()
{
  unsigned int v0; // r6
  int v1; // r4
  _BYTE v3[80]; // [sp+0h] [bp-50h] BYREF

  v0 = 64;
  v1 = 2;
  sub_8002356(v3, 64, 255);
  if ( (unsigned int)(dword_20010F5C - dword_200015D0) <= 0x40 )
  {
    v1 = 3;
    v0 = (unsigned __int8)(dword_20010F5C - dword_200015D0);
  }
  qmemcpy((unsigned int)v3, ((unsigned __int16)word_200015B4++ << 6) + 134490112, v0);
  dword_200015D0 = (unsigned __int16)word_200015B4 << 6;
  if ( v1 == 3 )
  {
    word_200015B4 = 0;
    dword_200015D0 = 0;
  }
  return sub_801828C(v1, (unsigned int)v3, v0);
}
// 200015B4: using guessed type __int16 word_200015B4;
// 200015D0: using guessed type int dword_200015D0;
// 20010F5C: using guessed type int dword_20010F5C;

//----- (0801CBE0) --------------------------------------------------------
int sub_801CBE0()
{
  int v1; // [sp+0h] [bp-8h] BYREF

  v1 = dword_20010F58;
  return sub_801828C(4, (unsigned int)&v1, 4u);
}
// 20010F58: using guessed type int dword_20010F58;

//----- (0801CBF8) --------------------------------------------------------
int sub_801CBF8()
{
  int result; // r0

  result = 0;
  if ( BYTE2(dword_20002D68) != 1 )
  {
    if ( SHIWORD(dword_20002D5A) <= 9 )
    {
      if ( SHIWORD(dword_20002D5A) >= -9 )
        return 1;
      else
        return 3;
    }
    else
    {
      return 2;
    }
  }
  return result;
}
// 20002D5A: using guessed type int dword_20002D5A;
// 20002D68: using guessed type int dword_20002D68;

//----- (0801CC20) --------------------------------------------------------
int sub_801CC20()
{
  sprintf(
    (int)&unk_20003B6B,
    "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
    (unsigned __int16)dword_20002D77,
    HIWORD(dword_20002D77),
    (unsigned __int16)dword_20002D7B,
    HIWORD(dword_20002D7B),
    (unsigned __int16)dword_20002D7F,
    HIWORD(dword_20002D7F),
    (unsigned __int16)dword_20002D83,
    HIWORD(dword_20002D83),
    (unsigned __int16)dword_20002D87,
    HIWORD(dword_20002D87),
    (unsigned __int16)dword_20002D8B,
    HIWORD(dword_20002D8B),
    (unsigned __int16)dword_20002D8F,
    HIWORD(dword_20002D8F),
    (unsigned __int16)dword_20002D93,
    HIWORD(dword_20002D93));
  sprintf(
    (int)&unk_20003BEB,
    "%d,%d,%d,%d",
    (__int16)dword_20002D6F,
    SHIWORD(dword_20002D6F),
    (__int16)dword_20002D73,
    SHIWORD(dword_20002D73));
  return sprintf((int)&unk_20003C33, "%d,%d,%d,%d", dword_20002D9C, dword_20002DA0, dword_20002DA4, dword_20002DA8);
}
// 20002D6F: using guessed type int dword_20002D6F;
// 20002D73: using guessed type int dword_20002D73;
// 20002D77: using guessed type int dword_20002D77;
// 20002D7B: using guessed type int dword_20002D7B;
// 20002D7F: using guessed type int dword_20002D7F;
// 20002D83: using guessed type int dword_20002D83;
// 20002D87: using guessed type int dword_20002D87;
// 20002D8B: using guessed type int dword_20002D8B;
// 20002D8F: using guessed type int dword_20002D8F;
// 20002D93: using guessed type int dword_20002D93;
// 20002D9C: using guessed type int dword_20002D9C;
// 20002DA0: using guessed type int dword_20002DA0;
// 20002DA4: using guessed type int dword_20002DA4;
// 20002DA8: using guessed type int dword_20002DA8;

//----- (0801CCE0) --------------------------------------------------------
int sub_801CCE0()
{
  int v0; // r0
  unsigned int v1; // r6
  unsigned int v2; // r3
  unsigned int v3; // r1
  unsigned int v4; // r6
  unsigned int v5; // r1
  int result; // r0

  v0 = 0;
  v1 = dword_200004E8;
  v2 = dword_20005058 + 20;
  if ( (unsigned int)dword_200004E8 > 0xE10 )
  {
    v3 = dword_200004E8 / 0xE10u;
    dword_200004E8 %= 0xE10u;
    dword_20002F16 += v1 / 0xE10;
    dword_20002F22 += v1 / 0xE10;
    dword_20002F2E += v1 / 0xE10;
    if ( byte_20002E38 == 2 )
    {
      if ( v2 > dword_2000002C && (unsigned int)dword_2000002C > 0x15 )
        v0 = dword_20005050 * v3;
      dword_20002F1E -= v0 / 10;
      dword_20002F2A -= v0 / 10;
      dword_20002F36 -= v0 / 10;
    }
  }
  v4 = dword_200004EC;
  if ( (unsigned int)dword_200004EC > 0xE10 )
  {
    v5 = dword_200004EC / 0xE10u;
    dword_200004EC %= 0xE10u;
    dword_20002F1A += v4 / 0xE10;
    dword_20002F26 += v4 / 0xE10;
    dword_20002F32 += v4 / 0xE10;
    if ( byte_20002E38 == 2 )
    {
      if ( v2 > dword_2000002C && (unsigned int)dword_2000002C > 0x15 )
        v0 = dword_20005054 * v5;
      dword_20002F1E += v0 / 10;
      dword_20002F2A += v0 / 10;
      dword_20002F36 += v0 / 10;
    }
  }
  if ( (unsigned __int8)byte_20000500 >= (unsigned int)(unsigned __int8)byte_20002F12 )
  {
    if ( byte_20000501 == byte_20002F13 )
    {
      if ( byte_20000502 != byte_20002F14 )
      {
        byte_20002F12 = byte_20000500;
        byte_20002F13 = byte_20000501;
        byte_20002F14 = byte_20000502;
        sub_800511C(1);
      }
    }
    else
    {
      byte_20002F12 = byte_20000500;
      byte_20002F13 = byte_20000501;
      byte_20002F14 = byte_20000502;
      sub_800511C(2);
    }
    byte_20002F12 = byte_20000500;
    byte_20002F13 = byte_20000501;
    byte_20002F14 = byte_20000502;
  }
  result = sub_801AAF4(&algn_200004CC[2], 0x258u);
  if ( result )
    return sub_80055E0();
  return result;
}
// 2000002C: using guessed type int dword_2000002C;
// 200004CC: using guessed type _BYTE[4];
// 200004E8: using guessed type int dword_200004E8;
// 200004EC: using guessed type int dword_200004EC;
// 20000500: using guessed type char byte_20000500;
// 20000501: using guessed type char byte_20000501;
// 20000502: using guessed type char byte_20000502;
// 20002E38: using guessed type char byte_20002E38;
// 20002F12: using guessed type char byte_20002F12;
// 20002F13: using guessed type char byte_20002F13;
// 20002F14: using guessed type char byte_20002F14;
// 20002F16: using guessed type int dword_20002F16;
// 20002F1A: using guessed type int dword_20002F1A;
// 20002F1E: using guessed type int dword_20002F1E;
// 20002F22: using guessed type int dword_20002F22;
// 20002F26: using guessed type int dword_20002F26;
// 20002F2A: using guessed type int dword_20002F2A;
// 20002F2E: using guessed type int dword_20002F2E;
// 20002F32: using guessed type int dword_20002F32;
// 20002F36: using guessed type int dword_20002F36;
// 20005050: using guessed type int dword_20005050;
// 20005054: using guessed type int dword_20005054;
// 20005058: using guessed type int dword_20005058;

//----- (0801CE34) --------------------------------------------------------
int sub_801CE34()
{
  int result; // r0

  dword_2000171C = 1073759232;
  dword_20001720 = 115200;
  dword_20001724 = 0;
  dword_20001728 = 0;
  dword_2000172C = 0;
  dword_20001734 = 0;
  dword_20001730 = 12;
  dword_20001738 = 0;
  sub_8013E1C((int)&dword_2000171C, 0, 2, 2);
  sub_80151A6((int)&dword_2000171C, 0);
  sub_801515A((int)&dword_2000171C);
  sub_80157DC((int)&dword_2000171C, (int)byte_2000303A, 1u);
  result = dword_2000171C;
  *(_DWORD *)(dword_2000171C + 8) &= ~1u;
  return result;
}
// 2000171C: using guessed type int dword_2000171C;
// 20001720: using guessed type int dword_20001720;
// 20001724: using guessed type int dword_20001724;
// 20001728: using guessed type int dword_20001728;
// 2000172C: using guessed type int dword_2000172C;
// 20001730: using guessed type int dword_20001730;
// 20001734: using guessed type int dword_20001734;
// 20001738: using guessed type int dword_20001738;

//----- (0801CE90) --------------------------------------------------------
int __fastcall sub_801CE90(int result)
{
  int v1; // r1

  v1 = 5000;
  do
    --v1;
  while ( v1 && (MEMORY[0x4000441C] & 0x40) == 0 );
  MEMORY[0x40004428] = result;
  return result;
}

//----- (0801CEAC) --------------------------------------------------------
unsigned int *__fastcall sub_801CEAC(int a1, unsigned __int16 a2)
{
  unsigned int *result; // r0
  unsigned int v3; // r1

  sub_8015924((int)&dword_2000171C, a1, a2);
  *(_DWORD *)(dword_2000171C + 32) = 64;
  do
  {
    result = (unsigned int *)(dword_2000171C + 8);
    v3 = __ldrex((unsigned int *)(dword_2000171C + 8));
  }
  while ( __strex(v3 | 0x80, result) );
  return result;
}
// 2000171C: using guessed type int dword_2000171C;

//----- (0801CEDC) --------------------------------------------------------
int __fastcall sub_801CEDC(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 5000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000441C] & 0x40) == 0 );
    MEMORY[0x40004428] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801CF08) --------------------------------------------------------
int __fastcall sub_801CF08(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 60000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000441C] & 0x40) == 0 );
    MEMORY[0x40004428] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801CF74) --------------------------------------------------------
int __fastcall sub_801CF74(int result)
{
  int v1; // r1

  v1 = 5000;
  do
    --v1;
  while ( v1 && (MEMORY[0x4000801C] & 0x40) == 0 );
  MEMORY[0x40008028] = result;
  return result;
}

//----- (0801CF8C) --------------------------------------------------------
int __fastcall sub_801CF8C(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 5000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000801C] & 0x40) == 0 );
    MEMORY[0x40008028] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801CFB4) --------------------------------------------------------
int sub_801CFB4()
{
  sub_801CE34();
  return sub_8017E4C();
}

//----- (0801CFC4) --------------------------------------------------------
int sub_801CFC4()
{
  dword_20002224 = 134338529;
  return sub_8020934((int)&dword_200021BC, (int)&unk_20002228, 0x200u);
}
// 200021BC: using guessed type int dword_200021BC;
// 20002224: using guessed type int dword_20002224;

//----- (0801CFE0) --------------------------------------------------------
int __fastcall sub_801CFE0(int a1, __int16 a2)
{
  if ( byte_20000030 == 1 && byte_20000504 )
    sub_801CEDC(a1, a2);
  return a2;
}
// 20000030: using guessed type char byte_20000030;
// 20000504: using guessed type char byte_20000504;

//----- (0801D004) --------------------------------------------------------
void sub_801D004()
{
  if ( dword_20000298 == 1 )
  {
    dword_20000298 = 0;
    dword_200002A0 = 1000;
    dword_200021B0[0] = 0;
    dword_200021B4 = 0;
    dword_200021B8 = 0;
  }
  if ( dword_2000029C )
    sub_8016E38();
  JUMPOUT(0x801D030);
}
// 801D02E: control flows out of bounds to 801D030
// 20000298: using guessed type int dword_20000298;
// 2000029C: using guessed type int dword_2000029C;
// 200002A0: using guessed type int dword_200002A0;
// 200021B0: using guessed type int dword_200021B0[];
// 200021B4: using guessed type int dword_200021B4;
// 200021B8: using guessed type int dword_200021B8;

//----- (0801D630) --------------------------------------------------------
#error "801D128: call analysis failed (funcsize=454)"

//----- (0801DAE4) --------------------------------------------------------
int *sub_801DAE4()
{
  int v0; // r0
  int *result; // r0
  int v2; // [sp+0h] [bp-38h] BYREF

  sub_8018E88(&byte_200004FC, (int)&byte_20002DF4);
  byte_20000500 = byte_200004FF;
  byte_20000501 = byte_200004FD;
  byte_20000502 = byte_200004FE;
  byte_20000503 = byte_20002DF4;
  sub_801CCE0();
  sub_8004688();
  if ( byte_2000050C == 1 )
  {
    byte_200004AD = 0;
  }
  else if ( dword_20001C10 <= 10 )
  {
    if ( dword_20001C10 >= -10 && SHIWORD(dword_20002D5A) <= 4 )
    {
      if ( (byte_20002E37[0] || byte_20002EAB) && (unsigned __int8)byte_200002A8 == 204 )
      {
        byte_200004AD = 6;
      }
      else if ( (byte_20002E37[0] || byte_20002EAB) && (unsigned int)(unsigned __int8)byte_200002A8 - 212 <= 2 )
      {
        byte_200004AD = 4;
      }
      else
      {
        byte_200004AD = 1;
      }
    }
    else
    {
      byte_200004AD = 2;
    }
  }
  else
  {
    byte_200004AD = 3;
  }
  sub_8022B00();
  sub_801AAF4(algn_200004CC, 0x3Cu);
  if ( byte_20000520 == 1 )
  {
    sub_80031E4();
    sub_801EE84(v0);
    sub_8022ADC();
  }
  if ( byte_20002E38 != byte_200004AF )
  {
    sub_8003234();
    byte_200004AF = byte_20002E38;
  }
  switch ( byte_20002E38 )
  {
    case 0:
    case 5:
      sub_8019018();
      goto LABEL_86;
    case 1:
      sub_800FC08();
      sub_8003234();
      goto LABEL_86;
    case 2:
      sub_801AB1C();
      goto LABEL_86;
    case 3:
      sub_8003EBC();
      goto LABEL_86;
    case 10:
      if ( !byte_20000521
        || byte_20000521 != 3
        || (unsigned __int8)byte_20000522 < (unsigned int)(unsigned __int16)dword_20002D52
        || (unsigned __int8)byte_20000522 > (unsigned int)(unsigned __int16)dword_20002D52 )
      {
        goto LABEL_85;
      }
      byte_20000521 = 0;
      goto LABEL_86;
    case 11:
      if ( (unsigned __int16)dword_20002D52 < 0xFu && byte_200004AE == 1
        || (unsigned __int16)dword_20002D52 > 0x63u && byte_200004AE == 2 )
      {
        byte_200004AE = 0;
        sub_8017DFC(2, (unsigned int)*(float *)&dword_20001C24, (unsigned __int16)dword_20002D52, word_20002D5E);
      }
      if ( byte_200004AE )
      {
        if ( byte_200004AE == 1 )
        {
          flt_200004E0 = 2500.0;
          if ( !sub_801AAF4(&word_200004BC[1], 0x258u) )
            goto LABEL_85;
          goto LABEL_50;
        }
        if ( byte_200004AE == 2 )
        {
          flt_200004E0 = -2500.0;
          if ( sub_801AAF4(&word_200004BC[2], 0x258u) )
LABEL_50:
            sub_8017DFC(2, (unsigned int)*(float *)&dword_20001C24, (unsigned __int16)dword_20002D52, word_20002D5E);
        }
      }
      else
      {
        if ( byte_20000478 == 1 && sub_801AAF4(word_200004BC, 0xE10u) )
        {
          if ( (unsigned __int16)dword_20002D52 <= 0x32u )
            byte_200004AE = 2;
          else
            byte_200004AE = 1;
        }
        flt_200004E0 = 0.0;
      }
LABEL_85:
      sub_8003234();
LABEL_86:
      if ( byte_20002E38 && byte_20002E38 != 5 || (result = (int *)(unsigned __int8)byte_200015DE, !byte_200015DE) )
      {
        flt_200004D4 = 0.01;
        dword_200004D8 = 0;
        byte_200004A8 = 0;
        byte_200004AA = 0;
        result = dword_20002D9C;
        dword_20002D9C[0] = 0;
        dword_20002DA0 = 0;
        dword_20002DA4 = 0;
        dword_20002DA8 = 0;
      }
      return result;
    case 12:
      if ( (unsigned __int16)dword_20002D52 < 0x50u )
        sub_8003234();
      if ( (unsigned __int16)dword_20002D52 > 0x55u )
        goto LABEL_85;
      goto LABEL_86;
    case 14:
      switch ( word_20002DE0 )
      {
        case 0:
          byte_20000507 = 0;
          word_20000515 = 2500;
          word_20002DE0 = 1;
          dword_20002DF0 = dword_2000002C;
          dword_200004E4 = 7200;
          if ( (unsigned __int16)word_20002D56 > 0xBB8u )
            dword_200004E4 = 14400;
          break;
        case 1:
          sub_8003234();
          if ( (unsigned __int16)dword_20002D52 == 100 || dword_2000002C - dword_20002DF0 > (unsigned int)dword_200004E4 )
          {
            word_20002DE0 = 2;
            dword_20002DF0 = dword_2000002C;
          }
          break;
        case 2:
          sub_8003234();
          if ( (unsigned int)(dword_2000002C - dword_20002DF0) >= 0x3C
            && (word_20002D5E < 450 || (unsigned int)(dword_2000002C - dword_20002DF0) > 0x708) )
          {
            dword_20002DF0 = dword_2000002C;
            dword_20002DEC = dword_20002F1A;
            word_20002DE0 = 3;
          }
          break;
        case 3:
          sub_8003234();
          word_20002DE4 = dword_20002F1A - dword_20002DEC;
          if ( (dword_20002D68 & 0x40) == 0 && (unsigned __int16)dword_20002D52 < 0x1Eu
            || dword_2000002C - dword_20002DF0 > (unsigned int)dword_200004E4
            || !byte_200002B4 )
          {
            word_20002DE0 = 4;
            dword_20002DF0 = dword_2000002C;
          }
          break;
        case 4:
          sub_8003234();
          if ( (unsigned int)(dword_2000002C - dword_20002DF0) >= 0x3C
            && (word_20002D5E < 500 || (unsigned int)(dword_2000002C - dword_20002DF0) > 0x708 || byte_200002B7 == 1) )
          {
            word_20002DE0 = 5;
            dword_20002DF0 = dword_2000002C;
            dword_20002DE8 = dword_20002F16;
          }
          break;
        case 5:
          sub_8003234();
          word_20002DE2 = dword_20002F16 - dword_20002DE8;
          if ( (unsigned __int16)dword_20002D52 >= 0x50u
            || dword_2000002C - dword_20002DF0 > (unsigned int)dword_200004E4 )
          {
            word_20002DE0 = 6;
            dword_20002DF0 = dword_2000002C;
            dword_20002DEC = dword_20002F1A;
            sub_80055F0(0x950u, &word_20002DE2, 2u);
            sub_80055F0(0x952u, &word_20002DE4, 2u);
            byte_20000507 = 1;
            word_20000515 = 800;
            sub_80055F0(0x90u, &byte_20000507, 1u);
            v2 = 2;
            sub_80055F0(0, &v2, 1u);
          }
          break;
        case 6:
          sub_8003234();
          break;
        default:
          word_20002DE0 = 7;
          sub_8003234();
          break;
      }
      if ( word_20002DE0 == 1 )
        sub_8003234();
      goto LABEL_86;
    default:
      goto LABEL_86;
  }
}
// 801DBB6: variable 'v0' is possibly undefined
// 8019018: using guessed type int sub_8019018(void);
// 801EE84: using guessed type __int64 __fastcall sub_801EE84(_DWORD);
// 2000002C: using guessed type int dword_2000002C;
// 200002A8: using guessed type char byte_200002A8;
// 200002B4: using guessed type char byte_200002B4;
// 200002B7: using guessed type char byte_200002B7;
// 20000478: using guessed type char byte_20000478;
// 200004A8: using guessed type char byte_200004A8;
// 200004AA: using guessed type char byte_200004AA;
// 200004AD: using guessed type char byte_200004AD;
// 200004AE: using guessed type char byte_200004AE;
// 200004AF: using guessed type char byte_200004AF;
// 200004BC: using guessed type _WORD[3];
// 200004CC: using guessed type _BYTE algn_200004CC[4];
// 200004D4: using guessed type float flt_200004D4;
// 200004D8: using guessed type int dword_200004D8;
// 200004E0: using guessed type float flt_200004E0;
// 200004E4: using guessed type int dword_200004E4;
// 200004FC: using guessed type char byte_200004FC;
// 200004FD: using guessed type char byte_200004FD;
// 200004FE: using guessed type char byte_200004FE;
// 200004FF: using guessed type char byte_200004FF;
// 20000500: using guessed type char byte_20000500;
// 20000501: using guessed type char byte_20000501;
// 20000502: using guessed type char byte_20000502;
// 20000503: using guessed type char byte_20000503;
// 20000507: using guessed type char byte_20000507;
// 20000508: using guessed type __int16 word_20000508;
// 2000050A: using guessed type __int16 word_2000050A;
// 2000050C: using guessed type char byte_2000050C;
// 20000515: using guessed type __int16 word_20000515;
// 20000520: using guessed type char byte_20000520;
// 20000521: using guessed type char byte_20000521;
// 20000522: using guessed type char byte_20000522;
// 200015DE: using guessed type char byte_200015DE;
// 20001C10: using guessed type int dword_20001C10;
// 20001C24: using guessed type int dword_20001C24;
// 20002D52: using guessed type int dword_20002D52;
// 20002D56: using guessed type __int16 word_20002D56;
// 20002D5A: using guessed type int dword_20002D5A;
// 20002D5E: using guessed type __int16 word_20002D5E;
// 20002D68: using guessed type int dword_20002D68;
// 20002D9C: using guessed type int dword_20002D9C[];
// 20002DA0: using guessed type int dword_20002DA0;
// 20002DA4: using guessed type int dword_20002DA4;
// 20002DA8: using guessed type int dword_20002DA8;
// 20002DE0: using guessed type __int16 word_20002DE0;
// 20002DE2: using guessed type __int16 word_20002DE2;
// 20002DE4: using guessed type __int16 word_20002DE4;
// 20002DE8: using guessed type int dword_20002DE8;
// 20002DEC: using guessed type int dword_20002DEC;
// 20002DF0: using guessed type int dword_20002DF0;
// 20002DF4: using guessed type char byte_20002DF4;
// 20002E38: using guessed type char byte_20002E38;
// 20002EAB: using guessed type char byte_20002EAB;
// 20002F16: using guessed type int dword_20002F16;
// 20002F1A: using guessed type int dword_20002F1A;

//----- (0801DFE8) --------------------------------------------------------
int __fastcall sub_801DFE8(int a1, int a2, int a3, int a4)
{
  int v4; // r8
  int v5; // r5
  int v6; // r7
  int v7; // r4
  int v8; // r6
  int v9; // r0
  int v11; // r0
  _BYTE *i; // r1
  int v13; // r3
  int v14; // r0
  unsigned __int8 *j; // r1
  int v16; // r12
  int v17; // r2
  int v18; // r1
  unsigned int v19; // r1
  unsigned int v20; // [sp+4h] [bp-444h] BYREF
  int v21; // [sp+8h] [bp-440h] BYREF
  _BYTE v22[16]; // [sp+Ch] [bp-43Ch] BYREF
  _BYTE v23[3]; // [sp+1Ch] [bp-42Ch] BYREF
  _BYTE v24[1065]; // [sp+1Fh] [bp-429h] BYREF

  v20 = 0;
  dword_200008AC = 134490112;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = sub_8018744(v23, &v21, 2000, a4);
      if ( v9 )
      {
        if ( v9 == 1 )
        {
          sub_8019444(24);
          sub_8019444(24);
          return -3;
        }
        if ( v6 > 0 )
          ++v5;
        if ( v5 > 5 )
        {
          sub_8019444(24);
          sub_8019444(24);
          return 0;
        }
        sub_8019444(67);
      }
      else
      {
        v5 = 0;
        if ( v21 == -1 )
        {
          sub_8019444(6);
          return 0;
        }
        if ( !v21 )
        {
          sub_8019444(6);
          v8 = 1;
          continue;
        }
        if ( v23[1] != (unsigned __int8)v7 )
        {
          sub_8019444(21);
          continue;
        }
        if ( v7 )
        {
          if ( sub_800F558((_DWORD *)dword_200008AC, (int)v24, v21 / 8) )
          {
            sub_8019444(24);
            sub_8019444(24);
            return -2;
          }
          dword_200008AC += v21;
          sub_8019444(6);
        }
        else
        {
          if ( !v24[0] )
          {
            sub_8019444(6);
            v8 = 1;
            v4 = 1;
            continue;
          }
          v11 = 0;
          for ( i = v24; *i && v11 <= 255; ++i )
          {
            v13 = v11++;
            byte_2000354A[v13] = *i;
          }
          byte_2000354A[v11] = 0;
          v14 = 0;
          for ( j = i + 1; ; ++j )
          {
            v17 = *j;
            if ( v17 == 32 || v14 >= 16 )
              break;
            v16 = v14++;
            v22[v16] = v17;
          }
          v22[v14] = 0;
          sub_801A078(v22, &v20);
          dword_200008B0 = v20;
          if ( MEMORY[0x1FFF75E0] == 0xFFFF )
            v18 = 0x80000;
          else
            v18 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
          if ( v18 - 1 < v20 )
          {
            sub_8019444(24);
            sub_8019444(24);
            return -1;
          }
          if ( MEMORY[0x1FFF75E0] == 0xFFFF )
            v19 = 0x80000;
          else
            v19 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
          sub_800F4F4(0x8040000u, (v19 >> 1) + 134479872);
          sub_8019444(6);
          sub_8019444(67);
        }
        ++v7;
        v6 = 1;
      }
    }
    while ( !v8 );
  }
  while ( !v4 );
  return v20;
}
// 801E01A: variable 'a4' is possibly undefined
// 200008AC: using guessed type int dword_200008AC;
// 200008B0: using guessed type int dword_200008B0;
// 2000354A: using guessed type _BYTE byte_2000354A[258];

//----- (0801E1B0) --------------------------------------------------------
int sub_801E1B0(int a1, ...)
{
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  return printf_core(a1, (int)varg_r1, (int)&unk_20000038, (void (*)(void))sub_801F5A4);
}
// 801F5A4: using guessed type int sub_801F5A4();

//----- (0801E1D0) --------------------------------------------------------
int snprintf(int a1, int a2, const char *a3, ...)
{
  int result; // r0
  _DWORD v4[3]; // [sp+0h] [bp-20h] BYREF
  va_list varg_r3; // [sp+1Ch] [bp-4h] BYREF

  va_start(varg_r3, a3);
  v4[0] = a1;
  v4[1] = a2 - 1;
  result = printf_core((int)a3, (int)varg_r3, (int)v4, (void (*)(void))&loc_801F3AE);
  *(_BYTE *)v4[0] = 0;
  return result;
}

//----- (0801E1F8) --------------------------------------------------------
int sprintf(int a1, const char *a2, ...)
{
  int v2; // r4
  int varg_r0; // [sp+8h] [bp-10h] BYREF
  va_list varg_r2; // [sp+10h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  v2 = printf_core((int)a2, (int)varg_r2, (int)&varg_r0, (void (*)(void))&loc_801F3C4);
  sub_801EBC4(0, &varg_r0);
  return v2;
}

//----- (0801E220) --------------------------------------------------------
int __fastcall sub_801E220(int a1, int a2)
{
  return printf_core(a1, a2, (int)&unk_20000038, (void (*)(void))sub_801F5A4);
}
// 801F5A4: using guessed type int sub_801F5A4();

//----- (0801E252) --------------------------------------------------------
int __fastcall _NVIC_SetPriority(int a1, char a2)
{
  char v2; // r1
  int result; // r0

  v2 = 16 * a2;
  if ( a1 < 0 )
  {
    result = (a1 & 0xF) - 536813568;
    *(_BYTE *)(result + 3348) = v2;
  }
  else
  {
    result = a1 - 536813568;
    *(_BYTE *)(result + 1024) = v2;
  }
  return result;
}
// 801E252: invalid function type 'void __fastcall _NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)' has been ignored

//----- (0801E274) --------------------------------------------------------
void __noreturn sub_801E274()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801E298) --------------------------------------------------------
void __noreturn sub_801E298()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801E2BC) --------------------------------------------------------
void __noreturn sub_801E2BC()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801E2E0) --------------------------------------------------------
void *sub_801E2E0()
{
  return &unk_200016B8;
}

//----- (0801E31C) --------------------------------------------------------
__int64 __fastcall fp_digits(__int64 a1, double a2, int a3, int a4)
{
  int v4; // r11
  __int64 v5; // r4
  int v6; // r0
  double v7; // r8
  double v8; // kr00_8
  int i; // r7
  double v11; // r0
  unsigned __int64 v12; // r0
  int j; // r4
  unsigned __int64 v14; // r2
  int v15; // r4
  int v16; // r3
  int v17; // r2
  __int64 v18; // [sp+0h] [bp-38h]

  v18 = a1;
  v4 = a3;
  if ( a2 == 0.0 )
  {
    if ( a4 == 1 )
      HIDWORD(a1) = ~a3;
    else
      HIDWORD(a1) = 0;
    *(_DWORD *)a1 = &dword_801E474;
    *(_DWORD *)(a1 + 4) = HIDWORD(a1);
    *(_DWORD *)(a1 + 8) = 1;
    *(_DWORD *)(a1 + 12) = a4;
  }
  else
  {
    HIDWORD(v5) = (signed int)(19728 * ((HIDWORD(a2) >> 20) - 1023)) >> 16;
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = a4 == 1 ? -v4 : HIDWORD(v5) - v4 + 1;
        v7 = 1.0;
        v8 = 10.0;
        for ( i = v6 >= 0 ? v6 : -v6; i; i >>= 1 )
        {
          if ( i << 31 )
            v7 = v7 * v8;
          v8 = v8 * v8;
        }
        v11 = v6 >= 0 ? a2 / v7 : a2 * v7;
        if ( v11 < 1.84467441e19 )
          LODWORD(v12) = sub_8002D00(COERCE_UNSIGNED_INT64(v11 + 0.5), HIDWORD(COERCE_UNSIGNED_INT64(v11 + 0.5)));
        else
          v12 = -1;
        for ( j = 16; v12 && j >= 0; --j )
        {
          v14 = v12 % 0xA;
          v12 /= 0xAu;
          *(_BYTE *)(HIDWORD(v18) + j) = v14 + 48;
        }
        v15 = j + 1;
        v16 = 17 - v15;
        LODWORD(v5) = v15 + HIDWORD(v18);
        if ( a4 == 1 )
          break;
        v17 = 1;
        if ( v12 || v16 > v4 )
        {
          v17 = 0;
          ++HIDWORD(v5);
        }
        else if ( v16 < v4 )
        {
          v17 = 0;
          --HIDWORD(v5);
        }
        if ( v17 )
          goto LABEL_40;
      }
      if ( !v12 )
        break;
      v4 = 17;
      a4 = 0;
    }
    HIDWORD(v5) = v16 - v4 - 1;
LABEL_40:
    *(_DWORD *)(v18 + 8) = v16;
    *(_DWORD *)(v18 + 12) = a4;
    *(_QWORD *)v18 = v5;
  }
  return v18;
}
// 801E400: variable 'v12' is possibly undefined
// 801E474: using guessed type int dword_801E474;

//----- (0801E480) --------------------------------------------------------
int __fastcall printf_core(int a1, int a2, int a3, void (*a4)(void))
{
  int v4; // r10
  int *v6; // r9
  unsigned __int8 *v7; // r6
  int v8; // r5
  unsigned int v9; // r4
  int v10; // r7
  char v11; // t1
  int v12; // r0
  int v13; // r0
  int v14; // r2
  _QWORD *v15; // t1
  int v16; // t1
  int v17; // r0
  int v18; // t1
  int v19; // r0
  __int64 v20; // r0
  bool v21; // zf
  bool v22; // cc
  int v23; // r0
  _BYTE *v24; // r1
  unsigned __int8 v25; // t1
  int v26; // r0
  int v27; // t1
  int v28; // r1
  int v29; // r8
  int v30; // r7
  int v31; // t1
  bool v32; // cf
  void (__fastcall *v33)(int, int); // r3
  __int16 v34; // r1
  int v35; // r0
  int v36; // r2
  int v37; // r2
  int v38; // r12
  int v39; // t1
  int *v40; // r2
  char v41; // r2
  int v42; // r2
  int v43; // r8
  int v44; // r1
  int v45; // r2
  int v46; // r2
  int v47; // t1
  int *v48; // r2
  int v49; // r2
  const char *v50; // r0
  unsigned __int64 v51; // r2
  int v52; // r0
  int i; // r7
  int v54; // r1
  int v55; // r0
  unsigned int v57; // r12
  double v58; // r2
  char *v59; // r12
  int v60; // r0
  __int64 v61; // r0
  int v62; // r0
  __int64 v63; // r0
  int v64; // r0
  int v65; // r0
  __int64 v66; // r0
  int v67; // r1
  int v68; // r1
  char *v69; // r7
  int v70; // r8
  unsigned int v71; // r1
  _BYTE *v72; // r8
  int v73; // r0
  int v74; // r0
  int v75; // r1
  int v76; // t1
  unsigned int v77; // [sp+0h] [bp-88h] BYREF
  int v78; // [sp+4h] [bp-84h]
  int v79; // [sp+8h] [bp-80h]
  const char *v80; // [sp+Ch] [bp-7Ch]
  int v81; // [sp+10h] [bp-78h]
  int v82; // [sp+14h] [bp-74h]
  _BYTE v83[32]; // [sp+18h] [bp-70h] BYREF
  int v84; // [sp+38h] [bp-50h] BYREF
  int v85; // [sp+3Ch] [bp-4Ch]
  int v86; // [sp+40h] [bp-48h]
  int v87; // [sp+44h] [bp-44h]
  _BYTE v88[7]; // [sp+48h] [bp-40h] BYREF
  char v89; // [sp+4Fh] [bp-39h] BYREF
  char *v90; // [sp+50h] [bp-38h]
  int v91; // [sp+54h] [bp-34h]
  int v92; // [sp+58h] [bp-30h]
  int v93; // [sp+5Ch] [bp-2Ch]
  int v94; // [sp+60h] [bp-28h]

  v91 = a1;
  v92 = a2;
  v93 = a3;
  v94 = (int)a4;
  v6 = (int *)a2;
  v7 = (unsigned __int8 *)a1;
  v8 = 0;
  while ( *v7 )
  {
    if ( *v7 != 37 )
    {
LABEL_57:
      a4();
      ++v8;
      goto LABEL_148;
    }
    v9 = 0;
    v10 = 0;
    v82 = 0;
    while ( 1 )
    {
      v11 = *++v7;
      v12 = 1 << (v11 - 32);
      if ( (v12 & 0x12809) == 0 )
        break;
      v9 |= v12;
    }
    if ( *v7 == 42 )
    {
      v15 = (_QWORD *)*v6++;
      v14 = (int)v15;
      v82 = (int)v15;
      if ( (int)v15 < 0 )
      {
        v9 |= 0x2000u;
        v82 = -v14;
      }
      v9 |= 2u;
      ++v7;
    }
    else
    {
      while ( 1 )
      {
        v13 = *v7;
        if ( (unsigned int)(v13 - 48) > 9 )
          break;
        v9 |= 2u;
        ++v7;
        v82 = v13 + 10 * v82 - 48;
      }
    }
    if ( *v7 == 46 )
    {
      v16 = *++v7;
      v9 |= 4u;
      if ( v16 == 42 )
      {
        v18 = *v6++;
        v10 = v18;
        ++v7;
      }
      else
      {
        while ( 1 )
        {
          v17 = *v7;
          if ( (unsigned int)(v17 - 48) > 9 )
            break;
          v10 = v17 + 10 * v10 - 48;
          ++v7;
        }
      }
    }
    v19 = *v7;
    if ( v19 == 108 )
    {
      v9 |= 0x100000u;
LABEL_28:
      if ( v7[1] == v19 )
      {
        v9 += 0x100000;
        ++v7;
      }
      goto LABEL_30;
    }
    if ( *v7 <= 0x6Cu )
    {
      if ( v19 != 76 )
      {
        if ( v19 == 104 )
        {
          v9 |= 0x300000u;
          goto LABEL_28;
        }
        if ( v19 != 106 )
          goto LABEL_31;
        v9 |= 0x200000u;
      }
LABEL_30:
      ++v7;
      goto LABEL_31;
    }
    if ( v19 == 116 || v19 == 122 )
      goto LABEL_30;
LABEL_31:
    LODWORD(v20) = *v7;
    v21 = (_DWORD)v20 == 102;
    v22 = (unsigned int)v20 <= 0x66;
    while ( 1 )
    {
      if ( v21 )
        goto LABEL_151;
      if ( !v22 )
        break;
      if ( (_DWORD)v20 == 88 )
      {
        v44 = 16;
        goto LABEL_102;
      }
      if ( *v7 > 0x58u )
      {
        if ( (_DWORD)v20 != 99 )
        {
          if ( (_DWORD)v20 != 100 )
          {
            if ( (_DWORD)v20 != 101 )
              goto LABEL_57;
LABEL_151:
            if ( (v9 & 4) == 0 )
              v10 = 6;
            v57 = ((unsigned int)v6 + 7) & 0xFFFFFFF8;
            v58 = *(double *)v57;
            v6 = (int *)(v57 + 8);
            if ( (*(_DWORD *)(v57 + 4) & 0x80000000) != 0 )
            {
              v59 = &byte_801EB50;
            }
            else if ( (v9 & 0x800) != 0 )
            {
              v59 = &byte_801EB54;
            }
            else if ( v9 << 31 )
            {
              v59 = &byte_801EB58;
            }
            else
            {
              v59 = "";
            }
            HIDWORD(v58) &= ~0x80000000;
            v90 = v59;
            if ( (_DWORD)v20 == 101 )
              goto LABEL_169;
            if ( (int)v20 <= 101 )
            {
              if ( (_DWORD)v20 != 69 )
              {
                if ( (_DWORD)v20 != 70 )
                {
                  if ( (_DWORD)v20 == 71 )
                    goto LABEL_179;
LABEL_198:
                  if ( (v9 & 8) == 0 && v78 >= v4 )
                    v78 = -1;
                  v89 = 0;
                  v69 = &v89;
                  if ( v79 != 0x80000000 )
                  {
                    v84 = 43;
                    v70 = 2;
                    if ( v79 < 0 )
                    {
                      v79 = -v79;
                      v84 = 45;
                    }
                    while ( 1 )
                    {
                      v22 = v70-- <= 0;
                      if ( v22 && !v79 )
                        break;
                      v71 = v79 % 0xAu;
                      v79 /= 0xAu;
                      *--v69 = v71 + 48;
                    }
                    *(v69 - 1) = v84;
                    *(v69 - 2) = *v7 & 0x20 | 0x45;
                    v69 -= 2;
                  }
                  v72 = (_BYTE *)(v88 - v69 + 7);
                  v73 = (unsigned __int8)*v90;
                  if ( *v90 )
                    v73 = 1;
                  v82 = v82 - (_DWORD)&v72[v73 + v4 + (v78 >> 31)] - 1;
                  if ( (v9 & 0x10000) == 0 )
                    v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
                  if ( *v90 )
                  {
                    a4();
                    ++v8;
                  }
                  if ( (v9 & 0x10000) != 0 )
                    v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
                  while ( 1 )
                  {
                    v22 = v4-- <= 0;
                    if ( v22 )
                      break;
                    if ( v81 < 0 || (int)v80 <= v81 )
                    {
                      v75 = v93;
                      v74 = 48;
                    }
                    else
                    {
                      v74 = *(unsigned __int8 *)(v77 + v81);
                      v75 = v93;
                    }
                    ((void (__fastcall *)(int, int))a4)(v74, v75);
                    ++v8;
                    ++v81;
                    if ( !--v78 )
                    {
                      ((void (__fastcall *)(int, int))a4)(46, v93);
                      ++v8;
                    }
                  }
                  while ( 1 )
                  {
                    v22 = (int)v72-- <= 0;
                    if ( v22 )
                      break;
                    v76 = (unsigned __int8)*v69++;
                    ((void (__fastcall *)(int, int))a4)(v76, v93);
                    ++v8;
                  }
LABEL_227:
                  v33 = (void (__fastcall *)(int, int))a4;
                  v34 = v9;
                  v36 = v93;
                  v35 = v82;
LABEL_147:
                  v8 += printf_post_padding(v35, v34, v36, v33);
                  goto LABEL_148;
                }
LABEL_173:
                v79 = 0x80000000;
                HIDWORD(v63) = v83;
                LODWORD(v63) = &v84;
                fp_digits(v63, v58, v10, 1);
                v80 = (const char *)v86;
                v4 = v86;
                v77 = v84;
                v81 = 0;
                if ( !v87 )
                  v4 = v85 + v10 + 1;
                if ( v10 - v4 >= 0 )
                {
                  v64 = -1 - (v10 - v4);
                  v4 = v10 + 1;
                  v81 = v64;
                }
                v78 = v4 - v10;
                goto LABEL_198;
              }
LABEL_169:
              if ( v10 < 17 )
                v60 = v10 + 1;
              else
                v60 = 17;
              v77 = v60;
              HIDWORD(v61) = v83;
              LODWORD(v61) = &v84;
              fp_digits(v61, v58, v77, 0);
              v62 = v85;
              v80 = (const char *)v86;
              v77 = v84;
              v4 = v10 + 1;
              v81 = 0;
LABEL_191:
              v78 = 1;
              v79 = v62;
              goto LABEL_198;
            }
            if ( (_DWORD)v20 == 102 )
              goto LABEL_173;
            if ( (_DWORD)v20 != 103 )
              goto LABEL_198;
LABEL_179:
            if ( v10 < 1 )
              v10 = 1;
            if ( v10 <= 17 )
              v65 = v10;
            else
              v65 = 17;
            v77 = v65;
            HIDWORD(v66) = v83;
            LODWORD(v66) = &v84;
            fp_digits(v66, v58, v77, 0);
            v62 = v85;
            v80 = (const char *)v86;
            v81 = 0;
            v77 = v84;
            v4 = v10;
            if ( (v9 & 8) == 0 )
            {
              v67 = (int)v80;
              if ( (int)v80 >= v10 )
                goto LABEL_187;
              while ( 1 )
              {
                v4 = v67;
LABEL_187:
                if ( v4 <= 1 || *(_BYTE *)(v77 + v4 - 1) != 48 )
                  break;
                v67 = v4 - 1;
              }
            }
            if ( v85 >= v10 || v85 < -4 )
              goto LABEL_191;
            if ( v85 <= 0 )
            {
              v81 += v85;
              v68 = v4 - v85;
              goto LABEL_196;
            }
            v68 = v85 + 1;
            if ( v85 + 1 > v4 )
LABEL_196:
              v4 = v68;
            v78 = v85 - v81 + 1;
            v79 = 0x80000000;
            goto LABEL_198;
          }
LABEL_85:
          v77 = 10;
          v37 = (v9 >> 20) & 7;
          if ( v37 == 2 )
          {
            v40 = (int *)(((unsigned int)v6 + 7) & 0xFFFFFFF8);
            HIDWORD(v20) = v40[1];
            v38 = *v40;
            v6 = v40 + 2;
          }
          else
          {
            v39 = *v6++;
            v38 = v39;
            HIDWORD(v20) = v39 >> 31;
            if ( v37 == 3 )
            {
              v38 = (__int16)v38;
              HIDWORD(v20) = (__int16)v38 >> 31;
            }
            if ( v37 == 4 )
            {
              v38 = (char)v38;
              HIDWORD(v20) = (char)v38 >> 31;
            }
          }
          if ( v20 < 0 )
          {
            v32 = v38 == 0;
            v38 = -v38;
            HIDWORD(v20) = -(HIDWORD(v20) + !v32);
            v41 = 45;
            goto LABEL_98;
          }
          if ( (v9 & 0x800) != 0 )
          {
            v41 = 43;
            goto LABEL_98;
          }
          v42 = v9 << 31;
          if ( v9 << 31 )
          {
            v41 = 32;
LABEL_98:
            LOBYTE(v78) = v41;
            v42 = 1;
          }
          v43 = v42;
LABEL_123:
          if ( (_DWORD)v20 == 88 )
            v50 = "0123456789ABCDEF";
          else
            v50 = "0123456789abcdef";
          v80 = v50;
          v79 = (int)&v84;
          while ( v38 | HIDWORD(v20) )
          {
            LODWORD(v20) = v38;
            v51 = v20 % (unsigned __int64)v77;
            v20 /= (unsigned __int64)v77;
            v38 = v20;
            LOBYTE(v51) = v80[v51];
            *(_BYTE *)--v79 = v51;
          }
          v4 = (int)&v83[-v79 + 32];
          if ( (v9 & 4) != 0 )
            v9 &= ~0x10000u;
          else
            v10 = 1;
          if ( v10 <= v4 )
            v52 = 0;
          else
            v52 = v10 - v4;
          v77 = v52;
          v82 -= v52 + v4 + v43;
          if ( (v9 & 0x10000) == 0 )
            v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
          for ( i = 0; i < v43; ++i )
          {
            ((void (__fastcall *)(_DWORD, int))a4)(*((unsigned __int8 *)&v78 + i), v93);
            ++v8;
          }
          if ( (v9 & 0x10000) != 0 )
            v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
          while ( 1 )
          {
            v54 = v77--;
            if ( v54 <= 0 )
              break;
            ((void (__fastcall *)(int, int))a4)(48, v93);
            ++v8;
          }
          while ( 1 )
          {
            v22 = v4-- <= 0;
            if ( v22 )
              break;
            v55 = *(unsigned __int8 *)v79++;
            ((void (__fastcall *)(int, int))a4)(v55, v93);
            ++v8;
          }
          goto LABEL_227;
        }
        v25 = *(_BYTE *)v6++;
        LOWORD(v77) = v25;
        v4 = (int)&v77;
        v26 = 1;
LABEL_68:
        v28 = 0;
        if ( (v9 & 4) != 0 )
        {
          while ( 1 )
          {
            v29 = v28;
            if ( v28 >= v10 || v28 >= v26 && !*(_BYTE *)(v4 + v28) )
              break;
            ++v28;
          }
        }
        else
        {
          while ( 1 )
          {
            v29 = v28;
            if ( v28 >= v26 && !*(_BYTE *)(v4 + v28) )
              break;
            ++v28;
          }
        }
        v30 = v82 - v29;
        v8 += printf_pre_padding_0(v82 - v29, v9, v93, (void (__fastcall *)(int, int))a4) + v29;
        while ( 1 )
        {
          v32 = v29-- != 0;
          if ( !v32 )
            break;
          v31 = *(unsigned __int8 *)v4++;
          ((void (__fastcall *)(int, int))a4)(v31, v93);
        }
        v33 = (void (__fastcall *)(int, int))a4;
        v34 = v9;
        v35 = v30;
        v36 = v93;
        goto LABEL_147;
      }
      if ( !*v7 )
        return v8;
      v21 = (_DWORD)v20 == 69;
      v22 = *v7 <= 0x45u;
      if ( (_DWORD)v20 != 69 )
      {
        v21 = (_DWORD)v20 == 70;
        v22 = *v7 <= 0x46u;
        if ( (_DWORD)v20 != 70 )
        {
          if ( (_DWORD)v20 != 71 )
            goto LABEL_57;
          goto LABEL_151;
        }
      }
    }
    if ( (_DWORD)v20 == 112 )
    {
      v9 |= 4u;
      v10 = 8;
      v77 = 16;
      goto LABEL_104;
    }
    if ( *v7 > 0x70u )
    {
      switch ( (_DWORD)v20 )
      {
        case 's':
          v27 = *v6++;
          v4 = v27;
          v26 = -1;
          goto LABEL_68;
        case 'u':
          v44 = 10;
LABEL_102:
          v77 = v44;
          break;
        case 'x':
          v45 = 16;
LABEL_103:
          v77 = v45;
          break;
        default:
          goto LABEL_57;
      }
LABEL_104:
      v46 = (v9 >> 20) & 7;
      if ( v46 == 2 )
      {
        v48 = (int *)(((unsigned int)v6 + 7) & 0xFFFFFFF8);
        HIDWORD(v20) = v48[1];
        v38 = *v48;
        v6 = v48 + 2;
      }
      else
      {
        v47 = *v6++;
        v38 = v47;
        HIDWORD(v20) = 0;
        if ( v46 == 3 )
          v38 = (unsigned __int16)v38;
        if ( v46 == 4 )
          v38 = (unsigned __int8)v38;
      }
      v43 = 0;
      if ( (v9 & 8) == 0 )
        goto LABEL_123;
      if ( (_DWORD)v20 != 112 )
      {
        if ( v77 == 0x10 && v38 | HIDWORD(v20) )
        {
          LOBYTE(v78) = 48;
          BYTE1(v78) = v20;
          v49 = 2;
LABEL_118:
          v43 = v49;
        }
        if ( v77 == 8 && (v38 | HIDWORD(v20) || (v9 & 4) != 0) )
        {
          LOBYTE(v78) = 48;
          v43 = 1;
          --v10;
        }
        goto LABEL_123;
      }
      LOBYTE(v78) = 64;
      v49 = 1;
      goto LABEL_118;
    }
    if ( (_DWORD)v20 == 103 )
      goto LABEL_151;
    if ( (_DWORD)v20 == 105 )
      goto LABEL_85;
    if ( (_DWORD)v20 != 110 )
    {
      if ( (_DWORD)v20 != 111 )
        goto LABEL_57;
      v45 = 8;
      goto LABEL_103;
    }
    v23 = (v9 >> 20) & 7;
    if ( v23 == 2 )
    {
      *(_QWORD *)*v6 = v8;
    }
    else if ( v23 == 3 )
    {
      *(_WORD *)*v6 = v8;
    }
    else
    {
      v24 = (_BYTE *)*v6;
      if ( v23 == 4 )
        *v24 = v8;
      else
        *(_DWORD *)v24 = v8;
    }
    ++v6;
LABEL_148:
    ++v7;
  }
  return v8;
}
// 801EA2E: variable 'v4' is possibly undefined
// 801EB50: using guessed type char byte_801EB50;
// 801EB54: using guessed type char byte_801EB54;
// 801EB58: using guessed type char byte_801EB58;

//----- (0801EB5C) --------------------------------------------------------
int __fastcall printf_post_padding(int a1, __int16 a2, int a3, void (__fastcall *a4)(int, int))
{
  int v5; // r5

  v5 = 0;
  if ( (a2 & 0x2000) != 0 )
  {
    while ( --a1 >= 0 )
    {
      a4(32, a3);
      ++v5;
    }
  }
  return v5;
}

//----- (0801EB80) --------------------------------------------------------
int __fastcall printf_pre_padding_0(int a1, int a2, int a3, void (__fastcall *a4)(int, int))
{
  int v5; // r5
  int v8; // r7

  v5 = 0;
  if ( (a2 & 0x10000) != 0 )
    v8 = 48;
  else
    v8 = 32;
  if ( (a2 & 0x2000) == 0 )
  {
    while ( --a1 >= 0 )
    {
      a4(v8, a3);
      ++v5;
    }
  }
  return v5;
}

//----- (0801EBAE) --------------------------------------------------------
int __fastcall sub_801EBAE(int result, _DWORD *a2)
{
  _BYTE *v2; // r2

  if ( a2[1] )
  {
    v2 = (_BYTE *)(*a2)++;
    *v2 = result;
    result = a2[1] - 1;
    a2[1] = result;
  }
  return result;
}

//----- (0801EBC4) --------------------------------------------------------
char __fastcall sub_801EBC4(char result, _DWORD *a2)
{
  _BYTE *v2; // r2

  v2 = (_BYTE *)(*a2)++;
  *v2 = result;
  return result;
}

//----- (0801EBD0) --------------------------------------------------------
__int64 __fastcall sub_801EBD0(unsigned int a1)
{
  _QWORD v2[3]; // [sp+0h] [bp-18h] BYREF

  dword_2000353A = 134490112;
  dword_2000353E = a1;
  dword_20003542 = 1;
  dword_20003546 = sub_800F61C(134490112, a1);
  qmemcpy((unsigned int)v2, (unsigned int)&dword_2000353A, 0x10u);
  sub_800F558((_DWORD *)0x8040000, (int)v2, 2u);
  return v2[0];
}
// 2000353A: using guessed type int dword_2000353A;
// 2000353E: using guessed type int dword_2000353E;
// 20003542: using guessed type int dword_20003542;
// 20003546: using guessed type int dword_20003546;

//----- (0801EC38) --------------------------------------------------------
int sub_801EC38()
{
  int result; // r0

  result = 0;
  dword_200004A0 = 0;
  return result;
}
// 200004A0: using guessed type int dword_200004A0;

//----- (0801EC40) --------------------------------------------------------
int sub_801EC40()
{
  int result; // r0

  if ( byte_20000480 )
    sub_801A978();
  else
    sub_801A96C();
  if ( dword_200004A0 <= 0 )
  {
    dword_200004A0 = 0;
    byte_20000480 = 0;
  }
  else
  {
    --dword_200004A0;
    byte_20000480 = 1 - byte_20000480;
  }
  result = dword_200004A4;
  if ( dword_200004A4 > 0 )
  {
    --dword_200004A4;
    return sub_801A978();
  }
  return result;
}
// 20000480: using guessed type char byte_20000480;
// 200004A0: using guessed type int dword_200004A0;
// 200004A4: using guessed type int dword_200004A4;

//----- (0801EC94) --------------------------------------------------------
int sub_801EC94()
{
  int result; // r0

  result = 10;
  dword_200004A4 = 10;
  return result;
}
// 200004A4: using guessed type int dword_200004A4;

//----- (0801ECA0) --------------------------------------------------------
int sub_801ECA0()
{
  byte_200015E1 = 1;
  sub_8024960(dword_20000430, 0);
  byte_200036B1 = 0;
  return sub_8024A40(dword_20000458, 0, 0, 0);
}
// 20000430: using guessed type int dword_20000430;
// 20000458: using guessed type int dword_20000458;
// 200015E1: using guessed type char byte_200015E1;
// 200036B1: using guessed type char byte_200036B1;

//----- (0801ECDC) --------------------------------------------------------
int sub_801ECDC()
{
  dword_20000034 = 0;
  return sub_80157DC((int)&dword_2000171C, (int)&byte_2000303A, 1u);
}
// 20000034: using guessed type int dword_20000034;
// 2000171C: using guessed type int dword_2000171C;
// 2000303A: using guessed type char byte_2000303A;

//----- (0801ECF8) --------------------------------------------------------
int __fastcall sub_801ECF8(int a1)
{
  int result; // r0
  int *v3; // r5
  int v4; // r6
  int v5; // r7
  int v6; // r1

  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1354);
  if ( a1 == dword_2000164C )
    return 0;
  sub_8023064();
  v3 = *(int **)(a1 + 20);
  v4 = dword_20001684;
  v5 = dword_20001688;
  sub_80230E4();
  if ( v3 == (int *)v4 || v3 == (int *)v5 )
    return 2;
  if ( v3 == &dword_200118C8 )
  {
    if ( *(_DWORD *)(a1 + 40) )
    {
      return 2;
    }
    else
    {
      result = 3;
      v6 = 0;
      while ( *(_BYTE *)(a1 + v6 + 88) != 1 )
      {
        if ( ++v6 >= 1 )
          return result;
      }
      return 2;
    }
  }
  else if ( v3 == dword_200118B4 || !v3 )
  {
    return 4;
  }
  else
  {
    return 1;
  }
}
// 2000164C: using guessed type int dword_2000164C;
// 20001684: using guessed type int dword_20001684;
// 20001688: using guessed type int dword_20001688;
// 200118B4: using guessed type _DWORD dword_200118B4[3];
// 200118C8: using guessed type int dword_200118C8;

//----- (0801EDC8) --------------------------------------------------------
int sub_801EDC8()
{
  int result; // r0

  dword_20000448 = sub_80248E4(0x14u, 1u, 0);
  dword_2000044C = sub_80248E4(1u, 4u, 0);
  dword_20000464 = (int)sub_80248CC(1);
  dword_20000454 = sub_80248E4(1u, 0, 3);
  dword_20000458 = (int)sub_80248CC(1);
  dword_2000045C = sub_80248E4(1u, 0, 3);
  dword_20000460 = sub_80248E4(1u, 0, 3);
  dword_20000430 = sub_80248E4(5u, 0x80u, 0);
  dword_20000450 = sub_80248E4(2u, 0x100u, 0);
  dword_20000434 = sub_80248E4(1u, 0x10u, 0);
  dword_20000438 = sub_80248E4(1u, 4u, 0);
  dword_2000042C = sub_80248E4(1u, 0, 3);
  dword_2000043C = sub_80248E4(0x100u, 1u, 0);
  dword_20000444 = sub_80248E4(0x40u, 1u, 0);
  result = sub_80248E4(0x400u, 1u, 0);
  dword_20000440 = result;
  return result;
}
// 2000042C: using guessed type int dword_2000042C;
// 20000430: using guessed type int dword_20000430;
// 20000434: using guessed type int dword_20000434;
// 20000438: using guessed type int dword_20000438;
// 2000043C: using guessed type int dword_2000043C;
// 20000440: using guessed type int dword_20000440;
// 20000444: using guessed type int dword_20000444;
// 20000448: using guessed type int dword_20000448;
// 2000044C: using guessed type int dword_2000044C;
// 20000450: using guessed type int dword_20000450;
// 20000454: using guessed type int dword_20000454;
// 20000458: using guessed type int dword_20000458;
// 2000045C: using guessed type int dword_2000045C;
// 20000460: using guessed type int dword_20000460;
// 20000464: using guessed type int dword_20000464;

//----- (0801EE88) --------------------------------------------------------
int __fastcall sub_801EE88(int a1, unsigned int a2, int *a3)
{
  unsigned int i; // r3
  int result; // r0

  for ( i = 0; i < a2; ++i )
    *a3 += *(unsigned __int8 *)(a1 + i);
  result = ~*a3;
  *a3 = result;
  return result;
}

//----- (0801EEA4) --------------------------------------------------------
int sub_801EEA4()
{
  *(_DWORD *)dword_20001BD0 = 43690;
  return 0;
}
// 20001BD0: using guessed type int dword_20001BD0;

//----- (0801EEB0) --------------------------------------------------------
int sub_801EEB0()
{
  if ( (MEMORY[0x40021094] & 0x20000000) != 0 )
    sub_8017DFC(65, 0, 0, 0);
  MEMORY[0x40021094] |= 0x800000u;
  dword_20001BD0 = 1073754112;
  dword_20001BD4 = 5;
  dword_20001BD8 = 1000;
  dword_20001BDC = 4095;
  return sub_801317C(&dword_20001BD0);
}
// 20001BD0: using guessed type int dword_20001BD0;
// 20001BD4: using guessed type int dword_20001BD4;
// 20001BD8: using guessed type int dword_20001BD8;
// 20001BDC: using guessed type int dword_20001BDC;

//----- (0801EEFC) --------------------------------------------------------
int sub_801EEFC()
{
  int v0; // r2
  int v1; // r0
  int result; // r0

  v0 = 0;
  if ( (unsigned __int16)dword_20002D52 >= (unsigned int)(unsigned __int8)byte_20000512 )
  {
    if ( (unsigned __int16)dword_20002D52 >= 0x1Fu )
    {
      if ( (unsigned __int16)dword_20002D52 >= 0x37u )
      {
        if ( (unsigned __int16)dword_20002D52 >= 0x50u )
          v1 = 11;
        else
          v1 = 10;
      }
      else
      {
        v1 = 9;
      }
    }
    else
    {
      v1 = 8;
    }
  }
  else
  {
    v1 = 7;
  }
  if ( byte_200004AD == 3 )
  {
    v0 = 6;
  }
  else if ( byte_200004AD == 2 )
  {
    v0 = 5;
  }
  if ( (unsigned __int8)byte_20000479 != v1 )
  {
    byte_20000479 = v1;
    dword_20000488 = 0;
  }
  if ( (unsigned __int8)byte_2000047A != v0 )
  {
    byte_2000047A = v0;
    dword_20000488 = 0;
  }
  result = 2;
  if ( byte_200002AB )
    byte_2000047F = 2;
  else
    byte_2000047F = 0;
  if ( byte_20004237 == 2 )
    byte_2000047C = 2;
  else
    byte_2000047C = byte_20004237 == 1 || byte_20004237 == 3;
  if ( byte_20000928 )
    byte_2000047D = 2;
  else
    byte_2000047D = 0;
  if ( byte_200015DE )
    byte_2000047B = 2;
  else
    byte_2000047B = 0;
  if ( (byte_20002E37[0] || byte_20002EAB == 2) && (unsigned int)(unsigned __int8)byte_200002A8 - 204 <= 0xD )
    byte_2000047E = 2;
  else
    byte_2000047E = 0;
  return result;
}
// 200002A8: using guessed type char byte_200002A8;
// 200002AB: using guessed type char byte_200002AB;
// 20000479: using guessed type char byte_20000479;
// 2000047A: using guessed type char byte_2000047A;
// 2000047B: using guessed type char byte_2000047B;
// 2000047C: using guessed type char byte_2000047C;
// 2000047D: using guessed type char byte_2000047D;
// 2000047E: using guessed type char byte_2000047E;
// 2000047F: using guessed type char byte_2000047F;
// 20000488: using guessed type int dword_20000488;
// 200004AD: using guessed type char byte_200004AD;
// 20000512: using guessed type char byte_20000512;
// 20000928: using guessed type char byte_20000928;
// 200015DE: using guessed type char byte_200015DE;
// 20002D52: using guessed type int dword_20002D52;
// 20002EAB: using guessed type char byte_20002EAB;
// 20004237: using guessed type char byte_20004237;

//----- (0801EFEC) --------------------------------------------------------
int sub_801EFEC()
{
  sub_801227E(1207963648, 64, 0);
  sub_801227E(1207961600, 2048, 0);
  sub_801227E(1207959552, 16, 0);
  sub_801227E(1207963648, 4, 0);
  sub_801227E(1207963648, 8, 0);
  sub_801227E(1207963648, 16, 0);
  sub_801227E(1207963648, 32, 0);
  ((void (__fastcall *)(_DWORD))loc_8010000)(0);
  sub_801227E(1207959552, 8, 0);
  return sub_801227E(1207959552, 32, 0);
}

//----- (0801F064) --------------------------------------------------------
int sub_801F064()
{
  sub_801EEFC();
  if ( byte_2000050C )
  {
    sub_8010014(0, 0);
    sub_8010014(1, 0);
    sub_8010014(2, 0);
    sub_8010014(3, 0);
    sub_8010014(4, 0);
    sub_8010014(5, 0);
    ((void (__fastcall *)(_DWORD))loc_8010000)(0);
    sub_8010014(7, 0);
    sub_8010014(8, 0);
    sub_8010014(9, 0);
    goto LABEL_158;
  }
  if ( byte_20002E38 != 13 )
  {
    if ( !byte_2000047C || byte_2000047C == 1 )
    {
      sub_8010014(5, 0);
    }
    else if ( byte_2000047C == 2 )
    {
      sub_8010014(5, 1);
    }
    if ( byte_2000047B )
    {
      if ( byte_2000047B != 1 )
      {
        if ( byte_2000047B == 2 )
          sub_8010014(3, 1);
        goto LABEL_21;
      }
      if ( (unsigned int)dword_20000490 > 5 )
        dword_20000490 = 0;
      if ( !dword_20000490 )
        sub_8010014(3, 1);
      if ( dword_20000490 != 3 )
      {
LABEL_21:
        if ( byte_2000047D )
        {
          if ( byte_2000047D != 1 )
          {
            if ( byte_2000047D == 2 )
              sub_8010014(4, 1);
            goto LABEL_32;
          }
          if ( (unsigned int)dword_20000494 > 5 )
            dword_20000494 = 0;
          if ( !dword_20000494 )
            sub_8010014(4, 1);
          if ( dword_20000494 != 3 )
          {
LABEL_32:
            if ( byte_2000047F && byte_2000047F == 2 )
              sub_8010014(1, 1);
            else
              sub_8010014(1, 0);
            if ( byte_2000047E && byte_2000047E == 2 )
              sub_8010014(2, 1);
            else
              sub_8010014(2, 0);
            if ( !byte_2000047A )
            {
              switch ( byte_20000479 )
              {
                case 7:
                  if ( (unsigned int)dword_20000488 >= 0x14 )
                    dword_20000488 = 0;
                  if ( (unsigned int)dword_20000488 <= 0xA )
                    ((void (__fastcall *)(int))loc_8010000)(100 * dword_20000488);
                  else
                    ((void (__fastcall *)(int))loc_8010000)(100 * (20 - dword_20000488));
                  sub_8010014(7, 0);
                  sub_8010014(8, 0);
                  sub_8010014(9, 0);
                  break;
                case 8:
                  ((void (__fastcall *)(int))loc_8010000)(10000);
                  sub_8010014(7, 0);
                  sub_8010014(8, 0);
                  sub_8010014(9, 0);
                  break;
                case 9:
                  ((void (__fastcall *)(int))loc_8010000)(10000);
                  sub_8010014(7, 1);
                  sub_8010014(8, 0);
                  sub_8010014(9, 0);
                  break;
                case 10:
                  ((void (__fastcall *)(int))loc_8010000)(10000);
                  sub_8010014(7, 1);
                  sub_8010014(8, 1);
                  sub_8010014(9, 0);
                  break;
                case 11:
                  ((void (__fastcall *)(int))loc_8010000)(10000);
                  sub_8010014(7, 1);
                  sub_8010014(8, 1);
                  sub_8010014(9, 1);
                  break;
              }
              goto LABEL_157;
            }
            if ( byte_2000047A != 5 )
            {
              if ( byte_2000047A != 6 )
                goto LABEL_157;
              if ( byte_20000479 != 7 )
              {
                switch ( byte_20000479 )
                {
                  case 8:
                    if ( (unsigned int)dword_20000488 >= 0xA )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      ((void (__fastcall *)(int))loc_8010000)(10000);
                      sub_8010014(7, 0);
                      sub_8010014(8, 0);
                      sub_8010014(9, 0);
                    }
                    if ( dword_20000488 != 5 )
                      goto LABEL_157;
LABEL_156:
                    ((void (__fastcall *)(_DWORD))loc_8010000)(0);
                    goto LABEL_157;
                  case 9:
                    if ( (unsigned int)dword_20000488 >= 0xF )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      ((void (__fastcall *)(int))loc_8010000)(10000);
                      sub_8010014(7, 1);
                      sub_8010014(8, 0);
                      sub_8010014(9, 0);
                    }
                    if ( dword_20000488 != 5 )
                    {
                      if ( dword_20000488 != 10 )
                        goto LABEL_157;
                      goto LABEL_156;
                    }
                    break;
                  case 10:
                    if ( (unsigned int)dword_20000488 >= 0x14 )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      ((void (__fastcall *)(int))loc_8010000)(10000);
                      sub_8010014(7, 1);
                      sub_8010014(8, 1);
                      sub_8010014(9, 0);
                    }
                    if ( dword_20000488 == 5 )
                    {
LABEL_141:
                      sub_8010014(8, 0);
                      goto LABEL_157;
                    }
                    if ( dword_20000488 != 10 )
                    {
                      if ( dword_20000488 != 15 )
                        goto LABEL_157;
                      goto LABEL_156;
                    }
                    break;
                  case 11:
                    if ( (unsigned int)dword_20000488 >= 0x19 )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      ((void (__fastcall *)(int))loc_8010000)(10000);
                      sub_8010014(7, 1);
                      sub_8010014(8, 1);
                      sub_8010014(9, 1);
                    }
                    if ( dword_20000488 == 5 )
                    {
                      sub_8010014(9, 0);
                      goto LABEL_157;
                    }
                    if ( dword_20000488 != 10 )
                    {
                      if ( dword_20000488 != 15 )
                      {
                        if ( dword_20000488 != 20 )
                          goto LABEL_157;
                        goto LABEL_156;
                      }
                      break;
                    }
                    goto LABEL_141;
                  default:
                    goto LABEL_157;
                }
                sub_8010014(7, 0);
                goto LABEL_157;
              }
              ((void (__fastcall *)(_DWORD))loc_8010000)(0);
              sub_8010014(7, 0);
              sub_8010014(8, 0);
              sub_8010014(9, 0);
LABEL_157:
              ++dword_20000494;
              ++dword_2000048C;
              ++dword_20000490;
              ++dword_20000488;
              goto LABEL_158;
            }
            if ( byte_20000479 == 7 || byte_20000479 == 8 )
            {
              if ( (unsigned int)dword_20000488 >= 0x19 )
                dword_20000488 = 0;
              if ( !dword_20000488 )
              {
                ((void (__fastcall *)(_DWORD))loc_8010000)(0);
                sub_8010014(7, 0);
                sub_8010014(8, 0);
                sub_8010014(9, 0);
              }
              if ( dword_20000488 == 5 )
              {
                ((void (__fastcall *)(int))loc_8010000)(10000);
                goto LABEL_157;
              }
              if ( dword_20000488 != 10 )
              {
                if ( dword_20000488 != 15 )
                {
                  if ( dword_20000488 != 20 )
                    goto LABEL_157;
                  goto LABEL_102;
                }
                goto LABEL_101;
              }
            }
            else
            {
              if ( byte_20000479 != 9 )
              {
                if ( byte_20000479 != 10 )
                {
                  if ( byte_20000479 == 11 )
                  {
                    if ( (unsigned int)dword_20000488 >= 0xA )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      ((void (__fastcall *)(int))loc_8010000)(10000);
                      sub_8010014(7, 1);
                      sub_8010014(8, 1);
                      sub_8010014(9, 0);
                    }
                    if ( dword_20000488 == 5 )
                      sub_8010014(9, 1);
                  }
                  goto LABEL_157;
                }
                if ( (unsigned int)dword_20000488 >= 0xF )
                  dword_20000488 = 0;
                if ( !dword_20000488 )
                {
                  ((void (__fastcall *)(int))loc_8010000)(10000);
                  sub_8010014(7, 1);
                  sub_8010014(8, 0);
                  sub_8010014(9, 0);
                }
                if ( dword_20000488 != 5 )
                {
                  if ( dword_20000488 != 10 )
                    goto LABEL_157;
LABEL_102:
                  sub_8010014(9, 1);
                  goto LABEL_157;
                }
                goto LABEL_101;
              }
              if ( (unsigned int)dword_20000488 >= 0x14 )
                dword_20000488 = 0;
              if ( !dword_20000488 )
              {
                ((void (__fastcall *)(int))loc_8010000)(10000);
                sub_8010014(7, 0);
                sub_8010014(8, 0);
                sub_8010014(9, 0);
              }
              if ( dword_20000488 != 5 )
              {
                if ( dword_20000488 != 10 )
                {
                  if ( dword_20000488 != 15 )
                    goto LABEL_157;
                  goto LABEL_102;
                }
LABEL_101:
                sub_8010014(8, 1);
                goto LABEL_157;
              }
            }
            sub_8010014(7, 1);
            goto LABEL_157;
          }
        }
        sub_8010014(4, 0);
        goto LABEL_32;
      }
    }
    sub_8010014(3, 0);
    goto LABEL_21;
  }
LABEL_158:
  if ( (unsigned int)++dword_2000049C <= 4 )
    JUMPOUT(0x801F6A0);
  return sub_801F5A4();
}
// 801F5A2: control flows out of bounds to 801F6A0
// 801F5A4: using guessed type int sub_801F5A4(void);
// 20000479: using guessed type char byte_20000479;
// 2000047A: using guessed type char byte_2000047A;
// 2000047B: using guessed type char byte_2000047B;
// 2000047C: using guessed type char byte_2000047C;
// 2000047D: using guessed type char byte_2000047D;
// 2000047E: using guessed type char byte_2000047E;
// 2000047F: using guessed type char byte_2000047F;
// 20000488: using guessed type int dword_20000488;
// 2000048C: using guessed type int dword_2000048C;
// 20000490: using guessed type int dword_20000490;
// 20000494: using guessed type int dword_20000494;
// 2000049C: using guessed type int dword_2000049C;
// 2000050C: using guessed type char byte_2000050C;
// 20002E38: using guessed type char byte_20002E38;

//----- (0801F5A4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_801F5A4()
{
  int v0; // r4
  _BYTE *v1; // r5
  unsigned int v2; // r6
  int v3; // r7
  int v4; // r0
  int (*v6)(void); // [sp-4h] [bp-4h]

  if ( byte_20000506 == 1 && byte_20000928 == 1 )
  {
    byte_20000506 = v0;
    sub_801227E(1207962624, 1, 1);
    sub_80031E4();
    sub_801EE84(v4);
    sub_8007960(0);
    sub_80232B4(60000);
    sub_8022ADC();
  }
  sub_801226E(1207962624, 1);
  *(_DWORD *)(v3 + 36) = v0;
  sub_801EC40();
  if ( (unsigned __int8)byte_20000505 >= 2u )
  {
    byte_20000505 -= 2;
    sub_80055F0(0x150u, &byte_20000505, 1u);
  }
  if ( byte_200004AD != 1 || byte_200002AB || byte_200036AF || byte_200036B0 )
  {
    sub_8022F0C();
  }
  else if ( (unsigned int)(dword_2000002C - *(_DWORD *)(v3 + 32) - 3601) < 0x63 )
  {
    *v1 = 1;
    sub_8004798();
  }
  sub_8003248();
  if ( *v1 )
  {
    if ( !BYTE2(dword_20002D68) && *(_BYTE *)v3 == 1 )
    {
      *v1 = v0;
      sub_80055F0(0x100u, &byte_2000050C, 1u);
    }
  }
  else if ( BYTE2(dword_20002D68) == 1 )
  {
    *v1 = 1;
    sub_8017DFC(21, 0, 0, 0);
  }
  if ( byte_200002C6 )
  {
    sub_801CE90(15);
    byte_200002C6 = v0;
  }
  sub_800478C();
  if ( (unsigned int)(sub_8012298() - dword_20000474) <= 0x4E20 && dword_20000474 )
    *(_BYTE *)v3 = 1;
  else
    *(_BYTE *)v3 = v0;
  if ( sub_8012298() - dword_20000474 <= v2 || sub_8012298() - *(_DWORD *)(v3 + 12) <= v2 )
    return v6();
  *(_DWORD *)(v3 + 12) = sub_8012298();
  return sub_80047B8();
}
// 801F6D2: positive sp value 18 has been found
// 801F5A4: could not find valid save-restore pair for r8
// 801F5B8: variable 'v0' is possibly undefined
// 801F5D2: variable 'v4' is possibly undefined
// 801F5F0: variable 'v3' is possibly undefined
// 801F630: variable 'v1' is possibly undefined
// 801F6BA: variable 'v2' is possibly undefined
// 801F6DA: variable 'v6' is possibly undefined
// 801EE84: using guessed type __int64 __fastcall sub_801EE84(_DWORD);
// 2000002C: using guessed type int dword_2000002C;
// 200002AB: using guessed type char byte_200002AB;
// 200002C6: using guessed type char byte_200002C6;
// 20000474: using guessed type int dword_20000474;
// 200004AD: using guessed type char byte_200004AD;
// 20000505: using guessed type char byte_20000505;
// 20000506: using guessed type char byte_20000506;
// 2000050C: using guessed type char byte_2000050C;
// 20000928: using guessed type char byte_20000928;
// 20002D68: using guessed type int dword_20002D68;
// 200036AF: using guessed type char byte_200036AF;
// 200036B0: using guessed type char byte_200036B0;

//----- (0801F7E0) --------------------------------------------------------
int sub_801F7E0()
{
  sub_80031E4();
  sub_8023648((_DWORD *)dword_2000001C);
  sub_8023648((_DWORD *)dword_20000020);
  sub_8023648((_DWORD *)dword_20000024);
  sub_8023648((_DWORD *)dword_20000004);
  return sub_8023648((_DWORD *)dword_20000010);
}
// 20000004: using guessed type int dword_20000004;
// 20000010: using guessed type int dword_20000010;
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 20000024: using guessed type int dword_20000024;

//----- (0801F81C) --------------------------------------------------------
_DWORD *__fastcall sub_801F81C(int a1, int a2)
{
  unsigned int v4; // r6
  int v5; // r0
  _DWORD *result; // r0
  unsigned int v7; // r4

  v4 = dword_20001658;
  *(_BYTE *)(dword_2000164C + 89) = 0;
  if ( !sub_8022F20((_DWORD *)(dword_2000164C + 4)) )
    dword_2000165C &= ~(1 << *(_BYTE *)(dword_2000164C + 44));
  if ( a1 == -1 && a2 )
  {
    v5 = dword_200118CC;
    *(_DWORD *)(dword_2000164C + 8) = dword_200118CC;
    *(_DWORD *)(dword_2000164C + 12) = *(_DWORD *)(v5 + 8);
    *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4) = dword_2000164C + 4;
    *(_DWORD *)(v5 + 8) = dword_2000164C + 4;
    *(_DWORD *)(dword_2000164C + 20) = &dword_200118C8;
    return (_DWORD *)++dword_200118C8;
  }
  else
  {
    v7 = a1 + v4;
    *(_DWORD *)(dword_2000164C + 4) = v7;
    if ( v7 >= v4 )
    {
      sub_802301C((_DWORD *)dword_20001684, (_DWORD *)(dword_2000164C + 4));
      result = (_DWORD *)dword_20001674;
      if ( v7 < dword_20001674 )
        dword_20001674 = v7;
    }
    else
    {
      return sub_802301C((_DWORD *)dword_20001688, (_DWORD *)(dword_2000164C + 4));
    }
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001658: using guessed type int dword_20001658;
// 2000165C: using guessed type int dword_2000165C;
// 20001674: using guessed type int dword_20001674;
// 20001684: using guessed type int dword_20001684;
// 20001688: using guessed type int dword_20001688;
// 200118C8: using guessed type int dword_200118C8;
// 200118CC: using guessed type int dword_200118CC;

//----- (0801F8B0) --------------------------------------------------------
unsigned int __fastcall sub_801F8B0(_DWORD *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  unsigned int result; // r0

  sub_8023064();
  ++dword_20001654;
  if ( dword_2000164C )
  {
    if ( !dword_20001660 && *(_DWORD *)(dword_2000164C + 44) <= a1[11] )
      dword_2000164C = (int)a1;
  }
  else
  {
    dword_2000164C = (int)a1;
    if ( dword_20001654 == 1 )
      sub_801FBD4();
  }
  a1[17] = ++dword_20001670;
  v2 = a1[11];
  dword_2000165C |= 1 << v2;
  v3 = dword_200115F8[5 * v2 + 1];
  a1[2] = v3;
  a1[3] = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4) = a1 + 1;
  *(_DWORD *)(v3 + 8) = a1 + 1;
  v4 = 5 * a1[11];
  a1[5] = &dword_200115F8[5 * a1[11]];
  ++dword_200115F8[v4];
  sub_80230E4();
  result = dword_20001660;
  if ( dword_20001660 )
  {
    result = *(_DWORD *)(dword_2000164C + 44);
    if ( result < a1[11] )
    {
      result = 0x10000000;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001654: using guessed type int dword_20001654;
// 2000165C: using guessed type int dword_2000165C;
// 20001660: using guessed type int dword_20001660;
// 20001670: using guessed type int dword_20001670;
// 200115F8: using guessed type int dword_200115F8[160];
// E000ED04: using guessed type int ICSR;

//----- (0801F95C) --------------------------------------------------------
int sub_801F95C()
{
  int v0; // r4
  int result; // r0

  while ( 1 )
  {
    result = dword_20001650;
    if ( !dword_20001650 )
      break;
    sub_8023064();
    v0 = *(_DWORD *)(dword_200118C0 + 12);
    sub_8022F20((_DWORD *)(v0 + 4));
    --dword_20001654;
    --dword_20001650;
    sub_80230E4();
    sub_801FA2E(v0);
  }
  return result;
}
// 20001650: using guessed type int dword_20001650;
// 20001654: using guessed type int dword_20001654;
// 200118C0: using guessed type int dword_200118C0;

//----- (0801F998) --------------------------------------------------------
_DWORD *__fastcall sub_801F998(_DWORD *result, unsigned int a2)
{
  unsigned int v3; // r2
  unsigned int v4; // r1

  v3 = result[16];
  if ( v3 )
  {
    v4 = result[3] + v3;
    result[3] = v4;
    if ( v4 >= result[2] )
      result[3] = *result;
    return (_DWORD *)qmemcpy(a2, result[3], v3);
  }
  return result;
}

//----- (0801F9C0) --------------------------------------------------------
int __fastcall sub_801F9C0(unsigned int *a1, unsigned int a2, int a3)
{
  int v5; // r6
  unsigned int v6; // r5
  unsigned int v7; // r2
  unsigned int v8; // r0
  unsigned int v9; // r1
  unsigned int v10; // r0

  v5 = 0;
  v6 = a1[14];
  v7 = a1[16];
  if ( v7 )
  {
    if ( a3 )
    {
      qmemcpy(a1[3], a2, v7);
      v8 = a1[16];
      v9 = a1[3] - v8;
      a1[3] = v9;
      if ( v9 < *a1 )
        a1[3] = a1[2] - v8;
      if ( a3 == 2 && v6 )
        --v6;
    }
    else
    {
      qmemcpy(a1[1], a2, v7);
      v10 = a1[1] + a1[16];
      a1[1] = v10;
      if ( v10 >= a1[2] )
        a1[1] = *a1;
    }
  }
  else if ( !*a1 )
  {
    v5 = sub_802554C(a1[2]);
    a1[2] = 0;
  }
  a1[14] = v6 + 1;
  return v5;
}

//----- (0801FA2E) --------------------------------------------------------
void __fastcall sub_801FA2E(int a1)
{
  ((void (__fastcall *)(_DWORD))loc_8023154)(*(_DWORD *)(a1 + 48));
  JUMPOUT(0x8023154);
}
// 801FA3E: control flows out of bounds to 8023154

//----- (0801FA42) --------------------------------------------------------
int __fastcall sub_801FA42(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
    return 32 - **(_DWORD **)(a1 + 48);
  else
    return 0;
}

//----- (0801FAC8) --------------------------------------------------------
_DWORD *__fastcall sub_801FAC8(_DWORD *result)
{
  if ( result )
  {
    result[2] = 0;
    *result = 0;
    result[3] = 0;
    return (_DWORD *)sub_8024A40((int)result, 0, 0, 0);
  }
  return result;
}

//----- (0801FAE0) --------------------------------------------------------
int __fastcall sub_801FAE0(int a1, int a2, int a3, char a4, int a5)
{
  int result; // r0

  if ( a2 )
    *(_DWORD *)a5 = a3;
  else
    *(_DWORD *)a5 = a5;
  *(_DWORD *)(a5 + 60) = a1;
  *(_DWORD *)(a5 + 64) = a2;
  sub_8024960(a5, 1);
  *(_BYTE *)(a5 + 80) = a4;
  result = 0;
  *(_DWORD *)(a5 + 72) = 0;
  return result;
}

//----- (0801FB08) --------------------------------------------------------
_DWORD *__fastcall sub_801FB08(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, int a7)
{
  int v7; // r5
  unsigned int v12; // r7
  unsigned int i; // r0
  _DWORD *result; // r0

  v7 = a5;
  sub_8002356(*(_BYTE **)(a7 + 48), 4 * a3, 165);
  v12 = (*(_DWORD *)(a7 + 48) + 4 * (a3 - 1)) & 0xFFFFFFF8;
  if ( v12 << 29 )
    sub_801E1B0((int)sub_801FBC4, "..\\..\\SDK\\FreeRTOS\\tasks.c", 861);
  if ( a2 )
  {
    for ( i = 0; i < 0x10; ++i )
    {
      *(_BYTE *)(a7 + i + 52) = *(_BYTE *)(a2 + i);
      if ( !*(_BYTE *)(a2 + i) )
        break;
    }
    *(_BYTE *)(a7 + 67) = 0;
  }
  if ( a5 >= 0x20 )
  {
    sub_801E1B0((int)sub_801FBC4, "..\\..\\SDK\\FreeRTOS\\tasks.c", 914);
    v7 = 31;
  }
  *(_DWORD *)(a7 + 44) = v7;
  *(_DWORD *)(a7 + 76) = v7;
  sub_8023016(a7 + 4);
  sub_8023016(a7 + 24);
  *(_DWORD *)(a7 + 16) = a7;
  *(_DWORD *)(a7 + 24) = 32 - v7;
  *(_DWORD *)(a7 + 36) = a7;
  result = sub_8020020(v12, a1, a4);
  *(_DWORD *)a7 = result;
  if ( a6 )
    *a6 = a7;
  return result;
}

//----- (0801FBC4) --------------------------------------------------------
int __fastcall sub_801FBC4(int a1)
{
  char v1; // r5

  *(_BYTE *)(a1 + 9) = v1;
  return sub_801FBD4();
}
// 801FBC4: variable 'v1' is possibly undefined
// 801FBD4: using guessed type int sub_801FBD4(void);

//----- (0801FBD4) --------------------------------------------------------
int *sub_801FBD4()
{
  unsigned int i; // r4
  int *result; // r0

  for ( i = 0; i < 0x20; ++i )
    sub_8023000(&dword_200115F8[5 * i]);
  sub_8023000(dword_20011878);
  sub_8023000(&dword_20011878[5]);
  sub_8023000(&dword_200118A0);
  sub_8023000(dword_200118B4);
  sub_8023000(&dword_200118C8);
  result = &dword_2000164C;
  dword_20001684 = (int)dword_20011878;
  dword_20001688 = (int)&dword_20011878[5];
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001684: using guessed type int dword_20001684;
// 20001688: using guessed type int dword_20001688;
// 200115F8: using guessed type int dword_200115F8[160];
// 20011878: using guessed type _DWORD dword_20011878[10];
// 200118A0: using guessed type int dword_200118A0;
// 200118B4: using guessed type _DWORD dword_200118B4[3];
// 200118C8: using guessed type int dword_200118C8;

//----- (0801FC2C) --------------------------------------------------------
int *__fastcall sub_801FC2C(int *result)
{
  int *i; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r4

  for ( i = &dword_200016A0; ; i = (int *)*i )
  {
    v2 = *i;
    if ( *i >= (unsigned int)result )
      break;
  }
  v3 = i[1];
  if ( (int *)((char *)i + v3) == result )
  {
    i[1] = result[1] + v3;
    result = i;
  }
  v4 = result[1];
  if ( (int *)((char *)result + v4) == (int *)*i )
  {
    if ( v2 == dword_2000168C )
    {
      *result = dword_2000168C;
    }
    else
    {
      result[1] = *(_DWORD *)(v2 + 4) + v4;
      *result = *(_DWORD *)*i;
    }
  }
  else
  {
    *result = v2;
  }
  if ( i != result )
    *i = (int)result;
  return result;
}
// 2000168C: using guessed type int dword_2000168C;
// 200016A0: using guessed type int dword_200016A0;

//----- (0801FC80) --------------------------------------------------------
BOOL __fastcall sub_801FC80(int a1)
{
  BOOL v2; // r4

  sub_8023064();
  v2 = *(_DWORD *)(a1 + 56) == 0;
  sub_80230E4();
  return v2;
}

//----- (0801FC9A) --------------------------------------------------------
BOOL __fastcall sub_801FC9A(int a1)
{
  BOOL v2; // r4

  sub_8023064();
  v2 = *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 60);
  sub_80230E4();
  return v2;
}

//----- (0801FCB8) --------------------------------------------------------
int __fastcall sub_801FCB8(int a1, _DWORD *a2, int a3)
{
  int v6; // r6
  _DWORD *v7; // r0
  _DWORD *v8; // r7
  int v9; // r10
  _DWORD *v10; // r5
  int v11; // r5

  v6 = 0;
  if ( *a2 )
  {
    v7 = *(_DWORD **)(a2[1] + 4);
    a2[1] = v7;
    v8 = a2 + 2;
    if ( v7 == a2 + 2 )
      a2[1] = v7[1];
    v9 = *(_DWORD *)(a2[1] + 12);
    do
    {
      v10 = *(_DWORD **)(a2[1] + 4);
      a2[1] = v10;
      if ( v10 == v8 )
        a2[1] = v10[1];
      v11 = *(_DWORD *)(a2[1] + 12);
      sub_802332C(v11, a1 + 36 * v6++, 1, a3);
    }
    while ( v11 != v9 );
  }
  return v6;
}

//----- (0801FD14) --------------------------------------------------------
int __fastcall sub_801FD14(int a1)
{
  int v1; // r4
  int v2; // r6
  unsigned int v3; // r5
  int v5; // [sp+0h] [bp-18h] BYREF

  v5 = a1;
  v1 = *(_DWORD *)(a1 + 72);
  v2 = 0;
  if ( !v1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3043);
  if ( *(_DWORD *)(v1 + 56) >= *(_DWORD *)(v1 + 60) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3044);
  if ( *(_DWORD *)(v1 + 56) < *(_DWORD *)(v1 + 60) )
  {
    v3 = *(char *)(v1 + 69);
    v2 = sub_801F9C0((unsigned int *)v1, (unsigned int)&v5, 0);
    if ( v3 == -1 )
    {
      if ( *(_DWORD *)(v1 + 36) && sub_80256DC(v1 + 36) )
        return 1;
    }
    else if ( v3 < sub_8022F48() )
    {
      if ( v3 == 127 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3076);
      *(_BYTE *)(v1 + 69) = v3 + 1;
    }
  }
  return v2;
}

//----- (0801FDC0) --------------------------------------------------------
int *sub_801FDC0()
{
  int *result; // r0

  result = &dword_2000164C;
  if ( *(_DWORD *)dword_20001684 )
    dword_20001674 = **(_DWORD **)(dword_20001684 + 12);
  else
    dword_20001674 = -1;
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001674: using guessed type int dword_20001674;
// 20001684: using guessed type int dword_20001684;

//----- (0801FDE0) --------------------------------------------------------
int __fastcall sub_801FDE0(unsigned __int8 *a1)
{
  unsigned int v1; // r1

  v1 = 0;
  while ( *a1 == 165 )
  {
    ++a1;
    ++v1;
  }
  return (unsigned __int16)(v1 >> 2);
}

//----- (0801FE60) --------------------------------------------------------
int __fastcall sub_801FE60(int a1)
{
  int i; // r5
  int j; // r5

  sub_8023064();
  for ( i = *(char *)(a1 + 69); i > 0; i = (char)(i - 1) )
  {
    if ( *(_DWORD *)(a1 + 72) )
    {
      if ( !sub_801FD14(a1) )
        continue;
LABEL_7:
      sub_802345C();
      continue;
    }
    if ( !*(_DWORD *)(a1 + 36) )
      break;
    if ( sub_80256DC(a1 + 36) )
      goto LABEL_7;
  }
  *(_BYTE *)(a1 + 69) = -1;
  sub_80230E4();
  sub_8023064();
  for ( j = *(char *)(a1 + 68); j > 0 && *(_DWORD *)(a1 + 16); j = (char)(j - 1) )
  {
    if ( sub_80256DC(a1 + 16) )
      sub_802345C();
  }
  *(_BYTE *)(a1 + 68) = -1;
  return sub_80230E4();
}

//----- (0801FEDC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_801FEDC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *i; // r0

  sub_800240C(a1, a2);
  for ( i = sub_80023E2(a1); (unsigned int)i < 0xF; ++i )
    i[(_DWORD)a1] = 32;
  i[(_DWORD)a1] = 0;
  return &a1[(_DWORD)i];
}

//----- (0801FF14) --------------------------------------------------------
void __fastcall sub_801FF14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  unsigned int v10; // r5
  int v11; // r6
  int **v12; // r7
  int v17; // r0
  int v18; // r5
  int *v19; // r1
  int *i; // r4
  int v21; // r1
  int *v22; // r0

  __asm { STC             p1, c11, [R1,#0x134]! }
  v17 = 16 - (v10 & 7);
  if ( v10 > ~v17 )
    v18 = 0;
  else
    v18 = v10 + v17;
  if ( v18 > 0 && v18 <= (unsigned int)v12[1] )
  {
    v19 = &dword_200016A0;
    for ( i = (int *)dword_200016A0; i[1] < (unsigned int)v18 && *i; i = (int *)*i )
      v19 = i;
    if ( i != *v12 )
    {
      v11 = *v19 + 8;
      *v19 = *i;
      if ( (unsigned int)(i[1] - v18) > 0x10 )
      {
        if ( ((_DWORD)i + v18) << 29 )
          sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 220);
        *(int *)((char *)i + v18 + 4) = i[1] - v18;
        i[1] = v18;
        sub_801FC2C((int *)((char *)i + v18));
      }
      v21 = i[1];
      v22 = (int *)((char *)v12[1] - v21);
      v12[1] = v22;
      if ( v22 < v12[2] )
        v12[2] = v22;
      i[1] = v21 | 0x80000000;
      *i = 0;
      v12[3] = (int *)((char *)v12[3] + 1);
    }
  }
  sub_80257E4();
  if ( v11 << 29 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 284);
  __asm { POP.W           {R4-R8,PC} }
}
// 801FFC0: unbalanced stack, ignored a potential tail call
// 801FF18: variable 'v10' is possibly undefined
// 801FF30: variable 'v12' is possibly undefined
// 801FFAE: variable 'v11' is possibly undefined
// 200016A0: using guessed type int dword_200016A0;

//----- (08020008) --------------------------------------------------------
int sub_8020008()
{
  if ( dword_2000164C )
    ++*(_DWORD *)(dword_2000164C + 80);
  return dword_2000164C;
}
// 2000164C: using guessed type int dword_2000164C;

//----- (08020020) --------------------------------------------------------
_DWORD *__fastcall sub_8020020(int a1, int a2, int a3)
{
  _DWORD *v3; // r0

  v3 = (_DWORD *)(a1 - 36);
  v3[8] = 0x1000000;
  v3[7] = a2 & 0xFFFFFFFE;
  v3[6] = 134350325;
  v3[1] = a3;
  *v3 = -3;
  return v3 - 8;
}

//----- (08020044) --------------------------------------------------------
unsigned int __fastcall sub_8020044(unsigned int a1, unsigned int a2, __int16 a3)
{
  unsigned int v3; // r3
  unsigned int v4; // r0
  unsigned int result; // r0

  v3 = a1 % 0x64 + 100;
  v4 = (unsigned __int16)((v3 + (v3 >> 2)) % 7 + a3 + *((unsigned __int8 *)dword_8026138 + a2 - 1));
  if ( !(v3 << 30) && a2 < 3 )
    v4 = (unsigned __int16)(v4 - 1);
  result = v4 % 7;
  if ( !result )
    LOBYTE(result) = 7;
  return (unsigned __int8)result;
}
// 8026138: using guessed type int dword_8026138[3];

//----- (08020090) --------------------------------------------------------
int sub_8020090()
{
  MEMORY[0x40021090] |= 0x8000u;
  MEMORY[0x40021058] |= 0x10000000u;
  dword_2000213C = 1073752064;
  dword_20002140 = 0;
  dword_20002144 = 127;
  dword_20002148 = 255;
  dword_2000214C = 0;
  dword_20002154 = 0;
  dword_20002158 = 0x40000000;
  dword_2000215C = 0;
  return sub_8013F48((int)&dword_2000213C);
}
// 2000213C: using guessed type int dword_2000213C;
// 20002140: using guessed type int dword_20002140;
// 20002144: using guessed type int dword_20002144;
// 20002148: using guessed type int dword_20002148;
// 2000214C: using guessed type int dword_2000214C;
// 20002154: using guessed type int dword_20002154;
// 20002158: using guessed type int dword_20002158;
// 2000215C: using guessed type int dword_2000215C;

//----- (080200DC) --------------------------------------------------------
int __fastcall sub_80200DC(unsigned int a1, unsigned int a2, __int16 a3)
{
  unsigned __int8 v3; // r4
  unsigned __int8 v5[16]; // [sp+0h] [bp-10h] BYREF

  v3 = a1;
  v5[2] = a3;
  v5[1] = a2;
  v5[0] = sub_8020044(a1, a2, a3);
  v5[3] = v3;
  return sub_8014030(&dword_2000213C, v5, 0);
}
// 2000213C: using guessed type int dword_2000213C;

//----- (08020108) --------------------------------------------------------
int __fastcall sub_8020108(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  unsigned __int8 v4[12]; // [sp+0h] [bp-18h] BYREF
  int v5; // [sp+Ch] [bp-Ch]
  int v6; // [sp+10h] [bp-8h]

  v4[0] = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = 0;
  v5 = 0;
  v6 = 0;
  return sub_80140D4(&dword_2000213C, v4, 0);
}
// 2000213C: using guessed type int dword_2000213C;

//----- (08020134) --------------------------------------------------------
int __fastcall sub_8020134(int result)
{
  int v1; // r1

  v1 = 0;
  while ( dword_200115D8[v1] )
  {
    v1 = (__int16)(v1 + 1);
    if ( v1 >= 5 )
      return result;
  }
  dword_200115D8[v1] = result;
  return result;
}
// 200115D8: using guessed type _DWORD dword_200115D8[5];

//----- (0802015C) --------------------------------------------------------
int __fastcall sub_802015C(int a1)
{
  int result; // r0

  if ( sub_80023F0(*(_DWORD *)(a1 + 16), *(_DWORD *)(*(_DWORD *)a1 + 8)) )
  {
    sub_8021244(a1, (unsigned __int8 *)dword_2000162C);
  }
  else
  {
    *(_BYTE *)(a1 + 96) |= 1u;
    sub_8021244(a1, (unsigned __int8 *)dword_200015F8);
  }
  result = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 14) = 0;
  return result;
}
// 200015F8: using guessed type int dword_200015F8;
// 2000162C: using guessed type int dword_2000162C;

//----- (0802019C) --------------------------------------------------------
int __fastcall sub_802019C(int a1, _BYTE *a2)
{
  if ( (!*a2 || (a2[1] & 0xF) == 8 || (*a2 & **(_BYTE **)a1) != 0)
    && (*(unsigned __int8 *)(a1 + 96) << 31 || (a2[1] & 0x10) != 0) )
  {
    return 0;
  }
  else
  {
    return -1;
  }
}

//----- (080201CC) --------------------------------------------------------
int sub_80201CC()
{
  int result; // r0

  result = sub_80206C4();
  if ( result )
    return sub_8021244(result, (unsigned __int8 *)dword_20001630);
  return result;
}
// 20001630: using guessed type int dword_20001630;

//----- (080201E8) --------------------------------------------------------
int __fastcall sub_80201E8(int a1)
{
  int i; // r4

  for ( i = (__int16)(*(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 14)); i > 0; i = (__int16)(i - 1) )
    sub_802109A(a1, 32);
  return sub_80202D8(a1, *(unsigned __int8 *)(a1 + 12));
}

//----- (080202D8) --------------------------------------------------------
int __fastcall sub_80202D8(int result, int a2)
{
  int i; // r5
  bool v4; // cf

  for ( i = result; ; result = sub_8021244(i, (unsigned __int8 *)sub_80202F0) )
  {
    v4 = a2 != 0;
    a2 = (unsigned __int8)(a2 - 1);
    if ( !v4 )
      break;
  }
  return result;
}

//----- (080202F0) --------------------------------------------------------
int __fastcall sub_80202F0(int a1, int a2)
{
  return sub_802082C(a2, -1);
}

//----- (080202FC) --------------------------------------------------------
int __fastcall sub_80202FC(int a1)
{
  sub_8020314(a1);
  return sub_8021158(a1, 1);
}

//----- (08020314) --------------------------------------------------------
unsigned int __fastcall sub_8020314(int a1)
{
  unsigned int result; // r0
  int v3; // r1

  result = *(unsigned __int16 *)(a1 + 12);
  if ( result )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 16) + result) = 0;
    if ( *(unsigned __int8 *)(a1 + 96) << 31 )
    {
      sub_80208C6(a1);
      sub_8020BA8(a1);
      *(_WORD *)(a1 + 14) = 0;
      *(_WORD *)(a1 + 12) = 0;
      result = *(unsigned __int16 *)(a1 + 54);
      if ( *(_WORD *)(a1 + 54) )
      {
        sub_8021244(a1, (unsigned __int8 *)&dword_8020380);
        v3 = sub_8020D08(a1, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 88), 0);
        if ( v3 )
          return sub_8020C76(a1, v3);
        else
          return sub_8021244(a1, (unsigned __int8 *)dword_20001610);
      }
    }
    else
    {
      return sub_802015C(a1);
    }
  }
  return result;
}
// 8020380: using guessed type int dword_8020380;
// 20001610: using guessed type int dword_20001610;

//----- (08020388) --------------------------------------------------------
int __fastcall sub_8020388(unsigned __int8 *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r3

  v1 = 0;
  v2 = *a1;
  if ( v2 == 48 && ((v3 = a1[1], v3 == 120) || v3 == 88) )
  {
    v1 = 3;
  }
  else if ( v2 == 48 && ((v4 = a1[1], v4 == 98) || v4 == 66) )
  {
    v1 = 1;
  }
  else if ( v2 == 48 )
  {
    v1 = 2;
  }
  while ( *a1++ )
  {
    if ( *a1 == 46 && a1[1] )
      return 4;
  }
  return v1;
}

//----- (080203D6) --------------------------------------------------------
int __fastcall sub_80203D6(int a1)
{
  unsigned __int8 *v1; // r1
  int result; // r0
  int v3; // r1

  v1 = (unsigned __int8 *)(a1 + 1);
  result = 0;
  if ( *v1 != 92 )
    return *v1;
  v3 = v1[1];
  if ( v3 == 110 )
    return 10;
  if ( v3 > 110 )
  {
    if ( v3 == 114 )
      return 13;
    if ( v3 == 116 )
      return 9;
    return v3;
  }
  if ( v3 != 48 )
  {
    if ( v3 == 98 )
      return 8;
    return v3;
  }
  return result;
}

//----- (08020412) --------------------------------------------------------
float __fastcall sub_8020412(_BYTE *a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r7
  int v5; // r6
  unsigned int v6; // r5
  int v7; // r0
  int v8; // r9
  _BYTE *i; // r4
  int v10; // r0
  float result; // r0

  v2 = 10;
  v3 = 0;
  v4 = 1;
  v5 = 0;
  v6 = 0;
  if ( *a1 == 45 )
    v4 = -1;
  v7 = sub_8020388(&a1[v4 == -1]);
  v8 = v7;
  switch ( v7 )
  {
    case 1:
      v2 = 2;
      v3 = 2;
      break;
    case 2:
      v2 = 8;
      v3 = 1;
      break;
    case 3:
      v2 = 16;
      v3 = 2;
      break;
  }
  for ( i = &a1[v3 + (v4 == -1)]; ; ++i )
  {
    v10 = (unsigned __int8)*i;
    if ( !*i )
      break;
    if ( v10 == 46 )
    {
      v6 = 1;
    }
    else
    {
      v5 = sub_802064C(v10) + v5 * v2;
      v6 *= 10;
    }
  }
  if ( v8 == 4 && v6 )
    return (float)((float)(unsigned int)v5 / (float)v6) * (float)v4;
  LODWORD(result) = v5 * v4;
  return result;
}

//----- (080204D4) --------------------------------------------------------
float __fastcall sub_80204D4(int a1, unsigned __int8 *a2)
{
  int v4; // r1
  unsigned __int8 *v6; // r6
  unsigned __int8 *v7; // r4
  int v8; // r5
  int v9; // r0
  int v10; // r4
  int v11; // r0

  v4 = *a2;
  if ( v4 == 39 && a2[1] )
    return COERCE_FLOAT(sub_80203D6((int)a2));
  if ( v4 == 45 || (unsigned int)(v4 - 48) <= 9 )
    return sub_8020412(a2);
  if ( v4 == 36 && a2[1] )
  {
    v10 = a1;
    v11 = sub_8020D08(a1, (int)(a2 + 1), *(_DWORD *)(a1 + 88), 0);
    if ( v11 )
      return COERCE_FLOAT(sub_80206EC(v10, v11));
    else
      return 0.0;
  }
  else if ( v4 )
  {
    v6 = a2;
    v7 = a2;
    v8 = 0;
    if ( *a2 == 34 )
    {
      v7 = a2 + 1;
      v6 = a2 + 1;
    }
    while ( 1 )
    {
      v9 = *v7;
      if ( !*v7 )
        break;
      if ( v9 == 92 )
      {
        v6[v8] = sub_80203D6((int)(v7++ - 1));
      }
      else if ( v9 == 34 )
      {
        v6[v8] = 0;
      }
      else
      {
        v6[v8] = v9;
      }
      ++v7;
      v8 = (unsigned __int16)(v8 + 1);
    }
    v6[v8] = 0;
    return *(float *)&v6;
  }
  else
  {
    return 0.0;
  }
}

//----- (08020578) --------------------------------------------------------
int __fastcall sub_8020578(int a1, int a2, int a3, int a4)
{
  int v8; // r6
  int v9; // r7
  int i; // r4
  int result; // r0
  int v12; // [sp+10h] [bp-40h] BYREF
  int v13; // [sp+14h] [bp-3Ch]
  int v14; // [sp+18h] [bp-38h]
  int v15; // [sp+1Ch] [bp-34h]
  int v16; // [sp+20h] [bp-30h]
  int v17; // [sp+24h] [bp-2Ch]
  int v18; // [sp+28h] [bp-28h]

  sub_8002364(&v12, 32);
  v8 = a3 - 1;
  v9 = *(_BYTE *)(a2 + 2) & 0xF;
  if ( v9 <= a3 - 1 )
    v9 = a3 - 1;
  for ( i = 0; i < v8; ++i )
    *((float *)&v12 + i) = sub_80204D4(a1, *(unsigned __int8 **)(a4 + 4 * (i + 1)));
  switch ( v9 )
  {
    case 0:
      result = (*(int (**)(void))(a2 + 8))();
      break;
    case 1:
      result = (*(int (__fastcall **)(int))(a2 + 8))(v12);
      break;
    case 2:
      result = (*(int (__fastcall **)(int, int))(a2 + 8))(v12, v13);
      break;
    case 3:
      result = (*(int (__fastcall **)(int, int, int))(a2 + 8))(v12, v13, v14);
      break;
    case 4:
      result = (*(int (__fastcall **)(int, int, int, int))(a2 + 8))(v12, v13, v14, v15);
      break;
    case 5:
      result = (*(int (__fastcall **)(int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16);
      break;
    case 6:
      result = (*(int (__fastcall **)(int, int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16, v17);
      break;
    case 7:
      result = (*(int (__fastcall **)(int, int, int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16, v17, v18);
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (0802064C) --------------------------------------------------------
int __fastcall sub_802064C(int a1)
{
  if ( (unsigned int)(a1 - 48) <= 9 )
    return (unsigned __int8)(a1 - 48);
  if ( (unsigned int)(a1 - 97) <= 5 )
    return (unsigned __int8)(a1 - 87);
  if ( (unsigned int)(a1 - 65) > 5 )
    return 0;
  return (unsigned __int8)(a1 - 55);
}

//----- (08020678) --------------------------------------------------------
int __fastcall sub_8020678(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08020684) --------------------------------------------------------
_BYTE *__fastcall sub_8020684(int a1)
{
  unsigned int i; // r1
  unsigned int v2; // r1

  for ( i = 0; i < 9; i = (unsigned __int8)(i + 1) )
    byte_200115EC[i] = 48;
  v2 = *(_BYTE *)(a1 + 1) & 0xF;
  if ( v2 <= 1 )
    return *(_BYTE **)(a1 + 4);
  if ( v2 <= 7 )
    return *(_BYTE **)(a1 + 4);
  if ( v2 <= 8 )
    return *(_BYTE **)(a1 + 4);
  sub_802106A(*(_DWORD *)(a1 + 4), (int)byte_200115EC);
  return byte_200115EC;
}
// 200115EC: using guessed type _BYTE byte_200115EC[12];

//----- (080206C4) --------------------------------------------------------
int sub_80206C4()
{
  int i; // r0
  int v1; // r1

  for ( i = 0; i < 5; i = (__int16)(i + 1) )
  {
    v1 = dword_200115D8[i];
    if ( v1 && (*(_BYTE *)(v1 + 96) & 2) != 0 )
      return dword_200115D8[i];
  }
  return 0;
}
// 200115D8: using guessed type _DWORD dword_200115D8[5];

//----- (080206EC) --------------------------------------------------------
int __fastcall sub_80206EC(int a1, int a2)
{
  int result; // r0
  _DWORD *v3; // r0
  int (__fastcall *v4)(_DWORD); // r1

  result = 0;
  switch ( *(_BYTE *)(a2 + 1) & 0xF )
  {
    case 2:
      result = **(_DWORD **)(a2 + 8);
      break;
    case 3:
      result = **(__int16 **)(a2 + 8);
      break;
    case 4:
      result = **(unsigned __int8 **)(a2 + 8);
      break;
    case 5:
    case 6:
      result = *(_DWORD *)(a2 + 8);
      break;
    case 7:
      v3 = *(_DWORD **)(a2 + 8);
      v4 = (int (__fastcall *)(_DWORD))v3[1];
      if ( v4 )
        result = v4(*v3);
      else
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

//----- (0802072C) --------------------------------------------------------
int __fastcall sub_802072C(int result, int a2)
{
  int v2; // r5
  int v3; // r8
  int v4; // r4
  int v5; // r9
  unsigned int v6; // r0
  int v7; // r10
  int i; // r6
  int v9; // r7
  int v10; // r0
  int v11; // r2
  void (__fastcall *v12)(int); // r1

  v2 = result;
  v3 = a2;
  if ( a2 )
  {
    v4 = 24;
    v5 = 0;
    v6 = *(_DWORD *)(result + 0x38);
    if ( (v6 & 0xFF00) != 0 )
    {
      v4 = 0;
      v5 = -256;
    }
    else if ( (v6 & 0xFF0000) != 0 )
    {
      v4 = 8;
      v5 = -65536;
    }
    else if ( HIBYTE(v6) )
    {
      v4 = 16;
      v5 = -16777216;
    }
    v7 = *(_DWORD *)(v2 + 0x58);
    for ( i = 0; *(unsigned __int16 *)(v2 + 0x5C) > i; i = (__int16)(i + 1) )
    {
      v9 = v7 + 16 * i;
      if ( (*(_BYTE *)(v9 + 1) & 0xF) == 9 && !sub_802019C(v2, (_BYTE *)(v7 + 16 * i)) )
      {
        v10 = *(_DWORD *)(v9 + 4);
        v11 = *(_DWORD *)(v2 + 0x38);
        if ( (v10 & v5) == v11 && (v10 & (255 << v4)) == v3 << v4 )
        {
          *(_DWORD *)(v2 + 0x38) = v11 | (v3 << v4);
          v3 = 0;
          if ( !v4 || (*(_DWORD *)(v9 + 4) & (255 << (v4 - 8))) == 0 )
          {
            v12 = *(void (__fastcall **)(int))(v7 + 16 * i + 8);
            if ( v12 )
              v12(v2);
            *(_DWORD *)(v2 + 0x38) = 0;
            break;
          }
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(v2 + 0x38) = 0;
      sub_8020B98(v2, v3);
    }
    result = sub_8012298();
    if ( result )
    {
      result = sub_8012298();
      *(_DWORD *)(v2 + 4) = result;
    }
  }
  return result;
}

//----- (08020804) --------------------------------------------------------
int __fastcall sub_8020804(int a1, int a2)
{
  int result; // r0
  int v4; // r3

  result = sub_80206C4();
  if ( result )
  {
    if ( v4 == 1 )
    {
      return sub_8020A9E(result);
    }
    else if ( v4 > 1 )
    {
      return sub_80210F8(result, *(_DWORD *)(a2 + 4));
    }
  }
  return result;
}
// 8020814: variable 'v4' is possibly undefined

//----- (0802082C) --------------------------------------------------------
int __fastcall sub_802082C(int result, int a2)
{
  int v2; // r4
  int v3; // r4
  int v4; // r2
  unsigned int v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r3

  v2 = result;
  if ( a2 <= 0 )
  {
    if ( a2 >= 0 )
      return result;
    result = (__int16)(*(_WORD *)(result + 84) + 1);
    *(_WORD *)(v2 + 84) = result;
    if ( result > 0 )
    {
      *(_WORD *)(v2 + 84) = 0;
      return result;
    }
  }
  else
  {
    v3 = result + 80;
    v4 = *(__int16 *)(result + 84);
    *(_WORD *)(result + 84) = v4 - 1;
    v5 = *(unsigned __int16 *)(result + 80);
    v6 = *(unsigned __int16 *)(v3 + 2);
    v2 = v3 - 80;
    if ( v5 <= v6 )
      v7 = v6;
    else
      v7 = v5;
    if ( v4 <= (signed int)-v7 )
    {
      if ( v5 <= v6 )
        LOWORD(v5) = v6;
      *(_WORD *)(v2 + 84) = -(__int16)v5;
    }
  }
  sub_80201E8(v2);
  result = *(__int16 *)(v2 + 84);
  if ( *(_WORD *)(v2 + 84) )
  {
    result = sub_8020EBC(
               *(_DWORD *)(v2 + 16),
               *(_DWORD *)(v2 + 4 * ((result + *(unsigned __int16 *)(v2 + 82) + 5) % 5) + 60));
    *(_WORD *)(v2 + 12) = result;
    if ( result )
    {
      *(_WORD *)(v2 + 14) = result;
      return sub_8021244(v2, *(unsigned __int8 **)(v2 + 16));
    }
  }
  else
  {
    *(_WORD *)(v2 + 12) = 0;
    *(_WORD *)(v2 + 14) = 0;
  }
  return result;
}
// 80201E8: using guessed type int __fastcall sub_80201E8(_DWORD);

//----- (080208C6) --------------------------------------------------------
unsigned int __fastcall sub_80208C6(int a1)
{
  int v2; // r0
  unsigned int result; // r0
  unsigned int v4; // r0

  *(_WORD *)(a1 + 84) = 0;
  if ( !*(_WORD *)(a1 + 80) )
    goto LABEL_13;
  v2 = *(unsigned __int16 *)(a1 + 82);
  if ( !*(_WORD *)(a1 + 82) )
    v2 = 5;
  result = sub_80023F0(*(_DWORD *)(a1 + 4 * (v2 - 1) + 60), *(_DWORD *)(a1 + 16));
  if ( result )
  {
LABEL_13:
    if ( sub_8020EBC(*(_DWORD *)(a1 + 4 * *(unsigned __int16 *)(a1 + 82) + 60), *(_DWORD *)(a1 + 16)) )
      ++*(_WORD *)(a1 + 82);
    v4 = (unsigned __int16)(*(_WORD *)(a1 + 80) + 1);
    *(_WORD *)(a1 + 80) = v4;
    if ( v4 > 5 )
      *(_WORD *)(a1 + 80) = 5;
    result = *(unsigned __int16 *)(a1 + 82);
    if ( result >= 5 )
      *(_WORD *)(a1 + 82) = 0;
  }
  return result;
}

//----- (08020934) --------------------------------------------------------
int __fastcall sub_8020934(int a1, int a2, unsigned int a3)
{
  int v4; // r0
  int v5; // r0

  v4 = 0;
  *(_WORD *)(a1 + 0xC) = 0;
  *(_WORD *)(a1 + 0xE) = 0;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x60) |= 1u;
  *(_DWORD *)(a1 + 0x10) = a2;
  *(_WORD *)(a1 + 0x34) = a3 / 6;
  *(_WORD *)(a1 + 0x54) = 0;
  *(_WORD *)(a1 + 0x50) = 0;
  *(_WORD *)(a1 + 0x52) = 0;
  do
  {
    *(_DWORD *)(a1 + 4 * v4 + 60) = a2 + *(unsigned __int16 *)(a1 + 0x34) * (v4 + 1);
    v4 = (__int16)(v4 + 1);
  }
  while ( v4 < 5 );
  *(_DWORD *)(a1 + 0x58) = dword_802947C;
  *(_WORD *)(a1 + 0x5C) = (unsigned int)(&loc_802982C - (_UNKNOWN *)dword_802947C) >> 4;
  sub_8020134(a1);
  v5 = sub_8020D08(a1, (int)"User", *(_DWORD *)(a1 + 0x58), 0);
  sub_8020D7C(a1, v5);
  return sub_8021158(a1, 1);
}
// 802947C: using guessed type int dword_802947C[5];

//----- (080209BC) --------------------------------------------------------
int __fastcall sub_80209BC(int a1, char a2)
{
  int v3; // r2
  int result; // r0
  unsigned int v5; // r2
  int i; // r0
  int v7; // r3
  int v8; // r0
  int v9; // r1
  int v10; // r0
  int j; // r5
  int k; // r5

  v3 = *(unsigned __int16 *)(a1 + 52);
  result = *(unsigned __int16 *)(a1 + 12);
  if ( result < v3 - 1 )
  {
    v5 = *(unsigned __int16 *)(a1 + 14);
    if ( v5 == result )
    {
      *(_WORD *)(a1 + 12) = result + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + result) = a2;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(a1 + 12)) = 0;
      ++*(_WORD *)(a1 + 14);
      return sub_802109A(a1, a2);
    }
    else if ( v5 < result )
    {
      for ( i = (__int16)(result - v5); i > 0; i = (__int16)(i - 1) )
      {
        v7 = *(unsigned __int16 *)(a1 + 14) + *(_DWORD *)(a1 + 16);
        *(_BYTE *)(i + v7) = *(_BYTE *)(v7 + i - 1);
      }
      v8 = *(unsigned __int16 *)(a1 + 14);
      *(_WORD *)(a1 + 14) = v8 + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + v8) = a2;
      v9 = *(_DWORD *)(a1 + 16);
      v10 = (unsigned __int16)(*(_WORD *)(a1 + 12) + 1);
      *(_WORD *)(a1 + 12) = v10;
      *(_BYTE *)(v9 + v10) = 0;
      for ( j = (__int16)(*(_WORD *)(a1 + 14) - 1); *(unsigned __int16 *)(a1 + 12) > j; j = (__int16)(j + 1) )
        sub_802109A(a1, *(_BYTE *)(*(_DWORD *)(a1 + 16) + j));
      result = *(unsigned __int16 *)(a1 + 12) - *(unsigned __int16 *)(a1 + 14);
      for ( k = (__int16)result; k > 0; k = (__int16)(k - 1) )
        result = sub_802109A(a1, 8);
    }
  }
  else
  {
    sub_8021244(a1, (unsigned __int8 *)dword_200015FC);
    sub_8021158(a1, 1);
    return sub_8021244(a1, *(unsigned __int8 **)(a1 + 16));
  }
  return result;
}
// 200015FC: using guessed type int dword_200015FC;

//----- (08020A84) --------------------------------------------------------
int __fastcall sub_8020A84(int a1)
{
  int result; // r0

  result = *(unsigned __int16 *)(a1 + 14);
  if ( result )
  {
    sub_802109A(a1, 8);
    result = *(unsigned __int16 *)(a1 + 14) - 1;
    *(_WORD *)(a1 + 14) = result;
  }
  return result;
}

//----- (08020A9E) --------------------------------------------------------
int __fastcall sub_8020A9E(int a1)
{
  int v2; // r7
  int i; // r4
  int result; // r0

  v2 = *(_DWORD *)(a1 + 88);
  sub_8021244(a1, (unsigned __int8 *)dword_20001600);
  for ( i = 0; ; i = (__int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 92);
    if ( result <= i )
      break;
    if ( (*(_BYTE *)(v2 + 16 * i + 1) & 0xFu) <= 1 && !sub_802019C(a1, (_BYTE *)(v2 + 16 * i)) )
      sub_8020AF0(a1, v2 + 16 * i);
  }
  return result;
}
// 20001600: using guessed type int dword_20001600;

//----- (08020AF0) --------------------------------------------------------
int __fastcall sub_8020AF0(int a1, int a2)
{
  unsigned __int8 *v4; // r0
  int v5; // r4
  unsigned int v6; // r0
  _BYTE *v7; // r0

  v4 = sub_8020684(a2);
  LOWORD(v5) = 22 - sub_8021244(a1, v4);
  if ( (__int16)v5 <= 0 )
    LOWORD(v5) = 4;
  do
  {
    sub_802109A(a1, 32);
    v5 = (__int16)(v5 - 1);
  }
  while ( v5 );
  v6 = *(_BYTE *)(a2 + 1) & 0xF;
  if ( v6 > 1 )
  {
    if ( v6 > 7 )
    {
      if ( v6 > 8 )
      {
        if ( v6 > 9 )
          sub_8021244(a1, (unsigned __int8 *)dword_20001648);
        else
          sub_8021244(a1, (unsigned __int8 *)dword_20001644);
      }
      else
      {
        sub_8021244(a1, (unsigned __int8 *)dword_20001640);
      }
    }
    else
    {
      sub_8021244(a1, (unsigned __int8 *)dword_2000163C);
    }
  }
  else
  {
    sub_8021244(a1, (unsigned __int8 *)dword_20001638);
  }
  sub_8021244(a1, (unsigned __int8 *)&dword_8020B90);
  v7 = (_BYTE *)sub_8020678(a2);
  sub_80210A8(a1, v7);
  return sub_8021244(a1, (unsigned __int8 *)&dword_8020B94);
}
// 8020B90: using guessed type int dword_8020B90;
// 8020B94: using guessed type int dword_8020B94;
// 20001638: using guessed type int dword_20001638;
// 2000163C: using guessed type int dword_2000163C;
// 20001640: using guessed type int dword_20001640;
// 20001644: using guessed type int dword_20001644;
// 20001648: using guessed type int dword_20001648;

//----- (08020B98) --------------------------------------------------------
int __fastcall sub_8020B98(int a1, char a2)
{
  *(_BYTE *)(a1 + 96) &= ~4u;
  return sub_80209BC(a1, a2);
}

//----- (08020BA8) --------------------------------------------------------
int __fastcall sub_8020BA8(int result)
{
  BOOL v1; // r2
  int v2; // r3
  int i; // r1
  unsigned int j; // r1
  int v5; // r5
  int v6; // r4
  unsigned int v7; // r3
  int v8; // r5

  v1 = 0;
  v2 = 1;
  for ( i = 0; i < 8; i = (__int16)(i + 1) )
    *(_DWORD *)(result + 4 * i + 20) = 0;
  *(_WORD *)(result + 54) = 0;
  for ( j = 0; *(unsigned __int16 *)(result + 12) > j; j = (unsigned __int16)(j + 1) )
  {
    if ( v1 || (v5 = *(_DWORD *)(result + 16), *(_BYTE *)(v5 + j) != 32) && *(_BYTE *)(v5 + j) )
    {
      v6 = *(_DWORD *)(result + 16);
      if ( *(_BYTE *)(v6 + j) == 34 )
        v1 = !v1;
      if ( v2 == 1 )
      {
        v7 = *(unsigned __int16 *)(result + 54);
        if ( v7 < 8 )
        {
          *(_WORD *)(result + 54) = v7 + 1;
          *(_DWORD *)(result + 4 * v7 + 20) = v6 + j;
        }
        v2 = 0;
      }
      v8 = *(_DWORD *)(result + 16);
      if ( *(_BYTE *)(v8 + j) == 92 )
      {
        if ( *(_BYTE *)(v8 + j + 1) )
          LOWORD(j) = j + 1;
      }
    }
    else
    {
      *(_BYTE *)(v5 + j) = 0;
      v2 = 1;
    }
  }
  return result;
}

//----- (08020C1E) --------------------------------------------------------
unsigned int __fastcall sub_8020C1E(int a1)
{
  unsigned int i; // r5
  int v3; // r4
  _BYTE *v4; // r1
  unsigned __int16 v5; // r0
  int v6; // r2
  int v7; // r1
  unsigned int result; // r0

  for ( i = 0; ; i = (unsigned __int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 54);
    if ( result <= i )
      break;
    v3 = a1 + 4 * i;
    v4 = *(_BYTE **)(v3 + 20);
    if ( *v4 == 34 )
    {
      *v4 = 0;
      ++*(_DWORD *)(v3 + 20);
    }
    v5 = (unsigned __int16)sub_80023E2(*(unsigned __int8 **)(v3 + 20));
    v6 = *(_DWORD *)(v3 + 20);
    v7 = v5 - 1;
    if ( *(_BYTE *)(v6 + v7) == 34 )
      *(_BYTE *)(v6 + v7) = 0;
  }
  return result;
}

//----- (08020C60) --------------------------------------------------------
int __fastcall sub_8020C60(int result)
{
  unsigned int v1; // r1

  v1 = *(unsigned __int16 *)(result + 14);
  if ( v1 < *(unsigned __int16 *)(result + 12) )
  {
    *(_WORD *)(result + 14) = v1 + 1;
    return sub_802109A(result, *(unsigned __int8 *)(*(_DWORD *)(result + 16) + v1));
  }
  return result;
}

//----- (08020C76) --------------------------------------------------------
unsigned int __fastcall sub_8020C76(int a1, int a2)
{
  unsigned int v4; // r7
  int v5; // r0
  int v6; // r0

  v4 = 0;
  *(_BYTE *)(a1 + 96) |= 2u;
  v5 = *(unsigned __int8 *)(a2 + 1);
  if ( !(v5 << 28) )
  {
    sub_8020C1E(a1);
    v4 = (*(int (__fastcall **)(_DWORD, int))(a2 + 8))(*(unsigned __int16 *)(a1 + 54), a1 + 20);
    if ( (*(_BYTE *)(a2 + 1) & 0x20) != 0 )
      goto LABEL_11;
LABEL_6:
    sub_80211BC(a1, v4);
    goto LABEL_11;
  }
  v6 = v5 & 0xF;
  if ( v6 == 1 )
  {
    v4 = sub_8020578(a1, a2, *(unsigned __int16 *)(a1 + 54), a1 + 20);
    if ( (*(_BYTE *)(a2 + 1) & 0x20) != 0 )
      goto LABEL_11;
    goto LABEL_6;
  }
  if ( (unsigned int)(v6 - 2) > 5 )
  {
    if ( v6 == 8 )
      sub_8020D7C(a1, a2);
  }
  else
  {
    sub_8020DDC(a1, a2);
  }
LABEL_11:
  *(_BYTE *)(a1 + 96) &= ~2u;
  return v4;
}

//----- (08020D08) --------------------------------------------------------
int __fastcall sub_8020D08(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v8; // r7
  unsigned int i; // r4
  _BYTE *v10; // r1

  v8 = (unsigned __int16)(*(_WORD *)(a1 + 92) - ((unsigned int)(a3 - *(_DWORD *)(a1 + 88)) >> 4));
  for ( i = 0; ; i = (unsigned __int16)(i + 1) )
  {
    if ( i >= v8 )
      return 0;
    if ( (*(_BYTE *)(a3 + 16 * i + 1) & 0xF) == 9 || sub_802019C(a1, (_BYTE *)(a3 + 16 * i)) )
      continue;
    v10 = sub_8020684(a3 + 16 * i);
    if ( a4 )
      break;
    if ( !sub_80023F0(a2, (int)v10) )
      return a3 + 16 * i;
LABEL_8:
    ;
  }
  if ( sub_800241E(a2, (int)v10, a4) )
    goto LABEL_8;
  return a3 + 16 * i;
}

//----- (08020D7C) --------------------------------------------------------
int __fastcall sub_8020D7C(int a1, int a2)
{
  unsigned __int8 *v4; // r0
  char v5; // r0
  int result; // r0

  *(_DWORD *)a1 = a2;
  v4 = *(unsigned __int8 **)(a2 + 8);
  if ( v4
    && sub_80023E2(v4)
    && (*(unsigned __int16 *)(a1 + 54) < 2u || sub_80023F0(*(_DWORD *)(a2 + 8), *(_DWORD *)(a1 + 24))) )
  {
    v5 = *(_BYTE *)(a1 + 96) & 0xFE;
  }
  else
  {
    v5 = *(_BYTE *)(a1 + 96) | 1;
  }
  *(_BYTE *)(a1 + 96) = v5;
  sub_8021244(a1, (unsigned __int8 *)dword_20001630);
  result = *(unsigned __int8 *)(a1 + 96) << 31;
  if ( result )
    return sub_8021244(a1, (unsigned __int8 *)dword_200015F8);
  return result;
}
// 200015F8: using guessed type int dword_200015F8;
// 20001630: using guessed type int dword_20001630;

//----- (08020DDC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_8020DDC(int a1, int a2)
{
  unsigned __int8 *v4; // r6
  int v5; // r0
  int i; // r0
  char v8[32]; // [sp+0h] [bp-20h] BYREF

  strcpy(v8, "00000000000");
  v4 = (unsigned __int8 *)sub_80206EC(a1, a2);
  sub_8021244(a1, *(unsigned __int8 **)(a2 + 4));
  sub_8021244(a1, " = ");
  if ( (*(_BYTE *)(a2 + 1) & 0xF) == 5 )
  {
    sub_8021244(a1, "\"");
    sub_8021244(a1, v4);
    sub_8021244(a1, "\"");
  }
  else
  {
    v5 = sub_8021018((int)v4, (int)v8);
    sub_8021244(a1, (unsigned __int8 *)&v8[11 - v5]);
    sub_8021244(a1, ", 0x");
    for ( i = 0; i < 11; i = (__int16)(i + 1) )
      v8[i] = 48;
    sub_802106A((unsigned int)v4, (int)v8);
    sub_8021244(a1, (unsigned __int8 *)v8);
  }
  sub_8021244(a1, "\r\n");
  return v4;
}

//----- (08020E98) --------------------------------------------------------
int __fastcall sub_8020E98(int a1, int a2)
{
  int result; // r0
  int i; // r2

  result = 0;
  for ( i = 0;
        *(_BYTE *)(a1 + i) && *(_BYTE *)(a2 + i) && *(unsigned __int8 *)(a1 + i) == *(unsigned __int8 *)(a2 + i);
        i = (unsigned __int16)(i + 1) )
  {
    result = (unsigned __int16)(result + 1);
  }
  return result;
}

//----- (08020EBC) --------------------------------------------------------
int __fastcall sub_8020EBC(int a1, int a2)
{
  int result; // r0

  for ( result = 0; *(_BYTE *)(a2 + result); result = (unsigned __int16)(result + 1) )
    *(_BYTE *)(a1 + result) = *(_BYTE *)(a2 + result);
  *(_BYTE *)(a1 + result) = 0;
  return result;
}

//----- (08020ED4) --------------------------------------------------------
int __fastcall sub_8020ED4(int a1)
{
  unsigned int v2; // r7
  int v3; // r11
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r9
  int i; // r6
  _BYTE *v8; // r0
  int v9; // r11
  _BYTE *v10; // r8
  _BYTE *v11; // r0
  unsigned int v12; // r0
  int result; // r0
  _BYTE *v14; // r0
  int v15; // t1

  v2 = *(unsigned __int16 *)(a1 + 52);
  v3 = 0;
  v4 = 0;
  v5 = *(unsigned __int16 *)(a1 + 12);
  if ( !v5 )
  {
    sub_8020A9E(a1);
    sub_8021158(a1, 1);
LABEL_21:
    result = sub_8012298();
    if ( result )
    {
      if ( v4 == 1 && (*(_BYTE *)(a1 + 96) & 4) != 0 && (unsigned int)(sub_8012298() - *(_DWORD *)(a1 + 4)) < 0xC8 )
      {
        sub_8021244(a1, (unsigned __int8 *)&dword_8021014);
        sub_80210F8(a1, *(_DWORD *)(a1 + 16));
        sub_8021158(a1, 1);
        return sub_8021244(a1, *(unsigned __int8 **)(a1 + 16));
      }
      else
      {
        v15 = *(unsigned __int8 *)(a1 + 96);
        result = v15 | 4;
        *(_BYTE *)(a1 + 96) = v15 | 4;
      }
    }
    return result;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 16) + v5) = 0;
  v6 = *(_DWORD *)(a1 + 88);
  for ( i = 0; ; i = (__int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 92);
    if ( result <= i )
      break;
    if ( !sub_802019C(a1, (_BYTE *)(v6 + 16 * i)) )
    {
      v8 = sub_8020684(v6 + 16 * i);
      if ( sub_8020E98(*(_DWORD *)(a1 + 16), (int)v8) == *(unsigned __int16 *)(a1 + 12) )
      {
        if ( v4 )
        {
          if ( v4 == 1 )
            sub_8021244(a1, (unsigned __int8 *)&dword_8021014);
          v9 = v6 + 16 * v3;
          sub_8020AF0(a1, v9);
          v10 = sub_8020684(v6 + 16 * i);
          v11 = sub_8020684(v9);
          v12 = sub_8020E98((int)v11, (int)v10);
          if ( v2 <= v12 )
            v12 = v2;
          v2 = v12;
        }
        v3 = (unsigned __int16)i;
        v4 = (unsigned __int16)(v4 + 1);
      }
    }
  }
  if ( v4 )
  {
    if ( v4 == 1 )
      sub_80201E8(a1);
    v14 = sub_8020684(v6 + 16 * v3);
    *(_WORD *)(a1 + 12) = sub_8020EBC(*(_DWORD *)(a1 + 16), (int)v14);
    if ( v4 > 1 )
    {
      sub_8020AF0(a1, v6 + 16 * v3);
      sub_8021158(a1, 1);
      *(_WORD *)(a1 + 12) = v2;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(a1 + 12)) = 0;
    *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 12);
    sub_8021244(a1, *(unsigned __int8 **)(a1 + 16));
    goto LABEL_21;
  }
  return result;
}
// 8021014: using guessed type int dword_8021014;

//----- (08021018) --------------------------------------------------------
int __fastcall sub_8021018(int a1, int a2)
{
  int v2; // r2
  int v3; // r3

  LOBYTE(v2) = 11;
  v3 = a1;
  if ( a1 < 0 )
    v3 = -a1;
  *(_BYTE *)(a2 + 11) = 0;
  while ( v3 )
  {
    LOBYTE(v2) = v2 - 1;
    *(_BYTE *)(a2 + (unsigned __int8)v2) = v3 % 10 + 48;
    v3 /= 10;
  }
  if ( a1 < 0 )
  {
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = 45;
  }
  if ( !a1 )
  {
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = 48;
  }
  return (char)(11 - v2);
}

//----- (0802106A) --------------------------------------------------------
int __fastcall sub_802106A(unsigned int a1, int a2)
{
  int v2; // r3
  char v3; // r2
  char v4; // r2

  LOBYTE(v2) = 8;
  *(_BYTE *)(a2 + 8) = 0;
  while ( a1 )
  {
    v3 = a1 & 0xF;
    if ( (a1 & 0xF) <= 9 )
      v4 = v3 + 48;
    else
      v4 = v3 + 87;
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = v4;
    a1 >>= 4;
  }
  return (char)(8 - v2);
}

//----- (08021094) --------------------------------------------------------
int __fastcall sub_8021094(int a1)
{
  return sub_802082C(a1, 1);
}

//----- (0802109A) --------------------------------------------------------
int __fastcall sub_802109A(int a1, int a2)
{
  int v3; // [sp+4h] [bp-Ch] BYREF

  v3 = a2;
  return (*(int (__fastcall **)(int *, int))(a1 + 104))(&v3, 1);
}

//----- (080210A8) --------------------------------------------------------
int __fastcall sub_80210A8(int a1, _BYTE *a2)
{
  unsigned int v4; // r4
  _BYTE *v5; // r0
  void (__fastcall *v6)(_BYTE *, unsigned int); // r2
  int v8; // r1

  v4 = 0;
  v5 = a2;
  v6 = *(void (__fastcall **)(_BYTE *, unsigned int))(a1 + 104);
  if ( !v6 )
    return 0;
  while ( 1 )
  {
    v8 = (unsigned __int8)*v5;
    if ( !*v5 || v8 == 13 || v8 == 10 )
      break;
    ++v5;
    v4 = (unsigned __int16)(v4 + 1);
  }
  if ( v4 <= 0x96 )
  {
    v6(a2, v4);
  }
  else
  {
    v6(a2, 150u);
    (*(void (__fastcall **)(int (*)(), int))(a1 + 104))(sub_80210F4, 3);
  }
  if ( v4 <= 0x96 )
    return 153;
  else
    return 150;
}

//----- (080210F4) --------------------------------------------------------
int sub_80210F4()
{
  return sub_80210F8();
}
// 80210F8: using guessed type int sub_80210F8(void);

//----- (080210F8) --------------------------------------------------------
int __fastcall sub_80210F8(int a1, int a2)
{
  int v3; // r4
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r0

  v3 = sub_8020D08(a1, a2, *(_DWORD *)(a1 + 88), 0);
  if ( !v3 )
    return sub_8021244(a1, (unsigned __int8 *)dword_20001610);
  sub_8021244(a1, (unsigned __int8 *)dword_20001624);
  v4 = sub_8020684(v3);
  sub_8021244(a1, v4);
  sub_8021244(a1, (unsigned __int8 *)&dword_8021154);
  v5 = (unsigned __int8 *)sub_8020678(v3);
  sub_8021244(a1, v5);
  return sub_8021244(a1, (unsigned __int8 *)&dword_8021154);
}
// 8021154: using guessed type int dword_8021154;
// 20001610: using guessed type int dword_20001610;
// 20001624: using guessed type int dword_20001624;

//----- (08021158) --------------------------------------------------------
int __fastcall sub_8021158(int a1, int a2)
{
  unsigned __int8 *v3; // r1

  if ( !(*(unsigned __int8 *)(a1 + 96) << 31) )
    return sub_8021244(a1, (unsigned __int8 *)dword_20001628);
  if ( a2 )
    sub_8021244(a1, (unsigned __int8 *)&dword_80211A8);
  sub_8021244(a1, *(unsigned __int8 **)(*(_DWORD *)a1 + 4));
  sub_8021244(a1, (unsigned __int8 *)&dword_80211AC);
  v3 = *(unsigned __int8 **)(a1 + 8);
  if ( !v3 )
    v3 = (unsigned __int8 *)&dword_80211B0;
  sub_8021244(a1, v3);
  return sub_8021244(a1, (unsigned __int8 *)&dword_80211B4);
}
// 80211A8: using guessed type int dword_80211A8;
// 80211AC: using guessed type int dword_80211AC;
// 80211B0: using guessed type int dword_80211B0;
// 80211B4: using guessed type int dword_80211B4;
// 20001628: using guessed type int dword_20001628;

//----- (080211BC) --------------------------------------------------------
int __fastcall sub_80211BC(int a1, unsigned int a2)
{
  int v4; // r0
  int i; // r2
  char v7[32]; // [sp+0h] [bp-20h] BYREF

  strcpy(v7, "00000000000");
  sub_8021244(a1, "Return: ");
  v4 = sub_8021018(a2, (int)v7);
  sub_8021244(a1, (unsigned __int8 *)&v7[11 - v4]);
  sub_8021244(a1, ", 0x");
  for ( i = 0; i < 11; i = (__int16)(i + 1) )
    v7[i] = 48;
  sub_802106A(a2, (int)v7);
  sub_8021244(a1, (unsigned __int8 *)v7);
  return sub_8021244(a1, "\r\n");
}

//----- (08021244) --------------------------------------------------------
int __fastcall sub_8021244(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r0
  int v4; // r2
  unsigned __int16 (__fastcall *v5)(unsigned __int8 *, int); // r4

  v3 = a2;
  v4 = 0;
  v5 = *(unsigned __int16 (__fastcall **)(unsigned __int8 *, int))(a1 + 104);
  if ( !v5 )
    return 0;
  while ( *a2++ )
    v4 = (unsigned __int16)(v4 + 1);
  return v5(v3, v4);
}

//----- (08021270) --------------------------------------------------------
void __fastcall sub_8021270(int a1)
{
  if ( a1 )
    sub_801E1B0((int)sub_8021298);
  else
    sub_801E1B0((int)&loc_80212AC);
  sub_80031EE();
}
// 8021298: using guessed type int sub_8021298();

//----- (0802135C) --------------------------------------------------------
void sub_802135C()
{
  JUMPOUT(0x80210BE);
}
// 802135E: control flows out of bounds to 80210BE

//----- (080213FC) --------------------------------------------------------
int sub_80213FC()
{
  return sub_801E1B0((int)"[BLE] type=%s,id=%s,mac=%s", (const char *)&dword_200038E3, byte_200037BB, byte_20004029);
}
// 200038E3: using guessed type int dword_200038E3;

//----- (08021430) --------------------------------------------------------
int __fastcall sub_8021430(int a1)
{
  int result; // r0

  if ( a1 == 1 )
  {
    result = 1;
    byte_200036AD = 1;
  }
  else if ( a1 == 2 )
  {
    result = 2;
    byte_200036AD = 2;
  }
  else
  {
    result = 0;
    byte_200036AD = 0;
  }
  return result;
}
// 200036AD: using guessed type char byte_200036AD;

//----- (08021450) --------------------------------------------------------
int sub_8021450()
{
  return sub_8007CF8(0);
}

//----- (08021458) --------------------------------------------------------
int sub_8021458()
{
  sub_8007C6C();
  return sub_801E1B0((int)"[BLE] firmware version: %s", (const char *)&dword_200037D5);
}
// 200037D5: using guessed type int dword_200037D5;

//----- (0802148C) --------------------------------------------------------
int __fastcall sub_802148C(int result)
{
  unsigned int i; // r4
  unsigned __int16 *v2; // r0
  unsigned int j; // r4
  unsigned __int16 *v4; // r0
  __int64 v5; // [sp+Ch] [bp-1Ch]

  if ( result )
  {
    if ( result == 1 )
    {
      sub_801E1B0((int)"Event info:\r\n");
      for ( i = 0; i < 0x14; ++i )
      {
        v2 = (unsigned __int16 *)&byte_20003D71[9 * i];
        result = sub_801E1B0(
                   (int)"event%d=%d|%d|%d|%d|%d|%d|%d\r\n",
                   i,
                   *v2,
                   *((unsigned __int8 *)v2 + 2),
                   *((unsigned __int8 *)v2 + 3),
                   *((unsigned __int8 *)v2 + 4),
                   *((unsigned __int8 *)v2 + 5),
                   *((unsigned __int8 *)v2 + 6),
                   *(unsigned __int16 *)((char *)v2 + 7));
      }
    }
  }
  else
  {
    sub_801E1B0((int)"Error code info:\r\n");
    for ( j = 0; j < 0x14; ++j )
    {
      v4 = (unsigned __int16 *)&dword_20003C59 + 7 * j;
      HIDWORD(v5) = *(_DWORD *)(v4 + 3);
      result = sub_801E1B0(
                 (int)"err%d=%d|%d|%d|%d|%d|%lld\r\n",
                 j,
                 *v4,
                 *((unsigned __int8 *)v4 + 2),
                 *((unsigned __int8 *)v4 + 3),
                 *((unsigned __int8 *)v4 + 4),
                 *((unsigned __int8 *)v4 + 5),
                 v5);
    }
  }
  return result;
}
// 8021506: variable 'v5' is possibly undefined
// 20003C59: using guessed type int dword_20003C59;
// 20003D71: using guessed type _BYTE byte_20003D71[180];

//----- (0802157C) --------------------------------------------------------
int sub_802157C()
{
  sub_801E1B0((int)sub_802159C);
  sub_801E1B0((int)sub_80215B4);
  sub_801E1B0((int)dword_80215C8);
  return sub_801E1B0((int)dword_80215DC);
}
// 802159C: using guessed type int sub_802159C();
// 80215C8: using guessed type int dword_80215C8[5];
// 80215DC: using guessed type int dword_80215DC[5];

//----- (080215B4) --------------------------------------------------------
int sub_80215B4()
{
  return sub_80213FC();
}

//----- (080215BA) --------------------------------------------------------
void __fastcall sub_80215BA(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R0-R2,R5-R7,PC} }
}
// 80215BC: unbalanced stack, ignored a potential tail call

//----- (080215F0) --------------------------------------------------------
int __fastcall sub_80215F0(int result, int a2)
{
  BOOL v2; // r1
  BOOL v3; // r1
  BOOL v4; // r1
  BOOL v5; // r1
  BOOL v6; // r1
  BOOL v7; // r1
  BOOL v8; // r1
  BOOL v9; // r1
  BOOL v10; // r1
  BOOL v11; // r1
  BOOL v12; // r1
  BOOL v13; // r1
  BOOL v14; // r1
  BOOL v15; // r1
  BOOL v16; // r1
  BOOL v17; // r1
  BOOL v18; // r1
  BOOL v19; // r1
  BOOL v20; // r1
  BOOL v21; // r1
  BOOL v22; // r1
  BOOL v23; // r1
  BOOL v24; // r1
  BOOL v25; // r1

  v2 = a2 != 0;
  switch ( result )
  {
    case 1:
      sub_801227E(1207962624, 2, v2);
      v3 = sub_8012260(1207962624, 2);
      result = sub_801E1B0((int)"1 LED0  =  %d\r\n", v3);
      break;
    case 2:
      sub_801227E(1207962624, 1, v2);
      v4 = sub_8012260(1207962624, 1);
      result = sub_801E1B0((int)"2 LED1  =  %d\r\n", v4);
      break;
    case 3:
      return result;
    case 4:
      sub_801227E(1207962624, 128, v2);
      v5 = sub_8012260(1207962624, 128);
      result = sub_801E1B0((int)dword_8021940, v5);
      break;
    case 5:
      sub_801227E(1207962624, 8, v2);
      v6 = sub_8012260(1207962624, 8);
      result = sub_801E1B0((int)dword_8021964, v6);
      break;
    case 6:
      sub_801227E(1207959552, 4096, v2);
      v7 = sub_8012260(1207959552, 4096);
      result = sub_801E1B0((int)sub_8021988, v7);
      break;
    case 7:
      sub_801227E(1207961600, 1024, v2);
      v8 = sub_8012260(1207961600, 1024);
      result = sub_801E1B0((int)&loc_80219AC, v8);
      break;
    case 8:
      sub_801227E(1207960576, 8, v2);
      v9 = sub_8012260(1207960576, 8);
      result = sub_801E1B0((int)&loc_80219D0, v9);
      break;
    case 9:
      sub_801227E(1207962624, 2048, v2);
      v10 = sub_8012260(1207962624, 2048);
      result = sub_801E1B0((int)&loc_80219F0, v10);
      break;
    case 10:
      sub_801227E(1207962624, 1024, v2);
      v11 = sub_8012260(1207962624, 1024);
      result = sub_801E1B0((int)&loc_8021A0C, v11);
      break;
    case 11:
      sub_801227E(1207963648, 64, v2);
      v12 = sub_8012260(1207963648, 64);
      result = sub_801E1B0((int)"11 LED_A  =  %d\r\n", v12);
      break;
    case 12:
      sub_801227E(1207961600, 2048, v2);
      v13 = sub_8012260(1207961600, 2048);
      result = sub_801E1B0((int)"11 LED_B  =  %d\r\n", v13);
      break;
    case 13:
      sub_801227E(1207959552, 16, v2);
      v14 = sub_8012260(1207959552, 16);
      result = sub_801E1B0((int)"11 LED_C  =  %d\r\n", v14);
      break;
    case 14:
      sub_801227E(1207963648, 4, v2);
      v15 = sub_8012260(1207963648, 4);
      result = sub_801E1B0((int)"11 LED_D  =  %d\r\n", v15);
      break;
    case 15:
      sub_801227E(1207963648, 8, v2);
      v16 = sub_8012260(1207963648, 8);
      result = sub_801E1B0((int)"11 LED_E  =  %d\r\n", v16);
      break;
    case 16:
      sub_801227E(1207963648, 16, v2);
      v17 = sub_8012260(1207963648, 16);
      result = sub_801E1B0((int)"11 LED_F  =  %d\r\n", v17);
      break;
    case 17:
      sub_801227E(1207963648, 32, v2);
      v18 = sub_8012260(1207963648, 32);
      result = sub_801E1B0((int)"11 LED_G  =  %d\r\n", v18);
      break;
    case 18:
      sub_801227E(1207960576, 16, v2);
      v19 = sub_8012260(1207960576, 16);
      result = sub_801E1B0((int)"11 LED_H  =  %d\r\n", v19);
      break;
    case 19:
      sub_801227E(1207959552, 8, v2);
      v20 = sub_8012260(1207959552, 8);
      result = sub_801E1B0((int)"11 LED_I  =  %d\r\n", v20);
      break;
    case 20:
      sub_801227E(1207959552, 32, v2);
      v21 = sub_8012260(1207959552, 32);
      result = sub_801E1B0((int)"11    LED_J  =  %d\r\n", v21);
      break;
    case 21:
      sub_801227E(1207961600, 16, v2);
      v22 = sub_8012260(1207961600, 16);
      result = sub_801E1B0((int)"11 LED_K  =  %d\r\n", v22);
      break;
    case 22:
      sub_801227E(1207961600, 32, v2);
      v23 = sub_8012260(1207961600, 32);
      result = sub_801E1B0((int)"11 LED_L  =  %d\r\n", v23);
      break;
    case 23:
      sub_801227E(1207960576, 4, v2);
      v24 = sub_8012260(1207960576, 4);
      result = sub_801E1B0((int)"11 LED_M  =  %d\r\n", v24);
      break;
    case 24:
      sub_801227E(1207960576, 0x8000, v2);
      v25 = sub_8012260(1207960576, 0x8000);
      result = sub_801E1B0((int)"11 LED_N  =  %d\r\n", v25);
      break;
    default:
      result = sub_801E1B0((int)sub_8021B48, v2);
      break;
  }
  return result;
}
// 8021940: using guessed type int dword_8021940[9];
// 8021964: using guessed type int dword_8021964[3];
// 8021988: using guessed type int sub_8021988();
// 8021B48: using guessed type int sub_8021B48();

//----- (08021994) --------------------------------------------------------
void sub_8021994()
{
  __int16 v0; // r5
  int v1; // r7

  if ( v1 )
  {
    *(_WORD *)(*(unsigned __int16 *)(v1 + 60) + 0x2E) = v0;
    JUMPOUT(0x80212AE);
  }
  JUMPOUT(0x80218EA);
}
// 80212AC: control flows out of bounds to 80212AE
// 8021998: control flows out of bounds to 80218EA
// 8021996: variable 'v1' is possibly undefined
// 80212AC: variable 'v0' is possibly undefined

//----- (080220E8) --------------------------------------------------------
int sub_80220E8()
{
  sub_801E1B0((int)sub_8022104);
  byte_20000504 = 0;
  return sub_80055F0(0x900u, &byte_20000504, 1u);
}
// 20000504: using guessed type char byte_20000504;

//----- (08022104) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_8022104(int a1, int a2)
{
  BOOL v2; // r0
  BOOL v3; // r0
  BOOL v4; // r0
  BOOL v5; // r0
  BOOL v6; // r0
  BOOL v7; // r0
  int v8; // r9
  int v9; // [sp-14h] [bp-14h]
  int v10; // [sp-Ch] [bp-Ch]
  int v11; // [sp-4h] [bp-4h]

  sub_801E1B0(v9, a2);
  v2 = sub_8012260(1207963648, 64);
  sub_801E1B0((int)"11 LED_A  =  %d\r\n", v2);
  v3 = sub_8012260(v11, v8);
  sub_801E1B0((int)"12 LED_B  =  %d\r\n", v3);
  v4 = sub_8012260(v10, 16);
  sub_801E1B0((int)"13 LED_C  =  %d\r\n", v4);
  v5 = sub_8012260(1207963648, 4);
  sub_801E1B0((int)"14 LED_D  =  %d\r\n", v5);
  v6 = sub_8012260(1207963648, 8);
  sub_801E1B0((int)"15 LED_E  =  %d\r\n", v6);
  v7 = sub_8012260(1207963648, 16);
  sub_801E1B0((int)"16 LED_F  =  %d\r\n", v7);
  sub_8012260(1207963648, 32);
  JUMPOUT(0x8021C7C);
}
// 8021C0A: positive sp value 14 has been found
// 8021C7A: control flows out of bounds to 8021C7C
// 8021C0A: variable 'v9' is possibly undefined
// 8021C26: variable 'v11' is possibly undefined
// 8021C26: variable 'v8' is possibly undefined
// 8021C36: variable 'v10' is possibly undefined

//----- (08022118) --------------------------------------------------------
__int16 *sub_8022118()
{
  __int16 *result; // r0

  byte_20002E38 = 14;
  result = &word_20002DE0;
  word_20002DE0 = 0;
  word_20002DE2 = 0;
  word_20002DE4 = 0;
  return result;
}
// 20002DE0: using guessed type __int16 word_20002DE0;
// 20002DE2: using guessed type __int16 word_20002DE2;
// 20002DE4: using guessed type __int16 word_20002DE4;
// 20002E38: using guessed type char byte_20002E38;

//----- (08022134) --------------------------------------------------------
void __fastcall sub_8022134(int a1)
{
  if ( a1 == 2 )
  {
    sub_801E1B0((int)sub_8022184);
  }
  else if ( a1 == 1 )
  {
    sub_801E1B0((int)dword_8022198);
  }
  else
  {
    sub_801E1B0((int)dword_8022170);
  }
  sub_80031F8();
}
// 8022170: using guessed type int dword_8022170[5];
// 8022184: using guessed type int sub_8022184();
// 8022198: using guessed type int dword_8022198[5];

//----- (080221F0) --------------------------------------------------------
void sub_80221F0()
{
  float v0; // s0

  sub_801E1B0((int)dword_8022220, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
  sub_8003284();
}
// 80221FE: variable 'v0' is possibly undefined
// 8022220: using guessed type int dword_8022220[8];

//----- (08022240) --------------------------------------------------------
void sub_8022240()
{
  float v0; // s0

  sub_801E1B0((int)dword_8022270, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
  sub_800328E();
}
// 802224E: variable 'v0' is possibly undefined
// 8022270: using guessed type int dword_8022270[4];

//----- (080222F8) --------------------------------------------------------
int __fastcall sub_80222F8(int a1)
{
  if ( a1 == 1 )
  {
    sub_801E1B0((int)sub_8022348);
    return sub_80050B4(0);
  }
  else
  {
    sub_801E1B0((int)&unk_8022320);
    return sub_80050B4(2);
  }
}
// 8022348: using guessed type int sub_8022348();

//----- (08022360) --------------------------------------------------------
int sub_8022360()
{
  int v0; // r1
  int v1; // r2
  int v2; // r3
  int v4; // [sp+0h] [bp-108h]
  _DWORD v5[65]; // [sp+4h] [bp-104h] BYREF

  sub_8002364(v5, 256);
  sub_80233B0((unsigned __int8 *)v5);
  sub_801E1B0((int)"%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d", v0, v1, v2, v4, v5[0], v5[1]);
  return sub_801E1B0((int)"\r\n%s\r\n", (const char *)v5);
}
// 8022376: variable 'v0' is possibly undefined
// 8022376: variable 'v1' is possibly undefined
// 8022376: variable 'v2' is possibly undefined
// 8022376: variable 'v4' is possibly undefined

//----- (08022394) --------------------------------------------------------
int __fastcall sub_8022394(int result)
{
  dword_200004DC = 3600;
  return sub_801AA4C(result);
}
// 200004DC: using guessed type int dword_200004DC;

//----- (080223A4) --------------------------------------------------------
int __fastcall sub_80223A4(int a1)
{
  if ( a1 == 1 )
  {
    sub_801E1B0((int)sub_8022454);
    byte_20002E38 = 1;
  }
  else if ( a1 )
  {
    switch ( a1 )
    {
      case 4:
        sub_801E1B0((int)"Ctl_mode_default");
        byte_20002E38 = 4;
        break;
      case 2:
        sub_801E1B0((int)dword_8022484);
        byte_20002E38 = 2;
        break;
      case 12:
        sub_801E1B0((int)dword_8022494);
        byte_20002E38 = 12;
        break;
      case 11:
        sub_801E1B0((int)dword_80224A4);
        byte_20002E38 = 11;
        break;
      case 14:
        sub_801E1B0((int)dword_80224AC);
        byte_20002E38 = 14;
        break;
      case 15:
        sub_801E1B0((int)sub_80224B8);
        byte_20002E38 = 15;
        break;
      default:
        sub_801E1B0((int)&unk_8022444);
        byte_20002E38 = 3;
        break;
    }
  }
  else
  {
    sub_801E1B0((int)"anti-feed");
    byte_20002E38 = 0;
  }
  return sub_80055F0(0x301u, &byte_20002E38, 1u);
}
// 8022454: using guessed type int sub_8022454();
// 8022484: using guessed type int dword_8022484[4];
// 8022494: using guessed type int dword_8022494[4];
// 80224A4: using guessed type int dword_80224A4[2];
// 80224AC: using guessed type int dword_80224AC[3];
// 80224B8: using guessed type int sub_80224B8();
// 20002E38: using guessed type char byte_20002E38;

//----- (080224F8) --------------------------------------------------------
int sub_80224F8()
{
  float v0; // s0

  sub_8003234();
  return sub_801E1B0((int)sub_8022518, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
}
// 8022502: variable 'v0' is possibly undefined

//----- (08022518) --------------------------------------------------------
void sub_8022518()
{
  JUMPOUT(0x80219F8);
}
// 802209C: control flows out of bounds to 80219F8

//----- (08022676) --------------------------------------------------------
void sub_8022676()
{
  JUMPOUT(0x80222BC);
}
// 8022678: control flows out of bounds to 80222BC

//----- (080227CE) --------------------------------------------------------
void __fastcall sub_80227CE(int a1)
{
  unsigned int v1; // r4
  __int16 v2; // r5

  *(_WORD *)(a1 + 44) = v2;
  STACK[0x3B4] = v1;
  JUMPOUT(0x8022052);
}
// 8022738: control flows out of bounds to 8022052
// 80227CE: variable 'v2' is possibly undefined
// 80227D0: variable 'v1' is possibly undefined

//----- (080228A0) --------------------------------------------------------
int sub_80228A0()
{
  int result; // r0

  byte_200004AD = 5;
  sub_80031E4();
  result = 1;
  byte_20000294 = 1;
  byte_20000031 = 1;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200004AD: using guessed type char byte_200004AD;

//----- (080228D4) --------------------------------------------------------
char *sub_80228D4()
{
  char *result; // r0

  byte_20010F54 = 1;
  sub_80031E4();
  byte_20000294 = 1;
  result = &byte_20000031;
  byte_20000031 = 1;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 20010F54: using guessed type char byte_20010F54;

//----- (08022904) --------------------------------------------------------
int __fastcall sub_8022904(int a1)
{
  if ( a1 )
  {
    sub_801E1B0((int)sub_802292C);
    return sub_8007960(1);
  }
  else
  {
    sub_801E1B0((int)sub_802292C);
    return sub_8007960(0);
  }
}
// 802292C: using guessed type int sub_802292C();

//----- (08022A3C) --------------------------------------------------------
unsigned int sub_8022A3C()
{
  unsigned int result; // r0
  _DWORD v1[5]; // [sp+4h] [bp-5Ch] BYREF
  _DWORD v2[7]; // [sp+18h] [bp-48h] BYREF
  int v3; // [sp+34h] [bp-2Ch]
  int v4; // [sp+38h] [bp-28h]
  int v5; // [sp+3Ch] [bp-24h]
  int v6; // [sp+40h] [bp-20h]
  int v7; // [sp+44h] [bp-1Ch]
  int v8; // [sp+48h] [bp-18h]
  int v9; // [sp+4Ch] [bp-14h]

  sub_8002364(v2, 56);
  sub_8002364(v1, 20);
  sub_8013348(0);
  sub_8013414();
  MEMORY[0x40021090] &= 0xFFFFFFE7;
  v2[0] = 1;
  v2[1] = 0x10000;
  v3 = 2;
  v4 = 3;
  v5 = 2;
  v6 = 85;
  v7 = 4;
  v8 = 8;
  v9 = 2;
  if ( sub_80139C4((unsigned __int8 *)v2) )
    sub_80058BC();
  v2[0] = 4;
  v3 = 0;
  v2[2] = 1;
  sub_80139C4((unsigned __int8 *)v2);
  v1[0] = 15;
  v1[1] = 3;
  memset(&v1[2], 0, 12);
  if ( sub_8013734((unsigned __int8 *)v1, 4u) )
    sub_80058BC();
  result = sub_801228C();
  if ( result == 4097 )
  {
    result = 1073881088;
    MEMORY[0x40022000] |= 0x100u;
  }
  return result;
}

//----- (08022ADC) --------------------------------------------------------
void __noreturn sub_8022ADC()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (08022B00) --------------------------------------------------------
int sub_8022B00()
{
  int v0; // s0

  *(float *)&v0 = 0.0;
  if ( *(float *)&dword_20001C24 > 0.0 )
    v0 = dword_20001C24;
  if ( *(float *)&dword_20001C28 > *(float *)&v0 )
    v0 = dword_20001C28;
  if ( *(float *)&dword_20001C20 > *(float *)&v0 )
    v0 = dword_20001C20;
  if ( dword_200004DC )
  {
    return --dword_200004DC;
  }
  else if ( v0 <= 1109393408 )
  {
    return sub_801AA4C(400);
  }
  else
  {
    return sub_801AA4C(300 - (int)(float)((float)(*(float *)&v0 - 40.0) * 30.0));
  }
}
// 200004DC: using guessed type int dword_200004DC;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;

//----- (08022B90) --------------------------------------------------------
int sub_8022B90()
{
  int v1; // [sp+4h] [bp-24h] BYREF
  int v2; // [sp+8h] [bp-20h]

  MEMORY[0x40021058] |= 4u;
  sub_8002364(&v1, 28);
  dword_20001AEC = 1073743872;
  dword_20001AF0 = 8499;
  dword_20001AF4 = 0;
  dword_20001AF8 = 65533;
  dword_20001AFC = 0;
  dword_20001B00 = 0;
  dword_20001B04 = 0;
  sub_8014A90((int)&dword_20001AEC);
  v1 = 0;
  v2 = 0xFFFF;
  sub_80149E0((_DWORD **)&dword_20001AEC, &v1, 0);
  v2 = 0xFFFF;
  sub_80149E0((_DWORD **)&dword_20001AEC, &v1, 4);
  off_20000064 = (int (*)(void))(&loc_801B2C8 + 1);
  off_20000068 = (int (*)(void))(&loc_801B2C8 + 1);
  sub_80132C0(30, 0xAu, 0);
  sub_80132A4(30);
  return sub_8014AE0((unsigned __int8 *)&dword_20001AEC, 0);
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AEC: using guessed type int dword_20001AEC;
// 20001AF0: using guessed type int dword_20001AF0;
// 20001AF4: using guessed type int dword_20001AF4;
// 20001AF8: using guessed type int dword_20001AF8;
// 20001AFC: using guessed type int dword_20001AFC;
// 20001B00: using guessed type int dword_20001B00;
// 20001B04: using guessed type int dword_20001B04;

//----- (08022C24) --------------------------------------------------------
int __fastcall sub_8022C24(int a1, int a2, int a3)
{
  int v6; // r5

  if ( a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4697);
  sub_8023064();
  if ( !*(_DWORD *)(dword_2000164C + 4 * a1 + 84) )
  {
    *(_BYTE *)(dword_2000164C + a1 + 88) = 1;
    if ( a3 )
    {
      sub_801F81C(a3, 1);
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_80230E4();
  sub_8023064();
  v6 = *(_DWORD *)(dword_2000164C + 4 * a1 + 84);
  if ( v6 )
  {
    if ( a2 )
      *(_DWORD *)(dword_2000164C + 4 * a1 + 84) = 0;
    else
      *(_DWORD *)(dword_2000164C + 4 * a1 + 84) = v6 - 1;
  }
  *(_BYTE *)(dword_2000164C + a1 + 88) = 0;
  sub_80230E4();
  return v6;
}
// 2000164C: using guessed type int dword_2000164C;
// E000ED04: using guessed type int ICSR;

//----- (08022CE4) --------------------------------------------------------
int __fastcall sub_8022CE4(unsigned int a1, __int16 a2, unsigned int a3, int a4)
{
  unsigned int v6; // r0
  int v7; // r9
  int v8; // r6
  unsigned int v9; // r7
  int i; // r5
  int v11; // r1
  float v12; // s0
  int v13; // r0
  unsigned int v14; // r0
  int v15; // r1
  unsigned int v16; // r0
  _BYTE v18[80]; // [sp+0h] [bp-78h] BYREF
  float v19; // [sp+50h] [bp-28h] BYREF
  unsigned int v20; // [sp+54h] [bp-24h] BYREF

  v6 = ((*(_BYTE *)(a4 + 9) & 0xF) * (unsigned int)*(unsigned __int8 *)(a4 + 11)) >> 1;
  v7 = (unsigned __int16)(a2 - *(_WORD *)a4);
  v20 = 0;
  v19 = 0.0;
  v8 = 0;
  v9 = (unsigned __int16)(v6 - v7);
  if ( v9 > a3 )
    v9 = a3;
  for ( i = 0; *(unsigned __int8 *)(a4 + 11) > i; ++i )
  {
    v11 = *(unsigned __int8 *)(a4 + 8);
    if ( v11 == 36 )
    {
      v12 = *(float *)(*(_DWORD *)(a4 + 4) + 4 * i);
      v19 = v12;
      v13 = *(unsigned __int8 *)(a4 + 10);
      switch ( v13 )
      {
        case 1:
          v19 = v12 * 10.0;
          break;
        case 2:
          v19 = v12 * 100.0;
          break;
        case 3:
          v19 = v12 * 0.1;
          break;
        case 4:
          v19 = v12 * 0.01;
          break;
      }
      v14 = *(unsigned __int8 *)(a4 + 8);
      v15 = *(unsigned __int8 *)(a4 + 9);
      if ( v14 == v15 )
      {
        sub_8004CBE((int)&v18[v8], (int)&v19, v15 & 0xF);
        v8 = (unsigned __int8)((*(_BYTE *)(a4 + 9) & 0xF) + v8);
        continue;
      }
      if ( v14 >= 0x11 )
        v20 = (int)v19;
      else
        v20 = (unsigned int)v19;
    }
    else
    {
      if ( v11 == 17 )
      {
        v20 = *(char *)(*(_DWORD *)(a4 + 4) + i);
      }
      else if ( *(unsigned __int8 *)(a4 + 8) > 0x11u )
      {
        switch ( v11 )
        {
          case 18:
            v20 = *(__int16 *)(*(_DWORD *)(a4 + 4) + 2 * i);
            break;
          case 20:
            v20 = *(_DWORD *)(*(_DWORD *)(a4 + 4) + 4 * i);
            break;
          case 49:
            v16 = *(unsigned __int8 *)(*(_DWORD *)(a4 + 4) + i);
            v20 = v16;
            if ( v16 >= 0x61 )
              v20 = v16 - 32;
            break;
        }
      }
      else
      {
        switch ( v11 )
        {
          case 1:
            v20 = *(unsigned __int8 *)(*(_DWORD *)(a4 + 4) + i);
            break;
          case 2:
            v20 = *(unsigned __int16 *)(*(_DWORD *)(a4 + 4) + 2 * i);
            break;
          case 4:
            v20 = *(_DWORD *)(*(_DWORD *)(a4 + 4) + 4 * i);
            break;
        }
      }
      switch ( *(_BYTE *)(a4 + 10) )
      {
        case 1:
          v20 *= 10;
          break;
        case 2:
          v20 *= 100;
          break;
        case 3:
          v20 /= 0xAu;
          break;
        case 4:
          v20 /= 0x64u;
          break;
        case 5:
          v20 = -v20;
          break;
        default:
          break;
      }
    }
    sub_8004CBE((int)&v18[v8], (int)&v20, *(_BYTE *)(a4 + 9) & 0xF);
    v8 = (unsigned __int8)((*(_BYTE *)(a4 + 9) & 0xF) + v8);
  }
  qmemcpy(a1, (unsigned int)&v18[v7], 2 * v9);
  return (unsigned __int8)v9;
}

//----- (08022F0C) --------------------------------------------------------
int sub_8022F0C()
{
  int result; // r0

  result = dword_2000002C;
  dword_20000498 = dword_2000002C;
  return result;
}
// 2000002C: using guessed type int dword_2000002C;
// 20000498: using guessed type int dword_20000498;

//----- (08022F20) --------------------------------------------------------
int __fastcall sub_8022F20(_DWORD *a1)
{
  _DWORD *v1; // r1

  v1 = (_DWORD *)a1[4];
  *(_DWORD *)(a1[1] + 8) = a1[2];
  *(_DWORD *)(a1[2] + 4) = a1[1];
  if ( (_DWORD *)v1[1] == a1 )
    v1[1] = a1[2];
  a1[4] = 0;
  return --*v1;
}

//----- (08022F48) --------------------------------------------------------
int sub_8022F48()
{
  return dword_20001654;
}
// 20001654: using guessed type int dword_20001654;

//----- (08022F54) --------------------------------------------------------
int __fastcall sub_8022F54(int a1, int a2, _DWORD *a3)
{
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r3
  int v8; // r4
  int v9; // r4
  int v10; // r4

  v5 = 0;
  v6 = 32;
  sub_8023734();
  if ( v7 >= dword_20001654 )
  {
    do
    {
      --v6;
      v5 += sub_801FCB8(a1 + 36 * v5, &dword_200115F8[5 * v6], 1);
    }
    while ( v6 );
    v8 = v5 + sub_801FCB8(a1 + 36 * v5, (_DWORD *)dword_20001684, 2);
    v9 = v8 + sub_801FCB8(a1 + 36 * v8, (_DWORD *)dword_20001688, 2);
    v10 = v9 + sub_801FCB8(a1 + 36 * v9, dword_200118B4, 4);
    v5 = v10 + sub_801FCB8(a1 + 36 * v10, &dword_200118C8, 3);
    if ( a3 )
      *a3 = 0;
  }
  sub_80257E4();
  return v5;
}
// 8022F70: variable 'v7' is possibly undefined
// 20001654: using guessed type int dword_20001654;
// 20001684: using guessed type int dword_20001684;
// 20001688: using guessed type int dword_20001688;
// 200115F8: using guessed type int dword_200115F8[160];
// 200118B4: using guessed type _DWORD dword_200118B4[3];
// 200118C8: using guessed type int dword_200118C8;

//----- (08023000) --------------------------------------------------------
_DWORD *__fastcall sub_8023000(_DWORD *result)
{
  result[1] = result + 2;
  result[2] = -1;
  result[3] = result + 2;
  result[4] = result + 2;
  *result = 0;
  return result;
}

//----- (08023016) --------------------------------------------------------
int __fastcall sub_8023016(int result)
{
  *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (0802301C) --------------------------------------------------------
_DWORD *__fastcall sub_802301C(_DWORD *result, _DWORD *a2)
{
  _DWORD *i; // r2
  int v3; // r3

  if ( *a2 == -1 )
  {
    i = (_DWORD *)result[4];
  }
  else
  {
    for ( i = result + 2; *(_DWORD *)i[1] <= *a2; i = (_DWORD *)i[1] )
      ;
  }
  v3 = i[1];
  a2[1] = v3;
  *(_DWORD *)(v3 + 8) = a2;
  a2[2] = i;
  i[1] = a2;
  a2[4] = result;
  ++*result;
  return result;
}

//----- (0802304C) --------------------------------------------------------
_DWORD *__fastcall sub_802304C(_DWORD *result, _DWORD *a2)
{
  int v2; // r2

  v2 = result[1];
  a2[1] = v2;
  a2[2] = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4) = a2;
  *(_DWORD *)(v2 + 8) = a2;
  a2[4] = result;
  ++*result;
  return result;
}

//----- (08023064) --------------------------------------------------------
int sub_8023064()
{
  int result; // r0

  _R0 = 144;
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  result = ++dword_200016AC;
  if ( dword_200016AC == 1 )
  {
    result = ICSR;
    if ( (_BYTE)ICSR )
      return sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 441);
  }
  return result;
}
// 200016AC: using guessed type int dword_200016AC;
// E000ED04: using guessed type int ICSR;

//----- (080230E4) --------------------------------------------------------
int sub_80230E4()
{
  int result; // r0

  if ( !dword_200016AC )
    sub_801E1B0((int)sub_8023144, "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 448);
  result = dword_200016AC - 1;
  dword_200016AC = result;
  if ( !result )
    __asm { MSR.W           BASEPRI, R0 }
  return result;
}
// 200016AC: using guessed type int dword_200016AC;

//----- (08023144) --------------------------------------------------------
int __fastcall sub_8023144(int result)
{
  char v1; // r5
  int *v2; // r4

  *(_BYTE *)(result + 9) = v1;
  if ( result )
  {
    v2 = (int *)(result - 8);
    if ( *(int *)(result - 4) >= 0 )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 303);
    if ( *v2 )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 304);
    result = v2[1];
    if ( result < 0 && !*v2 )
    {
      v2[1] = result & 0x7FFFFFFF;
      sub_8023734();
      dword_20001690 += v2[1];
      sub_801FC2C(v2);
      ++dword_2000169C;
      return sub_80257E4();
    }
  }
  return result;
}
// 8023144: could not find valid save-restore pair for r4
// 8023144: variable 'v1' is possibly undefined
// 80257E4: using guessed type int sub_80257E4(void);
// 20001690: using guessed type int dword_20001690;
// 2000169C: using guessed type int dword_2000169C;

//----- (080231FC) --------------------------------------------------------
int sub_80231FC()
{
  int result; // r0

  result = -536813568;
  SYST_CVR = 0;
  SYST_RVR = dword_20000290 / 0x3E8u - 1;
  SYST_CSR = 7;
  return result;
}
// 20000290: using guessed type int dword_20000290;
// E000E010: using guessed type int SYST_CSR;
// E000E014: using guessed type int SYST_RVR;
// E000E018: using guessed type int SYST_CVR;

//----- (08023220) --------------------------------------------------------
unsigned int sub_8023220()
{
  unsigned int v0; // r0
  unsigned int result; // r0

  v0 = sub_80022A4();
  if ( v0 >= 0x10 && *(unsigned __int8 *)(v0 - 536812560) < (unsigned int)(unsigned __int8)byte_200016A8 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 845);
  result = AIRCR & 0x700;
  if ( result > dword_200016B0 )
    return sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 861);
  return result;
}
// 200016A8: using guessed type char byte_200016A8;
// 200016B0: using guessed type int dword_200016B0;
// E000ED0C: using guessed type int AIRCR;

//----- (080232B4) --------------------------------------------------------
int __fastcall sub_80232B4(int a1)
{
  int result; // r0

  result = 0;
  if ( a1 )
  {
    if ( dword_20001680 )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1308);
    sub_8023734();
    sub_801F81C(a1, 0);
    result = sub_80257E4();
  }
  if ( !result )
  {
    result = 0x10000000;
    ICSR = 0x10000000;
    __dsb(0xFu);
    __isb(0xFu);
  }
  return result;
}
// 20001680: using guessed type int dword_20001680;
// E000ED04: using guessed type int ICSR;

//----- (0802332C) --------------------------------------------------------
int __fastcall sub_802332C(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  int result; // r0

  if ( a1 )
    v6 = a1;
  else
    v6 = dword_2000164C;
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v6 + 52;
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(v6 + 44);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(v6 + 48);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(v6 + 76);
  *(_DWORD *)(a2 + 24) = 0;
  if ( a4 == 5 )
  {
    result = sub_801ECF8(v6);
    *(_BYTE *)(a2 + 12) = result;
  }
  else
  {
    result = dword_2000164C;
    if ( v6 == dword_2000164C )
    {
      *(_BYTE *)(a2 + 12) = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 12) = a4;
      if ( a4 == 3 )
      {
        sub_8023734();
        if ( *(_DWORD *)(v6 + 40) )
          *(_BYTE *)(a2 + 12) = 2;
        result = sub_80257E4();
      }
    }
  }
  if ( a3 )
  {
    result = sub_801FDE0(*(unsigned __int8 **)(v6 + 48));
    *(_WORD *)(a2 + 32) = result;
  }
  else
  {
    *(_WORD *)(a2 + 32) = 0;
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;

//----- (080233A0) --------------------------------------------------------
_DWORD *__fastcall sub_80233A0(_DWORD *result)
{
  *result = dword_2000166C;
  result[1] = dword_20001658;
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 2000166C: using guessed type int dword_2000166C;

//----- (080233B0) --------------------------------------------------------
int __fastcall sub_80233B0(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r8
  int v2; // r4
  int result; // r0
  int v4; // r7
  unsigned int v5; // r9
  unsigned int i; // r6
  unsigned int v7; // r5
  int v8; // r4
  unsigned __int8 *v9; // r8

  v1 = a1;
  *a1 = 0;
  v2 = dword_20001654;
  result = ((int (__fastcall *)(int))loc_801FF00)(36 * dword_20001654);
  v4 = result;
  if ( result )
  {
    v5 = sub_8022F54(result, v2, 0);
    for ( i = 0; i < v5; ++i )
    {
      v7 = v4 + 36 * i;
      switch ( *(_BYTE *)(v7 + 12) )
      {
        case 0:
          v8 = 88;
          break;
        case 1:
          v8 = 82;
          break;
        case 2:
          v8 = 66;
          break;
        case 3:
          v8 = 83;
          break;
        case 4:
          v8 = 68;
          break;
        default:
          v8 = 0;
          break;
      }
      v9 = sub_801FEDC(v1, *(unsigned __int8 **)(v7 + 4));
      sprintf(
        (int)v9,
        "\t%c\t%u\t%u\t%u\r\n",
        v8,
        *(_DWORD *)(v7 + 16),
        *(unsigned __int16 *)(v7 + 32),
        *(_DWORD *)(v7 + 8));
      v1 = &sub_80023E2(v9)[(_DWORD)v9];
    }
    JUMPOUT(0x8023154);
  }
  return result;
}
// 8023440: control flows out of bounds to 8023154
// 20001654: using guessed type int dword_20001654;

//----- (0802345C) --------------------------------------------------------
int sub_802345C()
{
  int result; // r0

  result = 1;
  dword_20001668 = 1;
  return result;
}
// 20001668: using guessed type int dword_20001668;

//----- (08023468) --------------------------------------------------------
_DWORD *__fastcall sub_8023468(_DWORD *a1, int a2)
{
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3086);
  sub_802301C(a1, (_DWORD *)(dword_2000164C + 24));
  return sub_801F81C(a2, 1);
}
// 2000164C: using guessed type int dword_2000164C;

//----- (080234C8) --------------------------------------------------------
int __fastcall sub_80234C8(int result, unsigned int a2)
{
  _DWORD *v3; // r4
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r0
  int v7; // r0

  v3 = (_DWORD *)result;
  if ( result )
  {
    if ( !*(_DWORD *)(result + 80) )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4248);
    v4 = v3[19];
    if ( v4 < a2 )
      v4 = a2;
    result = v3[11];
    if ( result != v4 )
    {
      result = v3[20];
      if ( result == 1 )
      {
        if ( v3 == (_DWORD *)dword_2000164C )
          sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4275);
        v5 = v3[11];
        v3[11] = v4;
        if ( (int)v3[6] >= 0 )
          v3[6] = 32 - v4;
        result = (int)&dword_200115F8[5 * v5];
        if ( v3[5] == result )
        {
          if ( !sub_8022F20(v3 + 1) )
            dword_2000165C &= ~(1 << *((_BYTE *)v3 + 44));
          v6 = v3[11];
          dword_2000165C |= 1 << v6;
          v7 = dword_200115F8[5 * v6 + 1];
          v3[2] = v7;
          v3[3] = *(_DWORD *)(v7 + 8);
          *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4) = v3 + 1;
          *(_DWORD *)(v7 + 8) = v3 + 1;
          v3[5] = &dword_200115F8[5 * v3[11]];
          result = 5 * v3[11];
          ++dword_200115F8[5 * v3[11]];
        }
      }
    }
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 2000165C: using guessed type int dword_2000165C;
// 200115F8: using guessed type int dword_200115F8[160];

//----- (080235B8) --------------------------------------------------------
int sub_80235B8()
{
  int v0; // r0

  v0 = sub_80251BC(134349473, (int)"IDLE", 128, 0, 0, &dword_20001678);
  if ( v0 == 1 )
  {
    _R0 = 144;
    __asm { MSR.W           BASEPRI, R0 }
    __dsb(0xFu);
    __isb(0xFu);
    dword_20001674 = -1;
    dword_20001660 = 1;
    dword_20001658 = 0;
    sub_8024764();
  }
  else if ( v0 == -1 )
  {
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2066);
  }
  return dword_2000167C;
}
// 20001658: using guessed type int dword_20001658;
// 20001660: using guessed type int dword_20001660;
// 20001674: using guessed type int dword_20001674;
// 20001678: using guessed type _DWORD dword_20001678;
// 2000167C: using guessed type int dword_2000167C;

//----- (08023648) --------------------------------------------------------
int __fastcall sub_8023648(_DWORD *a1)
{
  int v2; // r0
  int i; // r0
  int result; // r0

  sub_8023064();
  if ( !a1 )
    a1 = (_DWORD *)dword_2000164C;
  if ( !sub_8022F20(a1 + 1) )
  {
    v2 = a1[11];
    if ( !dword_200115F8[5 * v2] )
      dword_2000165C &= ~(1 << v2);
  }
  if ( a1[10] )
    sub_8022F20(a1 + 6);
  sub_802304C(&dword_200118C8, a1 + 1);
  for ( i = 0; i < 1; ++i )
  {
    if ( *((_BYTE *)a1 + i + 88) == 1 )
      *((_BYTE *)a1 + i + 88) = 0;
  }
  sub_80230E4();
  if ( dword_20001660 )
  {
    sub_8023064();
    sub_801FDC0();
    sub_80230E4();
  }
  result = dword_2000164C;
  if ( a1 == (_DWORD *)dword_2000164C )
  {
    if ( dword_20001660 )
    {
      if ( dword_20001680 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1746);
      result = 0x10000000;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
    else
    {
      result = dword_200118C8;
      if ( dword_200118C8 == dword_20001654 )
        dword_2000164C = 0;
      else
        return sub_8023744();
    }
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001654: using guessed type int dword_20001654;
// 2000165C: using guessed type int dword_2000165C;
// 20001660: using guessed type int dword_20001660;
// 20001680: using guessed type int dword_20001680;
// 200115F8: using guessed type int dword_200115F8[160];
// 200118C8: using guessed type int dword_200118C8;
// E000ED04: using guessed type int ICSR;

//----- (08023734) --------------------------------------------------------
int *sub_8023734()
{
  int *result; // r0

  result = &dword_2000164C;
  ++dword_20001680;
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001680: using guessed type int dword_20001680;

//----- (08023744) --------------------------------------------------------
int sub_8023744()
{
  int result; // r0
  unsigned int v1; // r0
  int v2; // r4
  int *v3; // r0
  int *v4; // r1

  if ( dword_20001680 )
  {
    result = 1;
    dword_20001668 = 1;
  }
  else
  {
    dword_20001668 = 0;
    v1 = __clz(dword_2000165C);
    v2 = 5 * (31 - v1);
    if ( !dword_200115F8[5 * (31 - v1)] )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3062);
    v3 = &dword_200115F8[v2];
    v4 = *(int **)(v3[1] + 4);
    v3[1] = (int)v4;
    if ( v4 == v3 + 2 )
      v3[1] = v4[1];
    result = *(_DWORD *)(v3[1] + 12);
    dword_2000164C = result;
  }
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 2000165C: using guessed type int dword_2000165C;
// 20001668: using guessed type int dword_20001668;
// 20001680: using guessed type int dword_20001680;
// 200115F8: using guessed type int dword_200115F8[160];

//----- (080238FC) --------------------------------------------------------
int __fastcall sub_80238FC(_BYTE *a1, int a2, int a3, unsigned int a4)
{
  int v8; // r2
  char v9; // r8
  unsigned int v10; // r2
  bool v11; // zf
  bool v12; // cc
  int v13; // r0
  bool v14; // zf
  bool v15; // cc
  int v16; // r9
  int v17; // r1
  int v18; // r0
  bool v19; // zf
  bool v20; // cc
  int result; // r0
  int v22; // r9
  char *v23; // r0
  unsigned int v24; // r0
  unsigned int v25; // r0
  char *v26; // r2
  unsigned int v27; // r1
  unsigned int v28; // r0
  unsigned int v29; // r0
  char *v30; // r2
  unsigned int v31; // r1
  unsigned int v32; // r0
  unsigned int v33; // r0
  unsigned int v34; // r0
  char *v35; // r0
  unsigned int v36; // r1
  unsigned int v37; // r2
  unsigned int v38; // r2
  unsigned int v39; // [sp+0h] [bp-38h] BYREF
  int v40; // [sp+4h] [bp-34h] BYREF
  unsigned int v41; // [sp+8h] [bp-30h]

  v40 = 0;
  v41 = a4 >> 8;
  v8 = a2 - 43000;
  v9 = a4;
  if ( a2 != 43000 )
  {
    if ( a2 <= 43000 )
    {
      v10 = a2 - 41607;
      v11 = a2 == 41607;
      v12 = a2 <= 41607;
      while ( 2 )
      {
        if ( !v11 )
        {
          if ( v12 )
          {
            v10 = 41509;
            v13 = a2 - 41509;
            v14 = a2 == 41509;
            v15 = a2 <= 41509;
            while ( 1 )
            {
              if ( v14 )
                goto LABEL_128;
              if ( !v15 )
                break;
              v10 = 41501;
              v13 = a2 - 41501;
              v14 = a2 == 41501;
              v15 = a2 <= 41501;
              if ( a2 != 41501 )
              {
                if ( a2 > 41501 )
                {
                  switch ( a2 )
                  {
                    case 41502:
                    case 41503:
                    case 41504:
                    case 41505:
                    case 41506:
                    case 41507:
                    case 41508:
                      goto LABEL_128;
                    default:
                      return 2;
                  }
                }
                if ( a2 == 41010 )
                {
                  if ( a3 )
                  {
                    if ( a4 == 800 )
                    {
                      byte_20000507 = 1;
                      word_20000515 = 800;
                      sub_80055F0(0x204u, &word_20000515, 2u);
                      sub_80055F0(0x90u, &byte_20000507, 1u);
                      return 0;
                    }
                    else if ( a4 == 2500 )
                    {
                      byte_20000507 = 0;
                      word_20000515 = 2500;
                      sub_80055F0(0x204u, &word_20000515, 2u);
                      sub_80055F0(0x90u, &byte_20000507, 1u);
                      return 0;
                    }
                    else
                    {
                      return 3;
                    }
                  }
                  else
                  {
                    *a1 = 0;
                    a1[1] = byte_20000507;
                    return 0;
                  }
                }
                if ( a2 > 41010 )
                {
                  if ( a2 == 41100 )
                  {
                    if ( a3 )
                    {
                      if ( a4 )
                      {
                        byte_2000050D = a4;
                        sub_80055F0(0x101u, &byte_2000050D, 1u);
                        return 0;
                      }
                      else
                      {
                        return 3;
                      }
                    }
                    else
                    {
                      *a1 = 0;
                      a1[1] = byte_2000050D;
                      return 0;
                    }
                  }
                  if ( a2 != 41200 )
                  {
                    if ( a2 != 41500 )
                      return 2;
LABEL_128:
                    v22 = a2 - 41500;
                    if ( a3 )
                    {
                      byte_20002EB1[2 * v22] = v41;
                      byte_20002EB1[2 * v22 + 1] = a4;
                    }
                    else
                    {
                      *a1 = byte_20002EB1[2 * v22];
                      a1[1] = byte_20002EB1[2 * v22 + 1];
                    }
                    return 0;
                  }
                  if ( a3 )
                  {
                    if ( a4 < 2 )
                    {
                      sub_80031EE();
                      return 0;
                    }
                    else
                    {
                      return 3;
                    }
                  }
                  else
                  {
                    *a1 = 0;
                    a1[1] = byte_20002E37[0] != 1;
                    return 0;
                  }
                }
                else
                {
                  switch ( a2 )
                  {
                    case 40000:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          byte_20002E38 = 14;
                          word_20002DE0 = 0;
                          word_20002DE2 = 0;
                          word_20002DE4 = 0;
                          return 0;
                        }
                        else if ( a4 - 21921 > 5 )
                        {
                          return 3;
                        }
                        else
                        {
                          byte_20002E38 = 14;
                          word_20002DE0 = a4 - 21920;
                          word_20002DE2 = 0;
                          word_20002DE4 = 0;
                          return 0;
                        }
                      }
                      else
                      {
                        return 2;
                      }
                    case 41000:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          byte_20000520 = 1;
                          return 0;
                        }
                        else
                        {
                          return 3;
                        }
                      }
                      else
                      {
                        *a1 = 0;
                        a1[1] = byte_20000520;
                        return 0;
                      }
                    case 41001:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          sub_800511C(3);
                          byte_20000520 = 1;
                          return 0;
                        }
                        else
                        {
                          return 3;
                        }
                      }
                      else
                      {
                        *a1 = 0;
                        a1[1] = byte_20000520;
                        return 0;
                      }
                    default:
                      return 2;
                  }
                }
              }
            }
            v11 = v13 == 91;
            v12 = v13 <= 91;
            if ( v13 == 91 )
              continue;
            if ( v13 <= 91 )
            {
              switch ( v13 )
              {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                  goto LABEL_128;
                default:
                  return 2;
              }
            }
            if ( (unsigned int)(v13 - 92) > 5 )
              return 2;
          }
          else if ( v10 != 16 )
          {
            if ( v10 < 0x10 )
            {
              switch ( v10 )
              {
                case 0u:
                  return 2;
                case 1u:
                case 2u:
                case 3u:
                case 4u:
                case 5u:
                case 6u:
                case 7u:
                case 8u:
                case 9u:
                case 0xAu:
                case 0xBu:
                case 0xCu:
                case 0xDu:
                case 0xEu:
                case 0xFu:
                  goto LABEL_132;
                default:
                  if ( v10 - 17 <= 6 )
                    goto LABEL_132;
                  return 2;
              }
            }
            return 2;
          }
        }
        break;
      }
LABEL_132:
      v23 = &byte_20002EB1[2 * a2 - 83200];
      if ( a3 )
      {
        v23[32] = v41;
        v40 = (unsigned __int8)a4;
        v23[33] = a4;
        if ( !(_BYTE)a4 )
        {
          byte_20004236 = 1;
          byte_20000929 = 0;
          byte_20000928 = 0;
          byte_200036AC[0] = 2;
          byte_200036AE = 0;
        }
        return 0;
      }
      else
      {
        *a1 = v23[32];
        a1[1] = v23[33];
        return 0;
      }
    }
    if ( a2 == 44000 )
    {
      if ( a3 )
      {
        if ( a4 - 800 > 0xC8 )
        {
          return 3;
        }
        else
        {
          byte_20000511 = a4 / 0xA;
          sub_80055F0(0x201u, &byte_20000511, 1u);
          return 0;
        }
      }
      else
      {
        v40 = 10 * (unsigned __int8)byte_20000511;
        sub_8004CBE((int)a1, (int)&v40, 2u);
        return 0;
      }
    }
    if ( v8 <= 1000 )
    {
      v16 = a2 - 43100;
      switch ( a2 )
      {
        case 43100:
        case 43105:
        case 43110:
        case 43115:
        case 43120:
        case 43125:
          v24 = (unsigned __int8)(v16 / 5);
          if ( v24 <= 5 )
          {
            if ( a3 )
            {
              *(_WORD *)&byte_20002E37[10 * v24 + 2] = (unsigned __int8)a4;
            }
            else
            {
              v40 = (unsigned __int8)byte_20002E37[10 * v24 + 2];
              sub_8004CBE((int)a1, (int)&v40, 2u);
            }
            result = 0;
          }
          else
          {
            result = 3;
          }
          break;
        case 43101:
        case 43106:
        case 43111:
        case 43116:
        case 43121:
        case 43126:
          v25 = (unsigned __int8)(v16 / 5);
          if ( v25 <= 5 )
          {
            if ( a3 )
            {
              v26 = &byte_20002E37[10 * v25];
              v26[3] = 0;
              v27 = a4 % 0x64;
              if ( a4 / 0x64 >= 0x18 || v27 >= 0x3C )
              {
                result = 3;
              }
              else
              {
                *((_WORD *)v26 + 3) = v27 | ((unsigned __int16)(a4 / 0x64) << 8);
                result = 0;
              }
            }
            else
            {
              v28 = *(unsigned __int16 *)&byte_20002E37[10 * v25 + 6];
              v40 = (unsigned __int8)v28 + 100 * (v28 >> 8);
              sub_8004CBE((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43102:
        case 43107:
        case 43112:
        case 43117:
        case 43122:
        case 43127:
          v29 = (unsigned __int8)(v16 / 5);
          if ( v29 <= 5 )
          {
            if ( a3 )
            {
              v30 = &byte_20002E37[10 * v29];
              v30[3] = 0;
              v31 = a4 % 0x64;
              if ( a4 / 0x64 >= 0x18 || v31 >= 0x3C )
              {
                result = 3;
              }
              else
              {
                *((_WORD *)v30 + 4) = v31 | ((unsigned __int16)(a4 / 0x64) << 8);
                result = 0;
              }
            }
            else
            {
              v32 = *(unsigned __int16 *)&byte_20002E37[10 * v29 + 8];
              v40 = (unsigned __int8)v32 + 100 * (v32 >> 8);
              sub_8004CBE((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43103:
        case 43108:
        case 43113:
        case 43118:
        case 43123:
        case 43128:
          v33 = (unsigned __int8)(v16 / 5);
          if ( v33 <= 5 )
          {
            if ( a3 )
            {
              if ( (unsigned int)((__int16)a4 + 2500) < 0x1389 )
              {
                *(_WORD *)&byte_20002E37[10 * v33 + 4] = a4;
                result = 0;
              }
              else
              {
                result = 3;
              }
            }
            else
            {
              v40 = *(unsigned __int16 *)&byte_20002E37[10 * v33 + 4];
              sub_8004CBE((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43104:
        case 43109:
        case 43114:
        case 43119:
        case 43124:
        case 43129:
          v34 = (unsigned __int8)(v16 / 5);
          if ( v34 <= 5 )
          {
            if ( a3 )
            {
              if ( a4 == 1 )
              {
                byte_20002E37[10 * v34 + 3] = 1;
                result = 0;
              }
              else if ( a4 )
              {
                result = 3;
              }
              else
              {
                byte_20002E37[10 * v34 + 3] = 0;
                result = 0;
              }
            }
            else
            {
              v40 = (unsigned __int8)byte_20002E37[10 * v34 + 3];
              sub_8004CBE((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        default:
          return 2;
      }
      return result;
    }
    v17 = a2 - 45100;
    if ( a2 == 45100 )
    {
      if ( !a3 || byte_20002E38 != 13 && byte_20002E38 != 4 )
        return 1;
      if ( a4 << 31 )
        sub_801227E(1207963648, 64, 1);
      else
        sub_801227E(1207963648, 64, 0);
      if ( (a4 & 2) != 0 )
        sub_801227E(1207961600, 2048, 1);
      else
        sub_801227E(1207961600, 2048, 0);
      if ( (a4 & 4) != 0 )
        sub_801227E(1207959552, 16, 1);
      else
        sub_801227E(1207959552, 16, 0);
      if ( (a4 & 8) != 0 )
        sub_801227E(1207963648, 4, 1);
      else
        sub_801227E(1207963648, 4, 0);
      if ( (a4 & 0x10) != 0 )
        sub_801227E(1207963648, 8, 1);
      else
        sub_801227E(1207963648, 8, 0);
      if ( (a4 & 0x20) != 0 )
        sub_801227E(1207963648, 16, 1);
      else
        sub_801227E(1207963648, 16, 0);
      if ( (a4 & 0x40) != 0 )
        sub_801227E(1207963648, 32, 1);
      else
        sub_801227E(1207963648, 32, 0);
      if ( (a4 & 0x80) != 0 )
      {
        ((void (__fastcall *)(int))loc_8010000)(10000);
        sub_801227E(1207960576, 16, 1);
      }
      else
      {
        sub_801227E(1207960576, 16, 0);
        ((void (__fastcall *)(_DWORD))loc_8010000)(0);
      }
      if ( (a4 & 0x100) != 0 )
      {
        sub_801227E(1207959552, 8, 1);
        ((void (__fastcall *)(int))loc_8010000)(10000);
      }
      else
      {
        ((void (__fastcall *)(_DWORD))loc_8010000)(0);
        sub_801227E(1207959552, 8, 0);
      }
      if ( (a4 & 0x200) != 0 )
        sub_801227E(1207959552, 32, 1);
      else
        sub_801227E(1207959552, 32, 0);
      return 0;
    }
    if ( v8 <= 2100 )
    {
      v18 = a2 - 45012;
      v19 = v8 == 2012;
      v20 = v8 <= 2012;
      while ( 1 )
      {
        if ( v19 )
          goto LABEL_232;
        if ( !v20 )
        {
          switch ( v18 )
          {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              goto LABEL_232;
            default:
              return 2;
          }
        }
        if ( a2 == 44100 )
        {
          if ( a3 )
          {
            if ( a4 > 9 )
            {
              return 3;
            }
            else
            {
              byte_20000517 = a4;
              sub_80055F0(0x206u, &byte_20000517, 1u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int8)byte_20000517;
            sub_8004CBE((int)a1, (int)&v40, 2u);
            return 0;
          }
        }
        if ( v8 <= 1100 )
          break;
        if ( v8 == 2000 )
        {
          if ( a3 )
          {
            if ( a4 == 21998 )
            {
              sub_80032A2();
              sub_801EC38();
              sub_801EFEC();
              byte_2000050E = 0;
              byte_20002E37[0] = 0;
              byte_20002E38 = 13;
              return 0;
            }
            if ( a4 != 22015 )
            {
              if ( a4 != 21981 )
                return 3;
              sub_80032A2();
              sub_801EC38();
              sub_801EFEC();
              sub_8005498(0x102u, (int)&byte_2000050E, 1);
              sub_8005498(0x300u, (int)byte_20002E37, 1);
              sub_8005498(0x301u, (int)&byte_20002E38, 1);
              return 0;
            }
            sub_80032A2();
            sub_801EC38();
            sub_801EFEC();
            byte_20000507 = 0;
            word_20000515 = 2500;
            dword_200002E0 = 0;
            byte_2000050E = 0;
            byte_20002E37[0] = 0;
            byte_20002E38 = 4;
            sub_8003234();
          }
          goto LABEL_232;
        }
        v18 = v8 - 2010;
        v19 = v8 == 2010;
        v20 = v8 - 1868 <= 142;
        if ( v8 != 2010 )
        {
          if ( v8 != 2011 )
            return 2;
LABEL_232:
          if ( !a3 || byte_20002E38 != 13 && byte_20002E38 != 4 )
            return 1;
          v35 = (char *)&unk_20002E08 + 2 * a2 - 90020;
          v35[20] = v41;
          v35[21] = v9;
          if ( a2 == 45019 )
            sub_80055F0(0x21u, byte_20002E1C, 0x14u);
          return 0;
        }
      }
      switch ( a2 )
      {
        case 44001:
          if ( a3 )
          {
            if ( a4 - 120 > 0xB4 )
            {
              return 3;
            }
            else
            {
              byte_20000512 = a4 / 0xA;
              sub_80055F0(0x201u, &byte_20000512, 1u);
              return 0;
            }
          }
          else
          {
            v40 = 10 * (unsigned __int8)byte_20000512;
            sub_8004CBE((int)a1, (int)&v40, 2u);
            return 0;
          }
        case 44002:
          if ( a3 )
          {
            if ( a4 > 0x9C4 )
            {
              return 3;
            }
            else
            {
              word_20000513 = a4;
              sub_80055F0(0x202u, &word_20000513, 2u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int16)word_20000513;
            sub_8004CBE((int)a1, (int)&v40, 2u);
            return 0;
          }
        case 44003:
          if ( a3 )
          {
            if ( a4 > 0x9C4 )
            {
              return 3;
            }
            else if ( byte_20000507 == 1 && a4 > 0x320 )
            {
              return 3;
            }
            else
            {
              word_20000515 = a4;
              sub_80055F0(0x204u, &word_20000515, 2u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int16)word_20000515;
            sub_8004CBE((int)a1, (int)&v40, 2u);
            return 0;
          }
        default:
          return 2;
      }
    }
    if ( v8 == 2502 )
    {
      if ( !a3 )
        return 1;
      if ( byte_20002E38 == 13 )
      {
        if ( !a4 )
          goto LABEL_304;
        if ( a4 != 1 )
          return 3;
        goto LABEL_342;
      }
      if ( byte_20002E38 != 4 )
        return 1;
      if ( a4 >= 2 )
        return 3;
    }
    else
    {
      if ( v17 > 402 )
      {
        if ( v8 != 2604 )
        {
          if ( v17 > 504 )
          {
            if ( v8 == 3000 )
            {
              if ( !a3 )
                return 1;
              if ( a4 == 20736 )
              {
                byte_20000504 = 1;
                sub_80055F0(0x900u, &byte_20000504, 1u);
                return 0;
              }
              if ( a4 != 1234 )
                return 1;
              byte_20000504 = 1;
              byte_200004AD = 5;
              sub_80031E4();
              byte_20000294 = 1;
              byte_20000031 = 1;
            }
            else if ( v8 != 4000 )
            {
              return 2;
            }
            if ( !a3 )
              return 1;
            if ( a4 != 1 )
              return 1;
            v39 = 1;
            sub_80055F0(0x480u, &v39, 1u);
            byte_20000520 = 1;
            return 0;
          }
          if ( v8 == 2600 )
          {
            if ( !a3 )
              return 1;
            if ( byte_20002E38 != 4 )
              return 1;
            goto LABEL_345;
          }
          if ( v8 == 2601 )
          {
            if ( !a3 )
              return 1;
            if ( byte_20002E38 != 4 )
              return 1;
            goto LABEL_345;
          }
          if ( v8 != 2603 )
            return 2;
        }
        if ( a3 )
          return 1;
        if ( a2 == 45603 )
          sub_8005498(0x950u, (int)&v39, 2);
        else
          sub_8005498(0x952u, (int)&v39, 2);
        if ( (unsigned __int16)v39 < 0xFFFEu )
        {
          v36 = (unsigned __int16)v39 / 0xAu;
          v37 = (unsigned __int16)v39 % 0xAu + (unsigned __int16)v40 + 16 * (v36 % 0xA);
          v36 /= 0xAu;
          v38 = v37 + ((v36 % 0xA) << 8);
          v36 /= 0xAu;
          v40 = v38 + ((v36 % 0xA) << 12);
          v39 = v36 / 0xA;
        }
        sub_8004CBE((int)a1, (int)&v40, 2u);
        return 0;
      }
      if ( a2 == 45401 )
      {
        if ( !a3 || byte_20002E38 != 13 )
          return 1;
        if ( !a4 )
          goto LABEL_304;
LABEL_292:
        sub_80032AC();
        goto LABEL_304;
      }
      if ( v17 <= 301 )
      {
        switch ( a2 )
        {
          case 45200:
            if ( !a3 || byte_20002E38 != 13 && byte_20002E38 != 4 )
              return 1;
            sub_801EC94();
            return 0;
          case 45300:
            if ( !a3 || byte_20002E38 != 13 && byte_20002E38 != 4 )
              return 1;
            dword_200004DC = 100;
            if ( a4 )
              sub_801AA4C(200);
            else
              sub_801AA4C(0);
            return 0;
          case 45400:
            if ( !a3 || byte_20002E38 != 13 )
              return 1;
            if ( !a4 )
              goto LABEL_304;
            goto LABEL_292;
        }
        return 2;
      }
      if ( a2 == 45402 )
      {
        if ( !a3 || byte_20002E38 != 13 )
          return 1;
        if ( a4 )
        {
          sub_80032AC();
          word_2000051A = 0;
        }
        goto LABEL_304;
      }
      if ( a2 != 45500 )
      {
        if ( a2 != 45501 )
          return 2;
        if ( !a3 )
          return 1;
        if ( byte_20002E38 != 13 )
        {
          if ( byte_20002E38 != 4 )
            return 1;
          if ( a4 )
          {
            if ( a4 == 1 )
            {
              byte_20002E37[0] = 1;
              return 0;
            }
            else
            {
              return 3;
            }
          }
          else
          {
            sub_8003234();
            result = 0;
            byte_20002E37[0] = 0;
          }
          return result;
        }
        if ( !a4 )
        {
LABEL_304:
          sub_80032A2();
          return 0;
        }
        if ( a4 != 1 )
          return 3;
LABEL_342:
        sub_80032A2();
        sub_80116A0(1u);
        sub_80032AC();
        sub_80032A2();
        return 0;
      }
      if ( !a3 )
        return 1;
      if ( byte_20002E38 == 13 )
      {
        if ( !a4 )
          goto LABEL_304;
        if ( a4 != 1 )
          return 3;
        goto LABEL_342;
      }
      if ( byte_20002E38 != 4 )
        return 1;
      if ( a4 >= 2 )
        return 3;
    }
LABEL_345:
    sub_8003234();
    return 0;
  }
  if ( a3 )
  {
    if ( a4 )
    {
      if ( a4 == 1 )
      {
        byte_20002E38 = 0;
      }
      else
      {
        if ( a4 != 2 )
          return 3;
        byte_20002E38 = 5;
      }
    }
    else
    {
      byte_20002E38 = 1;
    }
    sub_80055F0(0x301u, &byte_20002E38, 1u);
    return 0;
  }
  else
  {
    if ( byte_20002E38 != 1 )
    {
      if ( byte_20002E38 == 2 )
        v40 = 2;
      else
        v40 = 1;
    }
    sub_8004CBE((int)a1, (int)&v40, 2u);
    return 0;
  }
}
// 80239F2: conditional instruction was optimized away because r2.4<10u
// 80239F4: conditional instruction was optimized away because r2.4<10u
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200002E0: using guessed type int dword_200002E0;
// 200004AD: using guessed type char byte_200004AD;
// 200004DC: using guessed type int dword_200004DC;
// 20000504: using guessed type char byte_20000504;
// 20000507: using guessed type char byte_20000507;
// 20000508: using guessed type __int16 word_20000508;
// 2000050A: using guessed type __int16 word_2000050A;
// 2000050D: using guessed type char byte_2000050D;
// 2000050E: using guessed type char byte_2000050E;
// 20000511: using guessed type char byte_20000511;
// 20000512: using guessed type char byte_20000512;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 20000517: using guessed type char byte_20000517;
// 2000051A: using guessed type __int16 word_2000051A;
// 20000520: using guessed type char byte_20000520;
// 20000521: using guessed type char byte_20000521;
// 20000522: using guessed type char byte_20000522;
// 20000928: using guessed type char byte_20000928;
// 20000929: using guessed type char byte_20000929;
// 20002DE0: using guessed type __int16 word_20002DE0;
// 20002DE2: using guessed type __int16 word_20002DE2;
// 20002DE4: using guessed type __int16 word_20002DE4;
// 20002E1C: using guessed type _BYTE[20];
// 20002E38: using guessed type char byte_20002E38;
// 200036AE: using guessed type char byte_200036AE;
// 20004236: using guessed type char byte_20004236;

//----- (08024764) --------------------------------------------------------
int sub_8024764()
{
  void *v0; // r2
  void *v1; // r3
  char v3; // [sp+0h] [bp-18h]
  char v4; // [sp+4h] [bp-14h]

  if ( CPUID == 1091551857 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 326);
  if ( CPUID == 1091551856 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 327);
  v4 = NVIC_IPR_0;
  NVIC_IPR_0 = -1;
  v3 = -1;
  sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 352);
  byte_200016A8 = -112;
  dword_200016B0 = 7;
  while ( v3 < 0 )
  {
    --dword_200016B0;
    v3 *= 2;
  }
  if ( dword_200016B0 != 3 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 372);
  if ( dword_200016B0 != 3 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 381);
  dword_200016B0 = ((unsigned __int8)dword_200016B0 << 8) & 0x700;
  NVIC_IPR_0 = v4;
  SHPR3 |= 0xF00000u;
  SHPR3 |= 0xF0000000;
  sub_80231FC();
  dword_200016AC = 0;
  sub_8002234();
  FPCCR |= 0xC0000000;
  sub_800220C((int)&FPCCR, (void *)FPCCR, v0, v1);
  return 0;
}
// 8024840: variable 'v0' is possibly undefined
// 8024840: variable 'v1' is possibly undefined
// 200016A8: using guessed type char byte_200016A8;
// 200016AC: using guessed type int dword_200016AC;
// 200016B0: using guessed type int dword_200016B0;
// E000E400: using guessed type char NVIC_IPR_0;
// E000ED00: using guessed type int CPUID;
// E000ED20: using guessed type int SHPR3;
// E000EF34: using guessed type int FPCCR;

//----- (080248A0) --------------------------------------------------------
int sub_80248A0()
{
  int result; // r0

  _R0 = 144;
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  if ( sub_80253F4() )
    ICSR = 0x10000000;
  result = 0;
  __asm { MSR.W           BASEPRI, R0 }
  return result;
}
// E000ED04: using guessed type int ICSR;

//----- (080248CC) --------------------------------------------------------
_DWORD *__fastcall sub_80248CC(char a1)
{
  _DWORD *v1; // r4

  v1 = (_DWORD *)sub_80248E4(1u, 0, a1);
  sub_801FAC8(v1);
  return v1;
}

//----- (080248E4) --------------------------------------------------------
int __fastcall sub_80248E4(unsigned int a1, unsigned int a2, char a3)
{
  int v6; // r4
  int v7; // r0

  v6 = 0;
  if ( a1 && 0xFFFFFFFF / a1 >= a2 && a1 * a2 <= 0xFFFFFFAB )
  {
    v7 = ((int (__fastcall *)(unsigned int))loc_801FF00)(a1 * a2 + 84);
    v6 = v7;
    if ( v7 )
      sub_801FAE0(a1, a2, v7 + 84, a3, v7);
  }
  else
  {
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 484);
  }
  return v6;
}

//----- (08024960) --------------------------------------------------------
int __fastcall sub_8024960(int a1, int a2)
{
  int v4; // r5
  unsigned int v5; // r0
  _DWORD *v6; // r0

  v4 = 1;
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 302);
  if ( a1 && (v5 = *(_DWORD *)(a1 + 60)) != 0 && 0xFFFFFFFF / v5 >= *(_DWORD *)(a1 + 64) )
  {
    sub_8023064();
    *(_DWORD *)(a1 + 8) = *(_DWORD *)a1 + *(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a1 + (*(_DWORD *)(a1 + 60) - 1) * *(_DWORD *)(a1 + 64);
    *(_BYTE *)(a1 + 68) = -1;
    *(_BYTE *)(a1 + 69) = -1;
    v6 = (_DWORD *)(a1 + 16);
    if ( a2 )
    {
      sub_8023000(v6);
      sub_8023000((_DWORD *)(a1 + 36));
    }
    else if ( *(_DWORD *)(a1 + 16) && sub_80256DC((int)v6) )
    {
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
    sub_80230E4();
  }
  else
  {
    v4 = 0;
  }
  if ( !v4 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 355);
  return v4;
}
// E000ED04: using guessed type int ICSR;

//----- (08024A40) --------------------------------------------------------
int __fastcall sub_8024A40(int a1, unsigned int a2, unsigned int a3, int a4)
{
  int v7; // r5
  int v8; // r5
  int v9; // r0
  _DWORD v11[4]; // [sp+0h] [bp-38h] BYREF
  unsigned int v12[10]; // [sp+10h] [bp-28h] BYREF

  v11[2] = a1;
  v11[3] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v7 = 0;
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 844);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 845);
  if ( a4 == 2 && *(_DWORD *)(a1 + 60) != 1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 846);
  if ( !sub_80253CC() && v12[0] )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 849);
  while ( 1 )
  {
    sub_8023064();
    if ( *(_DWORD *)(a1 + 56) < *(_DWORD *)(a1 + 60) || a4 == 2 )
    {
      v8 = *(_DWORD *)(a1 + 56);
      v9 = sub_801F9C0((unsigned int *)a1, a2, a4);
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( a4 == 2 && v8 || !sub_801FD14(a1) )
          goto LABEL_27;
        goto LABEL_26;
      }
      if ( *(_DWORD *)(a1 + 36) )
      {
        if ( sub_80256DC(a1 + 36) )
          goto LABEL_26;
      }
      else if ( v9 )
      {
LABEL_26:
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
LABEL_27:
      sub_80230E4();
      return 1;
    }
    if ( !v12[0] )
    {
      sub_80230E4();
      return 0;
    }
    if ( !v7 )
    {
      sub_80233A0(v11);
      v7 = 1;
    }
    sub_80230E4();
    sub_8023734();
    sub_8023064();
    if ( *(char *)(a1 + 68) == -1 )
      *(_BYTE *)(a1 + 68) = 0;
    if ( *(char *)(a1 + 69) == -1 )
      *(_BYTE *)(a1 + 69) = 0;
    sub_80230E4();
    if ( sub_8025104(v11, v12) )
      break;
    if ( sub_801FC9A(a1) )
    {
      sub_8023468((_DWORD *)(a1 + 16), v12[0]);
      sub_801FE60(a1);
      if ( !sub_80257E4() )
      {
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
    }
    else
    {
      sub_801FE60(a1);
      sub_80257E4();
    }
  }
  sub_801FE60(a1);
  sub_80257E4();
  return 0;
}
// E000ED04: using guessed type int ICSR;

//----- (08024BE4) --------------------------------------------------------
int __fastcall sub_8024BE4(int a1, unsigned int a2, _DWORD *a3, int a4)
{
  int result; // r0
  unsigned int v15; // r5
  int v16; // r9

  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1056);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1057);
  if ( a4 == 2 && *(_DWORD *)(a1 + 60) != 1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1058);
  sub_8023220();
  _R0 = 144;
  _R8 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  if ( *(_DWORD *)(a1 + 56) < *(_DWORD *)(a1 + 60) || a4 == 2 )
  {
    v15 = *(char *)(a1 + 69);
    v16 = *(_DWORD *)(a1 + 56);
    sub_801F9C0((unsigned int *)a1, a2, a4);
    if ( v15 == -1 )
    {
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( (a4 != 2 || !v16) && sub_801FD14(a1) && a3 )
          *a3 = 1;
      }
      else if ( *(_DWORD *)(a1 + 36) && sub_80256DC(a1 + 36) && a3 )
      {
        *a3 = 1;
      }
    }
    else if ( v15 < sub_8022F48() )
    {
      if ( v15 == 127 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1195);
      *(_BYTE *)(a1 + 69) = v15 + 1;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  __asm { MSR.W           BASEPRI, R8 }
  return result;
}

//----- (08024CF0) --------------------------------------------------------
int __fastcall sub_8024CF0(int a1, _DWORD *a2)
{
  unsigned int v10; // r0
  unsigned int v11; // r5
  int result; // r0

  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1225);
  if ( *(_DWORD *)(a1 + 64) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1229);
  if ( !*(_DWORD *)a1 && *(_DWORD *)(a1 + 8) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1234);
  sub_8023220();
  _R0 = 144;
  _R7 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  v10 = *(_DWORD *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 60) <= v10 )
  {
    result = 0;
  }
  else
  {
    v11 = *(char *)(a1 + 69);
    *(_DWORD *)(a1 + 56) = v10 + 1;
    if ( v11 == -1 )
    {
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( sub_801FD14(a1) && a2 )
          *a2 = 1;
      }
      else if ( *(_DWORD *)(a1 + 36) && sub_80256DC(a1 + 36) && a2 )
      {
        *a2 = 1;
      }
    }
    else if ( v11 < sub_8022F48() )
    {
      if ( v11 == 127 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1361);
      *(_BYTE *)(a1 + 69) = v11 + 1;
    }
    result = 1;
  }
  __asm { MSR.W           BASEPRI, R7 }
  return result;
}

//----- (08024DD8) --------------------------------------------------------
BOOL __fastcall sub_8024DD8(int a1)
{
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 2466);
  return *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 60);
}

//----- (08024E28) --------------------------------------------------------
int __fastcall sub_8024E28(int a1, unsigned int a2, int a3)
{
  int v5; // r6
  int v6; // r5
  _DWORD v8[4]; // [sp+4h] [bp-34h] BYREF
  int v9; // [sp+14h] [bp-24h] BYREF

  v8[2] = a1;
  v8[3] = a2;
  v9 = a3;
  v5 = 0;
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1387);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1391);
  if ( !sub_80253CC() && v9 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1396);
  while ( 1 )
  {
    sub_8023064();
    v6 = *(_DWORD *)(a1 + 56);
    if ( v6 )
      break;
    if ( !v9 )
    {
      sub_80230E4();
      return 0;
    }
    if ( !v5 )
    {
      sub_80233A0(v8);
      v5 = 1;
    }
    sub_80230E4();
    sub_8023734();
    sub_8023064();
    if ( *(char *)(a1 + 68) == -1 )
      *(_BYTE *)(a1 + 68) = 0;
    if ( *(char *)(a1 + 69) == -1 )
      *(_BYTE *)(a1 + 69) = 0;
    sub_80230E4();
    if ( sub_8025104(v8, (unsigned int *)&v9) )
    {
      sub_801FE60(a1);
      sub_80257E4();
      if ( sub_801FC80(a1) )
        return 0;
    }
    else if ( sub_801FC80(a1) )
    {
      sub_8023468((_DWORD *)(a1 + 36), v9);
      sub_801FE60(a1);
      if ( !sub_80257E4() )
      {
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
    }
    else
    {
      sub_801FE60(a1);
      sub_80257E4();
    }
  }
  sub_801F998((_DWORD *)a1, a2);
  *(_DWORD *)(a1 + 56) = v6 - 1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    if ( sub_80256DC(a1 + 16) )
    {
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_80230E4();
  return 1;
}
// E000ED04: using guessed type int ICSR;

//----- (08024F80) --------------------------------------------------------
int __fastcall sub_8024F80(int a1, int a2)
{
  int v3; // r5
  int v4; // r9
  int v5; // r0
  unsigned int v7; // r0
  _DWORD v8[3]; // [sp+4h] [bp-2Ch] BYREF
  int v9; // [sp+10h] [bp-20h] BYREF

  v8[2] = a1;
  v9 = a2;
  v3 = 0;
  v4 = 0;
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1533);
  if ( *(_DWORD *)(a1 + 64) )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1537);
  if ( !sub_80253CC() && v9 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1542);
  do
  {
    while ( 1 )
    {
      sub_8023064();
      v5 = *(_DWORD *)(a1 + 56);
      if ( v5 )
      {
        *(_DWORD *)(a1 + 56) = v5 - 1;
        if ( !*(_DWORD *)a1 )
          *(_DWORD *)(a1 + 8) = sub_8020008();
        if ( *(_DWORD *)(a1 + 16) )
        {
          if ( sub_80256DC(a1 + 16) )
          {
            ICSR = 0x10000000;
            __dsb(0xFu);
            __isb(0xFu);
          }
        }
        sub_80230E4();
        return 1;
      }
      if ( !v9 )
      {
        sub_80230E4();
        return 0;
      }
      if ( !v3 )
      {
        sub_80233A0(v8);
        v3 = 1;
      }
      sub_80230E4();
      sub_8023734();
      sub_8023064();
      if ( *(char *)(a1 + 68) == -1 )
        *(_BYTE *)(a1 + 68) = 0;
      if ( *(char *)(a1 + 69) == -1 )
        *(_BYTE *)(a1 + 69) = 0;
      sub_80230E4();
      if ( sub_8025104(v8, (unsigned int *)&v9) )
        break;
      if ( sub_801FC80(a1) )
      {
        if ( !*(_DWORD *)a1 )
        {
          sub_8023064();
          v4 = sub_8025628(*(_DWORD *)(a1 + 8));
          sub_80230E4();
        }
        sub_8023468((_DWORD *)(a1 + 36), v9);
        sub_801FE60(a1);
        if ( !sub_80257E4() )
        {
          ICSR = 0x10000000;
          __dsb(0xFu);
          __isb(0xFu);
        }
      }
      else
      {
        sub_801FE60(a1);
        sub_80257E4();
      }
    }
    sub_801FE60(a1);
    sub_80257E4();
  }
  while ( !sub_801FC80(a1) );
  if ( v4 )
  {
    sub_8023064();
    v7 = sub_801FA42(a1);
    sub_80234C8(*(_DWORD *)(a1 + 8), v7);
    sub_80230E4();
  }
  return 0;
}
// E000ED04: using guessed type int ICSR;

//----- (08025104) --------------------------------------------------------
int __fastcall sub_8025104(_DWORD *a1, unsigned int *a2)
{
  unsigned int v4; // r3
  unsigned int v5; // r0
  int v6; // r4
  unsigned int v7; // r1

  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3311);
  if ( !a2 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3312);
  sub_8023064();
  v4 = a1[1];
  v5 = dword_20001658 - v4;
  if ( *(_BYTE *)(dword_2000164C + 89) )
  {
    *(_BYTE *)(dword_2000164C + 89) = 0;
    v6 = 1;
  }
  else
  {
    v7 = *a2;
    if ( *a2 == -1 )
    {
      v6 = 0;
    }
    else if ( *a1 == dword_2000166C || v4 > dword_20001658 )
    {
      if ( v7 <= v5 )
      {
        *a2 = 0;
        v6 = 1;
      }
      else
      {
        *a2 = v7 - v5;
        sub_80233A0(a1);
        v6 = 0;
      }
    }
    else
    {
      v6 = 1;
      *a2 = 0;
    }
  }
  sub_80230E4();
  return v6;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001658: using guessed type int dword_20001658;
// 2000166C: using guessed type int dword_2000166C;

//----- (080251BC) --------------------------------------------------------
int __fastcall sub_80251BC(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6)
{
  int v10; // r5
  _BYTE *v11; // r0
  _DWORD *v12; // r4

  v10 = ((int (__fastcall *)(int))loc_801FF00)(4 * a3);
  if ( v10 )
  {
    v11 = (_BYTE *)((int (__fastcall *)(int))loc_801FF00)(92);
    v12 = v11;
    if ( v11 )
    {
      sub_8002364(v11, 92);
      v12[12] = v10;
    }
    else
    {
      ((void (__fastcall *)(int))loc_8023154)(v10);
    }
  }
  else
  {
    v12 = 0;
  }
  if ( !v12 )
    return -1;
  sub_801FB08(a1, a2, a3, a4, a5, a6, (int)v12);
  sub_801F8B0(v12);
  return 1;
}

//----- (08025224) --------------------------------------------------------
int __fastcall sub_8025224(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  int v10; // r8
  _DWORD *v17; // r0
  _BYTE *v18; // r1
  int v19; // r6
  int v20; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r1
  int v24; // r0
  int v25; // r0

  v10 = 1;
  if ( !a1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4984);
  if ( a2 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4985);
  sub_8023220();
  _R0 = 144;
  _R7 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  v17 = &a1[a2];
  if ( a5 )
    *a5 = v17[21];
  v18 = (char *)a1 + a2 + 88;
  v19 = (unsigned __int8)*v18;
  *v18 = 2;
  switch ( a4 )
  {
    case 0:
      break;
    case 1:
      v17[21] |= a3;
      break;
    case 2:
      ++v17[21];
      break;
    case 3:
      v17[21] = a3;
      break;
    case 4:
      if ( v19 == 2 )
        v10 = 0;
      else
        v17[21] = a3;
      break;
    default:
      if ( dword_20001658 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 5056);
      break;
  }
  if ( v19 == 1 )
  {
    if ( a1[10] )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 5067);
    if ( dword_20001680 )
    {
      v20 = dword_200118A4;
      a1[7] = dword_200118A4;
      a1[8] = *(_DWORD *)(v20 + 8);
      *(_DWORD *)(*(_DWORD *)(v20 + 8) + 4) = a1 + 6;
      *(_DWORD *)(v20 + 8) = a1 + 6;
      a1[10] = &dword_200118A0;
      ++dword_200118A0;
    }
    else
    {
      v22 = (_DWORD *)a1[5];
      *(_DWORD *)(a1[2] + 8) = a1[3];
      *(_DWORD *)(a1[3] + 4) = a1[2];
      v23 = a1 + 1;
      if ( (_DWORD *)v22[1] == a1 + 1 )
        v22[1] = a1[3];
      a1[5] = 0;
      --*v22;
      v24 = a1[11];
      dword_2000165C |= 1 << v24;
      v25 = dword_200115F8[5 * v24 + 1];
      a1[2] = v25;
      a1[3] = *(_DWORD *)(v25 + 8);
      *(_DWORD *)(*(_DWORD *)(v25 + 8) + 4) = v23;
      *(_DWORD *)(v25 + 8) = v23;
      a1[5] = &dword_200115F8[5 * a1[11]];
      ++dword_200115F8[5 * a1[11]];
    }
    if ( a1[11] > *(_DWORD *)(dword_2000164C + 44) )
    {
      if ( a6 )
        *a6 = 1;
      dword_20001668 = 1;
    }
  }
  __asm { MSR.W           BASEPRI, R7 }
  return v10;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001658: using guessed type int dword_20001658;
// 2000165C: using guessed type int dword_2000165C;
// 20001668: using guessed type int dword_20001668;
// 20001680: using guessed type int dword_20001680;
// 200115F8: using guessed type int dword_200115F8[160];
// 200118A0: using guessed type int dword_200118A0;
// 200118A4: using guessed type int dword_200118A4;

//----- (080253CC) --------------------------------------------------------
int sub_80253CC()
{
  if ( !dword_20001660 )
    return 1;
  if ( dword_20001680 )
    return 0;
  return 2;
}
// 20001660: using guessed type int dword_20001660;
// 20001680: using guessed type int dword_20001680;

//----- (080253E8) --------------------------------------------------------
int sub_80253E8()
{
  return dword_20001658;
}
// 20001658: using guessed type int dword_20001658;

//----- (080253F4) --------------------------------------------------------
int sub_80253F4()
{
  int v0; // r5
  unsigned int v2; // r4
  int v3; // r0
  _DWORD *v4; // r1
  _DWORD *v5; // r2
  _DWORD *v6; // r3
  _DWORD *v7; // r2
  int v8; // r0
  int v9; // r2
  int v10; // r0

  v0 = 0;
  if ( dword_20001680 )
  {
    ++dword_20001664;
  }
  else
  {
    v2 = dword_20001658 + 1;
    dword_20001658 = v2;
    if ( !v2 )
    {
      if ( *(_DWORD *)dword_20001684 )
        sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2743);
      v3 = dword_20001684;
      dword_20001684 = dword_20001688;
      dword_20001688 = v3;
      ++dword_2000166C;
      sub_801FDC0();
    }
    if ( v2 >= dword_20001674 )
    {
      while ( *(_DWORD *)dword_20001684 )
      {
        v4 = *(_DWORD **)(*(_DWORD *)(dword_20001684 + 12) + 12);
        if ( v2 < v4[1] )
        {
          dword_20001674 = v4[1];
          goto LABEL_13;
        }
        v5 = (_DWORD *)v4[5];
        *(_DWORD *)(v4[2] + 8) = v4[3];
        *(_DWORD *)(v4[3] + 4) = v4[2];
        v6 = v4 + 1;
        if ( (_DWORD *)v5[1] == v4 + 1 )
          v5[1] = v4[3];
        v4[5] = 0;
        --*v5;
        v7 = (_DWORD *)v4[10];
        if ( v7 )
        {
          *(_DWORD *)(v4[7] + 8) = v4[8];
          *(_DWORD *)(v4[8] + 4) = v4[7];
          if ( (_DWORD *)v7[1] == v4 + 6 )
            v7[1] = v4[8];
          v4[10] = 0;
          --*v7;
        }
        v8 = v4[11];
        dword_2000165C |= 1 << v8;
        v9 = dword_200115F8[5 * v8 + 1];
        v4[2] = v9;
        v4[3] = *(_DWORD *)(v9 + 8);
        *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = v6;
        *(_DWORD *)(v9 + 8) = v6;
        v10 = 5 * v4[11];
        v4[5] = &dword_200115F8[5 * v4[11]];
        ++dword_200115F8[v10];
        if ( v4[11] > *(_DWORD *)(dword_2000164C + 44) )
          v0 = 1;
      }
      dword_20001674 = -1;
    }
LABEL_13:
    if ( (unsigned int)dword_200115F8[5 * *(_DWORD *)(dword_2000164C + 44)] > 1 )
      v0 = 1;
    if ( dword_20001668 )
      return 1;
  }
  return v0;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001658: using guessed type int dword_20001658;
// 2000165C: using guessed type int dword_2000165C;
// 20001664: using guessed type int dword_20001664;
// 20001668: using guessed type int dword_20001668;
// 2000166C: using guessed type int dword_2000166C;
// 20001674: using guessed type int dword_20001674;
// 20001680: using guessed type int dword_20001680;
// 20001684: using guessed type int dword_20001684;
// 20001688: using guessed type int dword_20001688;
// 200115F8: using guessed type int dword_200115F8[160];

//----- (0802554C) --------------------------------------------------------
int __fastcall sub_802554C(int a1)
{
  int v2; // r6
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0

  v2 = 0;
  if ( a1 )
  {
    if ( a1 != dword_2000164C )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4168);
    if ( !*(_DWORD *)(a1 + 80) )
      sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4169);
    v3 = *(_DWORD *)(a1 + 80) - 1;
    *(_DWORD *)(a1 + 80) = v3;
    if ( *(_DWORD *)(a1 + 44) != *(_DWORD *)(a1 + 76) && !v3 )
    {
      if ( !sub_8022F20((_DWORD *)(a1 + 4)) )
        dword_2000165C &= ~(1 << *(_BYTE *)(a1 + 44));
      v4 = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a1 + 44) = v4;
      *(_DWORD *)(a1 + 24) = 32 - v4;
      v5 = *(_DWORD *)(a1 + 44);
      dword_2000165C |= 1 << v5;
      v6 = dword_200115F8[5 * v5 + 1];
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = a1 + 4;
      *(_DWORD *)(v6 + 8) = a1 + 4;
      *(_DWORD *)(a1 + 20) = &dword_200115F8[5 * *(_DWORD *)(a1 + 44)];
      ++dword_200115F8[5 * *(_DWORD *)(a1 + 44)];
      return 1;
    }
  }
  return v2;
}
// 2000164C: using guessed type int dword_2000164C;
// 2000165C: using guessed type int dword_2000165C;
// 200115F8: using guessed type int dword_200115F8[160];

//----- (08025628) --------------------------------------------------------
int __fastcall sub_8025628(int a1)
{
  int result; // r0
  int v3; // r0
  int v4; // r0

  result = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 44) >= *(_DWORD *)(dword_2000164C + 44) )
    {
      if ( *(_DWORD *)(a1 + 76) < *(_DWORD *)(dword_2000164C + 44) )
        return 1;
    }
    else
    {
      if ( *(int *)(a1 + 24) >= 0 )
        *(_DWORD *)(a1 + 24) = 32 - *(_DWORD *)(dword_2000164C + 44);
      if ( *(int **)(a1 + 20) == &dword_200115F8[5 * *(_DWORD *)(a1 + 44)] )
      {
        if ( !sub_8022F20((_DWORD *)(a1 + 4)) )
          dword_2000165C &= ~(1 << *(_BYTE *)(a1 + 44));
        v3 = *(_DWORD *)(dword_2000164C + 44);
        *(_DWORD *)(a1 + 44) = v3;
        dword_2000165C |= 1 << v3;
        v4 = dword_200115F8[5 * v3 + 1];
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4) = a1 + 4;
        *(_DWORD *)(v4 + 8) = a1 + 4;
        *(_DWORD *)(a1 + 20) = &dword_200115F8[5 * *(_DWORD *)(a1 + 44)];
        ++dword_200115F8[5 * *(_DWORD *)(a1 + 44)];
      }
      else
      {
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(dword_2000164C + 44);
      }
      return 1;
    }
  }
  return result;
}
// 80256D8: using guessed type int *off_80256D8;
// 2000164C: using guessed type int dword_2000164C;
// 2000165C: using guessed type int dword_2000165C;
// 200115F8: using guessed type int dword_200115F8[160];

//----- (080256DC) --------------------------------------------------------
int __fastcall sub_80256DC(int a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  _DWORD *v3; // r1
  int v4; // r0
  int result; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r1
  int v8; // r0
  int v9; // r0
  int v10; // r0

  v1 = *(_DWORD **)(*(_DWORD *)(a1 + 12) + 12);
  if ( !v1 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3188);
  v2 = (_DWORD *)v1[10];
  *(_DWORD *)(v1[7] + 8) = v1[8];
  *(_DWORD *)(v1[8] + 4) = v1[7];
  v3 = v1 + 6;
  if ( (_DWORD *)v2[1] == v1 + 6 )
    v2[1] = v1[8];
  v1[10] = 0;
  --*v2;
  if ( dword_20001680 )
  {
    v4 = dword_200118A4;
    v1[7] = dword_200118A4;
    v1[8] = *(_DWORD *)(v4 + 8);
    *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4) = v3;
    *(_DWORD *)(v4 + 8) = v3;
    v1[10] = &dword_200118A0;
    ++dword_200118A0;
  }
  else
  {
    v6 = (_DWORD *)v1[5];
    *(_DWORD *)(v1[2] + 8) = v1[3];
    *(_DWORD *)(v1[3] + 4) = v1[2];
    v7 = v1 + 1;
    if ( (_DWORD *)v6[1] == v1 + 1 )
      v6[1] = v1[3];
    v1[5] = 0;
    --*v6;
    v8 = v1[11];
    dword_2000165C |= 1 << v8;
    v9 = dword_200115F8[5 * v8 + 1];
    v1[2] = v9;
    v1[3] = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = v7;
    *(_DWORD *)(v9 + 8) = v7;
    v10 = 5 * v1[11];
    v1[5] = &dword_200115F8[5 * v1[11]];
    ++dword_200115F8[v10];
  }
  if ( v1[11] <= *(_DWORD *)(dword_2000164C + 44) )
    return 0;
  result = 1;
  dword_20001668 = 1;
  return result;
}
// 2000164C: using guessed type int dword_2000164C;
// 2000165C: using guessed type int dword_2000165C;
// 20001668: using guessed type int dword_20001668;
// 20001680: using guessed type int dword_20001680;
// 200115F8: using guessed type int dword_200115F8[160];
// 200118A0: using guessed type int dword_200118A0;
// 200118A4: using guessed type int dword_200118A4;

//----- (080257E4) --------------------------------------------------------
int sub_80257E4()
{
  _DWORD *v0; // r4
  int v1; // r8
  _DWORD *v2; // r1
  _DWORD *v3; // r1
  _DWORD *v4; // r0
  int v5; // r1
  int v6; // r1
  int v7; // r0
  int v8; // r4

  v0 = 0;
  v1 = 0;
  if ( !dword_20001680 )
    sub_801E1B0((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2181);
  sub_8023064();
  if ( !--dword_20001680 && dword_20001654 )
  {
    while ( dword_200118A0 )
    {
      v0 = *(_DWORD **)(dword_200118AC + 12);
      v2 = (_DWORD *)v0[10];
      *(_DWORD *)(v0[7] + 8) = v0[8];
      *(_DWORD *)(v0[8] + 4) = v0[7];
      if ( (_DWORD *)v2[1] == v0 + 6 )
        v2[1] = v0[8];
      v0[10] = 0;
      --*v2;
      v3 = (_DWORD *)v0[5];
      *(_DWORD *)(v0[2] + 8) = v0[3];
      *(_DWORD *)(v0[3] + 4) = v0[2];
      v4 = v0 + 1;
      if ( (_DWORD *)v3[1] == v0 + 1 )
        v3[1] = v0[3];
      v0[5] = 0;
      --*v3;
      v5 = v0[11];
      dword_2000165C |= 1 << v5;
      v6 = dword_200115F8[5 * v5 + 1];
      v0[2] = v6;
      v0[3] = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = v4;
      *(_DWORD *)(v6 + 8) = v4;
      v7 = 5 * v0[11];
      v0[5] = &dword_200115F8[5 * v0[11]];
      ++dword_200115F8[v7];
      if ( v0[11] >= *(_DWORD *)(dword_2000164C + 44) )
        dword_20001668 = 1;
    }
    if ( v0 )
      sub_801FDC0();
    v8 = dword_20001664;
    if ( dword_20001664 )
    {
      do
      {
        if ( sub_80253F4() )
          dword_20001668 = 1;
        --v8;
      }
      while ( v8 );
      dword_20001664 = 0;
    }
    if ( dword_20001668 )
    {
      v1 = 1;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_80230E4();
  return v1;
}
// 2000164C: using guessed type int dword_2000164C;
// 20001654: using guessed type int dword_20001654;
// 2000165C: using guessed type int dword_2000165C;
// 20001664: using guessed type int dword_20001664;
// 20001668: using guessed type int dword_20001668;
// 20001680: using guessed type int dword_20001680;
// 200115F8: using guessed type int dword_200115F8[160];
// 200118A0: using guessed type int dword_200118A0;
// 200118AC: using guessed type int dword_200118AC;
// E000ED04: using guessed type int ICSR;

//----- (08025EBC) --------------------------------------------------------
void sub_8025EBC()
{
  JUMPOUT(0x8025DC6);
}
// 8025EC0: control flows out of bounds to 8025DC6
// 8025DC4: using guessed type int dword_8025DC4;

//----- (08025EDE) --------------------------------------------------------
void sub_8025EDE()
{
  JUMPOUT(0x8025DE8);
}
// 8025EE2: control flows out of bounds to 8025DE8

//----- (08025F44) --------------------------------------------------------
void sub_8025F44()
{
  int v0; // r4

  *(_DWORD *)(v0 + 20) = v0;
  JUMPOUT(0x80256DA);
}
// 8025ED6: control flows out of bounds to 80256DA
// 8025F4A: variable 'v0' is possibly undefined
// 80256D8: using guessed type int *off_80256D8;

//----- (08025F56) --------------------------------------------------------
int sub_8025F56()
{
  return sub_80257E4();
}

//----- (08029518) --------------------------------------------------------
void sub_8029518()
{
  JUMPOUT(0x8012A7E);
}
// 8029520: control flows out of bounds to 8012A7E

//----- (08029522) --------------------------------------------------------
void sub_8029522()
{
  JUMPOUT(0x8011EA0);
}
// 802952A: control flows out of bounds to 8011EA0

//----- (0802952C) --------------------------------------------------------
void sub_802952C()
{
  JUMPOUT(0x8012A60);
}
// 8029534: control flows out of bounds to 8012A60

//----- (08029536) --------------------------------------------------------
void sub_8029536()
{
  JUMPOUT(0x80185FC);
}
// 802953E: control flows out of bounds to 80185FC

//----- (08029540) --------------------------------------------------------
int __fastcall sub_8029540(char a1, char a2, char a3)
{
  int v4; // r4
  char v5; // r5
  int v6; // r6
  int v7; // r7

  *(_BYTE *)(v6 + 25) = a3;
  *(_BYTE *)(v4 + 9) = v5;
  *(_BYTE *)(v4 + 16) = a1;
  *(_BYTE *)(v7 + 1) = a2;
  return IRQ_86_handler();
}
// 8006130: variable 'v6' is possibly undefined
// 8006132: variable 'v5' is possibly undefined
// 8006132: variable 'v4' is possibly undefined
// 8006136: variable 'v7' is possibly undefined
// 8006138: using guessed type int IRQ_86_handler(void);

//----- (0802954A) --------------------------------------------------------
void sub_802954A()
{
  JUMPOUT(0x8002FBC);
}
// 8029552: control flows out of bounds to 8002FBC

//----- (0802955E) --------------------------------------------------------
void sub_802955E()
{
  JUMPOUT(0x8002B32);
}
// 8029566: control flows out of bounds to 8002B32

//----- (08029568) --------------------------------------------------------
void sub_8029568()
{
  JUMPOUT(0x80047A0);
}
// 8029570: control flows out of bounds to 80047A0

//----- (08029572) --------------------------------------------------------
void sub_8029572()
{
  JUMPOUT(0x801EAE8);
}
// 802957A: control flows out of bounds to 801EAE8

//----- (0802957C) --------------------------------------------------------
void sub_802957C()
{
  JUMPOUT(0x8002FE4);
}
// 8029584: control flows out of bounds to 8002FE4

//----- (08029586) --------------------------------------------------------
void sub_8029586()
{
  JUMPOUT(0x8003F20);
}
// 802958E: control flows out of bounds to 8003F20

//----- (08029590) --------------------------------------------------------
void sub_8029590()
{
  JUMPOUT(0x8016F44);
}
// 8029598: control flows out of bounds to 8016F44
// 8016F44: using guessed type __int16 word_8016F44;

//----- (0802959A) --------------------------------------------------------
void sub_802959A()
{
  JUMPOUT(0x80170BC);
}
// 80295A2: control flows out of bounds to 80170BC

//----- (080295A4) --------------------------------------------------------
void sub_80295A4()
{
  JUMPOUT(0x80170EC);
}
// 80295AC: control flows out of bounds to 80170EC

//----- (080295AE) --------------------------------------------------------
void sub_80295AE()
{
  JUMPOUT(0x8016F94);
}
// 80295B6: control flows out of bounds to 8016F94

//----- (080295B8) --------------------------------------------------------
void sub_80295B8()
{
  JUMPOUT(0x80170D8);
}
// 80295C0: control flows out of bounds to 80170D8

//----- (080295C2) --------------------------------------------------------
void sub_80295C2()
{
  JUMPOUT(0x8016A70);
}
// 80295CA: control flows out of bounds to 8016A70

//----- (080295CC) --------------------------------------------------------
void sub_80295CC()
{
  JUMPOUT(0x801703C);
}
// 80295D4: control flows out of bounds to 801703C

//----- (080295D6) --------------------------------------------------------
void sub_80295D6()
{
  JUMPOUT(0x8016A98);
}
// 80295DE: control flows out of bounds to 8016A98

//----- (080295E0) --------------------------------------------------------
void sub_80295E0()
{
  JUMPOUT(0x801706C);
}
// 80295E8: control flows out of bounds to 801706C

//----- (080295EA) --------------------------------------------------------
void sub_80295EA()
{
  JUMPOUT(0x8017094);
}
// 80295F2: control flows out of bounds to 8017094

//----- (080295F4) --------------------------------------------------------
void sub_80295F4()
{
  JUMPOUT(0x801700C);
}
// 80295FC: control flows out of bounds to 801700C

//----- (080295FE) --------------------------------------------------------
void sub_80295FE()
{
  JUMPOUT(0x8016FE4);
}
// 8029606: control flows out of bounds to 8016FE4

//----- (08029608) --------------------------------------------------------
void sub_8029608()
{
  JUMPOUT(0x8016A60);
}
// 8029610: control flows out of bounds to 8016A60

//----- (08029612) --------------------------------------------------------
void sub_8029612()
{
  JUMPOUT(0x8016A54);
}
// 802961A: control flows out of bounds to 8016A54

//----- (0802961C) --------------------------------------------------------
void sub_802961C()
{
  JUMPOUT(0x8016F14);
}
// 8029624: control flows out of bounds to 8016F14
// 8016F14: using guessed type __int16 word_8016F14;

//----- (08029626) --------------------------------------------------------
void sub_8029626()
{
  JUMPOUT(0x8017054);
}
// 802962E: control flows out of bounds to 8017054

//----- (08029630) --------------------------------------------------------
void sub_8029630()
{
  JUMPOUT(0x8012A6E);
}
// 8029638: control flows out of bounds to 8012A6E

//----- (0802963A) --------------------------------------------------------
void sub_802963A()
{
  JUMPOUT(0x80041A8);
}
// 8029642: control flows out of bounds to 80041A8

//----- (08029644) --------------------------------------------------------
void sub_8029644()
{
  JUMPOUT(0x800FDD0);
}
// 802964C: control flows out of bounds to 800FDD0

//----- (0802964E) --------------------------------------------------------
void sub_802964E()
{
  JUMPOUT(0x8010814);
}
// 8029656: control flows out of bounds to 8010814

//----- (08029658) --------------------------------------------------------
void sub_8029658()
{
  JUMPOUT(0x800609C);
}
// 8029660: control flows out of bounds to 800609C

//----- (08029662) --------------------------------------------------------
void sub_8029662()
{
  JUMPOUT(0x801F488);
}
// 802966A: control flows out of bounds to 801F488

//----- (08029676) --------------------------------------------------------
void sub_8029676()
{
  JUMPOUT(0x8011838);
}
// 802967E: control flows out of bounds to 8011838

//----- (08029680) --------------------------------------------------------
void sub_8029680()
{
  JUMPOUT(0x80117F0);
}
// 8029688: control flows out of bounds to 80117F0

//----- (080296B4) --------------------------------------------------------
int sub_80296B4()
{
  int v1; // [sp+0h] [bp-8h]

  return v1 & 0x7FFFFFFF;
}
// 80296BA: variable 'v1' is possibly undefined

//----- (08029754) --------------------------------------------------------
void sub_8029754()
{
  int v0; // r0
  int v1; // r0

  sub_802952C();
  if ( v0 == 1 )
  {
    sub_8029518();
    dword_20000400 = 0;
  }
  else
  {
    ++dword_20000400;
  }
  if ( (unsigned int)dword_20000400 > 0x14 && dword_20001C04 < 1133248512 )
    sub_8029518();
  sub_802952C();
  if ( v1 == 1 )
  {
    if ( dword_20001C04 < 1132593152 )
      sub_8029518();
    dword_20000404 = 0;
  }
  else if ( (unsigned int)++dword_20000404 > 0xEA60 && dword_20001C04 > 1133248512 )
  {
    sub_8029518();
  }
}
// 8029770: variable 'v0' is possibly undefined
// 80297A4: variable 'v1' is possibly undefined
// 20000400: using guessed type int dword_20000400;
// 20000404: using guessed type int dword_20000404;
// 20001C04: using guessed type int dword_20001C04;

//----- (0802980C) --------------------------------------------------------
void __fastcall sub_802980C(int a1, char a2, unsigned int a3)
{
  char v3; // r1
  char v4; // r2
  char v5; // r0
  char v6; // r1
  char v7; // r2
  char v8; // r1
  char v9; // r0
  char v10; // r1
  char v11; // r2
  char v12; // [sp+0h] [bp-30h]

  if ( byte_2000050E )
  {
    a2 = dword_20002D60;
    a3 = (unsigned int)dword_20002D60 >> 2;
    if ( (unsigned int)dword_20002D60 >> 2 )
    {
      if ( !byte_200002B6 )
      {
        sub_8029536();
        BYTE2(dword_200028B4) |= 0x20u;
        byte_200002B6 = 1;
      }
    }
    else if ( byte_200002B6 == 1 )
    {
      sub_8029536();
      BYTE2(dword_200028B4) &= ~0x20u;
      byte_200002B6 = 0;
    }
    if ( byte_20000478 )
    {
      if ( !byte_200002B5 )
      {
        sub_8029536();
        byte_200002B5 = 1;
      }
      BYTE2(dword_200028B4) &= ~0x10u;
    }
    else if ( byte_200002B5 )
    {
      sub_8029536();
      BYTE2(dword_200028B4) |= 0x10u;
      byte_200002B5 = 0;
    }
  }
  else
  {
    byte_200002B6 = 0;
    byte_200002B5 = 1;
  }
  if ( byte_200002B4 )
  {
    if ( *(float *)&dword_20001C08 < flt_20002438 )
    {
      v12 = sub_8029540(byte_200002B4, a2, a3);
      sub_8029540(v12, v3, v4);
      sub_8029536();
      dword_200003FC = 0;
      byte_200002B4 = 0;
    }
    if ( byte_20002E38 != 14 )
    {
      if ( SLODWORD(flt_20002434) < 1036831949 )
      {
        sub_8029540(SLOBYTE(flt_20002434), a2, a3);
        sub_8029536();
        byte_200002B4 = 0;
        dword_200003FC = 0;
      }
      a2 = word_20002428;
      if ( word_20002428 < (int)(unsigned __int8)byte_20000512 )
      {
        sub_8029536();
        byte_200002B4 = 0;
        dword_200003FC = 0;
      }
    }
  }
  else if ( *(float *)&dword_20001C08 <= (float)(flt_20002438 + 1.0)
         || SLODWORD(flt_20002434) <= 1036831949
         || (a2 = byte_20000512, word_20002428 < (int)(unsigned __int8)byte_20000512) )
  {
    if ( (unsigned int)dword_2000002C > 5 )
      dword_200003FC = 0;
  }
  else
  {
    ++dword_200003FC;
    a2 = 16;
    if ( dword_200003FC > 10000 || byte_20002E38 == 13 )
    {
      sub_8029536();
      byte_200002B4 = 1;
    }
  }
  if ( byte_2000050E )
  {
    if ( byte_20002E38 == 14 )
    {
      if ( *(float *)&dword_20001C08 >= (float)(flt_20002438 + 1.0) )
      {
        if ( *(float *)&dword_20001C08 > (float)(flt_20002438 + 2.0) )
          byte_200002B7 = 0;
      }
      else
      {
        byte_200002B7 = 1;
      }
    }
    else if ( byte_200002B6 )
    {
      byte_200002B7 = 0;
    }
    else if ( byte_200002B7 )
    {
      a2 = word_20002428;
      if ( word_20002428 > (unsigned __int8)byte_20000512 - 2 )
        byte_200002B7 = 0;
    }
    else if ( word_20002428 < 6 )
    {
      byte_200002B7 = 1;
    }
  }
  else
  {
    byte_200002B7 = 0;
  }
  if ( byte_200002B3 )
  {
    if ( *(float *)&dword_20001C08 > (float)(flt_20002430 + 1.5) )
    {
      v5 = sub_8029540(byte_200002B3, a2, a3);
      sub_8029540(v5, v6, v7);
      sub_8029536();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    v8 = 0;
    if ( dword_20001BE8 > 1140899840 )
    {
      v9 = sub_8029540(dword_20001BE8, 0, a3);
      sub_8029540(v9, v10, v11);
      sub_8029536();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    if ( SLODWORD(flt_2000242C) < 1036831949 )
    {
      sub_8029540(SLOBYTE(flt_2000242C), v8, a3);
      sub_8029536();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    if ( word_20002428 > 99 || word_20002428 >= (int)(unsigned __int8)byte_20000511 )
    {
      sub_8029536();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
  }
  else if ( *(float *)&dword_20001C08 >= flt_20002430
         || SLODWORD(flt_2000242C) <= 1036831949
         || SLODWORD(flt_20002430) <= 1110704128
         || word_20002428 >= (int)(unsigned __int8)byte_20000511 )
  {
    if ( (unsigned int)dword_2000002C > 5 )
      dword_200003F8 = 0;
  }
  else if ( ++dword_200003F8 > 10000 || byte_20002E38 == 13 )
  {
    sub_8029536();
    byte_200002B3 = 1;
  }
}
// 80298D8: variable 'a2' is possibly undefined
// 80298D8: variable 'a3' is possibly undefined
// 80298E2: variable 'v3' is possibly undefined
// 80298E2: variable 'v4' is possibly undefined
// 80299E6: variable 'v6' is possibly undefined
// 80299E6: variable 'v7' is possibly undefined
// 8029A12: variable 'v10' is possibly undefined
// 8029A12: variable 'v11' is possibly undefined
// 8029A3A: variable 'v8' is possibly undefined
// 2000002C: using guessed type int dword_2000002C;
// 200002B3: using guessed type char byte_200002B3;
// 200002B4: using guessed type char byte_200002B4;
// 200002B5: using guessed type char byte_200002B5;
// 200002B6: using guessed type char byte_200002B6;
// 200002B7: using guessed type char byte_200002B7;
// 200003F8: using guessed type int dword_200003F8;
// 200003FC: using guessed type int dword_200003FC;
// 20000478: using guessed type char byte_20000478;
// 2000050E: using guessed type char byte_2000050E;
// 20000511: using guessed type char byte_20000511;
// 20000512: using guessed type char byte_20000512;
// 20001BE8: using guessed type int dword_20001BE8;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001C08: using guessed type int dword_20001C08;
// 20002428: using guessed type __int16 word_20002428;
// 2000242C: using guessed type float flt_2000242C;
// 20002430: using guessed type float flt_20002430;
// 20002434: using guessed type float flt_20002434;
// 20002438: using guessed type float flt_20002438;
// 200028B4: using guessed type int dword_200028B4;
// 20002D60: using guessed type int dword_20002D60;
// 20002E38: using guessed type char byte_20002E38;

//----- (08029B7C) --------------------------------------------------------
int sub_8029B7C()
{
  float v0; // s0
  int result; // r0

  if ( SLODWORD(v0) > 1065353216 )
    v0 = v0 - 2.0;
  dword_20000418 = (int)(float)(v0 * 2147500000.0);
  *(_DWORD *)(dword_200028C4 + 4) = dword_20000418;
  dword_20000424 = *(_DWORD *)(dword_200028C4 + 8);
  result = *(_DWORD *)(dword_200028C4 + 8);
  dword_20000428 = result;
  return result;
}
// 8029B84: variable 'v0' is possibly undefined
// 20000418: using guessed type int dword_20000418;
// 20000424: using guessed type int dword_20000424;
// 20000428: using guessed type int dword_20000428;
// 200028C4: using guessed type int dword_200028C4;

//----- (08029BC4) --------------------------------------------------------
int sub_8029BC4()
{
  float v0; // s0
  float v1; // s1
  int result; // r0

  if ( v0 < 0.0 )
    v0 = -v0;
  v1 = -0.032366;
  if ( SLODWORD(v0) <= 1065353216 )
  {
    for ( result = 1; result < 10; ++result )
      v1 = *(float *)(4 * (9 - result) + 0x10007704) + (float)(v0 * v1);
  }
  else
  {
    for ( result = 1; result < 10; ++result )
      v1 = *(float *)(4 * (9 - result) + 0x10007704) + (float)((float)(1.0 / v0) * v1);
  }
  return result;
}
// 8029BD2: variable 'v0' is possibly undefined

//----- (08029C64) --------------------------------------------------------
float *__fastcall sub_8029C64(float *result, float *a2)
{
  float v2; // s3
  float v3; // s2
  float v4; // s1
  float v5; // s0

  v2 = *result;
  v3 = result[2];
  v4 = result[3];
  v5 = (float)((float)((float)((float)(a2[4] * *result) + (float)(a2[3] * result[1])) + (float)(a2[2] * v3))
             + (float)(a2[1] * v4))
     + (float)(*a2 * result[4]);
  result[5] = v5;
  result[1] = v2;
  *result = v5;
  result[4] = v4;
  result[3] = v3;
  return result;
}

//----- (08029CB6) --------------------------------------------------------
float *__fastcall sub_8029CB6(float *result)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  float v4; // s3
  float v5; // s2
  float v6; // s3
  float v7; // s0

  v5 = (float)((float)(v3 * 2.0) * v2) * v1;
  v6 = (float)((float)(v4 * 2.0) * v2) * v1;
  v7 = (float)((float)(v2 * v1) * v2) * v1;
  result[4] = 2.0 - v6;
  result[3] = -1.0 - (float)(v7 - v6);
  result[2] = 1.0;
  result[1] = v5 - 2.0;
  *result = (float)(v7 - v5) + 1.0;
  return result;
}
// 8029CBA: variable 'v3' is possibly undefined
// 8029CBE: variable 'v2' is possibly undefined
// 8029CC2: variable 'v1' is possibly undefined
// 8029CC6: variable 'v4' is possibly undefined

//----- (08029D14) --------------------------------------------------------
_DWORD *__fastcall sub_8029D14(_DWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (08029D38) --------------------------------------------------------
float *__fastcall sub_8029D38(float *result)
{
  float v1; // s1
  float v2; // s0
  float v3; // s0

  v1 = (float)(*result - result[1]) * result[4];
  result[8] = v1;
  v2 = result[11];
  if ( result[3] == result[10] )
    v2 = v2 + (float)(result[5] * v1);
  result[9] = v2;
  result[11] = v2;
  v3 = v1 + v2;
  result[10] = v3;
  if ( v3 > result[6] )
    v3 = result[6];
  result[2] = v3;
  if ( v3 < result[7] )
    v3 = result[7];
  result[3] = v3;
  return result;
}

//----- (08029DAC) --------------------------------------------------------
_DWORD *__fastcall sub_8029DAC(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[3] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = 0;
  result[11] = 0;
  return result;
}

//----- (08029DD4) --------------------------------------------------------
float *__fastcall sub_8029DD4(float *result, float *a2)
{
  float v2; // s0
  float v3; // s3
  float v4; // s2
  float v5; // s1
  float v6; // s0

  a2[5] = v2;
  v3 = *a2;
  v4 = a2[2];
  v5 = (float)((float)((float)((float)(result[3] * a2[1]) + (float)(result[4] * *a2)) + (float)(*result * a2[3]))
             + (float)(result[1] * v4))
     + (float)(result[2] * v2);
  a2[4] = v5;
  a2[3] = v4;
  a2[2] = v2;
  a2[6] = v5;
  if ( v5 >= result[6] )
    v5 = result[6];
  a2[6] = v5;
  if ( v5 <= result[7] )
    v5 = result[7];
  a2[6] = v5;
  a2[1] = v3;
  *a2 = v5;
  v6 = (float)(v5 + (float)(v2 * result[5])) + v5;
  a2[6] = v6;
  if ( v6 <= result[7] )
    v6 = result[7];
  a2[6] = v6;
  if ( v6 >= result[6] )
    v6 = result[6];
  a2[6] = v6;
  return result;
}
// 8029DD4: variable 'v2' is possibly undefined

//----- (08029E98) --------------------------------------------------------
int __fastcall sub_8029E98(int result)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  float v4; // s3
  float v5; // s4
  float v6; // s1

  v4 = (float)(v3 * 6.2832) * (float)(v3 * 6.2832);
  v5 = 1.0 / (float)((float)((float)((float)(v1 * v1) * v4) + (float)(6.0 * v1)) + 4.0);
  v6 = (float)((float)((float)(v2 * 4.0) * 1.5) * v1) * v5;
  *(float *)(result + 8) = v6;
  *(_DWORD *)(result + 4) = 0;
  *(float *)result = -v6;
  *(float *)(result + 16) = (float)(8.0 - (float)((float)((float)(v1 * v1) * 2.0) * v4)) * v5;
  *(float *)(result + 12) = (float)((float)((float)((float)(v1 * 4.0) * 1.5) + -4.0) - (float)((float)(v1 * v1) * v4))
                          * v5;
  return result;
}
// 8029EA0: variable 'v3' is possibly undefined
// 8029EA4: variable 'v1' is possibly undefined
// 8029EC8: variable 'v2' is possibly undefined

//----- (08029F28) --------------------------------------------------------
_DWORD *__fastcall sub_8029F28(_DWORD *result)
{
  result[5] = 0;
  result[2] = 0;
  result[3] = 0;
  result[6] = 0;
  *result = 1084856730;
  result[1] = 1085066445;
  result[4] = 0;
  return result;
}

//----- (08029F60) --------------------------------------------------------
int __fastcall sub_8029F60(int result)
{
  *(_DWORD *)(result + 20) = -1138501878;
  *(_DWORD *)(result + 8) = -1138501878;
  *(_DWORD *)(result + 12) = 1025758986;
  *(_DWORD *)(result + 24) = 0;
  *(float *)result = 6.25;
  *(_DWORD *)(result + 4) = 1086681252;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (0802A044) --------------------------------------------------------
char *sub_802A044()
{
  float v0; // s0
  char *result; // r0
  float v2; // s2
  float v3; // s0
  float v4; // s0
  float v5; // [sp+0h] [bp-8h]
  float v6; // [sp+0h] [bp-8h]

  result = &byte_200002A4;
  if ( SLODWORD(v0) <= 1065336439 && LODWORD(v0) <= 0xBF7FBE77 )
  {
    v2 = v0 * v0;
    if ( SLODWORD(v0) <= 1061830001 )
    {
      if ( LODWORD(v0) > 0xBF4A3D71 )
      {
        v4 = (float)(1.0 / v2) - 1.0;
        if ( v4 < 0.0 )
          v6 = 0.0;
        else
          v6 = sqrtf(v4);
        flt_20000304 = (float)-v6 * *(float *)&dword_20000300;
      }
    }
    else
    {
      v3 = (float)(1.0 / v2) - 1.0;
      if ( v3 < 0.0 )
        v5 = 0.0;
      else
        v5 = sqrtf(v3);
      flt_20000304 = v5 * *(float *)&dword_20000300;
    }
  }
  else
  {
    flt_20000304 = 0.0;
  }
  return result;
}
// 802A054: variable 'v0' is possibly undefined
// 200002A4: using guessed type char byte_200002A4;
// 20000300: using guessed type int dword_20000300;
// 20000304: using guessed type float flt_20000304;

//----- (0802A11C) --------------------------------------------------------
int sub_802A11C()
{
  float v0; // s0
  int result; // r0

  flt_200027D0 = v0;
  sub_8029E98((int)&unk_200027BC);
  result = 0;
  dword_20000350 = 0;
  return result;
}
// 802A120: variable 'v0' is possibly undefined
// 20000350: using guessed type int dword_20000350;
// 200027D0: using guessed type float flt_200027D0;

//----- (0802A148) --------------------------------------------------------
unsigned int __fastcall sub_802A148(unsigned int result)
{
  float v1; // s0

  if ( result == 10 )
  {
    if ( (unsigned int)(LODWORD(v1) - 1169301505) < 0x47DFFF )
    {
      flt_200025B4 = v1;
      dword_200025B0 = 30;
      sub_802954A();
    }
LABEL_15:
    JUMPOUT(0x801E9B0);
  }
  if ( result < 0xA )
  {
    switch ( result )
    {
      case 1u:
        dword_200025B0 = 1;
        goto LABEL_15;
      case 2u:
        flt_200025B4 = v1;
        dword_200025B0 = 23;
        sub_802954A();
        goto LABEL_15;
      case 3u:
        flt_200025B4 = v1;
        dword_200025B0 = 25;
        sub_802954A();
        goto LABEL_15;
      case 4u:
        dword_200025B0 = 4;
        goto LABEL_15;
      case 6u:
        dword_200025B0 = 6;
        goto LABEL_15;
      case 8u:
        flt_200025B4 = v1;
        dword_200025B0 = 3;
        sub_802954A();
        goto LABEL_15;
      case 9u:
        flt_200025B4 = v1;
        dword_200025B0 = 24;
        goto LABEL_15;
      default:
        return result;
    }
  }
  return result;
}
// 802955C: control flows out of bounds to 801E9B0
// 802A16C: conditional instruction was optimized away because r0.4<Au
// 802A16E: conditional instruction was optimized away because r0.4<Au
// 802A172: conditional instruction was optimized away because r0.4<Au
// 802A176: conditional instruction was optimized away because r0.4<Au
// 802A17A: conditional instruction was optimized away because r0.4<Au
// 802A1D4: variable 'v1' is possibly undefined
// 200025B0: using guessed type int dword_200025B0;
// 200025B4: using guessed type float flt_200025B4;

//----- (0802A8A4) --------------------------------------------------------
_DWORD *__fastcall sub_802A8A4(_DWORD *result)
{
  float v1; // s0

  *result = 0;
  result[1] = (int)(float)(1000.0 / (float)(v1 + 15.0));
  result[2] = 0;
  result[3] = (int)(float)(1000.0 / (float)(v1 - 5.0));
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[16] = 0;
  result[17] = 0;
  result[15] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[18] = 0;
  return result;
}
// 802A8B0: variable 'v1' is possibly undefined

//----- (0802A914) --------------------------------------------------------
int sub_802A914()
{
  int v0; // r7
  int v1; // r0
  char v2; // r2
  char v3; // r1
  float v4; // r0
  char v5; // r1
  char v6; // r2
  char v7; // r0
  char v8; // r1
  char v9; // r2
  float v10; // r0
  char v11; // r1
  char v12; // r2
  char v13; // r0
  char v14; // r1
  char v15; // r2
  float *v16; // r2
  float v17; // s0
  int v18; // s0
  float v19; // s0
  float v20; // s0
  float v21; // s0
  int v22; // r0
  float v23; // s0
  float v24; // s0
  int v25; // s0
  float v26; // s0
  float v27; // s0
  float v28; // s0
  int v29; // r0
  float v30; // s0
  int v31; // s0
  unsigned int v32; // r1
  unsigned int v33; // r1
  unsigned int v34; // r1
  unsigned int v35; // r1
  unsigned int v36; // r1
  unsigned int v37; // r0
  char v38; // r0
  char v39; // r1
  char v40; // r2
  char v41; // r0
  char v42; // r1
  char v43; // r2
  char v44; // r1
  char v45; // r2
  int v46; // r0
  int result; // r0
  char v48; // r1
  char v49; // r2
  int v50; // r0
  char v51; // [sp+0h] [bp-40h]
  char v52; // [sp+0h] [bp-40h]

  v0 = 0;
  sub_8029586();
  v1 = (unsigned __int8)byte_200002C7++;
  dword_2000254C[v1] = dword_20001BFC;
  if ( (unsigned __int8)byte_200002C7 >= 0x19u )
    byte_200002C7 = 0;
  LODWORD(flt_20002890) = dword_20001BE8;
  sub_8029C64(flt_20002888, flt_200028A0);
  dword_20001C04 = LODWORD(flt_2000289C);
  sub_8030510(flt_200025C8);
  sub_803069C((int)&unk_20002654, (unsigned __int8)byte_200002C5);
  if ( (unsigned int)dword_200003AC >= 0xBA83126F )
  {
    v2 = dword_20002624;
    if ( (unsigned int)dword_20002624 < 0xBA83126F )
      v0 = 1;
  }
  v3 = byte_200002AA;
  if ( byte_200002AA )
  {
    if ( (v3 = 10, (unsigned int)dword_200003AC >= 0xBC23D70A)
      && (v2 = dword_20002624, (unsigned int)dword_20002624 < 0xBC23D70A)
      || dword_200003AC >= 1008981770 && dword_20002624 < 1008981770 )
    {
      sub_8029518();
      byte_200002AA = 0;
    }
  }
  dword_200003AC = dword_20002624;
  if ( byte_200002AB && byte_200002BD == 1 && dword_200027B4 )
  {
    if ( flt_20002610 <= flt_200027A8 )
    {
      if ( COERCE_INT(flt_200027A8 - flt_20002610) >= 1008981770 )
      {
        flt_200027A8 = flt_200027A8 - 0.001;
      }
      else
      {
        v10 = flt_200027A8 - flt_20002610;
        v52 = sub_8029540(SLOBYTE(v10), v3, v2);
        v13 = sub_8029540(v52, v11, v12);
        sub_8029540(v13, v14, v15);
        sub_8029536();
        flt_200027A8 = flt_20002610;
        byte_200002BE = 1;
        byte_200002BD = 0;
      }
    }
    else
    {
      v4 = flt_20002610 - flt_200027A8;
      if ( COERCE_INT(flt_20002610 - flt_200027A8) >= 1008981770 )
      {
        flt_200027A8 = flt_200027A8 + 0.005;
      }
      else
      {
        flt_200027A8 = flt_20002610;
        v51 = sub_8029540(SLOBYTE(v4), v3, v2);
        v7 = sub_8029540(v51, v5, v6);
        sub_8029540(v7, v8, v9);
        sub_8029536();
        byte_200002BE = 1;
        byte_200002BD = 0;
      }
    }
  }
  sub_80302B0((int)&unk_200027A0);
  sub_802F408((int)&unk_20002778, v0);
  if ( !byte_200002A4 )
  {
    if ( byte_200002B2 )
    {
      if ( byte_200002A6 == 4 )
      {
        byte_200002A6 = 0;
        byte_200002A4 = 26;
        if ( flt_200027A8 <= 0.0 )
          flt_200027A8 = 0.0;
        else
          flt_200027A8 = -0.99999;
        flt_200027AC = 0.0;
        sub_8029590();
        sub_802959A();
      }
      else if ( byte_200002A6 == 33 && byte_200026CC == 1 )
      {
        byte_200002A6 = 0;
        byte_200002A4 = 33;
        byte_200002C5 = 0;
        sub_8029590();
        sub_802959A();
      }
      if ( byte_200002A6 == 3 && byte_200002AB && v0 == 1 )
      {
        sub_8029590();
        sub_80295A4();
        byte_200002A6 = 0;
        byte_200002A4 = 3;
        sub_8029DAC(dword_20002828);
        sub_8029F60((int)flt_200027DC);
      }
    }
    if ( byte_200002B1 )
    {
      if ( byte_200002A6 == 5 && byte_200002AB && v0 == 1 )
      {
        sub_8029590();
        sub_802959A();
        byte_200002A6 = 0;
        byte_200002A4 = 5;
        sub_8029F28(flt_200027DC);
      }
      if ( byte_200002A6 == 9 && byte_200002AB && v0 == 1 )
      {
        sub_8029590();
        sub_802959A();
        byte_200002A6 = 0;
        byte_200002A4 = 9;
        sub_8029F60((int)flt_200027DC);
      }
    }
    if ( byte_200002A6 == 23 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 23;
      sub_8029590();
      sub_802959A();
    }
    else if ( byte_200002A6 == 24 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 24;
      sub_8029590();
      sub_802959A();
    }
    else if ( dword_200027B4 && byte_200002A6 == 25 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 25;
      sub_8029590();
      sub_802959A();
    }
    else if ( dword_200027B4 && byte_200002A6 == 26 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 26;
      sub_8029590();
      sub_802959A();
    }
  }
  if ( byte_200002A6 == 2 )
  {
    byte_200002A4 = 0;
    byte_200002A6 = 0;
    dword_200025B0 = 0;
    sub_80295A4();
    goto LABEL_151;
  }
  v16 = &flt_20002858;
  if ( byte_200002A4 == 23 )
    goto LABEL_77;
  if ( (unsigned __int8)byte_200002A4 > 0x17u )
  {
    if ( byte_200002A4 != 24 )
    {
      if ( byte_200002A4 == 25 )
      {
        v30 = *(float *)&dword_20001BE4;
        sub_80296B4();
        if ( v30 >= flt_20000360 )
        {
          v31 = dword_20001BE4;
          sub_80296B4();
          LODWORD(flt_20000360) = v31;
        }
        if ( dword_200027B4 )
        {
          flt_20000364 = 21.8 - (float)(130.37 / (float)(flt_20000360 + 6.0));
          flt_20000360 = 0.0;
        }
        flt_20000368 = flt_200027AC * (float)(flt_200025B4 + flt_20000364);
        sub_8029590();
        goto LABEL_151;
      }
      if ( byte_200002A4 != 26 )
      {
        if ( byte_200002A4 == 33 )
        {
          flt_20002858 = flt_200026D0 - *(float *)&dword_20000340;
          LODWORD(flt_2000285C) = dword_20001BEC;
          flt_20002884 = flt_20002884 + (float)(*(float *)&dword_20001C1C * 0.02);
          sub_8029D38(&flt_20002858);
          flt_20000368 = (float)(flt_20002864 - *(float *)&dword_20001BE4) * 5.0;
          flt_2000036C = *(float *)&dword_20001BEC + flt_20000368;
          sub_80295AE();
        }
        goto LABEL_151;
      }
LABEL_76:
      flt_20002858 = (float)(flt_200027AC * 326.0) - *(float *)&dword_20000340;
      LODWORD(flt_2000285C) = dword_20001BEC;
      sub_8029D38(&flt_20002858);
      flt_20000368 = (float)(flt_20002864 - *(float *)&dword_20001BE4) * 10.0;
      flt_2000036C = *(float *)&dword_20001BEC + flt_20000368;
      sub_80295AE();
      goto LABEL_151;
    }
LABEL_77:
    sub_8029590();
    goto LABEL_151;
  }
  if ( byte_200002A4 == 3 )
  {
    if ( dword_2000030C < 1045220557 )
      flt_20002454 = 0.0;
    if ( v0 == 1 )
    {
      flt_200002D4 = 0.0;
      v17 = flt_20002454;
      flt_200002D0 = flt_20002454 + flt_200002D0;
      sub_80296B4();
      flt_200002D8 = v17;
      if ( SLODWORD(v17) >= 1017370378 )
      {
        if ( SLODWORD(v17) >= 1041865114 )
        {
          if ( SLODWORD(v17) >= 1051931443 )
          {
            if ( SLODWORD(v17) >= 1060320051 )
            {
              flt_200002D4 = flt_20002454;
              flt_200002D0 = flt_200002D0 - flt_20002454;
            }
            else
            {
              v21 = flt_200002D0;
              sub_80296B4();
              if ( v21 > (float)(flt_200002D8 * 2.0) )
              {
                flt_200002D4 = flt_200002D0;
                flt_200002D0 = flt_200002D4 - flt_200002D4;
              }
            }
          }
          else
          {
            v20 = flt_200002D0;
            sub_80296B4();
            if ( v20 > (float)(flt_200002D8 * 3.0) )
            {
              flt_200002D4 = flt_200002D0;
              flt_200002D0 = flt_200002D4 - flt_200002D4;
            }
          }
        }
        else
        {
          v19 = flt_200002D0;
          sub_80296B4();
          if ( v19 > (float)(flt_200002D8 * 4.0) )
          {
            flt_200002D4 = flt_200002D0;
            flt_200002D0 = flt_200002D4 - flt_200002D4;
          }
        }
      }
      else
      {
        v18 = LODWORD(flt_200002D0);
        sub_80296B4();
        if ( v18 > 1034147594 )
        {
          flt_200002D4 = flt_200002D0;
          flt_200002D0 = flt_200002D4 - flt_200002D4;
        }
      }
      if ( flt_200002D4 == 0.0 )
        sub_80295A4();
      else
        sub_802959A();
    }
    sub_80295B8();
    if ( v22 )
      sub_8029DD4(flt_200027BC, flt_200027DC);
    goto LABEL_105;
  }
  if ( byte_200002A4 == 4 )
    goto LABEL_76;
  v16 = &flt_200027F8;
  if ( byte_200002A4 == 5 )
  {
    v23 = *(float *)&dword_20001BE8 - flt_200002F8;
    flt_2000035C = *(float *)&dword_20001BE8 - flt_200002F8;
    if ( COERCE_INT(*(float *)&dword_20001BE8 - flt_200002F8) <= 1103626240 )
    {
      if ( LODWORD(v23) > 0xC1C80000 )
      {
        flt_2000035C = (float)(v23 + 25.0) * 0.3;
        flt_20002824 = flt_20002824 - flt_2000035C;
        flt_20002804 = flt_20002804 - flt_2000035C;
        ++dword_20000350;
      }
    }
    else
    {
      flt_2000035C = (float)(v23 - 25.0) * 0.3;
      flt_20002824 = flt_20002824 - flt_2000035C;
      flt_20002804 = flt_20002804 - flt_2000035C;
    }
    if ( flt_20002824 < flt_20002814 )
      flt_20002824 = flt_20002814;
    if ( flt_20002804 < flt_20002814 )
      flt_20002804 = flt_20002814;
    if ( flt_20002824 > flt_20002810 )
      flt_20002824 = flt_20002810;
    if ( flt_20002804 > flt_20002810 )
      flt_20002804 = flt_20002810;
    flt_20000358 = (float)(flt_20002804 * -1.4142) / *(float *)&dword_2000278C;
    sub_8029DD4(flt_200027BC, flt_200027DC);
    flt_20000354 = (float)(flt_200027F4 + *(float *)&dword_20001BE0) / *(float *)&dword_20001BE8;
    sub_8029590();
  }
  else if ( byte_200002A4 == 9 )
  {
    flt_2000035C = *(float *)&dword_20001BE8 - 510.0;
    if ( (float)(*(float *)&dword_20001BE8 - 510.0) > 0.0 )
    {
      flt_20002454 = flt_20002454 + (float)((float)(*(float *)&dword_20001BE8 - 510.0) * 0.01);
      if ( flt_20002454 > 0.0 )
      {
        flt_20002824 = 0.0;
        flt_20002454 = 0.0;
      }
    }
    if ( dword_2000030C < 1045220557 )
      flt_20002454 = 0.0;
    if ( v0 == 1 )
    {
      flt_200002D4 = 0.0;
      v24 = flt_20002454;
      flt_200002D0 = flt_20002454 + flt_200002D0;
      sub_80296B4();
      flt_200002D8 = v24;
      if ( SLODWORD(v24) >= 1017370378 )
      {
        if ( SLODWORD(v24) >= 1041865114 )
        {
          if ( SLODWORD(v24) >= 1051931443 )
          {
            if ( SLODWORD(v24) >= 1060320051 )
            {
              flt_200002D4 = flt_20002454;
              flt_200002D0 = flt_200002D0 - flt_20002454;
            }
            else
            {
              v28 = flt_200002D0;
              sub_80296B4();
              if ( v28 > (float)(flt_200002D8 * 2.0) )
              {
                flt_200002D4 = flt_200002D0;
                flt_200002D0 = flt_200002D4 - flt_200002D4;
              }
            }
          }
          else
          {
            v27 = flt_200002D0;
            sub_80296B4();
            if ( v27 > (float)(flt_200002D8 * 3.0) )
            {
              flt_200002D4 = flt_200002D0;
              flt_200002D0 = flt_200002D4 - flt_200002D4;
            }
          }
        }
        else
        {
          v26 = flt_200002D0;
          sub_80296B4();
          if ( v26 > (float)(flt_200002D8 * 4.0) )
          {
            flt_200002D4 = flt_200002D0;
            flt_200002D0 = flt_200002D4 - flt_200002D4;
          }
        }
      }
      else
      {
        v25 = LODWORD(flt_200002D0);
        sub_80296B4();
        if ( v25 > 1034147594 )
        {
          flt_200002D4 = flt_200002D0;
          flt_200002D0 = flt_200002D4 - flt_200002D4;
        }
      }
      if ( flt_200002D4 == 0.0 )
        sub_80295A4();
      else
        sub_802959A();
    }
    sub_80295B8();
    if ( v29 )
      sub_8029DD4(flt_200027BC, flt_200027DC);
LABEL_105:
    flt_20000354 = (float)(flt_200027F4 + *(float *)&dword_20001BEC) / *(float *)&dword_20001BE8;
    sub_8029590();
  }
LABEL_151:
  if ( byte_200002A7 == 17 )
  {
    byte_200002A7 = 0;
    byte_200002A5 = 17;
    sub_80295FE();
  }
  else if ( (unsigned __int8)byte_200002A7 > 0x11u )
  {
    if ( byte_200002A7 == 21 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 21;
      dword_20000040 = 6550;
      sub_80295D6();
      sub_80295EA();
    }
    else if ( (unsigned __int8)byte_200002A7 > 0x15u )
    {
      if ( byte_200002A7 == 30 )
      {
        byte_200002A7 = 0;
        byte_200002A5 = 30;
        dword_20000040 = (unsigned int)flt_200025B4;
        sub_80295C2();
        if ( byte_200002C3 == 1 )
          sub_80295CC();
      }
      else if ( byte_200002A7 == 31 )
      {
        byte_200002A7 = 0;
        byte_200002A5 = 31;
        dword_20000040 = (unsigned int)flt_200025B4;
        sub_80295D6();
        if ( byte_200002C3 == 1 )
          sub_80295E0();
      }
    }
    else if ( byte_200002A7 == 19 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 19;
      dword_20000040 = 6550;
      sub_80295D6();
      sub_80295E0();
    }
    else if ( byte_200002A7 == 20 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 20;
      dword_20000040 = 6550;
      sub_80295D6();
      sub_80295E0();
    }
  }
  else if ( byte_200002A7 == 14 )
  {
    byte_200002A7 = 0;
    byte_200002A5 = 14;
    dword_20000040 = 6550;
    sub_80295D6();
    sub_80295EA();
  }
  else if ( (unsigned __int8)byte_200002A7 > 0xEu )
  {
    if ( byte_200002A7 == 15 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 15;
      dword_20000040 = 6550;
      sub_80295D6();
      sub_80295EA();
    }
    else if ( byte_200002A7 == 16 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 16;
      sub_80295C2();
      sub_80295CC();
    }
  }
  else if ( byte_200002A7 && byte_200002A7 == 13 )
  {
    dword_20000044 = 450;
    byte_200002A7 = 0;
    byte_200002A5 = 13;
    dword_20000040 = 6550;
    sub_80295F4();
  }
  if ( byte_2000003D == 1 && !byte_2000003C )
  {
    if ( *(float *)&dword_20001BE8 <= (float)(*(float *)&dword_20001C08 * 8.6) )
    {
      if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001C08 * 8.0) )
        sub_8029612();
    }
    else if ( byte_200002A5 != 15 )
    {
      sub_8029608();
    }
  }
  if ( byte_200002A7 == 2 )
  {
    byte_200002A5 = 0;
    byte_200002A7 = 0;
    dword_200025B0 = 0;
    sub_802961C();
  }
  else
  {
    switch ( byte_200002A5 )
    {
      case 21:
        LOBYTE(v16) = 0;
        if ( byte_2000003D == 1 )
        {
          if ( byte_2000003C )
          {
            if ( byte_2000003C == 3 )
            {
              if ( SLODWORD(flt_200002DC) <= 1084227584 )
              {
                if ( LODWORD(flt_200002DC) >= 0xC0400000 )
                {
                  dword_20000370 = 0;
                }
                else
                {
                  v34 = dword_20000370;
                  LOBYTE(v16) = ++dword_20000370;
                  if ( v34 > 0x1388 )
                  {
                    dword_20000370 = 0;
                    sub_80295EA();
                  }
                }
              }
              else
              {
                v33 = dword_20000370;
                LOBYTE(v16) = ++dword_20000370;
                if ( v33 > 0x1388 )
                {
                  dword_20000370 = 0;
                  flt_200002DC = 0.0;
                  sub_802961C();
                  sub_80295C2();
                }
              }
            }
          }
          else if ( *(float *)&dword_20001BE8 <= (float)(*(float *)&dword_20001C08 * 9.0) )
          {
            if ( LODWORD(flt_200002DC) <= 0xC0A00000 )
            {
              dword_20000370 = 0;
            }
            else
            {
              v32 = dword_20000370;
              LOBYTE(v16) = ++dword_20000370;
              if ( v32 > 0x1388 )
              {
                dword_20000370 = 0;
                sub_80295E0();
              }
            }
          }
          else
          {
            flt_200002DC = 0.0;
            sub_802961C();
            sub_80295C2();
          }
        }
        else if ( byte_2000003C == 1 )
        {
          if ( byte_2000003D )
          {
            if ( byte_2000003D == 3 )
            {
              if ( LODWORD(flt_200002DC) <= 0xC0A00000 )
              {
                if ( SLODWORD(flt_200002DC) >= 1077936128 )
                {
                  dword_20000370 = 0;
                }
                else
                {
                  v37 = dword_20000370++;
                  if ( v37 > 0xFA0 )
                  {
                    dword_20000370 = 0;
                    sub_8029626();
                  }
                }
              }
              else
              {
                v36 = dword_20000370;
                LOBYTE(v16) = ++dword_20000370;
                if ( v36 > 0x1388 )
                {
                  dword_20000370 = 0;
                  flt_200002DC = 0.0;
                  sub_802961C();
                  sub_80295D6();
                }
              }
            }
          }
          else if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_20001C08 * 8.0) )
          {
            if ( SLODWORD(flt_200002DC) <= 1084227584 )
            {
              dword_20000370 = 0;
            }
            else
            {
              v35 = dword_20000370;
              LOBYTE(v16) = ++dword_20000370;
              if ( v35 > 0x1388 )
              {
                dword_20000370 = 0;
                sub_80295CC();
              }
            }
          }
          else
          {
            flt_200002DC = 0.0;
            sub_802961C();
            sub_80295D6();
          }
        }
        break;
      case 30:
        dword_20000040 = (unsigned int)flt_200025B4;
        break;
      case 31:
        dword_20000040 = (unsigned int)flt_200025B4;
        break;
    }
  }
  if ( byte_200002A4 )
  {
    if ( dword_20001BE4 <= 1106247680 && (unsigned int)dword_20001BE4 <= 0xC1F00000 )
    {
      if ( dword_20001BE8 <= 1141145600 )
      {
        sub_802952C();
        if ( !v46 )
        {
          byte_200002A6 = 2;
          byte_200002AE = 1;
          byte_200002AF = 1;
          sub_802FF18(0, v44, v45);
        }
      }
      else
      {
        byte_200002A6 = 2;
        byte_200002AE = 1;
        byte_200002AF = 1;
        sub_8029540(dword_20001BE8, 0, (char)v16);
        sub_8029536();
        LOBYTE(dword_200028B8) = dword_200028B8 | 0x40;
      }
    }
    else
    {
      byte_200002A6 = 2;
      byte_200002AE = 1;
      byte_200002AF = 1;
      v38 = sub_8029540(dword_20001BE4, 0, (char)v16);
      v41 = sub_8029540(v38, v39, v40);
      sub_8029540(v41, v42, v43);
      sub_8029536();
      LOBYTE(dword_200028B8) = dword_200028B8 | 0x20;
    }
  }
  result = (unsigned __int8)byte_200002A5;
  if ( byte_200002A5 )
  {
    sub_802952C();
    if ( v50 )
    {
      result = dword_20001BE8;
      if ( dword_20001BE8 > 1141145600 )
      {
        LOBYTE(result) = byte_200002A5;
        if ( byte_200002A5 != 15 || (result = dword_20001BE8, v48 = 0, dword_20001BE8 > 1141800960) )
        {
          byte_200002A7 = 2;
          byte_200002AE = 1;
          byte_200002B0 = 1;
          sub_8029540(result, v48, v49);
          sub_8029536();
          result = (unsigned __int8)dword_200028B8 | 0x40;
          LOBYTE(dword_200028B8) = dword_200028B8 | 0x40;
        }
      }
    }
    else
    {
      byte_200002A7 = 2;
      byte_200002AE = 1;
      byte_200002B0 = 1;
      word_2000051A = 1;
      return sub_802FF18((int)&word_2000051A, v48, v49);
    }
  }
  return result;
}
// 802AA38: variable 'v3' is possibly undefined
// 802AA38: variable 'v2' is possibly undefined
// 802AA42: variable 'v5' is possibly undefined
// 802AA42: variable 'v6' is possibly undefined
// 802AA4C: variable 'v8' is possibly undefined
// 802AA4C: variable 'v9' is possibly undefined
// 802AA8C: variable 'v11' is possibly undefined
// 802AA8C: variable 'v12' is possibly undefined
// 802AA96: variable 'v14' is possibly undefined
// 802AA96: variable 'v15' is possibly undefined
// 802AF24: variable 'v22' is possibly undefined
// 802B242: variable 'v29' is possibly undefined
// 802B6C0: variable 'v16' is possibly undefined
// 802B6CA: variable 'v39' is possibly undefined
// 802B6CA: variable 'v40' is possibly undefined
// 802B6D4: variable 'v42' is possibly undefined
// 802B6D4: variable 'v43' is possibly undefined
// 802B728: variable 'v46' is possibly undefined
// 802B734: variable 'v44' is possibly undefined
// 802B734: variable 'v45' is possibly undefined
// 802B748: variable 'v50' is possibly undefined
// 802B778: variable 'v48' is possibly undefined
// 802B778: variable 'v49' is possibly undefined
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 200002A4: using guessed type char byte_200002A4;
// 200002A5: using guessed type char byte_200002A5;
// 200002A6: using guessed type char byte_200002A6;
// 200002A7: using guessed type char byte_200002A7;
// 200002AA: using guessed type char byte_200002AA;
// 200002AB: using guessed type char byte_200002AB;
// 200002AE: using guessed type char byte_200002AE;
// 200002AF: using guessed type char byte_200002AF;
// 200002B0: using guessed type char byte_200002B0;
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200002BD: using guessed type char byte_200002BD;
// 200002BE: using guessed type char byte_200002BE;
// 200002C3: using guessed type char byte_200002C3;
// 200002C5: using guessed type char byte_200002C5;
// 200002C7: using guessed type char byte_200002C7;
// 200002D0: using guessed type float flt_200002D0;
// 200002D4: using guessed type float flt_200002D4;
// 200002D8: using guessed type float flt_200002D8;
// 200002DC: using guessed type float flt_200002DC;
// 200002F8: using guessed type float flt_200002F8;
// 2000030C: using guessed type int dword_2000030C;
// 20000340: using guessed type int dword_20000340;
// 20000350: using guessed type int dword_20000350;
// 20000354: using guessed type float flt_20000354;
// 20000358: using guessed type float flt_20000358;
// 2000035C: using guessed type float flt_2000035C;
// 20000360: using guessed type float flt_20000360;
// 20000364: using guessed type float flt_20000364;
// 20000368: using guessed type float flt_20000368;
// 2000036C: using guessed type float flt_2000036C;
// 20000370: using guessed type int dword_20000370;
// 200003AC: using guessed type int dword_200003AC;
// 2000051A: using guessed type __int16 word_2000051A;
// 20001BE0: using guessed type int dword_20001BE0;
// 20001BE4: using guessed type int dword_20001BE4;
// 20001BE8: using guessed type int dword_20001BE8;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C04: using guessed type int dword_20001C04;
// 20001C08: using guessed type int dword_20001C08;
// 20001C14: using guessed type int dword_20001C14;
// 20001C1C: using guessed type int dword_20001C1C;
// 20002454: using guessed type float flt_20002454;
// 2000254C: using guessed type _DWORD dword_2000254C[25];
// 200025B0: using guessed type int dword_200025B0;
// 200025B4: using guessed type float flt_200025B4;
// 200025C8: using guessed type float flt_200025C8[15];
// 20002610: using guessed type float flt_20002610;
// 20002624: using guessed type int dword_20002624;
// 200026CC: using guessed type char byte_200026CC;
// 200026D0: using guessed type float flt_200026D0;
// 2000278C: using guessed type int dword_2000278C;
// 200027A8: using guessed type float flt_200027A8;
// 200027AC: using guessed type float flt_200027AC;
// 200027B4: using guessed type int dword_200027B4;
// 200027BC: using guessed type float flt_200027BC[5];
// 200027DC: using guessed type float flt_200027DC[6];
// 200027F4: using guessed type float flt_200027F4;
// 200027F8: using guessed type float flt_200027F8;
// 20002804: using guessed type float flt_20002804;
// 20002810: using guessed type float flt_20002810;
// 20002814: using guessed type float flt_20002814;
// 20002824: using guessed type float flt_20002824;
// 20002828: using guessed type _DWORD dword_20002828[4];
// 20002858: using guessed type float flt_20002858;
// 2000285C: using guessed type float flt_2000285C;
// 20002864: using guessed type float flt_20002864;
// 20002884: using guessed type float flt_20002884;
// 20002888: using guessed type float flt_20002888[2];
// 20002890: using guessed type float flt_20002890;
// 2000289C: using guessed type float flt_2000289C;
// 200028A0: using guessed type float flt_200028A0[5];
// 200028B8: using guessed type int dword_200028B8;

//----- (0802B7D4) --------------------------------------------------------
void sub_802B7D4()
{
  int v0; // r0
  float v1; // s23
  int v2; // r0
  int v3; // r1
  char v4; // r2
  int v5; // r0
  int v6; // r1
  char v7; // r2
  int v8; // r0
  char v9; // r1
  unsigned int v10; // r2
  float v11; // s0
  char v12; // r2
  float v13; // s21
  char v14; // r11
  bool v15; // cf
  bool v16; // zf
  unsigned int v17; // r0
  unsigned int v18; // r0
  bool v19; // cf
  float v20; // s19
  float v21; // s0
  float v22; // s19
  float v23; // s0
  float v24; // s19
  char v25; // r0
  char v26; // r1
  char v27; // r2
  float v28; // s19
  int v29; // r0
  char v30; // r0
  char v31; // r1
  char v32; // r2
  int v33; // r0
  float v34; // s19
  int v35; // s0
  float v36; // s19
  char v37; // r0
  char v38; // r1
  char v39; // r2
  int v40; // r0
  int v41; // r0
  char v42; // r0
  char v43; // r1
  char v44; // r2
  int v45; // r0
  float v46; // s19
  float v47; // s0
  float v48; // s19
  int v49; // r0
  float v50; // s0
  float v51; // s1
  float v52; // s2
  char v53; // r1
  char v54; // r2
  char v55; // r1
  char v56; // r2
  float v57; // s0
  float v58; // s0
  float v59; // s0
  float v60; // s0
  float v61; // s0
  float v62; // s1
  float v63; // s0
  float v64; // s0
  float v65; // s1
  float v66; // s3
  float v67; // s2
  float v68; // s1
  float v69; // s0
  float v70; // s2
  float v71; // s1
  float v72; // s0
  float v73; // s0
  char v74; // [sp+4h] [bp-54h]
  char v75; // [sp+8h] [bp-50h]

  v0 = dword_20000384++;
  if ( v0 > 1000 )
  {
    dword_20000384 = 0;
    sub_8029630();
  }
  v1 = *(float *)&dword_20001C18 + 0.0;
  sub_802963A();
  sub_8029644();
  flt_200002F4 = 0.0;
  ((void (__fastcall *)(void *))loc_802A6B4)(&unk_2000272C);
  sub_802F544();
  sub_802FFA8(v2, v3, v4);
  v8 = sub_8030108(v5, v6, v7);
  sub_802980C(v8, v9, v10);
  v11 = *(float *)&dword_20001BE0;
  sub_80296B4();
  *(float *)&dword_20000320 = (float)(v11 * 0.05) + (float)(*(float *)&dword_20000320 * 0.95);
  ++dword_20000374;
  if ( byte_200002C8 != byte_200002A8 )
    dword_20000374 = 0;
  byte_200002C8 = byte_200002A8;
  v13 = 8.3;
  v14 = 2;
  if ( byte_200002A8 == 101 )
  {
    if ( dword_200025B0 != 1 )
    {
      if ( byte_200002B4 )
      {
        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * 8.3) )
        {
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
            v28 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          else
            v28 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v28) < 1138819072 )
            v28 = 450.0;
          dword_20000044 = (unsigned int)v28;
          if ( dword_20000374 > 3000 )
          {
            sub_8029536();
            byte_200002A8 = 1;
          }
        }
        else
        {
          sub_8029536();
          byte_200002A8 = 102;
          byte_200002A7 = 21;
        }
      }
      else
      {
LABEL_913:
        sub_8029536();
        byte_200002A8 = 1;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_915;
    }
    goto LABEL_907;
  }
  if ( (unsigned __int8)byte_200002A8 > 0x65u )
  {
    if ( (unsigned __int8)byte_200002A8 == 217 )
    {
      if ( dword_200025B0 != 1 )
      {
        if ( byte_200002B3 && byte_200002B1 && byte_200002AE != 1 )
        {
          if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
          {
            sub_8029536();
            byte_200002A8 = -56;
            byte_200002A6 = 2;
          }
        }
        else
        {
          sub_8029536();
          byte_200002A8 = -56;
          dword_200002E0 = 60000;
          byte_200002A6 = 2;
        }
        if ( dword_20000374 >= 100 )
        {
          if ( dword_20001C08 < 1113325568 && dword_20001C0C < 1092616192 )
            flt_200002F8 = flt_200002F8 + 0.001;
          *(float *)&dword_20000300 = -flt_20002804;
          if ( SLODWORD(flt_200002F8) > 1139474432 )
            flt_200002F8 = 470.0;
          if ( dword_20001BE8 <= 1139146752 )
          {
            if ( byte_200002B4 && !byte_200002B7 )
            {
              byte_200002C0 = 1;
              sub_8029536();
              byte_200002A8 = -56;
            }
          }
          else
          {
            v37 = sub_8029540(dword_20001BE8, 0, v12);
            sub_8029540(v37, v38, v39);
            sub_8029536();
            sub_8029536();
            byte_200002A8 = -56;
            dword_200002E0 = 60000;
          }
        }
        goto LABEL_915;
      }
      goto LABEL_907;
    }
    if ( (unsigned __int8)byte_200002A8 > 0xD9u )
    {
      v17 = (unsigned __int8)byte_200002A8 - 218;
      v15 = v17 >= 0x11;
      switch ( byte_200002A8 )
      {
        case -38:
          goto LABEL_915;
        case -37:
          byte_200002A6 = 23;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -36:
          byte_200002A6 = 25;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -35:
          byte_200002A6 = 26;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -34:
          byte_200002A6 = 24;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -33:
          byte_200002A7 = 30;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -32:
          byte_200002A7 = 31;
          byte_200002A8 = 2;
          goto LABEL_915;
        case -31:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( dword_200002E0 <= 0 )
          {
            sub_802964E();
            byte_200002AE = 0;
            sub_8030078();
            if ( byte_200002A9 )
            {
              if ( byte_200002A9 == 2 )
              {
                sub_802952C();
                if ( v45 == 1 )
                {
                  sub_8029518();
                  byte_200002A9 = 0;
                }
              }
            }
            else
            {
              sub_802952C();
              if ( v41 )
              {
                if ( byte_200002AB )
                {
                  sub_8029590();
                  if ( dword_20001BE8 <= 1131413504 )
                    byte_200002A8 = -29;
                  else
                    byte_200002A8 = -30;
                }
                else
                {
                  sub_8029536();
                  byte_200002A8 = -25;
                }
              }
              else
              {
                byte_200002A9 = 2;
                sub_8029518();
                sub_8029540(v42, v43, v44);
                sub_8029536();
              }
            }
          }
          else
          {
            if ( dword_200002E0 > 2000 )
              sub_8029518();
            --dword_200002E0;
          }
          goto LABEL_915;
        case -30:
          if ( dword_20000374 == 1 )
            sub_8029518();
          if ( dword_20001BE8 > 1131413504 )
            byte_200002A8 = -29;
          if ( dword_20000374 > 3000 )
          {
            sub_8029536();
            BYTE1(dword_200028B8) |= 8u;
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
          }
          goto LABEL_915;
        case -29:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029518();
            sub_8029518();
          }
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( !byte_200002AB || byte_200002AE == 1 || byte_2000050C == 1 || byte_20002EAB == 1 )
          {
            sub_8029536();
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          else
          {
            if ( dword_20000374 == 60 )
              sub_8029518();
            if ( dword_20000374 == 80 )
              sub_8029518();
            if ( dword_20000374 == 120 )
            {
              sub_8030078();
              dword_20000300 = -1007026176;
              sub_8029DAC(&flt_200027F8);
              flt_20002870 = 19.5;
              flt_20002874 = -19.5;
              flt_20002804 = 200.0;
              if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_2000278C * 1.5) )
                flt_200002F8 = *(float *)&dword_20001BE8 + 10.0;
              else
                flt_200002F8 = *(float *)&dword_2000278C * 1.5;
              sub_8029536();
              byte_200002A6 = 5;
            }
            if ( dword_20000374 >= 160 )
            {
              if ( SLODWORD(flt_200002F8) >= 1137836032 )
              {
                if ( SLODWORD(flt_200002F8) > 1137836032 )
                  flt_200002F8 = flt_200002F8 - 0.05;
              }
              else
              {
                flt_200002F8 = flt_200002F8 + 0.05;
              }
              if ( (unsigned int)(LODWORD(flt_200002F8) - 1137737728) <= 0x30000 && byte_200002B2 )
              {
                if ( *(float *)&dword_20001BE8 > (float)(*(float *)&dword_20001BF0 * 8.2) )
                {
                  byte_200002A8 = -28;
                }
                else
                {
                  sub_8029536();
                  byte_200002A8 = -27;
                  byte_200002A7 = 20;
                  flt_200002F8 = 420.0;
                }
              }
              else if ( dword_20000374 > 10000 )
              {
                sub_8029536();
                BYTE1(dword_200028B8) |= 8u;
                dword_200002E0 = 60000;
                byte_200002A8 = -25;
              }
            }
          }
          goto LABEL_915;
        case -28:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( byte_200002B2 && byte_200002AB && byte_200002AE != 1 )
          {
            if ( dword_20000374 == 1 )
            {
              flt_2000037C = 0.0;
              sub_8029536();
              byte_200002A7 = 17;
              dword_20000380 = 0;
            }
            flt_2000037C = flt_2000037C + 0.0005;
            if ( SLODWORD(flt_2000037C) > 1065185444 )
              flt_2000037C = 1.0;
            v46 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
            if ( SLODWORD(v46) < 1138819072 )
              v46 = 450.0;
            dword_20000044 = (unsigned int)v46;
            if ( *(float *)&dword_20001BE8 <= (float)(*(float *)&dword_20001BF0 * 8.2) )
            {
              sub_8029536();
              byte_200002A8 = -27;
              byte_200002A7 = 20;
              flt_200002F8 = 420.0;
              goto LABEL_915;
            }
            if ( (float)(*(float *)&dword_20001BF0 * 8.5) > *(float *)&dword_20001BE8 )
              sub_8029608();
          }
          else
          {
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 > 5000 )
          {
            sub_8029536();
            byte_200002A8 = -25;
          }
          break;
        case -27:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( !byte_200002B2 || !byte_200002AB || byte_200002AE == 1 )
          {
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 > 200 )
            byte_200002A5 = 22;
          goto LABEL_915;
        case -26:
          goto LABEL_914;
        case -25:
          byte_200002AA = 0;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          byte_200002A8 = -31;
          dword_200002E0 = 60000;
          sub_8029518();
          sub_8029518();
          sub_8030078();
          goto LABEL_915;
        case -24:
          if ( !byte_200002B4 )
            goto LABEL_163;
          if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * 8.3) )
          {
            dword_20000044 = 450;
            byte_200002A7 = 13;
            byte_200002A8 = -23;
          }
          else
          {
            byte_200002A8 = -22;
            byte_200002A7 = 15;
          }
          goto LABEL_915;
        case -23:
          if ( dword_200025B0 == 1 || !byte_200002B4 )
          {
            sub_8029536();
            byte_200002A8 = 1;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_20001BF0 * 8.3) )
          {
            dword_20000040 = 6550;
            byte_200002A8 = -22;
            byte_200002A7 = 15;
          }
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          v47 = (float)(flt_2000037C * 850.0) + 5700.0;
          if ( v47 <= (float)(unsigned int)dword_20000040 )
            v48 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v47) - 180.0;
          else
            v48 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v48) < 1138819072 )
            v48 = 450.0;
          dword_20000044 = (unsigned int)v48;
          dword_20000040 = (unsigned int)v47;
          if ( dword_20000374 > 3000 )
            goto LABEL_907;
          goto LABEL_915;
        case -22:
          if ( dword_200025B0 != 1 && byte_200002B4 && !byte_200002AE )
            goto LABEL_915;
          sub_802952C();
          if ( !v49 )
            word_2000051A = 1;
          goto LABEL_913;
        default:
          goto LABEL_52;
      }
      goto LABEL_915;
    }
    if ( (unsigned __int8)byte_200002A8 == 207 )
    {
      if ( dword_20000374 == 1 )
        sub_8029518();
      if ( dword_20001BE8 > 1131413504 )
        byte_200002A8 = -48;
      if ( dword_20000374 > 3000 )
      {
LABEL_640:
        sub_8029536();
        BYTE1(dword_200028B8) |= 8u;
        dword_200002E0 = 60000;
        byte_200002A8 = -56;
      }
      goto LABEL_915;
    }
    if ( (unsigned __int8)byte_200002A8 > 0xCFu )
    {
      v17 = (unsigned __int8)byte_200002A8 - 208;
      v13 = -200.0;
      v15 = v17 >= 9;
LABEL_52:
      switch ( v17 )
      {
        case 0u:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029518();
            flt_200002F8 = *(float *)&dword_20001BF0 * 8.2;
            if ( COERCE_INT(*(float *)&dword_20001BF0 * 8.2) < 1136197632 )
            {
              flt_200002F8 = 370.0;
              sub_8029536();
              byte_200002A8 = -41;
              goto LABEL_915;
            }
          }
          if ( dword_200025B0 == 1 )
          {
            sub_8029536();
            byte_200002A8 = 1;
            goto LABEL_915;
          }
          if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
            goto LABEL_553;
          if ( byte_200002AE == 1 )
          {
            dword_200002FC = 0;
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            goto LABEL_915;
          }
          if ( dword_20000374 == 60 )
            sub_8029518();
          if ( dword_20000374 == 80 )
            sub_8029518();
          if ( dword_20000374 == 120 )
          {
            sub_8030078();
            dword_20000300 = LODWORD(v13);
            sub_8029DAC(&flt_200027F8);
            flt_20002804 = 200.0;
            if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_2000278C * 1.5) )
              flt_200002F8 = *(float *)&dword_20001BE8 + 10.0;
            else
              flt_200002F8 = *(float *)&dword_2000278C * 1.5;
            sub_8029536();
            byte_200002A6 = 9;
          }
          if ( dword_20000374 < 160 )
            goto LABEL_915;
          if ( (float)(*(float *)&dword_20001BF0 * 8.2) <= flt_200002F8 )
          {
            if ( (float)(*(float *)&dword_20001BF0 * 8.5) < flt_200002F8 )
              flt_200002F8 = flt_200002F8 - 0.05;
          }
          else
          {
            flt_200002F8 = flt_200002F8 + 0.05;
          }
          if ( (float)(*(float *)&dword_20001BF0 * 8.1) <= flt_200002F8
            && (float)(*(float *)&dword_20001BF0 * 8.5) >= flt_200002F8
            && byte_200002B2 )
          {
            byte_200002A8 = -47;
            goto LABEL_915;
          }
          if ( dword_20000374 > 10000 )
            goto LABEL_640;
          goto LABEL_915;
        case 1u:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_915;
          }
          if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
            goto LABEL_553;
          if ( dword_20000374 > 200 )
          {
            sub_8029536();
            byte_200002A7 = 21;
            byte_200002A8 = -46;
          }
          goto LABEL_915;
        case 2u:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( byte_200002B3 && byte_200002B1 && byte_200002B2 && byte_200002AE != 1 )
          {
            if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
            {
              sub_8029536();
              byte_200002A8 = -56;
              byte_200002A6 = 2;
            }
          }
          else
          {
            sub_8029536();
            byte_200002A8 = -56;
            dword_200002E0 = 60000;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 >= 100 )
          {
            if ( (unsigned int)dword_20000300 < 0xC47A0000 )
              *(float *)&dword_20000300 = *(float *)&dword_20000300 - 0.1;
            if ( (unsigned int)dword_200002FC <= 0xC1A00000 )
            {
              if ( byte_200002B4 || !byte_200002B7 )
              {
                sub_8029536();
                byte_200002C0 = 1;
                byte_200002A8 = -56;
              }
            }
            else
            {
              byte_200002C0 = 1;
              byte_200002A8 = -50;
            }
          }
          goto LABEL_915;
        case 3u:
        case 5u:
          goto LABEL_914;
        case 4u:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( !byte_200002B2 || byte_200002B0 == 1 || byte_200002AF == 1 || !byte_200002B4 )
            goto LABEL_789;
          if ( byte_200002AE == 1 )
          {
            sub_8029536();
            dword_200002E0 = 300000;
            byte_200002A8 = -56;
            goto LABEL_915;
          }
          if ( !byte_20002E37[0] && byte_20002EAB != 2 || byte_2000050C == 1 || byte_20002EAB == 1 )
            goto LABEL_791;
          if ( dword_20000374 == 1 )
          {
            byte_200002A7 = 21;
            sub_8030078();
          }
          if ( byte_20002EAB == 2 )
          {
            if ( dword_20000374 == 1 )
            {
              byte_200002C5 = 1;
              sub_803043C((int)&unk_20002654);
            }
            else if ( dword_20000374 == 250 )
            {
              sub_8029536();
              sub_8030078();
              byte_200002A6 = 33;
            }
            if ( dword_20000374 >= 350 && byte_200002AB )
            {
              sub_8029536();
              byte_200002A6 = 2;
              byte_200002A8 = -52;
              dword_200002EC = 0;
            }
          }
          else
          {
            if ( dword_20000374 == 9 )
            {
              sub_8029536();
              sub_8030078();
              byte_200002A6 = 4;
              byte_200002BE = 0;
            }
            if ( dword_20000374 >= 10 && byte_200002AB )
            {
              if ( byte_200002BE )
              {
                byte_200002BD = 0;
                byte_200002BF = 0;
                byte_200002A8 = -42;
              }
              else
              {
                byte_200002BD = 1;
              }
            }
          }
          goto LABEL_915;
        case 6u:
          if ( dword_20000374 == 1 )
            sub_8030078();
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( byte_200002B2 && byte_200002AE != 1 && byte_200002B4 )
          {
            if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
            {
LABEL_791:
              sub_8029536();
              byte_200002A8 = -56;
            }
            else
            {
              byte_200002AA = 1;
              if ( byte_200002BF )
              {
                if ( (unsigned __int8)byte_200002BF + 7 < dword_20000374 )
                {
                  sub_8029536();
                  byte_200002A6 = 2;
                  byte_200002A8 = -52;
                }
              }
              else
              {
                sub_802952C();
                if ( v40 == 1 )
                  byte_200002BF = dword_20000374;
              }
              if ( dword_20000374 > 100 )
              {
                sub_8029536();
                BYTE1(dword_200028B8) |= 8u;
                byte_200002A8 = -56;
              }
            }
          }
          else
          {
LABEL_789:
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
          }
          goto LABEL_915;
        case 7u:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029518();
            sub_8029518();
          }
          if ( dword_200025B0 == 1 )
          {
            sub_8029536();
            byte_200002A8 = 1;
            goto LABEL_915;
          }
          if ( !byte_200002B3 || !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029536();
            byte_200002A8 = -56;
            dword_200002E0 = 60000;
            byte_200002A6 = 2;
            goto LABEL_915;
          }
          if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
          {
            sub_8029536();
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_915;
          }
          if ( dword_20000374 == 60 )
            sub_8029518();
          if ( dword_20000374 == 80 )
            sub_8029518();
          if ( dword_20000374 == 120 )
          {
            sub_8030078();
            dword_20000300 = LODWORD(v13);
            sub_8029DAC(&flt_200027F8);
            flt_20002804 = 200.0;
            if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_2000278C * 1.5) )
              flt_200002F8 = *(float *)&dword_20001BE8 + 10.0;
            else
              flt_200002F8 = *(float *)&dword_2000278C * 1.5;
            sub_8029536();
            byte_200002A6 = 5;
            dword_200002E8 = 0;
          }
          if ( dword_20000374 >= 125 )
          {
            if ( SLODWORD(flt_200002F8) >= 1135869952 )
            {
              if ( SLODWORD(flt_200002F8) > 1135869952 )
                flt_200002F8 = flt_200002F8 - 0.05;
            }
            else
            {
              flt_200002F8 = flt_200002F8 + 0.05;
            }
            if ( (unsigned int)(dword_20001BE8 - 1135706113) >= 0x4FFFF )
              dword_200002E8 = 0;
            else
              ++dword_200002E8;
            if ( (unsigned int)dword_200002E8 > 0x3E8 )
            {
              dword_20000044 = 450;
              byte_200002A8 = -40;
            }
            if ( dword_20000374 > 5000 )
              goto LABEL_640;
          }
          goto LABEL_915;
        case 8u:
          if ( dword_200025B0 == 1 )
            goto LABEL_907;
          if ( !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_915;
          }
          if ( !byte_200002AB || byte_2000050C == 1 || byte_20002EAB == 1 )
            goto LABEL_553;
          if ( dword_20000374 == 1 )
          {
            flt_2000037C = 0.0;
            sub_8029536();
            byte_200002A7 = 17;
            dword_20000380 = 0;
          }
          if ( dword_20000374 >= 10000 )
          {
            if ( dword_20001BF0 <= 1113063424 )
            {
              if ( dword_20001BF4 <= 1106247680 )
              {
                if ( dword_20001BF4 <= 1092616192 && (dword_20001BF4 <= 1084227584 || dword_20001C08 >= 1106247680) )
                  flt_2000037C = flt_2000037C + 0.00005;
              }
              else
              {
                flt_2000037C = 0.0;
              }
LABEL_664:
              if ( SLODWORD(flt_2000037C) > 1065185444 )
                flt_2000037C = 1.0;
              v36 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
              if ( SLODWORD(v36) < 1138819072 )
                v36 = 450.0;
              dword_20000044 = (unsigned int)v36;
              *(float *)&dword_20000300 = -flt_20002804;
              if ( dword_20000374 > 6000 )
              {
                if ( dword_20001C08 < 1110179840 )
                  goto LABEL_678;
                if ( SLODWORD(flt_2000037C) > 1065185444 && (unsigned int)(dword_20000374 - dword_20000380) > 0x1770 )
                {
                  byte_200002A8 = -39;
                  goto LABEL_915;
                }
                if ( dword_20000374 <= 60000 )
                {
LABEL_678:
                  if ( dword_20000374 > 6000000 )
                  {
                    sub_8029536();
                    BYTE1(dword_200028B8) |= 8u;
                    byte_200002A8 = -56;
                    dword_200002E0 = 60000;
                  }
                }
                else
                {
                  sub_8029536();
                  if ( byte_200002B5 )
                  {
                    byte_200002A8 = -56;
                  }
                  else
                  {
                    BYTE1(dword_200028B8) |= 8u;
                    byte_200002A8 = -56;
                    dword_200002E0 = 60000;
                  }
                }
              }
              goto LABEL_915;
            }
          }
          else if ( dword_20001BF0 <= 1113063424 )
          {
            goto LABEL_664;
          }
          sub_8029608();
          dword_20000380 = dword_20000374;
          goto LABEL_664;
        default:
          goto LABEL_8;
      }
    }
    if ( (unsigned __int8)byte_200002A8 == 203 )
    {
      if ( dword_200025B0 == 1 )
        goto LABEL_907;
      if ( !byte_200002B4 )
      {
LABEL_508:
        sub_8029536();
        dword_200002E0 = 60000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_915;
      }
      if ( byte_2000050C != 1 && byte_20002EAB != 1 )
      {
        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * 8.3) )
        {
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
            v34 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          else
            v34 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v34) < 1138819072 )
            v34 = 450.0;
          dword_20000044 = (unsigned int)v34;
          if ( dword_20000374 > 3000 )
          {
            sub_8029536();
            BYTE1(dword_200028B8) |= 8u;
            byte_200002A8 = -56;
            dword_200002E0 = 60000;
          }
        }
        else
        {
          sub_8029536();
          dword_200002EC = 0;
          byte_200002A8 = -52;
          dword_200002E0 = 0;
          byte_200002A7 = 21;
        }
        goto LABEL_915;
      }
LABEL_515:
      sub_8029536();
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      goto LABEL_915;
    }
    if ( (unsigned __int8)byte_200002A8 <= 0xCBu )
    {
      if ( byte_200002A8 == 102 )
      {
        byte_200002A8 = 2;
        goto LABEL_915;
      }
      if ( (unsigned __int8)byte_200002A8 == 200 )
      {
        byte_200002AA = 0;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = -54;
        dword_200002FC = 0;
        sub_8029518();
        sub_8029518();
        sub_8029518();
        sub_8030078();
        goto LABEL_915;
      }
      if ( (unsigned __int8)byte_200002A8 == 201 )
      {
        byte_200002AA = 0;
        byte_200002A6 = 2;
        byte_200002A8 = -52;
        byte_200002A7 = 21;
        sub_8029518();
        sub_8029518();
        sub_8030078();
        goto LABEL_915;
      }
      v16 = (unsigned __int8)byte_200002A8 == 202;
      if ( (unsigned __int8)byte_200002A8 != 202 )
      {
LABEL_18:
        if ( v16 )
        {
          if ( dword_200025B0 == 1 || !byte_200002B4 )
          {
            sub_8029536();
            byte_200002A8 = 44;
            byte_200002A7 = v14;
            byte_200002A6 = v14;
          }
          if ( byte_200002B2 )
          {
            sub_8029518();
            byte_200002A8 = 43;
          }
          if ( dword_20000374 > 2000 )
          {
            sub_8029536();
            byte_200002A8 = 44;
          }
          goto LABEL_915;
        }
        goto LABEL_914;
      }
      if ( dword_200025B0 != 1 )
      {
        byte_200002AE = 0;
        byte_200002AF = 0;
        byte_200002B0 = 0;
        byte_200002C0 = 1;
        sub_8030078();
        if ( dword_20000374 >= 1000 )
        {
          if ( byte_2000050C )
          {
            dword_200002E0 = 2000;
          }
          else if ( dword_200002E0 <= 0 )
          {
            sub_802964E();
            if ( byte_20002EAB != 1 )
            {
              if ( byte_200002A9 )
              {
                if ( byte_200002A9 == 2 )
                {
                  sub_802952C();
                  if ( v33 == 1 )
                  {
                    sub_8029518();
                    byte_200002A9 = 0;
                  }
                }
                else if ( byte_200002A9 == 3 )
                {
                  if ( byte_200002B5 )
                  {
                    if ( (unsigned int)(dword_20000374 - 10000) >= 0xBB9 )
                      byte_200002A9 = 0;
                  }
                  else if ( dword_20000374 == 10000 )
                  {
                    byte_200002C6 = 1;
                  }
                  else if ( dword_20000374 > 30000
                         && byte_200002B3
                         && byte_200002AB
                         && !byte_200002B4
                         && byte_200002B7 == 1 )
                  {
                    sub_8029590();
                    byte_200002C0 = 0;
                    if ( dword_20001BE8 <= 1131413504 )
                      byte_200002A8 = -49;
                    else
                      byte_200002A8 = -48;
                  }
                }
                else
                {
                  byte_200002A9 = 0;
                }
              }
              else
              {
                sub_802952C();
                if ( v29 )
                {
                  if ( byte_200002B5 )
                  {
                    if ( byte_200002B6 )
                    {
                      dword_200002E0 = 3000;
                    }
                    else if ( byte_200002B4 )
                    {
                      if ( byte_20002E37[0] || *(float *)&dword_200002FC != 0.0 && byte_200002AB || byte_20002EAB == 2 )
                      {
                        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * 8.3) )
                        {
                          sub_8029536();
                          dword_20000044 = 450;
                          byte_200002A7 = 13;
                          byte_200002A8 = -53;
                        }
                        else
                        {
                          sub_8029536();
                          dword_200002EC = 0;
                          byte_200002A8 = -52;
                          dword_200002E0 = 0;
                          byte_200002A7 = 21;
                          byte_200002AA = 1;
                          sub_8029518();
                        }
                      }
                    }
                    else if ( byte_200002B3
                           && byte_200002AB
                           && (unsigned int)dword_20002D60 <= 1
                           && (byte_200002B7 || (unsigned int)dword_200002FC > 0xC1200000) )
                    {
                      sub_8029590();
                      if ( dword_20001BE8 <= 1131413504 )
                        byte_200002A8 = -49;
                      else
                        byte_200002A8 = -48;
                    }
                  }
                  else
                  {
                    byte_200002A9 = 3;
                    sub_8029536();
                  }
                }
                else
                {
                  byte_200002A9 = 2;
                  sub_8029518();
                  sub_8029540(v30, v31, v32);
                  sub_8029536();
                }
              }
            }
          }
          else
          {
            if ( dword_200002E0 > 2000 )
              sub_802964E();
            --dword_200002E0;
          }
        }
        goto LABEL_915;
      }
LABEL_907:
      sub_8029536();
      byte_200002A8 = 1;
      goto LABEL_915;
    }
    if ( (unsigned __int8)byte_200002A8 != 204 )
    {
      if ( (unsigned __int8)byte_200002A8 == 205 )
      {
        if ( dword_200025B0 != 1 )
        {
          if ( !byte_200002B2 || byte_200002B0 == 1 )
          {
            sub_8029536();
            dword_200002E0 = 60000;
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          else if ( byte_2000050C == 1 || byte_20002EAB == 1 )
          {
            sub_8029536();
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          else if ( byte_200002AF == 1 || !byte_200002AB )
          {
            sub_8029536();
            byte_200002A8 = -55;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 >= 40 )
          {
            sub_8030078();
            byte_200002A6 = 9;
            sub_8029536();
            byte_200002A7 = 21;
            byte_200002A8 = -50;
          }
          goto LABEL_915;
        }
      }
      else if ( dword_200025B0 != 1 )
      {
        if ( byte_200002AE || !byte_200002B2 || !byte_200002B5 )
        {
          dword_200002FC = 0;
          sub_8029536();
          dword_200002E0 = 60000;
          byte_200002A8 = -56;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          goto LABEL_915;
        }
        if ( byte_2000050C != 1 && byte_20002EAB != 1 )
        {
          if ( !byte_200002AB )
          {
            if ( byte_20002E37[0] || byte_20002EAB == 2 )
            {
              sub_8029536();
              byte_200002A6 = 2;
              byte_200002AA = 0;
              sub_8030078();
              sub_8029518();
              sub_8029518();
              byte_200002A8 = -44;
            }
            else
            {
LABEL_553:
              sub_8029536();
              byte_200002A8 = -56;
              byte_200002A6 = 2;
            }
            goto LABEL_915;
          }
          if ( !byte_200002B3 && *(float *)&dword_200002FC < -0.0 )
          {
            dword_200002FC = 0;
            sub_8029536();
            byte_200002A8 = -55;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            dword_200002E0 = 2000;
            goto LABEL_915;
          }
          if ( byte_200002B4 || (unsigned int)dword_200002FC >= 0xC0A00000 )
          {
            if ( *(float *)&dword_200002FC == 0.0 )
            {
              sub_8029536();
              byte_200002A8 = -55;
              byte_200002A6 = 2;
            }
            else
            {
              dword_20000300 = dword_200002FC;
            }
            goto LABEL_915;
          }
        }
        dword_200002FC = 0;
        sub_8029536();
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_915;
      }
      goto LABEL_907;
    }
    if ( dword_200025B0 == 1 )
      goto LABEL_907;
    if ( byte_200002B6 )
    {
      sub_8029536();
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      dword_200002E0 = 3000;
    }
    byte_200002AF = 0;
    if ( byte_200002B0 != 1 && byte_200002B5 && byte_200002B1 )
    {
      if ( byte_2000050C == 1 || byte_20002EAB == 1 )
      {
        sub_8029536();
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      else if ( byte_200002AE == 1 )
      {
        sub_8029536();
        dword_200002E0 = 300000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
    }
    else
    {
      sub_8029536();
      dword_200002E0 = 60000;
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
    }
    if ( byte_20002EAB == 2 )
    {
      if ( byte_200002AB )
      {
        if ( (unsigned int)dword_200002EC < 0xC8 && dword_20002764 > 1126170624 )
        {
          *(float *)&v35 = *(float *)&dword_20001BE0 - *(float *)&dword_20001C14;
          sub_80296B4();
          if ( v35 > 1106247680 )
            dword_200002EC = 0;
        }
        ++dword_200002EC;
      }
      else
      {
        dword_200002EC = 0;
      }
      if ( (unsigned int)dword_200002EC > 0xC8 )
      {
        sub_8029518();
        dword_200002EC = 210;
        byte_200002AA = 1;
        goto LABEL_494;
      }
    }
    else if ( byte_200002AB && byte_20002E37[0] )
    {
      sub_8029518();
      byte_200002AA = 1;
      goto LABEL_494;
    }
    byte_200002AA = 0;
    sub_8029518();
    sub_8029518();
LABEL_494:
    if ( dword_200002E0 > 0 )
      --dword_200002E0;
    if ( dword_20000374 < 1000 )
    {
      byte_200002BC = 0;
      goto LABEL_915;
    }
    if ( !byte_200002B2 )
      goto LABEL_508;
    if ( byte_200002AB )
    {
      if ( *(float *)&dword_200002FC < 0.0 && !byte_200002B3 )
        dword_200002FC = 0;
      if ( !byte_200002B4 && (unsigned int)dword_200002FC < 0xC1200000 )
        goto LABEL_508;
      if ( *(float *)&dword_200002FC != 0.0 )
      {
        if ( dword_200002E0 < 10 )
        {
          byte_200002A8 = -51;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029518();
        }
        goto LABEL_915;
      }
      if ( byte_20002EAB == 2 || byte_20002E37[0] )
        goto LABEL_915;
    }
    else
    {
      if ( !byte_200002B4 )
      {
        sub_8029536();
        dword_200002E0 = 60000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_915;
      }
      if ( byte_20002EAB == 2 || byte_20002E37[0] )
      {
        byte_200002AA = 0;
        sub_8029536();
        sub_8029518();
        sub_8029518();
        byte_200002A8 = -44;
        goto LABEL_915;
      }
    }
    goto LABEL_515;
  }
  v15 = (unsigned __int8)byte_200002A8 >= 0x21u;
  if ( byte_200002A8 == 33 )
  {
    if ( dword_20000374 == 50 )
    {
      sub_8029536();
      sub_8030078();
      byte_200002A6 = 4;
    }
    if ( dword_200025B0 == 1 || !byte_200002B4 || !byte_200002B2 || byte_200002AE == 1 || byte_200002B9 || byte_200002BA )
    {
      sub_8029536();
      byte_200002A8 = 34;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
    }
    goto LABEL_915;
  }
LABEL_8:
  if ( v15 )
  {
LABEL_914:
    sub_8029536();
    BYTE1(dword_200028B8) |= 2u;
    byte_200002A8 = 1;
    goto LABEL_915;
  }
  switch ( byte_200002A8 )
  {
    case 0:
      byte_200002AE = 0;
      v18 = dword_200025B0;
      v19 = (unsigned int)dword_200025B0 >= 0xB;
      if ( dword_200025B0 == 11 )
      {
        dword_200025B0 = 0;
        byte_200002A8 = 80;
      }
      else
      {
        while ( 2 )
        {
          if ( !v19 )
          {
            switch ( v18 )
            {
              case 0u:
              case 2u:
              case 8u:
                goto LABEL_915;
              case 1u:
                dword_200025B0 = 0;
                byte_200002A8 = 1;
                break;
              case 3u:
                dword_200025B0 = 0;
                byte_200002A8 = 20;
                break;
              case 4u:
                dword_200025B0 = 0;
                byte_200002A8 = 30;
                break;
              case 5u:
                dword_200025B0 = 0;
                byte_200002A8 = 10;
                break;
              case 6u:
                dword_200025B0 = 0;
                byte_200002A8 = 40;
                break;
              case 7u:
                dword_200025B0 = 0;
                byte_200002A8 = -31;
                break;
              case 9u:
                dword_200025B0 = 0;
                byte_200002A8 = -56;
                break;
              case 0xAu:
                dword_200025B0 = 0;
                byte_200002A8 = 70;
                break;
              default:
                v18 -= 23;
                v19 = v18 >= 0xC;
                switch ( v18 )
                {
                  case 0u:
                    dword_200025B0 = 0;
                    byte_200002A8 = -37;
                    break;
                  case 1u:
                    dword_200025B0 = 0;
                    byte_200002A8 = -34;
                    break;
                  case 2u:
                    sub_8029518();
                    sub_8029518();
                    if ( dword_20000374 >= 200 )
                    {
                      dword_200025B0 = 0;
                      byte_200002A8 = -36;
                    }
                    break;
                  case 3u:
                    sub_8029518();
                    sub_8029518();
                    if ( dword_20000374 >= 200 )
                    {
                      dword_200025B0 = 0;
                      byte_200002A8 = -35;
                    }
                    break;
                  case 4u:
                  case 5u:
                  case 6u:
                  case 0xAu:
                    goto LABEL_915;
                  case 7u:
                    dword_200025B0 = 0;
                    byte_200002A8 = -33;
                    break;
                  case 8u:
                    dword_200025B0 = 0;
                    byte_200002A8 = -32;
                    break;
                  case 9u:
                    dword_200025B0 = 0;
                    byte_200002A8 = 100;
                    break;
                  case 0xBu:
                    dword_200025B0 = 0;
                    byte_200002A8 = -24;
                    break;
                  default:
                    continue;
                }
                break;
            }
          }
          break;
        }
      }
      goto LABEL_915;
    case 1:
      byte_200002AA = 0;
      sub_8029518();
      sub_8029518();
      sub_8029518();
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      dword_200025B0 = 0;
      sub_8030078();
      goto LABEL_915;
    case 2:
      if ( dword_200025B0 == 1 || byte_200002AE == 1 )
      {
        sub_8029536();
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = 1;
      }
      goto LABEL_915;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 17:
    case 18:
    case 19:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
      goto LABEL_914;
    case 10:
      if ( !byte_200002AB )
        goto LABEL_163;
      if ( byte_200002B3 )
      {
        sub_8029590();
        if ( dword_20001BE8 <= 1131413504 )
        {
          byte_200002A8 = 11;
        }
        else
        {
          byte_200002A8 = 12;
          flt_200002F8 = *(float *)&dword_20001BF0 * 8.2;
        }
      }
      else
      {
        sub_8029536();
        byte_200002A8 = 0;
      }
      goto LABEL_915;
    case 11:
      if ( dword_20000374 == 1 )
        sub_8029518();
      if ( dword_20001BE8 > 1131413504 )
      {
        byte_200002A8 = 12;
        flt_200002F8 = *(float *)&dword_20001BF0 * 8.2;
        sub_8029518();
      }
      if ( dword_20000374 > 3000 )
      {
        sub_8029536();
        byte_200002A8 = 15;
      }
      goto LABEL_915;
    case 12:
      if ( dword_20000374 == 1 )
      {
        byte_200002AA = 1;
        sub_8029518();
      }
      if ( dword_20000374 == 30 )
      {
        sub_8029518();
        sub_8029518();
      }
      if ( dword_200025B0 == 1 || !byte_200002B3 || !byte_200002AB || byte_200002AE == 1 )
      {
        sub_8029536();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 80 )
        sub_8029518();
      if ( dword_20000374 == 100 )
        sub_8029518();
      if ( dword_20000374 >= 120 )
      {
        if ( dword_20000374 == 120 )
        {
          flt_20002810 = 2500.0;
          sub_8029DAC(&flt_200027F8);
          flt_20002804 = 200.0;
          if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_2000278C * 1.5) )
            LODWORD(flt_200002F8) = dword_20001BE8;
          else
            flt_200002F8 = *(float *)&dword_2000278C * 1.5;
          sub_8029536();
          byte_200002A6 = 5;
        }
        if ( (float)(*(float *)&dword_20001BF0 * 8.2) > flt_200002F8 )
          flt_200002F8 = flt_200002F8 + 0.05;
        if ( (float)(*(float *)&dword_20001BF0 * 8.2) <= flt_200002F8 || SLODWORD(flt_200002F8) >= 1139474432 )
          byte_200002A8 = 13;
        if ( dword_20000374 > 10000 )
        {
          sub_8029536();
          byte_200002A8 = 15;
        }
      }
      goto LABEL_915;
    case 13:
      if ( dword_200025B0 == 1 || !byte_200002B3 || !byte_200002AB || !byte_200002B1 || byte_200002AE == 1 )
      {
        sub_8029536();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 300 )
      {
        sub_8029536();
        byte_200002A7 = 16;
        byte_200002A8 = 14;
      }
      goto LABEL_915;
    case 14:
      if ( dword_200025B0 == 1 || !byte_200002B3 || !byte_200002AB || !byte_200002B1 || byte_200002AE == 1 )
      {
        sub_8029536();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_915;
    case 15:
      byte_200002AA = 0;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      sub_8029518();
      sub_8029518();
      sub_8030078();
      goto LABEL_915;
    case 20:
      if ( !byte_200002AB || !byte_200002B4 )
        goto LABEL_163;
      sub_8029590();
      if ( dword_20000374 == 1 )
        sub_8029518();
      if ( dword_20000374 == 31 )
        sub_8029518();
      if ( dword_20000374 >= 33 )
      {
        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * v13) )
        {
          sub_8029536();
          dword_20000044 = 450;
          byte_200002A7 = 13;
          byte_200002A8 = 21;
        }
        else
        {
          sub_8029536();
          byte_200002A8 = 22;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029518();
        }
      }
      goto LABEL_915;
    case 21:
      if ( dword_200025B0 != 1 && byte_200002B4 && byte_200002AB )
      {
        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * v13) )
        {
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
            v20 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          else
            v20 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v20) < 1138819072 )
            v20 = 450.0;
          dword_20000044 = (unsigned int)v20;
          if ( dword_20000374 > 3000 )
          {
            sub_8029536();
            byte_200002A8 = 24;
          }
        }
        else
        {
          sub_8029536();
          byte_200002A8 = 22;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029518();
        }
      }
      else
      {
        sub_8029536();
        byte_200002A8 = 24;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_915;
    case 22:
      if ( dword_200025B0 == 1 || !byte_200002B4 || !byte_200002AB )
      {
        sub_8029536();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 100 )
        sub_8029518();
      if ( dword_20000374 == 120 )
        sub_8029518();
      if ( dword_20000374 >= 130 && byte_200002B2 )
      {
        sub_8030078();
        byte_200002A6 = 3;
        sub_8029536();
        byte_200002A8 = 23;
      }
      goto LABEL_915;
    case 23:
      if ( dword_200025B0 == 1 || byte_200002AE == 1 || !byte_200002AB || !byte_200002B2 || !byte_200002B4 )
      {
        sub_8029536();
        byte_200002A8 = 24;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      dword_20000300 = LODWORD(flt_200025B4);
      goto LABEL_915;
    case 24:
      byte_200002AA = 0;
      sub_8029518();
      sub_8029518();
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      sub_8030078();
      goto LABEL_915;
    case 30:
      if ( byte_200002B4 )
      {
        sub_8029590();
        if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * v13) )
        {
          dword_20000044 = 450;
          byte_200002A7 = 13;
          byte_200002A8 = 31;
        }
        else
        {
          byte_200002A8 = 32;
          byte_200002A7 = 19;
        }
      }
      else
      {
        sub_8029536();
        byte_200002A8 = 0;
      }
      goto LABEL_915;
    case 31:
      if ( dword_200025B0 == 1 || !byte_200002B4 )
      {
        sub_8029536();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_20001BF0 * v13) )
      {
        dword_20000040 = 6550;
        byte_200002A8 = 32;
        byte_200002A7 = 19;
      }
      flt_2000037C = (float)dword_20000374 * 0.001;
      if ( SLODWORD(flt_2000037C) > 1065185444 )
        flt_2000037C = 1.0;
      v21 = (float)(flt_2000037C * 850.0) + 5700.0;
      if ( v21 <= (float)(unsigned int)dword_20000040 )
        v22 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v21) - 180.0;
      else
        v22 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
      if ( SLODWORD(v22) < 1138819072 )
        v22 = 450.0;
      dword_20000044 = (unsigned int)v22;
      dword_20000040 = (unsigned int)v21;
      if ( dword_20000374 > 3000 )
      {
        sub_8029536();
        byte_200002A8 = 34;
      }
      goto LABEL_915;
    case 32:
      if ( dword_200025B0 == 1 || !byte_200002B4 )
      {
        sub_8029536();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( byte_200002B2 )
      {
        sub_8029518();
        byte_200002A8 = 33;
      }
      if ( dword_20000374 > 2000 )
      {
        sub_8029536();
        byte_200002A8 = 34;
      }
      goto LABEL_915;
    default:
      if ( byte_200002A8 == 72 )
      {
        if ( dword_20000374 == 1 )
        {
          byte_200002AA = 1;
          sub_8029518();
          sub_8029518();
          flt_200002F8 = flt_200025B4;
        }
        if ( dword_200025B0 == 1 || !byte_200002AB || byte_200002AE == 1 )
        {
          sub_8029536();
          byte_200002A8 = 1;
        }
        else
        {
          if ( dword_20000374 == 60 )
            sub_8029518();
          if ( dword_20000374 == 80 )
            sub_8029518();
          if ( dword_20000374 == 120 )
          {
            flt_20002810 = 2500.0;
            sub_8029DAC(&flt_200027F8);
            flt_20002804 = 200.0;
            if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_2000278C * 1.5) )
              LODWORD(flt_200002F8) = dword_20001BE8;
            else
              flt_200002F8 = *(float *)&dword_2000278C * 1.5;
            sub_8029536();
            byte_200002A6 = 5;
          }
          if ( dword_20000374 >= 120 )
          {
            if ( flt_200025B4 > flt_200002F8 )
              flt_200002F8 = flt_200002F8 + 0.05;
            if ( flt_200025B4 <= flt_200002F8 || SLODWORD(flt_200002F8) >= 1138819072 )
            {
              flt_200002F8 = flt_200025B4;
              byte_200002A8 = 73;
            }
            if ( !byte_200002AB )
            {
              sub_8029536();
              byte_200002A8 = 74;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            if ( dword_20000374 > 10000 )
            {
              sub_8029536();
              byte_200002A8 = 74;
            }
          }
        }
        goto LABEL_915;
      }
      if ( (unsigned __int8)byte_200002A8 > 0x48u )
      {
        if ( byte_200002A8 == 81 )
        {
          if ( dword_200025B0 == 1 || !byte_200002AB || !byte_200002B2 )
          {
            sub_8029536();
            byte_200002A8 = 83;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 == 200 )
            sub_8029518();
          if ( dword_20000374 == 500 )
            sub_8029518();
          if ( dword_20000374 >= 1000 )
          {
            flt_200002F8 = 360.0;
            flt_20002454 = 0.0;
            dword_20000300 = 0;
            flt_20002458 = 0.0;
            byte_200002A6 = 3;
            sub_8029536();
            byte_200002A8 = 82;
          }
          goto LABEL_915;
        }
        if ( (unsigned __int8)byte_200002A8 <= 0x51u )
        {
          if ( byte_200002A8 == 73 )
          {
            if ( dword_200025B0 == 1 || byte_200002AE == 1 )
            {
              sub_8029536();
              byte_200002A7 = 2;
              byte_200002A6 = 2;
              byte_200002A8 = 74;
            }
            else if ( !byte_200002AB || !byte_200002B1 )
            {
              sub_8029536();
              byte_200002A8 = 74;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            flt_200002F8 = flt_200025B4;
            goto LABEL_915;
          }
          if ( byte_200002A8 == 74 )
          {
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            byte_200002A8 = 0;
            sub_8029518();
            sub_8029518();
            goto LABEL_915;
          }
          v16 = byte_200002A8 == 80;
          if ( byte_200002A8 != 80 )
            goto LABEL_18;
          if ( byte_200002AB )
          {
            if ( dword_20001BE8 > 1135542272 )
            {
              byte_200002A8 = 81;
              byte_200002AA = 1;
              sub_8029518();
            }
            if ( dword_20000374 > 3000 )
            {
              sub_8029536();
              byte_200002A8 = 83;
            }
            goto LABEL_915;
          }
          goto LABEL_163;
        }
        if ( byte_200002A8 == 82 )
        {
          if ( dword_200025B0 == 1 || byte_200002AE == 1 || !byte_200002AB || !byte_200002B2 )
          {
            sub_8029536();
            byte_200002A8 = 83;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          dword_20000300 = LODWORD(flt_200025B4);
          goto LABEL_915;
        }
        if ( byte_200002A8 == 83 )
        {
          byte_200002AA = 0;
          sub_8029518();
          sub_8029518();
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          byte_200002A8 = 0;
          goto LABEL_915;
        }
        v16 = byte_200002A8 == 100;
        if ( byte_200002A8 != 100 )
          goto LABEL_18;
        if ( byte_200002B5 )
        {
          if ( byte_200002B4 )
          {
            if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * v13) )
            {
              sub_8029536();
              dword_20000044 = 450;
              byte_200002A7 = 13;
              byte_200002A8 = 101;
            }
            else
            {
              sub_8029536();
              byte_200002A7 = 21;
              byte_200002A8 = 102;
            }
          }
          else
          {
            v25 = sub_8029540((char)&word_20002428, 100, v12);
            sub_8029540(v25, v26, v27);
            sub_8029536();
            byte_200002A8 = 1;
          }
          goto LABEL_915;
        }
        goto LABEL_907;
      }
      if ( byte_200002A8 == 43 )
      {
        if ( dword_20000374 == 50 )
        {
          byte_200002C5 = 1;
          sub_803043C((int)&unk_20002654);
        }
        else if ( dword_20000374 == 250 )
        {
          sub_8029536();
          sub_8030078();
          byte_200002A6 = 33;
        }
        if ( dword_200025B0 == 1
          || !byte_200002B4
          || !byte_200002B2
          || byte_200002AE == 1
          || byte_200002B9
          || byte_200002BA )
        {
          sub_8029536();
          byte_200002A8 = 44;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
        }
        goto LABEL_915;
      }
      if ( (unsigned __int8)byte_200002A8 <= 0x2Bu )
      {
        if ( byte_200002A8 != 34 )
        {
          if ( byte_200002A8 != 40 )
          {
            if ( byte_200002A8 != 41 )
            {
              v16 = byte_200002A8 == 42;
              goto LABEL_18;
            }
            if ( dword_200025B0 == 1 || !byte_200002B4 )
            {
              sub_8029536();
              byte_200002A8 = 44;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            if ( *(float *)&dword_20001BE8 >= (float)(*(float *)&dword_20001BF0 * v13) )
            {
              dword_20000040 = 6550;
              byte_200002A8 = 42;
              byte_200002A7 = 19;
            }
            flt_2000037C = (float)dword_20000374 * 0.001;
            if ( SLODWORD(flt_2000037C) > 1065185444 )
              flt_2000037C = 1.0;
            v23 = (float)(flt_2000037C * 850.0) + 5700.0;
            if ( v23 <= (float)(unsigned int)dword_20000040 )
              v24 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v23) - 180.0;
            else
              v24 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
            if ( SLODWORD(v24) < 1138819072 )
              v24 = 450.0;
            dword_20000044 = (unsigned int)v24;
            dword_20000040 = (unsigned int)v23;
            if ( dword_20000374 > 3000 )
            {
              sub_8029536();
              byte_200002A8 = 44;
            }
            goto LABEL_915;
          }
          if ( byte_200002B4 )
          {
            sub_8029590();
            if ( *(float *)&dword_20001BE8 < (float)(*(float *)&dword_20001BF0 * v13) )
            {
              dword_20000044 = 450;
              byte_200002A7 = 13;
              byte_200002A8 = 41;
            }
            else
            {
              byte_200002A8 = 42;
              byte_200002A7 = 19;
            }
            goto LABEL_915;
          }
LABEL_163:
          sub_8029536();
          byte_200002A8 = 0;
          goto LABEL_915;
        }
LABEL_58:
        sub_8029518();
        sub_8029518();
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = 0;
        goto LABEL_915;
      }
      if ( byte_200002A8 == 44 )
        goto LABEL_58;
      v14 = 72;
      if ( byte_200002A8 == 70 )
      {
        if ( byte_200002AB )
        {
          sub_8029590();
          if ( dword_20001BE8 <= 1131413504 )
            byte_200002A8 = 71;
          else
            byte_200002A8 = 72;
          goto LABEL_915;
        }
        goto LABEL_163;
      }
      v16 = byte_200002A8 == 71;
      if ( byte_200002A8 != 71 )
        goto LABEL_18;
      if ( dword_20000374 == 1 )
        sub_8029518();
      if ( dword_20001BE8 > 1131413504 )
        byte_200002A8 = 72;
      if ( dword_20000374 > 3000 )
      {
        sub_8029536();
        dword_200002E0 = 60000;
        byte_200002A8 = -56;
      }
LABEL_915:
      if ( dword_20000388 >= 100 || dword_2000273C )
        dword_20000388 = 0;
      switch ( ++dword_20000388 )
      {
        case 2:
          v50 = 2550.0;
          if ( (float)(*(float *)&dword_2000030C * 2550.0) < 2550.0 )
            v50 = *(float *)&dword_2000030C * 2550.0;
          v51 = *(float *)&dword_2000276C - (float)(*(float *)&dword_2000278C * 16.0);
          if ( byte_20000507 == 1 && (unsigned __int16)word_20000515 > 0x320u )
            word_20000515 = 800;
          if ( byte_20000507 == 2 && (unsigned __int16)word_20000515 > 0x258u )
            word_20000515 = 600;
          if ( v51 < (float)-v50 )
            v51 = -v50;
          if ( (float)(unsigned __int16)word_20000515 < v50 )
            v50 = (float)(unsigned __int16)word_20000515;
          if ( (float)-(float)(unsigned __int16)word_20000513 > v51 )
            v51 = -(float)(unsigned __int16)word_20000513;
          if ( byte_2000050E )
          {
            if ( v50 > (float)((float)(*(float *)&dword_20001C08 * flt_20002434) * 1.034) )
              v50 = (float)(*(float *)&dword_20001C08 * flt_20002434) * 1.034;
            if ( v51 < (float)((float)(*(float *)&dword_20001C08 * flt_2000242C) * -1.06) )
              v51 = (float)(*(float *)&dword_20001C08 * flt_2000242C) * -1.06;
          }
          flt_20000310 = v50;
          flt_20000314 = v51;
          v52 = (float)((float)(*(float *)&dword_20001C04 - (float)(*(float *)&dword_2000278C * 1.53)) * 2550.0) * 0.05;
          if ( flt_20000324 <= v52 )
            flt_20000324 = (float)((float)(*(float *)&dword_20001C04 - (float)(*(float *)&dword_2000278C * 1.53))
                                 * 2550.0)
                         * 0.05;
          else
            flt_20000324 = (float)(flt_20000324 * 0.6) + (float)(v52 * 0.4);
          if ( flt_20000324 < 0.0 )
            flt_20000324 = 0.0;
          if ( v50 > flt_20000324 )
            v50 = flt_20000324;
          if ( *(float *)&dword_20000300 <= v50 )
          {
            if ( *(float *)&dword_20000300 >= v51 )
              LODWORD(flt_20002440) = dword_20000300;
            else
              flt_20002440 = v51;
          }
          else
          {
            flt_20002440 = v50;
          }
          break;
        case 3:
          switch ( byte_200036A8 )
          {
            case 1:
              flt_2000038C = (float)(flt_2000038C * 0.8) + (float)(flt_200002F4 * 0.2);
              if ( flt_20003654 >= flt_2000038C )
              {
                byte_200002C9 = 0;
                if ( byte_200008B9 == 1 && flt_200025B4 < flt_20003698 )
                  flt_200025B4 = flt_200025B4 + (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
              }
              else if ( (unsigned __int8)byte_200002C9 <= 2u )
              {
                ++byte_200002C9;
              }
              else
              {
                if ( !byte_200008B9 )
                {
                  v75 = sub_8029540((char)&flt_200025BC, (char)&unk_200008B8, byte_200036A8);
                  v74 = sub_8029540(v75, v53, v54);
                  sub_8029540(v74, v55, v56);
                  sub_8029536();
                }
                byte_200008B9 = 1;
                flt_20002440 = *(float *)&dword_20000300
                             - (float)((float)((float)(flt_2000038C - flt_20003654) * *(float *)&dword_20000300)
                                     * flt_20003658);
                if ( flt_20002440 < 0.0 )
                  flt_20002440 = 0.0;
              }
              break;
            case 2:
              if ( flt_20003650 < (float)(*(float *)&dword_2000278C / 230.0) )
                flt_20002440 = 0.0;
              break;
            case 3:
              sub_802F3A4();
              break;
            case 8:
            case 11:
            case 15:
              if ( byte_200002C4 )
              {
                if ( flt_20002440 > flt_20000390 )
                  flt_20000390 = flt_20000390 + (float)((float)(flt_2000365C * 0.00033333) * flt_20002440);
              }
              else
              {
                flt_20000390 = 0.0;
              }
              flt_20002440 = flt_20000390;
              break;
            case 9:
              flt_20000304 = (float)(flt_20003688 * flt_20002440) * (float)(flt_200002F4 - 50.0);
              break;
            case 12:
              if ( flt_20002440 <= flt_20000394 )
                flt_20000394 = flt_20000394 - (float)((float)(flt_2000365C * 0.00033333) * flt_20003698);
              else
                flt_20000394 = flt_20000394 + (float)((float)(flt_2000365C * 0.00033333) * flt_20003698);
              flt_20002440 = flt_20000394;
              break;
            case 13:
              v57 = (float)(flt_20000398 * 0.8) + (float)(flt_200002F4 * 0.2);
              flt_20000398 = v57;
              if ( flt_20003654 >= v57 )
              {
                byte_200002CA = 0;
                if ( byte_200002CB == 1 )
                {
                  if ( SLODWORD(v57) >= 1112027955 )
                  {
                    dword_2000039C = 0;
                  }
                  else if ( (unsigned int)++dword_2000039C > 0xC1C )
                  {
                    byte_200002CB = 0;
                  }
                }
                if ( byte_200008B9 == 1 && !byte_200002CB && flt_200025B4 < flt_20003698 )
                  flt_200025B4 = flt_200025B4 + (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
              }
              else
              {
                if ( (unsigned __int8)byte_200002CA <= 2u )
                {
                  ++byte_200002CA;
                }
                else
                {
                  byte_200008B9 = 1;
                  flt_20002440 = *(float *)&dword_20000300
                               - (float)((float)(flt_20003698 * (float)(v57 - flt_20003654)) * flt_20003658);
                  if ( flt_20002440 < 0.0 )
                    flt_20002440 = 0.0;
                }
                if ( byte_200002CB )
                  flt_200025B4 = 0.0;
                else
                  byte_200002CB = SLODWORD(v57) > 1112421171;
              }
              break;
            case 16:
              v58 = (float)(flt_200003A0 * 0.8) + (float)(flt_200002F4 * 0.2);
              flt_200003A0 = v58;
              if ( SLODWORD(v58) >= 1111962419 )
              {
                if ( byte_200002CC == 1 )
                {
                  if ( SLODWORD(v58) <= 1111962419 )
                  {
                    dword_200003A4 = 0;
                  }
                  else if ( (unsigned int)++dword_200003A4 > 0xC1C )
                  {
                    byte_200002CC = 0;
                    flt_200003A8 = 0.0;
                  }
                  flt_20002440 = 0.0;
                }
                if ( !byte_200002CC )
                {
                  if ( byte_200008B9 == 1 )
                  {
                    v59 = flt_200003A8;
                    if ( flt_200003A8 >= *(float *)&dword_20000300 )
                    {
                      if ( flt_200003A8 <= *(float *)&dword_20000300 )
                      {
                        byte_200008B9 = 0;
                      }
                      else
                      {
                        flt_200003A8 = flt_200003A8 - (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
                        flt_20002440 = v59 - (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
                      }
                    }
                    else
                    {
                      flt_200003A8 = flt_200003A8 + (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
                      flt_20002440 = v59 + (float)((float)(flt_20003698 / flt_200025BC) * 0.0015);
                    }
                  }
                  else
                  {
                    LODWORD(flt_20002440) = dword_20000300;
                  }
                }
              }
              else
              {
                if ( SLODWORD(v58) < 1111359488 )
                {
                  byte_200002CC = 1;
                  byte_200008B9 = 1;
                  dword_200003A4 = 0;
                }
                if ( byte_200002CC == 1 )
                {
                  flt_20002440 = 0.0;
                }
                else
                {
                  flt_20002440 = *(float *)&dword_20000300
                               + (float)((float)(flt_20003698 * (float)(49.8 - v58)) * flt_20003658);
                  if ( flt_20002440 > flt_20003698 )
                    flt_20002440 = flt_20003698;
                }
              }
              break;
            case 17:
              if ( flt_20003650 < (float)(*(float *)&dword_2000278C / 230.0) )
                flt_20002440 = (float)(1.0
                                     - (float)((float)((float)(*(float *)&dword_2000278C / 230.0) - flt_20003650) * 20.0))
                             * *(float *)&dword_20000300;
              if ( flt_20002440 < 0.0 )
                flt_20002440 = 0.0;
              break;
            default:
              break;
          }
          if ( flt_20000308 != 0.0 )
            sub_802A044();
          goto LABEL_1018;
        case 4:
LABEL_1018:
          if ( byte_200036A9 == 1 )
          {
            v60 = (float)(flt_20002440 + 0.1) * 2.2913;
            flt_20002444 = v60;
            if ( (float)-v60 <= flt_20000304 )
            {
              if ( v60 >= flt_20000304 )
                flt_20002444 = (float)(flt_20003694 + flt_20000304) * *(float *)&dword_2000030C;
              else
                flt_20002444 = v60 + flt_20003694;
            }
            else
            {
              flt_20002444 = flt_20003694 - v60;
            }
          }
          else
          {
            flt_20002444 = (float)(flt_20003694 + flt_20000304) * *(float *)&dword_2000030C;
          }
          break;
        case 5:
          flt_20000408 = flt_200036A4 * 10.0;
          flt_20002448 = (float)(flt_20002444 + (float)(flt_20000408 * flt_20002448)) / (float)(flt_20000408 + 1.0);
          if ( COERCE_INT(flt_20002444 - flt_20002448) < 0x40000000
            && COERCE_UNSIGNED_INT(flt_20002444 - flt_20002448) < 0xC0000000 )
          {
            flt_20002448 = flt_20002444;
          }
          break;
        case 6:
          flt_20000408 = flt_200036A0 * 10.0;
          *(float *)&dword_2000244C = (float)(flt_20002440 + (float)(flt_20000408 * *(float *)&dword_2000244C))
                                    / (float)(flt_20000408 + 1.0);
          if ( COERCE_INT(flt_20002440 - *(float *)&dword_2000244C) < 0x40000000
            && COERCE_UNSIGNED_INT(flt_20002440 - *(float *)&dword_2000244C) < 0xC0000000 )
          {
            dword_2000244C = LODWORD(flt_20002440);
          }
          break;
        case 7:
          v61 = *(float *)&dword_2000244C;
          if ( *(float *)&dword_2000244C < 0.0 )
          {
            flt_2000243C = 0.0;
            LODWORD(flt_20002450) = dword_2000244C;
          }
          else
          {
            v62 = flt_20002448;
            sub_8029BC4();
            flt_2000243C = v62 / (float)(v61 + 0.1);
            v63 = (float)((float)(*(float *)&dword_2000244C + 0.1) * (float)(*(float *)&dword_2000244C + 0.1))
                + (float)(flt_20002448 * flt_20002448);
            if ( v63 < 0.0 )
              flt_20002450 = 0.0;
            else
              flt_20002450 = sqrtf(v63);
          }
          flt_20002458 = (float)(flt_20002450 * 1.4142) / *(float *)&dword_2000278C;
          break;
        case 8:
          if ( SLODWORD(flt_20002760) > 1050253722 )
            flt_20000414 = flt_20000414 + (float)(flt_20002760 * *(float *)&dword_2000278C);
          if ( *(float *)&dword_2000244C < 0.0 )
            flt_2000040C = flt_20002804 + flt_2000040C;
          else
            flt_20000410 = *(float *)&dword_2000244C + flt_20000410;
          ++dword_20000328;
          break;
        case 9:
          sub_8030A7C();
          break;
        case 10:
          if ( byte_200002A4 == 3 || byte_200002A4 == 9 || byte_200002A4 == 33 || byte_200002A4 == 26 )
          {
            v70 = v1 / 1.0;
            *(float *)&dword_2000034C = v1 / 1.0;
            v71 = flt_2000033C + (float)((float)(*(float *)&dword_20001C1C + flt_200008BC) * 0.01);
            flt_2000033C = flt_2000033C + (float)((float)(*(float *)&dword_20001C1C + flt_200008BC) * 0.01);
            flt_20000348 = v70 * 0.3;
            if ( COERCE_INT(v70 * 0.3) <= 1090519040 )
            {
              if ( COERCE_UNSIGNED_INT(v70 * 0.3) > 0xC1000000 )
                flt_20000348 = -8.0;
            }
            else
            {
              flt_20000348 = 8.0;
            }
            v72 = flt_20000344 + (float)(v70 * 0.02);
            flt_20000344 = v72;
            *(float *)&dword_20000340 = v72 + flt_20000348;
            if ( SLODWORD(v71) <= 1050253722 )
            {
              if ( LODWORD(v71) > 0xBE99999A )
                flt_2000033C = -0.3;
            }
            else
            {
              flt_2000033C = 0.3;
            }
            if ( SLODWORD(v72) <= 1090519040 )
            {
              if ( LODWORD(v72) > 0xC1000000 )
                flt_20000344 = -8.0;
            }
            else
            {
              flt_20000344 = 8.0;
            }
          }
          else
          {
            flt_20000344 = 0.0;
            flt_2000033C = 0.0;
            dword_20000340 = 0;
          }
          break;
        default:
          break;
      }
      v64 = flt_20000334 + 1.0;
      flt_20000334 = flt_20000334 + 1.0;
      v65 = *(float *)&dword_20001BF0 + flt_20000330;
      flt_20000330 = *(float *)&dword_20001BF0 + flt_20000330;
      v66 = *(float *)&dword_20001BF4 + flt_20000338;
      flt_20000338 = *(float *)&dword_20001BF4 + flt_20000338;
      if ( dword_2000273C )
      {
        v67 = v65 / v64;
        flt_20000318 = v65 / v64;
        v68 = v66 / v64;
        flt_2000031C = v66 / v64;
        v69 = v67 + 0.3;
        *(float *)&dword_20001C08 = v67 + 0.3;
        *(float *)&dword_20001C0C = (float)(v68 + 0.1) * 1.07;
        flt_200002DC = v68;
        flt_20001BF8 = (float)((float)((float)(v67 + 0.3) * 0.1) * *(float *)&dword_20001C0C)
                     + (float)(flt_20001BF8 * 0.9);
        flt_20000334 = 0.0;
        flt_20000330 = 0.0;
        flt_20000338 = 0.0;
        if ( SLODWORD(flt_200002F8) < 1133903872 )
          flt_200002F8 = 300.0;
        switch ( byte_200002A5 )
        {
          case 16:
            flt_200027F8 = flt_200025B4 * 8.2;
            flt_200027FC = v69 * 8.2;
            v73 = (float)(v69 * flt_200025B8) * 1.08;
            flt_20002810 = v73;
            flt_20002814 = -100.0;
            if ( v73 > flt_20000310 )
              flt_20002810 = flt_20000310;
            if ( flt_20002810 < flt_20002824 )
              flt_20002824 = flt_20002810;
            sub_8029D38(&flt_200027F8);
            LODWORD(flt_200002F8) = dword_20001BE8;
            break;
          case 19:
          case 21:
            flt_200027F8 = 475.6;
            flt_200027FC = v69 * 8.2;
            flt_20002810 = -flt_20002450;
            flt_20002814 = -100.0;
            if ( (float)-flt_20002450 < 0.0 )
              flt_20002810 = 0.0;
            if ( flt_20002810 < flt_20002824 )
              flt_20002824 = flt_20002810;
            sub_8029D38(&flt_200027F8);
            break;
          case 20:
            flt_20002810 = 2500.0;
            flt_20002814 = -2500.0;
            flt_200027F8 = flt_200002F8;
            LODWORD(flt_200027FC) = dword_20001BE8;
            sub_8029D38(&flt_200027F8);
            break;
          case 22:
            flt_20002810 = 2500.0;
            flt_20002814 = -2500.0;
            flt_200027F8 = 410.0;
            flt_200027FC = v69 * 8.2;
            sub_8029D38(&flt_200027F8);
            LODWORD(flt_200002F8) = dword_20001BE8;
            break;
          default:
            flt_20002810 = 300.0;
            flt_20002814 = -300.0;
            flt_200027F8 = flt_200002F8;
            LODWORD(flt_200027FC) = dword_20001BE8;
            sub_8029D38(&flt_200027F8);
            break;
        }
        if ( SLODWORD(flt_2000243C) < 1065353216 && LODWORD(flt_2000243C) < 0xBF800000 )
          dword_20002618 = LODWORD(flt_2000243C);
        if ( flt_20002450 < 0.0 )
          flt_20002458 = (float)(flt_20002804 * -1.4142) / *(float *)&dword_2000278C;
        if ( byte_200002C2 )
        {
          if ( SLODWORD(flt_20002458) <= 1101004800 )
          {
            if ( LODWORD(flt_20002458) <= 0xC185D8CA )
              flt_20002454 = flt_20002458;
            else
              flt_20002454 = -16.731;
          }
          else
          {
            flt_20002454 = 20.0;
          }
        }
        else if ( SLODWORD(flt_20002458) <= 1099290826 )
        {
          if ( LODWORD(flt_20002458) <= 0xC185D8CA )
            flt_20002454 = flt_20002458;
          else
            flt_20002454 = -16.731;
        }
        else
        {
          flt_20002454 = 16.731;
        }
      }
      if ( ++dword_20000378 >= 1000 )
      {
        if ( dword_20000328 > 0 )
          sub_8029658();
        flt_2000040C = 0.0;
        flt_20000410 = 0.0;
        flt_20000414 = 0.0;
        dword_20000328 = 0;
        dword_20000378 = 0;
      }
      sub_8029754();
      return;
  }
}
// 802B9A6: conditional instruction was optimized away because r1.4==CE
// 802B852: variable 'v2' is possibly undefined
// 802B852: variable 'v3' is possibly undefined
// 802B852: variable 'v4' is possibly undefined
// 802B856: variable 'v5' is possibly undefined
// 802B856: variable 'v6' is possibly undefined
// 802B856: variable 'v7' is possibly undefined
// 802B85A: variable 'v9' is possibly undefined
// 802B85A: variable 'v10' is possibly undefined
// 802CA50: variable 'v12' is possibly undefined
// 802CA5A: variable 'v26' is possibly undefined
// 802CA5A: variable 'v27' is possibly undefined
// 802CBEE: variable 'v29' is possibly undefined
// 802CC12: variable 'v30' is possibly undefined
// 802CC12: variable 'v31' is possibly undefined
// 802CC12: variable 'v32' is possibly undefined
// 802CD3A: variable 'v33' is possibly undefined
// 802DB02: variable 'v38' is possibly undefined
// 802DB02: variable 'v39' is possibly undefined
// 802DED4: variable 'v40' is possibly undefined
// 802DFBA: variable 'v41' is possibly undefined
// 802DFE8: variable 'v42' is possibly undefined
// 802DFE8: variable 'v43' is possibly undefined
// 802DFE8: variable 'v44' is possibly undefined
// 802E01E: variable 'v45' is possibly undefined
// 802E53A: variable 'v49' is possibly undefined
// 802E838: variable 'v53' is possibly undefined
// 802E838: variable 'v54' is possibly undefined
// 802E842: variable 'v55' is possibly undefined
// 802E842: variable 'v56' is possibly undefined
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 200002A4: using guessed type char byte_200002A4;
// 200002A5: using guessed type char byte_200002A5;
// 200002A6: using guessed type char byte_200002A6;
// 200002A7: using guessed type char byte_200002A7;
// 200002A8: using guessed type char byte_200002A8;
// 200002A9: using guessed type char byte_200002A9;
// 200002AA: using guessed type char byte_200002AA;
// 200002AB: using guessed type char byte_200002AB;
// 200002AE: using guessed type char byte_200002AE;
// 200002AF: using guessed type char byte_200002AF;
// 200002B0: using guessed type char byte_200002B0;
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200002B3: using guessed type char byte_200002B3;
// 200002B4: using guessed type char byte_200002B4;
// 200002B5: using guessed type char byte_200002B5;
// 200002B6: using guessed type char byte_200002B6;
// 200002B7: using guessed type char byte_200002B7;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002BB: using guessed type char byte_200002BB;
// 200002BC: using guessed type char byte_200002BC;
// 200002BD: using guessed type char byte_200002BD;
// 200002BE: using guessed type char byte_200002BE;
// 200002BF: using guessed type char byte_200002BF;
// 200002C0: using guessed type char byte_200002C0;
// 200002C2: using guessed type char byte_200002C2;
// 200002C4: using guessed type char byte_200002C4;
// 200002C5: using guessed type char byte_200002C5;
// 200002C6: using guessed type char byte_200002C6;
// 200002C7: using guessed type char byte_200002C7;
// 200002C8: using guessed type char byte_200002C8;
// 200002C9: using guessed type char byte_200002C9;
// 200002CA: using guessed type char byte_200002CA;
// 200002CB: using guessed type char byte_200002CB;
// 200002CC: using guessed type char byte_200002CC;
// 200002DC: using guessed type float flt_200002DC;
// 200002E0: using guessed type int dword_200002E0;
// 200002E8: using guessed type int dword_200002E8;
// 200002EC: using guessed type int dword_200002EC;
// 200002F4: using guessed type float flt_200002F4;
// 200002F8: using guessed type float flt_200002F8;
// 200002FC: using guessed type int dword_200002FC;
// 20000300: using guessed type int dword_20000300;
// 20000304: using guessed type float flt_20000304;
// 20000308: using guessed type float flt_20000308;
// 2000030C: using guessed type int dword_2000030C;
// 20000310: using guessed type float flt_20000310;
// 20000314: using guessed type float flt_20000314;
// 20000318: using guessed type float flt_20000318;
// 2000031C: using guessed type float flt_2000031C;
// 20000320: using guessed type int dword_20000320;
// 20000324: using guessed type float flt_20000324;
// 20000328: using guessed type int dword_20000328;
// 20000330: using guessed type float flt_20000330;
// 20000334: using guessed type float flt_20000334;
// 20000338: using guessed type float flt_20000338;
// 2000033C: using guessed type float flt_2000033C;
// 20000340: using guessed type int dword_20000340;
// 20000344: using guessed type float flt_20000344;
// 20000348: using guessed type float flt_20000348;
// 2000034C: using guessed type int dword_2000034C;
// 20000374: using guessed type int dword_20000374;
// 20000378: using guessed type int dword_20000378;
// 2000037C: using guessed type float flt_2000037C;
// 20000380: using guessed type int dword_20000380;
// 20000384: using guessed type int dword_20000384;
// 20000388: using guessed type int dword_20000388;
// 2000038C: using guessed type float flt_2000038C;
// 20000390: using guessed type float flt_20000390;
// 20000394: using guessed type float flt_20000394;
// 20000398: using guessed type float flt_20000398;
// 2000039C: using guessed type int dword_2000039C;
// 200003A0: using guessed type float flt_200003A0;
// 200003A4: using guessed type int dword_200003A4;
// 200003A8: using guessed type float flt_200003A8;
// 20000408: using guessed type float flt_20000408;
// 2000040C: using guessed type float flt_2000040C;
// 20000410: using guessed type float flt_20000410;
// 20000414: using guessed type float flt_20000414;
// 20000507: using guessed type char byte_20000507;
// 2000050C: using guessed type char byte_2000050C;
// 2000050E: using guessed type char byte_2000050E;
// 20000513: using guessed type __int16 word_20000513;
// 20000515: using guessed type __int16 word_20000515;
// 2000051A: using guessed type __int16 word_2000051A;
// 200008B9: using guessed type char byte_200008B9;
// 200008BC: using guessed type float flt_200008BC;
// 20001BE0: using guessed type int dword_20001BE0;
// 20001BE4: using guessed type int dword_20001BE4;
// 20001BE8: using guessed type int dword_20001BE8;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BF8: using guessed type float flt_20001BF8;
// 20001C04: using guessed type int dword_20001C04;
// 20001C08: using guessed type int dword_20001C08;
// 20001C0C: using guessed type int dword_20001C0C;
// 20001C14: using guessed type int dword_20001C14;
// 20001C18: using guessed type int dword_20001C18;
// 20001C1C: using guessed type int dword_20001C1C;
// 20002428: using guessed type __int16 word_20002428;
// 2000242C: using guessed type float flt_2000242C;
// 20002434: using guessed type float flt_20002434;
// 20002438: using guessed type float flt_20002438;
// 2000243C: using guessed type float flt_2000243C;
// 20002440: using guessed type float flt_20002440;
// 20002444: using guessed type float flt_20002444;
// 20002448: using guessed type float flt_20002448;
// 2000244C: using guessed type int dword_2000244C;
// 20002450: using guessed type float flt_20002450;
// 20002454: using guessed type float flt_20002454;
// 20002458: using guessed type float flt_20002458;
// 200025B0: using guessed type int dword_200025B0;
// 200025B4: using guessed type float flt_200025B4;
// 200025B8: using guessed type float flt_200025B8;
// 200025BC: using guessed type float flt_200025BC;
// 20002618: using guessed type int dword_20002618;
// 2000273C: using guessed type int dword_2000273C;
// 20002760: using guessed type float flt_20002760;
// 20002764: using guessed type int dword_20002764;
// 2000276C: using guessed type int dword_2000276C;
// 2000278C: using guessed type int dword_2000278C;
// 200027AC: using guessed type float flt_200027AC;
// 200027F8: using guessed type float flt_200027F8;
// 200027FC: using guessed type float flt_200027FC;
// 20002804: using guessed type float flt_20002804;
// 20002810: using guessed type float flt_20002810;
// 20002814: using guessed type float flt_20002814;
// 20002824: using guessed type float flt_20002824;
// 20002870: using guessed type float flt_20002870;
// 20002874: using guessed type float flt_20002874;
// 200028B8: using guessed type int dword_200028B8;
// 20002D60: using guessed type int dword_20002D60;
// 20002EAB: using guessed type char byte_20002EAB;
// 20003650: using guessed type float flt_20003650;
// 20003654: using guessed type float flt_20003654;
// 20003658: using guessed type float flt_20003658;
// 2000365C: using guessed type float flt_2000365C;
// 20003688: using guessed type float flt_20003688;
// 20003694: using guessed type float flt_20003694;
// 20003698: using guessed type float flt_20003698;
// 200036A0: using guessed type float flt_200036A0;
// 200036A4: using guessed type float flt_200036A4;
// 200036A8: using guessed type char byte_200036A8;
// 200036A9: using guessed type char byte_200036A9;

//----- (0802F2A4) --------------------------------------------------------
int sub_802F2A4()
{
  int result; // r0

  flt_200025BC = 50.0;
  flt_200025C0 = 51.8;
  flt_200025C4 = 47.1;
  sub_8030280((int)&unk_200027A0);
  sub_8029E98((int)flt_200027BC);
  sub_8030A7C();
  result = 2;
  byte_20000505 = 2;
  return result;
}
// 200002F4: using guessed type float flt_200002F4;
// 20000505: using guessed type char byte_20000505;
// 200025BC: using guessed type float flt_200025BC;
// 200025C0: using guessed type float flt_200025C0;
// 200025C4: using guessed type float flt_200025C4;
// 200027BC: using guessed type float flt_200027BC[5];

//----- (0802F324) --------------------------------------------------------
int sub_802F324()
{
  int result; // r0

  flt_200025BC = 60.0;
  flt_200025C0 = 61.8;
  flt_200025C4 = 57.0;
  sub_8030280((int)&unk_200027A0);
  sub_8029E98((int)flt_200027BC);
  sub_8030A7C();
  result = 3;
  byte_20000505 = 3;
  return result;
}
// 200002F4: using guessed type float flt_200002F4;
// 20000505: using guessed type char byte_20000505;
// 200025BC: using guessed type float flt_200025BC;
// 200025C0: using guessed type float flt_200025C0;
// 200025C4: using guessed type float flt_200025C4;
// 200027BC: using guessed type float flt_200027BC[5];

//----- (0802F3A4) --------------------------------------------------------
char *sub_802F3A4()
{
  float v0; // s0
  char *result; // r0

  result = &byte_200002A4;
  if ( (unsigned int)(LODWORD(v0) - 1050253723) >= 0xE66665 )
  {
    if ( (unsigned int)(LODWORD(v0) + 1097229925) >= 0xE66665 )
    {
      flt_20000304 = 0.0;
      flt_20000308 = 0.0;
    }
    else
    {
      flt_20000308 = v0;
    }
  }
  else
  {
    flt_20000308 = v0;
  }
  return result;
}
// 802F3AA: variable 'v0' is possibly undefined
// 200002A4: using guessed type char byte_200002A4;
// 20000304: using guessed type float flt_20000304;
// 20000308: using guessed type float flt_20000308;

//----- (0802F3F0) --------------------------------------------------------
int __fastcall sub_802F3F0(int a1)
{
  int result; // r0

  if ( a1 )
  {
    result = 1;
    byte_200002C3 = 1;
  }
  else
  {
    result = 0;
    byte_200002C3 = 0;
  }
  return result;
}
// 200002C3: using guessed type char byte_200002C3;

//----- (0802F408) --------------------------------------------------------
int __fastcall sub_802F408(int result, int a2)
{
  float v2; // s0
  float v3; // s1
  int v4; // r2
  float v5; // s3
  float v6; // s2
  float v7; // s0
  int v8; // s0

  v4 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v4;
  v5 = *(float *)(result + 16) + (float)(v2 * v2);
  *(float *)(result + 16) = v5;
  v6 = *(float *)(result + 24) + (float)(v2 * v3);
  *(float *)(result + 24) = v6;
  if ( a2 == 1 )
  {
    if ( *(_DWORD *)(result + 4) >= v4 || v4 >= *(_DWORD *)(result + 12) )
    {
      *(_DWORD *)(result + 32) = 0;
      *(float *)(result + 20) = 10.0;
    }
    else
    {
      v7 = v5 / (float)v4;
      if ( v7 < 0.0 )
        *(_DWORD *)(result + 20) = 0;
      else
        *(float *)(result + 20) = sqrtf(v7);
      *(float *)(result + 20) = *(float *)(result + 20) + 0.6;
      *(float *)&v8 = *(float *)(result + 28) + 1.0;
      *(float *)(result + 28) = *(float *)&v8;
      if ( v8 <= 1112014848 )
      {
        *(float *)(result + 36) = (float)(v6 / (float)v4) + *(float *)(result + 36);
      }
      else
      {
        *(_DWORD *)(result + 28) = 0;
        *(float *)(result + 32) = *(float *)(result + 36) * 0.02;
        *(_DWORD *)(result + 36) = 0;
      }
    }
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 24) = 0;
  }
  return result;
}
// 802F412: variable 'v2' is possibly undefined
// 802F41E: variable 'v3' is possibly undefined

//----- (0802F4E8) --------------------------------------------------------
_DWORD *__fastcall sub_802F4E8(_DWORD *result)
{
  float v1; // s0

  *result = 0;
  result[1] = (int)(float)(30000.0 / (float)(v1 + 25.0));
  result[2] = 0;
  result[3] = (int)(float)(30000.0 / (float)(v1 - 15.0));
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  return result;
}
// 802F4F4: variable 'v1' is possibly undefined

//----- (0802F544) --------------------------------------------------------
void sub_802F544()
{
  char v0; // r0
  char v1; // r1
  char v2; // r2
  char v3; // r0
  char v4; // r1
  char v5; // r2
  char v6; // r0
  char v7; // r1
  char v8; // r2
  int v9; // r0
  int v10; // r2
  char v11; // r0
  char v12; // r1
  char v13; // r2
  char v14; // r0
  char v15; // r1
  char v16; // r2
  int v17; // r2
  char v18; // r7
  char v19; // r1
  char v20; // r2
  char v21; // r0
  char v22; // r1
  char v23; // r2
  int v24; // r2
  char v25; // r0
  char v26; // r1
  char v27; // r2
  char v28; // r0
  char v29; // r1
  char v30; // r2
  int v31; // r2
  char v32; // r0
  char v33; // r1
  char v34; // r2
  char v35; // r0
  char v36; // r1
  char v37; // r2
  int v38; // r2
  int v39; // r1
  void *v40; // r2
  char v41; // r8
  char v42; // r1
  char v43; // r2
  char v44; // r0
  char v45; // r1
  char v46; // r2
  int v47; // r3
  char v48; // r3
  unsigned int v49; // r3
  int i; // r3
  int v51; // s0
  char v52; // r2
  char v53; // r0
  char v54; // r1
  char v55; // r2
  char v56; // r0
  char v57; // r1
  char v58; // r2
  int v59; // s0
  char v60; // r2

  if ( !byte_200002AB )
  {
    if ( flt_200025C4 >= flt_200002F4 || flt_200025C0 <= flt_200002F4 || dword_20000320 <= 1122893824 )
    {
      if ( --dword_200003C4 < 0 )
        dword_200003C4 = 0;
    }
    else if ( COERCE_INT(*(float *)&dword_20002604 - flt_200002F4) <= 0x40000000
           && COERCE_INT(flt_200002F4 - *(float *)&dword_20002604) <= 0x40000000 )
    {
      if ( --dword_200003C4 < 0 )
        dword_200003C4 = 0;
    }
    else if ( ++dword_200003C4 > 2000 )
    {
      sub_80303A4((int)flt_200025C8);
      v3 = sub_8029540(v0, v1, v2);
      v6 = sub_8029540(v3, v4, v5);
      sub_8029540(v6, v7, v8);
      sub_8029536();
      dword_200003C4 = 0;
    }
  }
  if ( byte_200002CD || byte_20000517 )
  {
    v9 = (unsigned __int8)byte_20002EAB;
    if ( byte_20002EAB == 2 )
    {
      if ( flt_200025C0 >= flt_200002F4 )
      {
        if ( flt_200025C4 <= flt_200002F4 )
        {
          dword_200003CC = 0;
        }
        else
        {
          v31 = ++dword_200003CC;
          if ( byte_200036A8 != 5 && v31 > 40 || v31 > 100 )
          {
            if ( byte_200002AB )
            {
              v32 = sub_8029540(byte_200002AB, (char)&flt_20003690, v31);
              v35 = sub_8029540(v32, v33, v34);
              sub_8029540(v35, v36, v37);
              sub_8029536();
              LOBYTE(dword_200028B4) = dword_200028B4 | 8;
            }
            dword_200003C0 = 0;
            byte_200002AB = 0;
            return;
          }
        }
      }
      else
      {
        v24 = ++dword_200003CC;
        if ( byte_200036A8 != 5 && v24 > 40 || v24 > 400 )
        {
          if ( byte_200002AB )
          {
            v25 = sub_8029540(byte_200002AB, (char)&flt_20003690, v24);
            v28 = sub_8029540(v25, v26, v27);
            sub_8029540(v28, v29, v30);
            sub_8029536();
            LOBYTE(dword_200028B4) = dword_200028B4 | 4;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
      }
      if ( *(float *)&dword_20002604 <= (float)(flt_200025C0 + 1.0)
        && *(float *)&dword_20002604 >= (float)(flt_200025C4 - 1.0) )
      {
        dword_200003C8 = 0;
      }
      else
      {
        v38 = dword_200003C8 + 1;
        dword_200003C8 = v38;
        if ( v38 > 40 )
        {
          if ( byte_200002AB )
          {
            sub_8029540(byte_200002AB, (char)&flt_20003690, v38);
            sub_8029536();
            BYTE1(dword_200028B4) = 1;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
      }
    }
    else if ( flt_200025C0 >= flt_200002F4 )
    {
      if ( flt_200025C4 <= flt_200002F4 )
      {
        dword_200003CC = 0;
      }
      else
      {
        v17 = dword_200003CC + 1;
        dword_200003CC = v17;
        if ( v17 > 100 )
        {
          if ( byte_200002AB )
          {
            v18 = sub_8029540(byte_200002AB, (char)&flt_20003690, v17);
            v21 = sub_8029540(v18, v19, v20);
            sub_8029540(v21, v22, v23);
            sub_8029536();
            LOBYTE(dword_200028B4) = dword_200028B4 | 8;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
      }
    }
    else
    {
      v10 = dword_200003CC + 1;
      dword_200003CC = v10;
      if ( v10 > 100 )
      {
        if ( byte_200002AB )
        {
          v11 = sub_8029540(byte_200002AB, (char)&flt_20003690, v10);
          v14 = sub_8029540(v11, v12, v13);
          sub_8029540(v14, v15, v16);
          sub_8029536();
          LOBYTE(dword_200028B4) = dword_200028B4 | 4;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    v39 = (unsigned __int8)byte_200036A8;
    v40 = &unk_2000364C;
    if ( byte_200036A8 == 6 )
    {
      if ( *(float *)&dword_2000278C <= flt_20003668
        && *(float *)&dword_2000278C >= flt_2000366C
        && flt_20003670 >= flt_200002F4
        && flt_20003674 <= flt_200002F4 )
      {
        if ( --dword_200003D0 < 0 )
          dword_200003D0 = 0;
      }
      else
      {
        ++dword_200003D0;
        dword_200003C0 = 0;
      }
      if ( dword_2000368C < (unsigned int)dword_200003D0 )
      {
        if ( byte_200002AB )
        {
          sub_8029540(byte_200002AB, 6, (char)&unk_2000364C);
          sub_8029536();
          LOBYTE(dword_200028B4) = dword_200028B4 | 1;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200036A8 == 10 )
    {
      if ( *(float *)&dword_2000278C >= flt_2000366C )
      {
        if ( *(float *)&dword_2000278C <= flt_2000367C )
        {
          if ( *(float *)&dword_2000278C <= flt_20003668 )
          {
            if ( flt_20003670 >= flt_200002F4 )
            {
              if ( flt_20003684 <= flt_200002F4 )
              {
                if ( flt_20003674 <= flt_200002F4 )
                {
                  dword_200003D4 -= 4;
                  if ( dword_200003D4 < 0 )
                    dword_200003D4 = 0;
                }
                else
                {
                  ++dword_200003D4;
                  dword_200003C0 = 0;
                }
              }
              else
              {
                dword_200003D4 += 40;
                dword_200003C0 = 0;
              }
            }
            else
            {
              dword_200003D4 += 40;
              dword_200003C0 = 0;
            }
          }
          else
          {
            dword_200003D4 += 20;
            dword_200003C0 = 0;
          }
        }
        else
        {
          dword_200003D4 += 40;
          dword_200003C0 = 0;
        }
      }
      else
      {
        dword_200003D4 += 40;
        dword_200003C0 = 0;
      }
      if ( dword_200003D4 > 20000 )
      {
        if ( byte_200002AB )
        {
          v41 = sub_8029540(byte_200002AB, 10, (char)&unk_2000364C);
          sub_8029540(v41, v42, v43);
          sub_8029536();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200036A8 == 14 )
    {
      if ( flt_20003670 >= flt_200002F4 )
      {
        if ( flt_20003674 <= flt_200002F4 )
        {
          if ( *(float *)&dword_2000278C <= flt_20003668 )
          {
            if ( *(float *)&dword_2000278C >= flt_20003680 )
            {
              if ( *(float *)&dword_2000278C >= flt_2000366C )
              {
                dword_200003D8 -= 4;
                if ( dword_200003D8 < 0 )
                  dword_200003D8 = 0;
              }
              else
              {
                ++dword_200003D8;
                dword_200003C0 = 0;
              }
            }
            else
            {
              dword_200003D8 += 10;
              dword_200003C0 = 0;
            }
          }
          else
          {
            dword_200003D8 += 30;
            dword_200003C0 = 0;
          }
        }
        else
        {
          dword_200003D8 += 30;
          dword_200003C0 = 0;
        }
      }
      else
      {
        dword_200003D8 += 30;
        dword_200003C0 = 0;
      }
      if ( dword_200003D8 > 3000 )
      {
        if ( byte_200002AB )
        {
          v44 = sub_8029540(byte_200002AB, 14, (char)&unk_2000364C);
          sub_8029540(v44, v45, v46);
          sub_8029536();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200036A8 == 7 )
    {
      v47 = dword_200003DC++;
      if ( v47 > 9998 )
      {
        dword_200003DC = 0;
        v48 = byte_200002C1;
        LODWORD(flt_2000245C[(unsigned __int8)byte_200002C1]) = dword_2000278C;
        v49 = (unsigned __int8)(v48 + 1);
        byte_200002C1 = v49;
        if ( v49 >= 0x3C )
          byte_200002C1 = 0;
        dword_2000032C = 0;
        for ( i = 0; i < 60; ++i )
          *(float *)&dword_2000032C = flt_2000245C[i] + *(float *)&dword_2000032C;
      }
      if ( (float)(flt_20003678 * 60.0) < *(float *)&dword_2000032C )
      {
        byte_200002AB = 0;
        dword_200003C0 = 0;
      }
    }
    if ( v39 == 8 )
    {
      if ( (unsigned int)(dword_2000278C - 1129250817) >= 0x2DFFFF
        || SLODWORD(flt_200002F4) <= 1111975526
        || SLODWORD(flt_200002F4) >= 1112054170 )
      {
        dword_200003E0 = 0;
      }
      else
      {
        ++dword_200003E0;
        dword_200003C0 = 0;
      }
      LOBYTE(v40) = dword_20003660;
      if ( dword_20003660 >= (unsigned int)dword_200003E0 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E0 = dword_20003660;
        byte_200002C4 = 1;
      }
    }
    if ( v39 == 15 )
    {
      if ( (unsigned int)(dword_2000278C - 1128497153) >= 0x397FFF
        || SLODWORD(flt_200002F4) <= 1111359488
        || SLODWORD(flt_200002F4) >= 1112041062 )
      {
        dword_200003E4 = 0;
      }
      else
      {
        ++dword_200003E4;
        dword_200003C0 = 0;
      }
      LOBYTE(v40) = 72;
      if ( dword_200003E4 <= 61000 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E4 = 61000;
        byte_200002C4 = 1;
      }
    }
    if ( v39 == 11 )
    {
      if ( (unsigned int)(dword_2000278C - 1128536475) >= 0x40FFFF
        || SLODWORD(flt_200002F4) <= 1111333274
        || SLODWORD(flt_200002F4) >= 1112565350 )
      {
        dword_200003E8 = 0;
      }
      else
      {
        ++dword_200003E8;
        dword_200003C0 = 0;
      }
      LOBYTE(v40) = 8;
      if ( dword_200003E8 <= 21000 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E8 = 21000;
        byte_200002C4 = 1;
      }
    }
    if ( v39 != 5 )
    {
      if ( v39 != 14 )
      {
        if ( dword_2000278C > 1133412352 )
        {
          if ( byte_200002AB )
          {
            sub_8029540(byte_200002AB, dword_2000278C, 0);
            sub_8029536();
            LOBYTE(dword_200028B4) = dword_200028B4 | 1;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
        if ( dword_2000278C < 1126825984 )
        {
          if ( byte_200002AB )
          {
            sub_8029540(byte_200002AB, dword_2000278C, 0);
            sub_8029536();
            LOBYTE(dword_200028B4) = dword_200028B4 | 2;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
        if ( v9 != 2 )
        {
          *(float *)&v51 = *(float *)&dword_20001BE0
                         - (float)((float)(*(float *)&dword_2000278C * 1.4142) * *(float *)&dword_20002624);
          sub_80296B4();
          if ( v51 <= 1117782016 )
          {
            dword_200003BC = 0;
          }
          else if ( ++dword_200003BC > 4 )
          {
            if ( byte_200002AB )
            {
              v53 = sub_8029540(byte_200002AB, 0, v52);
              v56 = sub_8029540(v53, v54, v55);
              sub_8029540(v56, v57, v58);
              sub_8029536();
              LOBYTE(dword_200028B4) = dword_200028B4 | 0x80;
            }
            dword_200003C0 = 0;
            byte_200002AB = 0;
            return;
          }
        }
      }
      goto LABEL_189;
    }
    if ( (unsigned int)(dword_2000278C - 1083388723) >= 0x3024CCE )
    {
      if ( byte_200002AB )
      {
        sub_8029540(byte_200002AB, 206, (char)v40);
        sub_8029536();
      }
      dword_200003C0 = 0;
      byte_200002AB = 0;
      dword_200003EC = 0;
      return;
    }
    if ( (unsigned int)(dword_2000278C - 1127592756) < 0x50D999 )
    {
      if ( dword_2000278C >= 1128346419 )
      {
        dword_200003EC = 0;
        dword_2000030C = 1.0;
      }
      else
      {
        ++dword_200003EC;
        dword_2000030C = 0;
      }
    }
    else
    {
      ++dword_200003EC;
      dword_2000030C = 0;
    }
    if ( dword_2000278C < 1128044953
      && (float)((float)((float)((float)(*(float *)&dword_2000278C / 230.0) - 0.02) * 4071.4) + 320.0) < (float)dword_200003EC )
    {
      if ( byte_200002AB )
      {
        sub_8029540(byte_200002AB, 153, (char)v40);
        sub_8029536();
      }
      dword_200003C0 = 0;
      byte_200002AB = 0;
      dword_200003EC = 0;
      return;
    }
    if ( dword_2000278C > 1133343539 )
    {
      if ( dword_200003EC > 300 )
      {
        if ( byte_200002AB )
        {
          sub_8029540(byte_200002AB, 51, (char)v40);
          sub_8029536();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        dword_200003EC = 0;
        return;
      }
LABEL_189:
      v59 = dword_20001BE0;
      sub_80296B4();
      if ( v59 <= 1138163712 )
      {
        if ( dword_200003C0 >= 1000 )
        {
          if ( !byte_200002AB )
          {
            sub_8029536();
            byte_200002AB = 1;
            dword_200028B4 &= 0xFFFF0000;
          }
        }
        else
        {
          ++dword_200003C0;
        }
      }
      else
      {
        if ( byte_200002AB )
        {
          sub_8029540(byte_200002AB, 0, v60);
          sub_8029536();
          LOBYTE(dword_200028B4) = dword_200028B4 | 0x10;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
      }
      return;
    }
    if ( dword_2000278C <= 1132891340 || dword_200003EC <= 5500 )
      goto LABEL_189;
    if ( byte_200002AB )
    {
      sub_8029540(byte_200002AB, 124, (char)v40);
      sub_8029536();
    }
    dword_200003C0 = 0;
    byte_200002AB = 0;
    dword_200003EC = 0;
  }
  else
  {
    if ( dword_2000278C > 1126825984 )
    {
      if ( (unsigned int)(LODWORD(flt_200002F4) - 1113849857) >= 0x17FFFF )
      {
        if ( (unsigned int)(LODWORD(flt_200002F4) - 1111228417) < 0x17FFFF )
          --dword_200003B8;
      }
      else
      {
        ++dword_200003B8;
      }
    }
    if ( dword_200003B8 <= 1000 )
    {
      if ( dword_200003B8 < -1000 )
      {
        sub_802F2A4();
        sub_8029536();
        byte_200002CD = 1;
      }
    }
    else
    {
      sub_802F324();
      sub_8029536();
      byte_200002CD = 1;
    }
  }
}
// 802F5C6: variable 'v0' is possibly undefined
// 802F5C6: variable 'v1' is possibly undefined
// 802F5C6: variable 'v2' is possibly undefined
// 802F5D0: variable 'v4' is possibly undefined
// 802F5D0: variable 'v5' is possibly undefined
// 802F5DA: variable 'v7' is possibly undefined
// 802F5DA: variable 'v8' is possibly undefined
// 802F65A: variable 'v12' is possibly undefined
// 802F65A: variable 'v13' is possibly undefined
// 802F664: variable 'v15' is possibly undefined
// 802F664: variable 'v16' is possibly undefined
// 802F714: variable 'v19' is possibly undefined
// 802F714: variable 'v20' is possibly undefined
// 802F71E: variable 'v22' is possibly undefined
// 802F71E: variable 'v23' is possibly undefined
// 802F784: variable 'v26' is possibly undefined
// 802F784: variable 'v27' is possibly undefined
// 802F78E: variable 'v29' is possibly undefined
// 802F78E: variable 'v30' is possibly undefined
// 802F7E0: variable 'v33' is possibly undefined
// 802F7E0: variable 'v34' is possibly undefined
// 802F7EA: variable 'v36' is possibly undefined
// 802F7EA: variable 'v37' is possibly undefined
// 802F9E0: variable 'v42' is possibly undefined
// 802F9E0: variable 'v43' is possibly undefined
// 802FAA2: variable 'v45' is possibly undefined
// 802FAA2: variable 'v46' is possibly undefined
// 802FDC0: variable 'v52' is possibly undefined
// 802FDCA: variable 'v54' is possibly undefined
// 802FDCA: variable 'v55' is possibly undefined
// 802FDD4: variable 'v57' is possibly undefined
// 802FDD4: variable 'v58' is possibly undefined
// 802FE14: variable 'v60' is possibly undefined
// 200002AB: using guessed type char byte_200002AB;
// 200002C1: using guessed type char byte_200002C1;
// 200002C4: using guessed type char byte_200002C4;
// 200002CD: using guessed type char byte_200002CD;
// 200002F4: using guessed type float flt_200002F4;
// 2000030C: using guessed type int dword_2000030C;
// 20000320: using guessed type int dword_20000320;
// 2000032C: using guessed type int dword_2000032C;
// 200003B8: using guessed type int dword_200003B8;
// 200003BC: using guessed type int dword_200003BC;
// 200003C0: using guessed type int dword_200003C0;
// 200003C4: using guessed type int dword_200003C4;
// 200003C8: using guessed type int dword_200003C8;
// 200003CC: using guessed type int dword_200003CC;
// 200003D0: using guessed type int dword_200003D0;
// 200003D4: using guessed type int dword_200003D4;
// 200003D8: using guessed type int dword_200003D8;
// 200003DC: using guessed type int dword_200003DC;
// 200003E0: using guessed type int dword_200003E0;
// 200003E4: using guessed type int dword_200003E4;
// 200003E8: using guessed type int dword_200003E8;
// 200003EC: using guessed type int dword_200003EC;
// 20000517: using guessed type char byte_20000517;
// 20001BE0: using guessed type int dword_20001BE0;
// 2000245C: using guessed type float flt_2000245C[60];
// 200025BC: using guessed type float flt_200025BC;
// 200025C0: using guessed type float flt_200025C0;
// 200025C4: using guessed type float flt_200025C4;
// 200025C8: using guessed type float flt_200025C8[15];
// 20002604: using guessed type int dword_20002604;
// 20002624: using guessed type int dword_20002624;
// 2000278C: using guessed type int dword_2000278C;
// 200028B4: using guessed type int dword_200028B4;
// 20002EAB: using guessed type char byte_20002EAB;
// 20003660: using guessed type int dword_20003660;
// 20003668: using guessed type float flt_20003668;
// 2000366C: using guessed type float flt_2000366C;
// 20003670: using guessed type float flt_20003670;
// 20003674: using guessed type float flt_20003674;
// 20003678: using guessed type float flt_20003678;
// 2000367C: using guessed type float flt_2000367C;
// 20003680: using guessed type float flt_20003680;
// 20003684: using guessed type float flt_20003684;
// 2000368C: using guessed type int dword_2000368C;
// 20003690: using guessed type float flt_20003690;
// 200036A8: using guessed type char byte_200036A8;

//----- (0802FEF0) --------------------------------------------------------
int __fastcall sub_802FEF0(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073875968 )
  {
    MEMORY[0x40021048] |= 8u;
    return MEMORY[0x40021048] & 8;
  }
  return result;
}

//----- (0802FF18) --------------------------------------------------------
int __fastcall sub_802FF18(int a1, char a2, char a3)
{
  sub_8029540((char)&dword_20001BE0, a2, a3);
  sub_8029536();
  if ( (unsigned __int8)byte_200002BB << 31 )
    LOBYTE(dword_200028B8) = dword_200028B8 | 2;
  if ( (byte_200002BB & 2) != 0 )
    LOBYTE(dword_200028B8) = dword_200028B8 | 8;
  if ( (byte_200002BB & 4) != 0 )
    LOBYTE(dword_200028B8) = dword_200028B8 | 4;
  if ( (byte_200002BB & 8) != 0 )
    LOBYTE(dword_200028B8) = dword_200028B8 | 1;
  LOBYTE(dword_200028B8) = dword_200028B8 | 0x10;
  byte_200002BB = 0;
  sub_8030AE4(23);
  return sub_8030AE4(40);
}
// 200002BB: using guessed type char byte_200002BB;
// 20001BE0: using guessed type int dword_20001BE0;
// 20001BE4: using guessed type int dword_20001BE4;
// 200028B8: using guessed type int dword_200028B8;

//----- (0802FF90) --------------------------------------------------------
char *__fastcall sub_802FF90(char *result)
{
  int v1; // r1

  if ( (unsigned int)result < 4 )
  {
    v1 = 1 << (char)result;
    result = &byte_200002A4;
    byte_200002BB |= v1;
  }
  return result;
}
// 200002A4: using guessed type char byte_200002A4;
// 200002BB: using guessed type char byte_200002BB;

//----- (0802FFA8) --------------------------------------------------------
void __fastcall sub_802FFA8(int a1, int a2, char a3)
{
  if ( byte_200002B2 )
  {
    if ( dword_20001BE8 < 1135214592 )
    {
      sub_8029540(dword_20001BE8, 0, a3);
      sub_8029536();
      dword_200003F4 = 0;
      byte_200002B2 = 0;
    }
  }
  else
  {
    if ( dword_20001BE8 < 1135706112 )
      dword_200003F4 = 0;
    if ( ++dword_200003F4 >= 1000 )
    {
      sub_8029536();
      byte_200002B2 = 1;
    }
  }
  if ( byte_200002B1 )
  {
    if ( dword_20001BE8 > 1140981760 )
    {
      sub_8029540(dword_20001BE8, 0, a3);
      sub_8029536();
      dword_200003F0 = 0;
      byte_200002B1 = 0;
    }
  }
  else
  {
    if ( dword_20001BE8 > 1139802112 )
      dword_200003F0 = 0;
    if ( ++dword_200003F0 >= 1000 )
    {
      sub_8029536();
      byte_200002B1 = 1;
    }
  }
}
// 8030020: variable 'a3' is possibly undefined
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200003F0: using guessed type int dword_200003F0;
// 200003F4: using guessed type int dword_200003F4;
// 20001BE8: using guessed type int dword_20001BE8;

//----- (08030078) --------------------------------------------------------
float *sub_8030078()
{
  float *result; // r0

  dword_20000300 = 0;
  flt_20000304 = 0.0;
  flt_2000243C = 0.0;
  flt_20002454 = 0.0;
  flt_20000324 = 2500.0;
  dword_200002E4 = 0;
  byte_200002B8 = 0;
  byte_200002B9 = 0;
  dword_200002F0 = 0;
  byte_200002BA = 0;
  flt_200002D0 = 0.0;
  flt_200002D4 = 0.0;
  flt_20002440 = 0.0;
  flt_20002444 = 0.0;
  flt_20002448 = 0.0;
  dword_2000244C = 0;
  flt_20002450 = 0.0;
  flt_20002458 = 0.0;
  dword_20001C10 = 0;
  sub_8029DAC(&flt_200027F8);
  sub_8029DAC(&flt_20002858);
  result = &flt_200027F8;
  flt_20002810 = 100.0;
  return result;
}
// 200002B8: using guessed type char byte_200002B8;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002D0: using guessed type float flt_200002D0;
// 200002D4: using guessed type float flt_200002D4;
// 200002E4: using guessed type int dword_200002E4;
// 200002F0: using guessed type int dword_200002F0;
// 20000300: using guessed type int dword_20000300;
// 20000304: using guessed type float flt_20000304;
// 20000324: using guessed type float flt_20000324;
// 20001C10: using guessed type int dword_20001C10;
// 2000243C: using guessed type float flt_2000243C;
// 20002440: using guessed type float flt_20002440;
// 20002444: using guessed type float flt_20002444;
// 20002448: using guessed type float flt_20002448;
// 2000244C: using guessed type int dword_2000244C;
// 20002450: using guessed type float flt_20002450;
// 20002454: using guessed type float flt_20002454;
// 20002458: using guessed type float flt_20002458;
// 200027F8: using guessed type float flt_200027F8;
// 20002810: using guessed type float flt_20002810;
// 20002858: using guessed type float flt_20002858;

//----- (08030108) --------------------------------------------------------
int __fastcall sub_8030108(int a1, int a2, char a3)
{
  int result; // r0
  float v4; // s1
  char v5; // r0
  char v6; // r1
  char v7; // r2
  char v8; // r0
  char v9; // r1
  char v10; // r2

  result = (unsigned __int8)byte_200002C2;
  if ( !byte_200002C2 )
  {
    v4 = flt_2000275C;
    if ( flt_2000275C <= flt_20002760 )
      v4 = flt_20002760;
    if ( v4 <= 14.67 )
    {
      if ( v4 <= 13.58 )
      {
        if ( v4 <= 11.95 )
        {
          if ( v4 <= 9.0 )
          {
            if ( v4 <= 4.5 )
              dword_200002E4 -= 1800;
            else
              dword_200002E4 -= 240;
          }
          else
          {
            --dword_200002E4;
          }
        }
        else
        {
          ++dword_200002E4;
        }
      }
      else
      {
        dword_200002E4 += 10;
      }
    }
    else
    {
      dword_200002E4 += 60;
    }
    if ( dword_200002E4 >= 0 )
    {
      if ( dword_200002E4 > 600000 )
      {
        dword_200002E4 = 600000;
        if ( !byte_200002B9 )
        {
          v5 = sub_8029540(0, 192, a3);
          sub_8029540(v5, v6, v7);
          sub_8029536();
          byte_200002B9 = 1;
        }
      }
    }
    else
    {
      dword_200002E4 = 0;
      byte_200002B9 = 0;
    }
    if ( dword_200002E4 <= 60000 )
    {
      byte_200002B8 = 0;
    }
    else
    {
      byte_200002B8 = 1;
      sub_8029662();
    }
    if ( byte_200002A4 == 4 )
    {
      if ( dword_20002768 >= 1129250816 )
      {
        if ( --dword_200002F0 < 0 )
          dword_200002F0 = 0;
      }
      else if ( dword_200002F0 <= 200 )
      {
        ++dword_200002F0;
      }
      else if ( !byte_200002BA )
      {
        v8 = sub_8029540(0, 0, a3);
        sub_8029540(v8, v9, v10);
        sub_8029536();
        byte_200002BA = 1;
      }
    }
    if ( byte_200002BA == 1 || byte_200002B9 == 1 )
    {
      result = (unsigned __int8)byte_200002AD;
      if ( byte_200002AD == 1 )
      {
        byte_200002AD = 0;
        byte_200002AE = 1;
      }
    }
    else
    {
      result = dword_200002F0 | dword_200002E4;
      if ( !(dword_200002F0 | dword_200002E4) )
      {
        byte_200002BA = 0;
        byte_200002B9 = 0;
        byte_200002AD = 1;
      }
    }
  }
  return result;
}
// 80301C0: variable 'v6' is possibly undefined
// 80301C0: variable 'v7' is possibly undefined
// 8030204: variable 'a3' is possibly undefined
// 8030212: variable 'v9' is possibly undefined
// 8030212: variable 'v10' is possibly undefined
// 200002A4: using guessed type char byte_200002A4;
// 200002AD: using guessed type char byte_200002AD;
// 200002AE: using guessed type char byte_200002AE;
// 200002B8: using guessed type char byte_200002B8;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002C2: using guessed type char byte_200002C2;
// 200002E4: using guessed type int dword_200002E4;
// 200002F0: using guessed type int dword_200002F0;
// 2000275C: using guessed type float flt_2000275C;
// 20002760: using guessed type float flt_20002760;
// 20002768: using guessed type int dword_20002768;

//----- (08030280) --------------------------------------------------------
int __fastcall sub_8030280(int result)
{
  float v1; // s0
  float v2; // s1

  *(float *)result = v1;
  *(float *)(result + 4) = (float)(v1 * 2.0) / v2;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  return result;
}
// 8030280: variable 'v1' is possibly undefined
// 803028C: variable 'v2' is possibly undefined

//----- (080302B0) --------------------------------------------------------
int __fastcall sub_80302B0(int a1)
{
  float v1; // s0
  int v2; // s0
  int result; // r0
  _DWORD *v4; // r3

  v1 = *(float *)(a1 + 8) + *(float *)(a1 + 4);
  *(float *)(a1 + 8) = v1;
  if ( *(_DWORD *)(a1 + 24) && SLODWORD(v1) > 1065353216 )
  {
    *(_DWORD *)(a1 + 20) = 1;
    *(_DWORD *)(a1 + 24) = 0;
  }
  else if ( SLODWORD(v1) <= 0x40000000 )
  {
    *(_DWORD *)(a1 + 20) = 0;
  }
  else
  {
    *(float *)(a1 + 8) = v1 - 2.0;
    *(_DWORD *)(a1 + 24) = 1;
  }
  v2 = *(_DWORD *)(a1 + 8);
  sub_8029B7C();
  result = sub_8030BA8(dword_20000424);
  v4[3] = v2;
  v4[4] = v4[2];
  return result;
}
// 803030A: variable 'v4' is possibly undefined
// 20000424: using guessed type int dword_20000424;

//----- (0803031C) --------------------------------------------------------
float *__fastcall sub_803031C(float *result)
{
  float v1; // s0
  float v2; // s0
  float v3; // s2
  float v4; // s0
  float v5; // s1
  float v6; // s0

  v2 = v1 * 6.2832;
  v3 = v2 * 0.000033333;
  v4 = (float)((float)(v2 * 0.000033333) * v2) * 0.000033333;
  v5 = 1.0 / (float)((float)(v3 + v4) + 4.0);
  result[25] = v3 * v5;
  result[26] = -(float)(v3 * v5);
  result[27] = (float)((float)(4.0 - v4) * 2.0) * v5;
  result[28] = (float)((float)(v3 - v4) - 4.0) * v5;
  v6 = (float)(v4 * 0.5) * v5;
  result[29] = v6;
  result[30] = v6 * 2.0;
  result[31] = v6;
  return result;
}
// 8030324: variable 'v1' is possibly undefined

//----- (080303A4) --------------------------------------------------------
void __fastcall sub_80303A4(int a1)
{
  int v1; // s0

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = v1;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 132) = 1126627692;
  *(_DWORD *)(a1 + 128) = -1020902375;
  *(float *)(a1 + 136) = -1.0;
  *(_DWORD *)(a1 + 96) = 940298085;
  sub_8030BE0();
}
// 80303E8: variable 'v1' is possibly undefined

//----- (0803043C) --------------------------------------------------------
int __fastcall sub_803043C(int result)
{
  float v1; // s0

  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(_DWORD *)(result + 92) = 0;
  *(_DWORD *)(result + 96) = 1001099969;
  *(_DWORD *)(result + 108) = 970045207;
  *(_DWORD *)(result + 104) = 981668463;
  *(_DWORD *)(result + 112) = 1110704128;
  *(_DWORD *)(result + 72) = 0;
  *(_DWORD *)(result + 76) = 0;
  *(_DWORD *)(result + 128) = 0;
  *(_DWORD *)(result + 132) = 0;
  *(_DWORD *)(result + 136) = 0;
  *(float *)(result + 140) = v1 + 0.011;
  *(_DWORD *)(result + 144) = 0;
  *(_DWORD *)(result + 148) = 0;
  *(_DWORD *)(result + 152) = 0;
  *(_DWORD *)(result + 156) = 0;
  *(_DWORD *)(result + 160) = 0;
  *(_DWORD *)(result + 168) = 0;
  *(_DWORD *)(result + 164) = 0;
  *(_DWORD *)(result + 208) = 1126627692;
  *(_DWORD *)(result + 204) = -1020902375;
  *(float *)(result + 212) = -1.0;
  *(_DWORD *)(result + 172) = 940298085;
  return result;
}
// 80304A4: variable 'v1' is possibly undefined

//----- (08030510) --------------------------------------------------------
int __fastcall sub_8030510(float *a1)
{
  float v1; // s0
  float v2; // s5
  float v3; // s3
  float v4; // s4
  float v5; // s2
  float v6; // s1
  float v7; // s6
  float v8; // s2
  float v9; // s5
  float v10; // s2
  float v11; // s0
  int v12; // s1
  float v13; // s1
  float v14; // s0
  int v15; // s0
  int v16; // s0
  int v17; // r3
  int v18; // r3
  float v19; // s0
  int v20; // s0
  int result; // r0
  int v22; // r3

  *a1 = v1;
  v2 = a1[2];
  v3 = a1[27];
  v4 = a1[28];
  v5 = a1[4];
  v6 = (float)((float)((float)(v1 - v2) * a1[25]) + (float)(v3 * v5)) + (float)(v4 * a1[5]);
  a1[3] = v6;
  a1[5] = v5;
  a1[4] = v6;
  v7 = a1[1];
  v8 = (float)((float)(a1[29] * v1) + (float)(a1[30] * v7)) + (float)(a1[31] * v2);
  v9 = a1[7];
  v10 = (float)(v8 + (float)(v3 * v9)) + (float)(v4 * a1[8]);
  a1[6] = v10;
  a1[8] = v9;
  a1[7] = v10;
  a1[2] = v7;
  a1[1] = v1;
  v11 = (float)(a1[22] * v6) + (float)(a1[23] * v10);
  a1[9] = v11;
  *(float *)&v12 = (float)(a1[14] + (float)(a1[33] * v11)) + (float)(a1[32] * a1[10]);
  a1[13] = *(float *)&v12;
  if ( v12 > 1106247680 )
    a1[13] = 30.0;
  if ( *((_DWORD *)a1 + 13) > 0xC1F00000 )
    a1[13] = -30.0;
  v13 = a1[13];
  a1[14] = v13;
  a1[10] = v11;
  v14 = a1[16] + v13;
  a1[15] = v14;
  *(float *)&v15 = a1[18] + (float)((float)(v14 * a1[24]) * 2.0);
  a1[17] = *(float *)&v15;
  if ( v15 > 0x40000000 )
    a1[17] = 0.0;
  v16 = *((_DWORD *)a1 + 17);
  *((_DWORD *)a1 + 18) = v16;
  sub_8029B7C();
  sub_8030BA8(dword_20000424);
  *(_DWORD *)(v17 + 92) = v16;
  sub_8030BA8(dword_20000428);
  *(_DWORD *)(v18 + 88) = v16;
  v19 = *(float *)(v18 + 72) + *(float *)(v18 + 80);
  *(float *)(v18 + 76) = v19;
  if ( SLODWORD(v19) <= 0x40000000 )
  {
    if ( v19 < 0.0 )
      *(float *)(v18 + 76) = v19 + 2.0;
  }
  else
  {
    *(float *)(v18 + 76) = v19 - 2.0;
  }
  v20 = *(_DWORD *)(v18 + 76);
  sub_8029B7C();
  result = sub_8030BA8(dword_20000424);
  *(_DWORD *)(v22 + 84) = v20;
  return result;
}
// 8030514: variable 'v1' is possibly undefined
// 8030636: variable 'v17' is possibly undefined
// 8030640: variable 'v18' is possibly undefined
// 8030686: variable 'v22' is possibly undefined
// 20000424: using guessed type int dword_20000424;
// 20000428: using guessed type int dword_20000428;

//----- (0803069C) --------------------------------------------------------
int __fastcall sub_803069C(int a1, int a2)
{
  float v2; // s0
  float v3; // s1
  float v4; // s2
  float v5; // s11
  float v6; // s5
  float v7; // s6
  float v8; // s7
  float v9; // s3
  float v10; // s4
  float v11; // s10
  float v12; // s8
  float v13; // s12
  float v14; // s9
  float v15; // s3
  float v16; // s11
  float v17; // s3
  float v18; // s11
  float v19; // s0
  float v20; // s5
  float v21; // s0
  float v22; // s10
  float v23; // s0
  float v24; // s8
  float v25; // s0
  float v26; // s7
  float v27; // s1
  float v28; // s6
  float v29; // s5
  float v30; // s0
  int v31; // s1
  float v32; // s1
  float v33; // s0
  int v34; // s0
  int v35; // s0
  int v36; // r3
  int v37; // r1
  int result; // r0
  int v39; // r3

  *(float *)a1 = v2;
  v5 = *(float *)(a1 + 8);
  v6 = *(float *)(a1 + 176);
  v7 = *(float *)(a1 + 184);
  v8 = *(float *)(a1 + 188);
  v9 = *(float *)(a1 + 28);
  v10 = (float)((float)((float)(v2 - v5) * v6) + (float)(v7 * v9)) + (float)(v8 * *(float *)(a1 + 32));
  *(float *)(a1 + 24) = v10;
  *(float *)(a1 + 32) = v9;
  *(float *)(a1 + 28) = v10;
  v11 = *(float *)(a1 + 192);
  v12 = *(float *)(a1 + 196);
  v13 = *(float *)(a1 + 4);
  v14 = *(float *)(a1 + 200);
  v15 = (float)((float)(v11 * v2) + (float)(v12 * v13)) + (float)(v14 * v5);
  v16 = *(float *)(a1 + 40);
  v17 = (float)(v15 + (float)(v7 * v16)) + (float)(v8 * *(float *)(a1 + 44));
  *(float *)(a1 + 36) = v17;
  *(float *)(a1 + 44) = v16;
  *(float *)(a1 + 40) = v17;
  *(float *)(a1 + 8) = v13;
  *(float *)(a1 + 4) = v2;
  *(float *)(a1 + 100) = v3 - *(float *)(a1 + 12);
  *(float *)(a1 + 12) = v3;
  v18 = *(float *)(a1 + 20);
  v19 = *(float *)(a1 + 52);
  v20 = (float)((float)((float)(v3 - v18) * v6) + (float)(v7 * v19)) + (float)(v8 * *(float *)(a1 + 56));
  *(float *)(a1 + 48) = v20;
  *(float *)(a1 + 56) = v19;
  *(float *)(a1 + 52) = v20;
  v21 = v11 * v3;
  v22 = *(float *)(a1 + 16);
  v23 = v21 + (float)(v12 * v22);
  v24 = *(float *)(a1 + 64);
  v25 = (float)((float)(v23 + (float)(v14 * v18)) + (float)(v7 * v24)) + (float)(v8 * *(float *)(a1 + 68));
  *(float *)(a1 + 60) = v25;
  *(float *)(a1 + 68) = v24;
  *(float *)(a1 + 64) = v25;
  *(float *)(a1 + 20) = v22;
  *(float *)(a1 + 16) = v3;
  v26 = *(float *)(a1 + 96);
  v27 = *(float *)(a1 + 88)
      + (float)((float)((float)((float)((float)(v20 * v10) + (float)(v25 * v17)) * 0.5) - *(float *)(a1 + 88)) * v26);
  *(float *)(a1 + 88) = v27;
  v28 = *(float *)(a1 + 92)
      + (float)((float)((float)((float)((float)(v10 * v25) - (float)(v17 * v20)) * 0.5) - *(float *)(a1 + 92)) * v26);
  *(float *)(a1 + 92) = v28;
  v29 = *(float *)(a1 + 140);
  if ( a2 )
  {
    v30 = (float)((float)(*(float *)(a1 + 164) * v10) + (float)(*(float *)(a1 + 168) * v17)) / 500.0;
    *(float *)(a1 + 72) = v30;
    *(float *)&v31 = (float)(*(float *)(a1 + 132) + (float)(*(float *)(a1 + 208) * v30))
                   + (float)(*(float *)(a1 + 204) * *(float *)(a1 + 76));
    *(float *)(a1 + 128) = *(float *)&v31;
    if ( v31 > 1106247680 )
      *(float *)(a1 + 128) = 30.0;
    if ( *(_DWORD *)(a1 + 128) > 0xC1F00000 )
      *(float *)(a1 + 128) = -30.0;
    v32 = *(float *)(a1 + 128);
    *(float *)(a1 + 132) = v32;
    *(float *)(a1 + 76) = v30;
    *(float *)(a1 + 136) = v29 + v32;
  }
  else
  {
    v33 = 1.2 - (float)(v27 * 0.0006);
    if ( v33 < 0.0 )
      v33 = 0.0;
    if ( SLODWORD(v33) > 1065353216 )
      v33 = 1.0;
    flt_20000420 = (float)(flt_20000420 * 0.2) + (float)(v33 * 0.8);
    *(float *)(a1 + 136) = v29
                         - (float)((float)(*(float *)(a1 + 108) * v27)
                                 * (float)(1.0 - (float)((float)((float)(v4 - 40.0) * 0.01) * flt_20000420)));
    *(float *)(a1 + 116) = 326.0 - (float)(*(float *)(a1 + 104) * v28);
  }
  *(float *)&v34 = *(float *)(a1 + 148) + (float)((float)(*(float *)(a1 + 136) * *(float *)(a1 + 172)) * 2.0);
  *(float *)(a1 + 144) = *(float *)&v34;
  if ( v34 <= 0x40000000 )
  {
    *(_BYTE *)(a1 + 120) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 144) = 0;
    *(_BYTE *)(a1 + 120) = 1;
  }
  v35 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 148) = v35;
  sub_8029B7C();
  sub_8030BA8(dword_20000424);
  *(_DWORD *)(v36 + 168) = v35;
  result = sub_8030BA8(*(_DWORD *)(v37 + 4));
  *(_DWORD *)(v39 + 164) = v35;
  *(float *)(v39 + 124) = (float)(*(float *)(v39 + 168) * *(float *)(v39 + 116))
                        - (float)(*(float *)(v39 + 112) * *(float *)(v39 + 100));
  return result;
}
// 80306A0: variable 'v2' is possibly undefined
// 803071C: variable 'v3' is possibly undefined
// 8030894: variable 'v4' is possibly undefined
// 803090A: variable 'v36' is possibly undefined
// 803090E: variable 'v37' is possibly undefined
// 8030914: variable 'v39' is possibly undefined
// 20000420: using guessed type float flt_20000420;
// 20000424: using guessed type int dword_20000424;

//----- (08030968) --------------------------------------------------------
void sub_8030968()
{
  ;
}

//----- (08030A7C) --------------------------------------------------------
float *sub_8030A7C()
{
  float v0; // s0
  float *result; // r0

  result = (float *)(LODWORD(v0) - 1110704129);
  if ( (unsigned int)(LODWORD(v0) - 1110704129) < 0x4DFFFF )
  {
    sub_8029CB6(flt_200028A0);
    sub_803031C(flt_200025C8);
    result = flt_200025C8;
    flt_20002608 = v0;
  }
  return result;
}
// 8030A8C: variable 'v0' is possibly undefined
// 200025C8: using guessed type float flt_200025C8[15];
// 20002608: using guessed type float flt_20002608;
// 200028A0: using guessed type float flt_200028A0[5];

//----- (08030AE4) --------------------------------------------------------
int __fastcall sub_8030AE4(int result)
{
  int v1; // r1

  if ( result >= 0 )
  {
    v1 = 1 << (result & 0x1F);
    result = 4 * ((unsigned int)result >> 5) - 536813568;
    *(_DWORD *)(result + 256) = v1;
  }
  return result;
}

//----- (08030B94) --------------------------------------------------------
int *sub_8030B94()
{
  int *result; // r0

  result = &dword_200028B4;
  dword_200028B8 &= 0xFFFF0000;
  return result;
}
// 200028B4: using guessed type int dword_200028B4;
// 200028B8: using guessed type int dword_200028B8;

//----- (08030BA8) --------------------------------------------------------
int __fastcall sub_8030BA8(int result)
{
  if ( result < 0 )
    return result & 0x7FFFFFFF;
  return result;
}

//----- (08030BE0) --------------------------------------------------------
void sub_8030BE0()
{
  dword_200028C4 = 1073875968;
  sub_8029676();
  sub_8029680();
}
// 200028C4: using guessed type int dword_200028C4;

// nfuncs=967 queued=878 decompiled=878 lumina nreq=0 worse=0 better=0
#error "There were 6 decompilation failure(s) on 878 function(s)"
