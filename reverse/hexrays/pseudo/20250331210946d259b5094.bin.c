/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_80021E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __fastcall sub_800220C(int a1, void *a2, void *a3, void *a4);
int *sub_8002234();
unsigned int sub_80022A4();
unsigned int __fastcall _aeabi_memcpy8(unsigned int result, unsigned int a2, unsigned int a3); // idb
_BYTE *__fastcall sub_8002356(_BYTE *result, int a2, char a3);
_BYTE *__fastcall sub_8002364(_BYTE *a1, int a2);
_BYTE *__fastcall sub_8002368(_BYTE *a1, char a2, int a3);
int __fastcall sub_800237A(int result, unsigned __int8 *a2);
unsigned __int8 *__fastcall strstr(unsigned __int8 *a1, unsigned __int8 *a2);
_BYTE *__fastcall sub_80023B6(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_80023CE(int a1, unsigned __int8 a2);
unsigned __int8 *__fastcall sub_80023E2(unsigned __int8 *a1);
int __fastcall sub_80023F0(int a1, int a2);
_BYTE *__fastcall sub_800240C(_BYTE *a1, unsigned __int8 *a2);
int __fastcall sub_800241E(int a1, int a2, unsigned int a3);
unsigned int __fastcall sub_800243C(_BYTE *a1, _BYTE *a2);
_BYTE *__fastcall sub_8002480(_BYTE *result, char a2);
_BYTE *__fastcall sub_80024A0(_BYTE *result, _BYTE *a2);
int scanf(int a1, int a2, ...); // idb
int __fastcall scanf_int(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_8002644(char *a1);
void __fastcall sub_8002764(unsigned int a1);
int __fastcall sub_8002814(__int64 a1);
int __fastcall sub_8002878(int a1, int a2, int a3);
unsigned int __fastcall ll_ushift_r(unsigned int a1, unsigned int a2, int a3); // idb
unsigned int __fastcall sub_80028B6(unsigned int result, unsigned int a2);
int __fastcall sub_80028D4(_DWORD *a1, int a2);
int __fastcall sub_80028E0(int a1, int a2, _DWORD *a3);
int __fastcall sub_80028FC(unsigned __int8 **a1);
int __fastcall sbackspace(int *a1); // idb
int __fastcall strtol(char *nptr, char **endptr, int base); // idb
unsigned int __fastcall SVCall_handler(unsigned int a1, int a2, int a3);
unsigned int __fastcall sub_8002A1A(unsigned int result, int a2, __int64 a3);
void __fastcall sub_8002A38(unsigned int a1, unsigned int a2, __int64 a3);
unsigned int __fastcall Reset_handler(int a1, int a2, __int64 a3, __int64 a4);
int __fastcall sub_8002D00(unsigned int a1, unsigned int a2);
int __fastcall ll_sshift_r(unsigned int a1, int a2, int a3);
char *sub_8002DA8();
int __fastcall sub_8002DB0(int a1);
int __fastcall sub_8002DC4(int a1, int a2);
unsigned int strtoul(const char *nptr, char **endptr, int base);
void __fastcall _decompress1(unsigned __int8 *src, unsigned __int8 *dst, int len);
void sub_80031E4();
void sub_80031EE();
void sub_80031F8();
void sub_8003202();
void sub_800320C();
void sub_8003216();
void sub_8003220();
void sub_800322A();
void sub_8003234();
void sub_800323E();
void sub_8003248();
void sub_8003252();
void sub_8003266();
void sub_8003270();
void sub_800327A();
void sub_8003284();
void sub_800328E();
void sub_80032A2();
void sub_80032AC();
int __fastcall sub_80032B6(int a1);
int __fastcall sub_8003334(int a1);
int __fastcall sub_800334E(int a1);
int __fastcall sub_8003358(int *a1);
int __fastcall sub_80033DC(int *a1);
int __fastcall sub_8003468(int a1, int a2, int a3, int a4);
int sub_8003488();
int sub_8003720();
int sub_8003814();
int sub_80039A8();
int __fastcall sub_8003ABC(int result, int a2, int a3, int a4);
int __fastcall sub_8003AE8(int a1, int a2, _WORD *a3, int a4, int a5);
int __fastcall sub_8003BE8(int a1, int a2, int a3);
int __fastcall sub_8003C98(int a1, int a2);
int __fastcall sub_8003D24(unsigned int a1);
int __fastcall sub_8003DB8(int a1);
int __fastcall sub_8003DC0(int a1);
int __fastcall sub_8003DCC(int result, int a2);
int __fastcall sub_8003E1C(int a1, int a2);
int __fastcall sub_8003E4C(unsigned __int8 a1);
unsigned int __fastcall sub_8003E7C(unsigned int a1);
int __fastcall sub_8003E94(unsigned int a1);
unsigned int __fastcall sub_8003EA6(unsigned int result, int a2);
void sub_8003EBC();
int __fastcall sub_80040A0(char *a1, int a2, int a3, unsigned int a4);
int *__fastcall sub_8004188(int *a1, int a2, int a3);
int *__fastcall sub_80041AE(int *a1, int a2, int a3);
int *__fastcall sub_80041D6(int *a1, int a2);
int __fastcall sub_8004200(unsigned __int8 *a1);
int sub_8004258();
int sub_80043D0();
void __fastcall sub_800448C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void sub_80044A0();
void __fastcall sub_80044B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall sub_80044EC(int a1);
char *sub_8004678();
int sub_8004688();
int __fastcall sub_80046BC(int result);
int __fastcall sub_8004790(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, unsigned __int8 a11);
int __fastcall sub_8004848(int result, int *a2);
BOOL sub_8004918();
BOOL sub_8004924();
int sub_8004938();
int sub_8004944();
int sub_800495C();
BOOL __fastcall sub_80049C0(int a1, int a2, int a3);
int sub_80049F8();
void __fastcall BusFault_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_8004A2C(int a1);
BOOL sub_8004A58();
BOOL __fastcall sub_8004AC0(_BYTE *a1, unsigned int a2);
int sub_8004B08();
__int64 sub_8004BA0();
void __fastcall sub_8004CCC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
BOOL __fastcall sub_8004DB8(unsigned __int8 *a1);
BOOL __fastcall sub_8004E04(unsigned int a1);
_BYTE *sub_8004E5C();
int sub_8004E8C();
int sub_8004EC4();
int sub_8004F08();
int sub_8004F40();
int __fastcall sub_8004F52(int a1, __int16 a2, int a3, __int16 a4);
int __fastcall sub_8004FA2(int result, int a2, unsigned int a3);
unsigned int __fastcall sub_8004FC8(float *a1);
int *__fastcall sub_8005090(int *result);
int __fastcall sub_80050D0(int result);
int __fastcall sub_80050F4(int *a1, int a2, int a3, int a4);
int sub_8005138();
int sub_80051B8();
int sub_800520C();
int sub_800528C();
int __fastcall sub_80052A0(int a1);
int __fastcall sub_80052B0(int a1);
int sub_80052C4(const char *a1, ...); // weak
int __fastcall sub_80052E8(int a1);
int sub_800536C();
int sub_8005382();
int __fastcall sub_8005398(int a1);
int __fastcall sub_80053F8(int a1);
int __fastcall sub_8005438(unsigned int a1, int a2, int a3, int a4);
int sub_8005464();
int sub_8005494();
int __fastcall sub_80054C8(int a1, int a2, int a3);
BOOL __fastcall sub_80057C4(unsigned int a1, int a2, __int16 a3);
int __fastcall sub_8005860(unsigned int a1);
int __fastcall IRQ_11_handler(_DWORD, _DWORD); // weak
int __fastcall sub_80058E0(unsigned int a1);
int sub_800590C();
int __fastcall sub_800591C(unsigned int a1, _BYTE *a2, unsigned int a3);
unsigned int __fastcall sub_8005A54(unsigned int result);
int __fastcall sub_8005A84(int result);
unsigned int __fastcall sub_8005AA4(unsigned int result);
int __fastcall DebugMonitor_handler(_DWORD, _DWORD, _DWORD); // weak
void __fastcall sub_8005AD0(int a1, int a2, unsigned int a3);
int __fastcall IRQ_40_handler(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7);
int IRQ_23_handler(void); // weak
unsigned int __fastcall sub_8005BB0(unsigned int result);
int __fastcall sub_8005BCC(__int16 a1);
int __fastcall sub_8005BFC(int a1, int a2);
void __fastcall __noreturn sub_8005C1C(_DWORD); // weak
int sub_8005C20();
int sub_8005C90();
int __fastcall sub_8005CA4(int *a1);
unsigned int __fastcall sub_8005D18(int a1, int *a2, int a3, int a4);
int sub_8005D8C();
int __fastcall sub_8005DE8(int a1);
int __fastcall sub_8005E24(unsigned __int8 a1, int a2);
_DWORD *__fastcall sub_8005E70(_DWORD *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_8005E8C(_DWORD *result, int *a2);
int __fastcall sub_8005EB8(unsigned int a1);
int __fastcall sub_8005F24(int a1);
int __fastcall sub_8005F98(int a1, int a2);
void __fastcall sub_8006000(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_8006494(); // weak
void __fastcall IRQ_86_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_8007038();
int __fastcall sub_8007280(int a1, int a2);
int __fastcall sub_800729C(int result, unsigned int a2, unsigned int a3);
int sub_80072DC();
int __fastcall sub_8007430(int a1, int a2);
unsigned __int8 *__fastcall sub_80074A8(unsigned __int8 *result);
int __fastcall sub_8007560(int a1);
int sub_80075BC();
int sub_8007608();
int sub_80076A8();
_BYTE *__fastcall sub_8007710(unsigned __int8 *a1, int a2);
_BYTE *__fastcall sub_8007788(unsigned __int8 *a1, int a2);
int __fastcall sub_80077E0(const char *a1);
int sub_8007844();
char *sub_80078B0();
int __fastcall sub_80078F8(const char *a1);
int sub_800795C();
unsigned int sub_8007A98();
BOOL sub_8007B1C();
int sub_8007B28();
int sub_8007B70();
int __fastcall sub_8007C0C(int result);
void __fastcall __noreturn sub_8007C20(int a1);
int __fastcall sub_8007D00(int a1);
int __fastcall sub_8007DE0(const char *a1, unsigned int a2, int a3);
int sub_8007EEC();
int sub_8007F58();
int sub_8008028();
int __fastcall sub_80080B4(int a1);
unsigned __int8 *__fastcall sub_800823C(unsigned __int8 *result, int a2);
int sub_800825C(void); // weak
int __fastcall sub_8008344(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_8008438(); // weak
int sub_80084A4();
int __fastcall sub_8008760(int a1);
_BYTE *sub_80087B4();
int sub_80087E8();
int __fastcall sub_8008828(int a1, int a2, unsigned int a3, int a4);
int sub_8008910();
int sub_80089C8();
int sub_8009B0C();
BOOL __fastcall sub_8009C2C(int a1, int a2);
int __fastcall sub_8009F48(int a1);
int __fastcall sub_800A170(__int64 a1);
int sub_800A1AC();
int sub_800A240();
BOOL __fastcall sub_800A3A8(int a1);
BOOL __fastcall sub_800A400(int a1, const char *a2, int a3);
int sub_800A494();
int sub_800A88C();
int __fastcall sub_800A96C(int a1, int a2, int a3);
int sub_800AA24();
int sub_800AB00();
int sub_800AC44();
int sub_800AD8C();
int __fastcall sub_800AEB0(int a1, int a2, int a3);
int sub_800AF6C();
int __fastcall sub_800AFB0(int a1, int a2, const char *a3, const char *a4, const char *a5);
int __fastcall sub_800B098(int a1);
int __fastcall sub_800B168(int result, unsigned int a2);
int __fastcall sub_800C738(int a1, int a2, int a3, int a4, const char *a5, int a6, const char *a7);
int __fastcall sub_800C800(int a1);
int __fastcall sub_800C8E4(int result, unsigned int a2);
int __fastcall sub_800C984(int a1, int a2, int a3, int a4);
int __fastcall sub_800CA3C(int a1, int a2, const char *a3, int a4);
int sub_800CAE8();
int __fastcall sub_800CB6C(int a1, unsigned int a2, int a3);
int sub_800CBBC();
int __fastcall sub_800CC74(int a1, int a2, int a3);
int sub_800CD2C();
unsigned int __fastcall sub_800D058(unsigned int result, int a2);
int sub_800D08C(); // weak
int __fastcall sub_800D0B0(int a1);
int sub_800D398(); // weak
int sub_800D3D8(); // weak
int sub_800D410(); // weak
int sub_800D42C(); // weak
_BYTE *__fastcall sub_800D450(_BYTE *result, unsigned int a2, signed int a3);
unsigned __int8 *sub_800D500();
int __fastcall sub_800D64C(int a1);
int sub_800DB08();
int __fastcall sub_800DC20(int result);
int sub_800DEE0();
int __fastcall sub_800DFB4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_800E0C4(); // weak
BOOL __fastcall sub_800E108(int a1, const char *a2, int a3);
int __fastcall sub_800E230(int a1, int a2, const char *a3);
int sub_800E2E4();
int __fastcall sub_800E570(int a1, int a2, int a3);
int __fastcall sub_800E61C(int a1, int a2, int a3);
int sub_800E6C8();
int __fastcall sub_800E768(int a1, int a2);
int __fastcall sub_800E77E(unsigned __int8 *a1);
int __fastcall sub_800E7A4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4);
int sub_800E860();
int __fastcall sub_800E89C(int result);
int __fastcall sub_800E94C(int a1);
int __fastcall sub_800E9EC(int a1);
unsigned __int8 *sub_800EA48();
void __fastcall sub_800F0E8(int a1, int a2, int a3, int a4);
int sub_800F130(); // weak
int __fastcall sub_800F1D8(unsigned __int8 *a1);
int sub_800F208();
int __fastcall sub_800F450(const char *a1, const char *a2, int a3, unsigned int a4);
int __fastcall sub_800F554(int a1);
int sub_800F740();
unsigned int sub_800F7A4();
int __fastcall nullsub_4(_DWORD); // weak
int __fastcall nullsub_3(_DWORD); // weak
int __fastcall nullsub_2(_DWORD); // weak
BOOL __fastcall sub_800F808(unsigned int a1, int a2);
int __fastcall sub_800F86C(_DWORD *a1, int a2, unsigned int a3);
int sub_800F8E4();
int __fastcall sub_800FBB0(int a1, unsigned int a2);
int sub_800FBCC();
int sub_800FBF0();
__int64 sub_800FC1C();
int sub_800FD78();
_BYTE *sub_800FF64();
__int64 __fastcall sub_800FFA4(__int64 a1);
__int64 __fastcall sub_8010070(__int64 a1, int a2, int a3);
int __fastcall sub_8010150(unsigned __int8 *a1, unsigned __int8 *a2);
int __fastcall sub_8010294(__int16 *a1, unsigned int a2);
int sub_80102C0();
int __fastcall sub_8010328(int result);
int __fastcall sub_801036C(int a1, __int16 a2);
int sub_801043C();
unsigned int __fastcall sub_80104B0(int a1);
int __fastcall sub_80104CC(int a1, unsigned int a2);
int sub_80104EC();
unsigned int __fastcall sub_80106B8(unsigned int result);
int __fastcall sub_80106CC(int a1, int a2);
int __fastcall sub_80107EC(int a1, int a2);
int __fastcall sub_8010888(int a1, int a2);
int __fastcall sub_8010D08(int *a1);
int __fastcall sub_8010D38(int a1);
int *__fastcall sub_8010F88(int *a1);
int __fastcall sub_80111F8(int a1, int a2, int a3);
int __fastcall sub_8011328(int a1);
int *__fastcall sub_80115A8(int **a1);
int __fastcall sub_801164C(int a1);
int __fastcall sub_80116A8(int a1, _DWORD *a2);
int __fastcall sub_80116F0(int a1);
int __fastcall sub_8011728(int a1, int a2, int a3);
int __fastcall sub_80118FC(int a1);
int __fastcall sub_8011928(int *a1);
int __fastcall sub_80119BC(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_80119EE(_BYTE *a1, int a2);
int __fastcall sub_8011A5C(int a1);
int __fastcall sub_8011AC4(int a1);
int __fastcall sub_8011C08(int a1);
int __fastcall sub_8011CC8(int a1, int a2, int a3, int a4);
unsigned int __fastcall sub_8011D58(unsigned int a1);
int __fastcall sub_8011D7C(unsigned __int8 *a1, int a2, int a3);
int __fastcall sub_8011E5C(_DWORD *a1, int *a2, int a3);
int __fastcall sub_8011EAA(int a1, int a2);
int __fastcall sub_8011F08(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_8011F3E(int a1);
int __fastcall sub_8011F6C(int a1, int a2, int *a3, int a4);
int __fastcall sub_80121D8(int a1);
int __fastcall sub_80123B4(int *a1);
int __fastcall sub_801243C(unsigned __int8 *a1, int a2);
int __fastcall sub_8012474(int a1);
int __fastcall sub_80124A0(int *a1);
int __fastcall sub_8012530(_DWORD *a1, unsigned int *a2);
BOOL sub_8012628();
int __fastcall sub_8012644(int a1, _DWORD *a2, int *a3, int a4);
int sub_80126C4();
int __fastcall sub_80126EC(int result);
int __fastcall sub_8012748(int result);
int *__fastcall sub_8012760(int *result, int a2);
BOOL __fastcall sub_8012910(int a1, int a2);
int __fastcall sub_801291E(int result, int a2);
int __fastcall sub_801292E(int result, int a2, int a3);
unsigned int sub_801293C();
int sub_8012948();
int __fastcall sub_8012954(_BYTE *a1, int a2, char a3);
int __fastcall sub_8012A70(_BYTE *a1, int a2, _DWORD *a3);
int __fastcall sub_8012CC2(int a1, int a2);
int __fastcall sub_8012D02(_BYTE *a1, int a2);
int __fastcall sub_8012D74(int a1, int a2, int a3);
int __fastcall sub_8012E04(int a1, int a2, _BYTE *a3);
int __fastcall sub_8012E3C(int a1);
int __fastcall sub_8012EF4(int *a1);
int *__fastcall sub_8012F1C(int **a1);
int __fastcall sub_8012FE0(_BYTE *a1, unsigned int a2);
int __fastcall sub_8013020(int a1, int a2, _DWORD *a3);
int __fastcall sub_8013054(_BYTE *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_80131D6(int a1, int a2);
int __fastcall sub_8013202(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_801323A(int a1, int a2);
int __fastcall sub_801326A(int a1, int a2);
int __fastcall sub_801329A(int a1, int a2, _DWORD *a3);
int __fastcall sub_8013330(int a1, int a2, _DWORD *a3);
int __fastcall sub_8013374(int a1, int a2);
int __fastcall sub_80133CE(int a1, int a2);
int __fastcall sub_8013424(int a1);
int __fastcall sub_80134E4(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5);
int __fastcall sub_8013630(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5);
int __fastcall sub_801377C(int *a1);
int __fastcall sub_801382C(_DWORD *a1);
int *sub_80138A0();
int sub_80138B0();
int __fastcall sub_80138D0(unsigned int a1);
int sub_801391C();
int __fastcall sub_8013954(int result);
int __fastcall sub_8013970(int a1, unsigned __int8 a2, char a3);
int __fastcall sub_80139B0(char a1);
void __noreturn sub_80139D4();
int __fastcall sub_80139F8(int a1);
int sub_8013AC4();
int __fastcall sub_8013AD4(_DWORD *a1);
int __fastcall sub_8013DE4(unsigned __int8 *a1, unsigned int a2);
int sub_8013FAC();
unsigned int sub_8013FB8();
unsigned int sub_8013FDC();
unsigned int sub_8014000();
int __fastcall sub_8014074(unsigned __int8 *a1);
int __fastcall sub_80144CC(int a1, int a2, int a3, int a4);
int __fastcall sub_8014560(int a1, _BYTE *a2, int a3);
int __fastcall sub_80145A4(int a1, int a2, int a3);
int __fastcall sub_80145F8(int a1);
int __fastcall sub_801468C(int *a1);
int __fastcall sub_80146E0(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_8014784(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_8014850(int a1);
int sub_8014884();
int __fastcall HAL_SYSTICK_Config(int a1);
int __fastcall nullsub_16(_DWORD); // weak
int __fastcall nullsub_17(_DWORD); // weak
int __fastcall nullsub_18(_DWORD); // weak
int __fastcall nullsub_19(_DWORD); // weak
int __fastcall nullsub_20(_DWORD); // weak
int __fastcall nullsub_21(_DWORD); // weak
int __fastcall sub_80148DC(int a1, int a2);
int __fastcall sub_80149B8(_BYTE *a1, int a2, int a3);
int __fastcall nullsub_22(_DWORD); // weak
int __fastcall sub_8014A4A(int a1);
int __fastcall sub_8014A98(int *a1);
int __fastcall sub_8014AD4(_BYTE *a1);
unsigned int __fastcall sub_8014B68(unsigned int *a1);
int __fastcall sub_8014BB8(int a1, int *a2, int a3);
int __fastcall sub_8014C78(int a1);
int __fastcall sub_8014CC8(int *a1);
int __fastcall sub_8014D04(unsigned __int8 *a1, int a2);
int __fastcall sub_8014E8C(int a1);
int __fastcall sub_8015090(_DWORD **a1, _DWORD *a2, int a3);
int __fastcall sub_8015100(int result);
int __fastcall sub_8015140(int a1);
int __fastcall nullsub_25(_DWORD); // weak
int __fastcall sub_8015190(unsigned __int8 *a1, int a2);
int __fastcall sub_80152FC(_DWORD **a1, _DWORD *a2, int a3);
int __fastcall sub_8015432(int a1);
int *__fastcall sub_8015480(int *a1);
int __fastcall nullsub_23(_DWORD); // weak
int __fastcall sub_8015588(int a1, int a2);
int __fastcall sub_80156B4(int a1, int a2);
int __fastcall sub_801576C(int *a1);
int __fastcall sub_80157A0(int a1, int a2);
int __fastcall nullsub_24(_DWORD); // weak
int __fastcall sub_80157CE(int a1);
int __fastcall sub_801580A(int a1);
int __fastcall nullsub_26(_DWORD, _DWORD); // weak
int __fastcall nullsub_27(_DWORD); // weak
int __fastcall sub_8015856(int a1, int a2);
int __fastcall sub_80158A2(int a1, int a2);
int __fastcall nullsub_28(_DWORD); // weak
int __fastcall nullsub_29(_DWORD, _DWORD); // weak
int __fastcall nullsub_30(_DWORD); // weak
int __fastcall sub_80158F4(int a1);
int __fastcall sub_80159B8(_DWORD *a1);
int __fastcall nullsub_32(_DWORD); // weak
int __fastcall sub_80159FC(_DWORD *a1);
int __fastcall sub_8015CE8(int a1);
int __fastcall nullsub_31(_DWORD); // weak
int __fastcall sub_8015D5C(int *a1);
int __fastcall sub_8015E8C(int a1, int a2, unsigned int a3);
int __fastcall sub_8015EE4(int *a1);
int __fastcall sub_8015FD4(int a1, int a2, int a3);
int __fastcall nullsub_33(_DWORD); // weak
int __fastcall nullsub_34(_DWORD); // weak
_DWORD *sub_801607C();
_DWORD *__fastcall sub_801621C(_DWORD *result, int a2, _BYTE *a3);
_DWORD *__fastcall sub_80164B0(_DWORD *result, int a2);
int __fastcall sub_8016530(int *a1, _DWORD *a2);
int __fastcall sub_8016556(int *a1, _DWORD *a2);
int __fastcall sub_80165EA(int *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_80166C8(int *a1, int a2, _DWORD *a3);
void __fastcall IRQ_71_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
unsigned int __fastcall sub_80168BC(int *a1, int a2, _DWORD *a3);
int sub_8016910();
int sub_801691C();
int sub_801692C();
int sub_8016938();
int sub_8016944();
int sub_8016950();
int sub_8016DAC();
int sub_8016DE0();
int sub_8016EB4();
int sub_8016EC0();
unsigned int __fastcall sub_8016ECC(unsigned int result);
int sub_8016EE4();
int sub_8016EF0();
int sub_8016F18();
int sub_8016F24();
int sub_8016F40();
int sub_8016F54();
int __fastcall I2C_Flush_TXDR(int *a1);
int __fastcall sub_8016F94(int *a1, unsigned int a2, int a3);
int __fastcall sub_80170A4(int *a1, __int16 a2, int a3, int a4, unsigned int a5);
void __fastcall HardFault_handler(__int16 a1);
int __fastcall sub_801712C(int a1, unsigned int a2, int a3);
int __fastcall sub_80171D4(int *a1, unsigned int a2, int a3);
int __fastcall sub_8017220(int *a1, unsigned int a2, int a3);
int sub_8017270();
int __fastcall sub_80172C8(int result, unsigned int a2);
int sub_8017310();
int __fastcall sub_801731C(int a1, int a2);
int __fastcall sub_8017328(int a1);
int __fastcall sub_8017330(int a1);
int __fastcall sub_8017338(int a1);
BOOL __fastcall sub_8017340(int a1);
int __fastcall sub_8017350(int a1, unsigned int a2, int a3);
int __fastcall sub_801736E(int a1, int a2, int a3);
int sub_8017380();
int __fastcall sub_8017398(char a1);
int sub_80173B0();
unsigned int sub_80174B4();
_DWORD *sub_80174E8();
int __fastcall sub_801750C(_DWORD); // weak
void sub_8017BBC();
int __fastcall sub_80183C0(int result, int a2);
float *sub_80183CC();
_DWORD *__fastcall sub_8018434(int a1, int a2, int a3, int a4);
int sub_8018484();
unsigned int __fastcall sub_80184DA(int a1, unsigned int a2);
int sub_8018510();
int sub_801861C();
BOOL __fastcall sub_8018648(unsigned int a1);
char *__fastcall sub_8018674(char *result);
int *__fastcall sub_80186F8(int *result, int a2, unsigned int a3, int a4);
int __fastcall sub_8018720(_WORD *a1, unsigned int a2);
int __fastcall sub_801874C(int result);
int __fastcall sub_80187D8(int result);
_BYTE *__fastcall sub_8018864(_BYTE *result, unsigned int a2, unsigned int a3);
int __fastcall sub_80188C4(int result, unsigned int a2, unsigned int a3);
int __fastcall sub_801897C(int result, int a2);
BOOL __fastcall sub_8018B94(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
char *__fastcall sub_8018C24(unsigned int a1, int a2, int a3);
unsigned int sub_8018C68();
int __fastcall sub_8018CB8(unsigned int a1);
int __fastcall sub_8018CCA(unsigned int a1);
int __fastcall MemManage_fault_handler(int a1, char a2);
int __fastcall sub_8018CE0(_BYTE *a1);
int __fastcall sub_8018D28(_BYTE *a1);
int __fastcall sub_8018D78(_BYTE *a1, int *a2, int a3, int a4);
void __fastcall NMI_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __fastcall sub_8018F5C(int result, int a2);
int sub_8019090();
char *sub_80190A8();
int __fastcall sub_8019118(int a1);
int __fastcall sub_801919C(int a1, int a2, int a3, int a4);
void sub_80191AC();
int __fastcall sub_80191E8(unsigned __int8 *a1, int a2);
int __fastcall sub_80192D0(unsigned __int8 *a1, int a2);
int __fastcall sub_8019334(unsigned __int8 *a1, int a2);
int __fastcall sub_8019364(unsigned __int8 *a1, unsigned int a2, int a3, int a4);
int __fastcall sub_801943C(int result, unsigned int a2, int a3, int a4);
int __fastcall sub_80194C8(_BYTE *a1, int a2);
int sub_80194E8();
void sub_8019658();
void __fastcall sub_8019950(int a1, unsigned int a2);
int __fastcall sub_8019A94(int a1);
void sub_8019AA0();
int __fastcall sub_8019FDC(int a1);
int sub_8019FF8();
int __fastcall sub_801A574(int result, int a2, int (*a3)(void));
int __fastcall sub_801A5C4(_BYTE *a1, _DWORD *a2);
int *sub_801A68C();
int *sub_801A6DC();
int __fastcall sub_801A6EC(_BYTE *a1);
int sub_801A7FC();
int sub_801A808();
int sub_801A814();
unsigned int *__fastcall sub_801A820(unsigned int *result, unsigned int *a2);
int __fastcall sub_801A8F4(int result, char a2, int a3);
int __fastcall sub_801A90E(int result, char a2, int a3);
_DWORD *__fastcall sub_801A928(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801A9D8(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801AA7C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801AB20(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_801ABC4(_DWORD *result, int a2);
_DWORD *__fastcall sub_801AC3C(_DWORD *result, int a2);
int __fastcall sub_801ACB8(int result, char a2, int a3, char a4);
int __fastcall sub_801AD38(int result, int a2, int a3, __int16 a4);
int __fastcall sub_801AD6E(int result, int a2, int a3, char a4);
int __fastcall sub_801ADA0(int result, int a2, int a3, __int16 a4);
int sub_801ADD8(int a1, ...);
int __fastcall SysTick_handler(_DWORD **a1, _DWORD *a2, int a3);
int sub_801AEB8();
int sub_801AEC4();
int sub_801AED0();
void __fastcall sub_801AEDC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int sub_801AF40();
int __fastcall sub_801AF98(int result);
unsigned int __fastcall sub_801AFB8(unsigned int result);
unsigned int __fastcall sub_801AFD0(unsigned int result);
int sub_801AFE8();
int __fastcall IRQ_80_handler(int a1, int a2);
int __fastcall IRQ_30_handler(_BYTE *);
int __fastcall sub_801B018(_WORD *a1, unsigned int a2);
int __fastcall sub_801B040(_WORD *a1, unsigned int a2);
void sub_801B068();
int __fastcall sub_801B0C8(int result);
int __fastcall sub_801B110(int result);
int __fastcall sub_801B1D8(int a1);
int __fastcall sub_801B238(int a1);
int __fastcall sub_801B24C(int a1);
int __fastcall sub_801B29C(int a1);
int __fastcall sub_801B2C4(int a1);
int __fastcall sub_801B306(int a1);
int __fastcall sub_801B310(int result);
int __fastcall sub_801B364(int a1);
int __fastcall sub_801B388(int result);
int __fastcall sub_801B3B6(int *a1);
unsigned int *__fastcall sub_801B458(_DWORD *a1);
int __fastcall sub_801B5CC(int *a1);
unsigned int *__fastcall sub_801B66C(_DWORD *a1);
int __fastcall sub_801B7E0(_DWORD *a1);
int __fastcall sub_801BAF0(int a1, int a2, unsigned int a3);
int __fastcall sub_801BC1C(unsigned int **a1, int a2, int a3, int a4, unsigned int a5);
BOOL __fastcall sub_801BCDC(unsigned __int8 *a1);
int sub_801BD64();
void __fastcall sub_801BD70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int sub_801C4D0(); // weak
void sub_801C528();
void __fastcall IRQ_38_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall sub_801C838(unsigned __int8 *a1, int a2, _DWORD *a3);
BOOL __fastcall sub_801CE9C(int a1);
_BYTE *__fastcall sub_801CF0C(_BYTE *result);
__int64 __fastcall sub_801CFA0(__int64 a1, int a2, unsigned int a3);
_BYTE *__fastcall sub_801D01C(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_801D094(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_801D0C8(_BYTE *result, int a2, int a3, int a4);
char *__fastcall sub_801D16C(int a1, int a2, int a3, int a4);
int __fastcall sub_801D258(int result, int a2);
int sub_801D288();
int __fastcall sub_801D2B4(int, int, int, int);
int sub_801D2B8();
int sub_801D31C();
int sub_801D334();
int sub_801D35C();
int sub_801D41C();
int sub_801D570();
int __fastcall sub_801D5CC(int result);
unsigned int *__fastcall sub_801D5E8(int a1, unsigned __int16 a2);
int __fastcall sub_801D618(int result, int a2);
int __fastcall sub_801D644(int result, int a2);
int __fastcall sub_801D6B0(int result);
int __fastcall sub_801D6C8(int result, int a2);
int sub_801D6F0();
int sub_801D700();
int __fastcall sub_801D71C(int a1, __int16 a2);
void sub_801D740();
int sub_801DBB4(); // weak
int sub_801DC34(); // weak
int sub_801DC74(); // weak
int sub_801DCE8(); // weak
int sub_801DD68(); // weak
int __fastcall UsageFault_handler(int *a1, unsigned int a2, int a3, char a4);
int sub_801E220();
int __fastcall sub_801E774(int a1, int a2, int a3, int a4);
int sub_801E93C(int a1, ...);
int snprintf(int a1, int a2, const char *a3, ...);
int sprintf(int a1, const char *a2, ...);
int __fastcall sub_801E9AC(int a1, int a2);
int __fastcall _NVIC_SetPriority(int a1, char a2);
void __noreturn sub_801EA00();
void __noreturn sub_801EA24();
void __noreturn sub_801EA48();
void *sub_801EA6C();
__int64 __fastcall fp_digits(__int64 a1, double a2, int a3, int a4);
int __fastcall printf_core(int a1, int a2, int a3, void (*a4)(void));
int __fastcall printf_post_padding(int a1, __int16 a2, int a3, void (__fastcall *a4)(int, int));
int __fastcall printf_pre_padding_0(int a1, int a2, int a3, void (__fastcall *a4)(int, int));
int __fastcall sub_801F33A(int result, _DWORD *a2);
char __fastcall sub_801F350(char result, _DWORD *a2);
__int64 __fastcall sub_801F35C(unsigned int a1);
int sub_801F3C4();
int sub_801F3CC();
int sub_801F420();
int sub_801F42C();
int sub_801F468();
int __fastcall sub_801F484(int a1);
int sub_801F554();
__int64 __fastcall sub_801F610(_DWORD); // weak
int __fastcall sub_801F614(int a1, unsigned int a2, int *a3);
int sub_801F630();
int sub_801F67C();
int sub_801F76C();
int sub_801F7E4();
int __fastcall sub_801FD30(_BYTE *a1);
int sub_801FF60();
_DWORD *__fastcall sub_801FF9C(int a1, int a2);
unsigned int __fastcall sub_8020030(_DWORD *a1);
int sub_80200DC();
_DWORD *__fastcall sub_8020118(_DWORD *result, unsigned int a2);
int __fastcall sub_8020140(unsigned int *a1, unsigned int a2, int a3);
void __fastcall sub_80201AE(int a1);
int __fastcall sub_80201C2(int a1);
_DWORD *__fastcall sub_8020248(_DWORD *result);
int __fastcall sub_8020260(int a1, int a2, int a3, char a4, int a5);
_DWORD *__fastcall sub_8020288(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, int a7);
int __fastcall sub_8020344(int a1);
int *sub_8020354();
int *__fastcall sub_80203AC(int *result);
BOOL __fastcall sub_8020400(int a1);
BOOL __fastcall sub_802041A(int a1);
int __fastcall sub_8020438(int a1, _DWORD *a2, int a3);
int __fastcall sub_8020494(int a1);
int *sub_8020540();
int __fastcall sub_8020560(unsigned __int8 *a1);
int __fastcall sub_80205E0(int a1);
unsigned __int8 *__fastcall sub_802065C(unsigned __int8 *a1, unsigned __int8 *a2);
void __fastcall sub_8020694(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int sub_8020788();
_DWORD *__fastcall sub_80207A0(int a1, int a2, int a3);
unsigned int __fastcall sub_80207C4(unsigned int a1, unsigned int a2, __int16 a3);
int sub_8020810();
int __fastcall sub_802085C(unsigned int a1, unsigned int a2, __int16 a3);
int __fastcall sub_8020888(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall sub_80208B4(int result);
int __fastcall sub_80208DC(int a1);
int __fastcall sub_802091C(int a1, _BYTE *a2);
int sub_802094C();
int __fastcall sub_8020968(int a1);
int __fastcall sub_8020A58(int result, int a2);
int __fastcall sub_8020A70(int a1, int a2);
int __fastcall sub_8020A7C(int a1);
unsigned int __fastcall sub_8020A94(int a1);
int __fastcall sub_8020B08(unsigned __int8 *a1);
int __fastcall sub_8020B56(int a1);
float __fastcall sub_8020B92(_BYTE *a1);
float __fastcall sub_8020C54(int a1, unsigned __int8 *a2);
int __fastcall sub_8020CF8(int a1, int a2, int a3, int a4);
int __fastcall sub_8020DCC(int a1);
int __fastcall sub_8020DF8(int a1);
_BYTE *__fastcall sub_8020E04(int a1);
int sub_8020E44();
int __fastcall sub_8020E6C(int a1, int a2);
int __fastcall sub_8020EAC(int result, int a2);
int __fastcall sub_8020F84(int a1, int a2);
int __fastcall sub_8020FAC(int result, int a2);
unsigned int __fastcall sub_8021046(int a1);
int __fastcall sub_80210B4(int a1, int a2, unsigned int a3);
int __fastcall sub_802113C(int a1, char a2);
int __fastcall sub_8021204(int a1);
int __fastcall sub_802121E(int a1);
int __fastcall sub_8021270(int a1, int a2);
int __fastcall sub_8021318(int a1, char a2);
int __fastcall sub_8021328(int result);
unsigned int __fastcall sub_802139E(int a1);
int __fastcall sub_80213E0(int result);
unsigned int __fastcall sub_80213F6(int a1, int a2);
int __fastcall sub_8021488(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_80214FC(int a1, int a2);
unsigned __int8 *__fastcall sub_802155C(int a1, int a2);
int __fastcall sub_8021618(int a1, int a2);
int __fastcall sub_802163C(int a1, int a2);
int __fastcall sub_8021654(int a1);
int __fastcall sub_8021798(int a1, int a2);
int __fastcall sub_80217EA(unsigned int a1, int a2);
int __fastcall sub_8021814(int a1);
int __fastcall sub_802181A(int a1, int a2);
int __fastcall sub_8021828(int a1, _BYTE *a2);
int sub_8021874();
int __fastcall sub_8021878(int a1, int a2);
int __fastcall sub_80218D8(int a1, int a2);
int __fastcall sub_802193C(int a1, unsigned int a2);
int __fastcall sub_80219C4(int a1, unsigned __int8 *a2);
void __fastcall sub_80219F0(int a1);
int sub_8021A18(); // weak
void sub_8021ADC();
int sub_8021B7C();
int __fastcall sub_8021BB0(int a1);
int sub_8021BD0();
int sub_8021BD8();
int __fastcall sub_8021C0C(int result);
int sub_8021CFC();
int sub_8021D1C(); // weak
int sub_8021D34();
void __fastcall sub_8021D3A(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_8021D70(int result, int a2);
int sub_8022108(); // weak
void sub_8022114();
int sub_80222C8(); // weak
int sub_8022868();
void __fastcall sub_8022884(int a1, int a2);
__int16 *sub_8022898();
void __fastcall sub_80228B4(int a1);
int sub_8022904(); // weak
void sub_8022970();
void sub_80229C0();
int __fastcall sub_8022A78(int a1);
int sub_8022AC8(); // weak
int __fastcall sub_8022B14(int result);
int __fastcall sub_8022B24(int a1);
int sub_8022BD4(); // weak
int sub_8022C38(); // weak
int sub_8022C78();
void sub_8022C98();
void sub_8022DF6();
void __fastcall sub_8022F4E(int a1);
int __fastcall sub_8022FF8(char a1);
int sub_8023020();
char *sub_8023054();
int __fastcall sub_8023084(int a1);
int sub_80230AC(); // weak
unsigned int sub_80231BC();
void __noreturn sub_802325C();
int sub_8023280();
int sub_8023310();
int __fastcall sub_80233A4(int a1, int a2, int a3);
int __fastcall sub_8023464(unsigned int a1, __int16 a2, unsigned int a3, int a4);
int sub_802368C();
int __fastcall sub_80236A0(_DWORD *a1);
int sub_80236C8();
int __fastcall sub_80236D4(int a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_8023780(_DWORD *result);
int __fastcall sub_8023796(int result);
_DWORD *__fastcall sub_802379C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_80237CC(_DWORD *result, _DWORD *a2);
int sub_80237E4();
int sub_8023864();
int __fastcall sub_80238C4(int result);
int sub_802397C();
unsigned int sub_80239A0();
int __fastcall sub_8023A34(int a1);
int __fastcall sub_8023AAC(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_8023B20(_DWORD *result);
int __fastcall sub_8023B30(unsigned __int8 *a1);
int sub_8023BDC();
_DWORD *__fastcall sub_8023BE8(_DWORD *a1, int a2);
int __fastcall sub_8023C48(int result, unsigned int a2);
int sub_8023D38();
int __fastcall sub_8023DC8(_DWORD *a1);
int *sub_8023EB4();
int sub_8023EC4();
int __fastcall sub_802407C(_BYTE *a1, int a2, int a3, unsigned int a4);
int sub_8024EAC();
int sub_8024FE8();
_DWORD *__fastcall sub_8025014(char a1);
int __fastcall sub_802502C(unsigned int a1, unsigned int a2, char a3);
int __fastcall sub_80250A8(int a1, int a2);
int __fastcall sub_8025188(int a1, unsigned int a2, unsigned int a3, int a4);
int __fastcall sub_802532C(int a1, unsigned int a2, _DWORD *a3, int a4);
int __fastcall sub_8025438(int a1, _DWORD *a2);
BOOL __fastcall sub_8025520(int a1);
int __fastcall sub_8025570(int a1, unsigned int a2, int a3);
int __fastcall sub_80256C8(int a1, int a2);
int __fastcall sub_802584C(_DWORD *a1, unsigned int *a2);
int __fastcall sub_8025904(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6);
int __fastcall sub_802596C(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int sub_8025B14();
int sub_8025B30();
int sub_8025B3C();
int __fastcall sub_8025C94(int a1);
int __fastcall sub_8025D70(int a1);
int __fastcall sub_8025E24(int a1);
int sub_8025F2C();
void sub_8029BFC();
void sub_8029C06();
void sub_8029C10();
void sub_8029C1A();
void sub_8029C24();
void sub_8029C2E();
void sub_8029C42();
void sub_8029C4C();
void sub_8029C56();
void sub_8029C60();
void sub_8029C6A();
void sub_8029C74();
void sub_8029C7E();
void sub_8029C88();
void sub_8029C92();
void sub_8029C9C();
void sub_8029CA6();
void sub_8029CB0();
void sub_8029CBA();
void sub_8029CC4();
void sub_8029CCE();
void sub_8029CD8();
void sub_8029CE2();
void sub_8029CEC();
void sub_8029CF6();
void sub_8029D00();
void sub_8029D0A();
void sub_8029D14();
void sub_8029D1E();
void sub_8029D28();
__int64 __fastcall sub_8029D32(__int64 a1);
void sub_8029D3C();
int __fastcall sub_8029D46(int a1, unsigned int a2, int a3);
void sub_8029D50();
void sub_8029D5A();
void sub_8029D6E();
void sub_8029D78();
int sub_8029DAC();
void sub_8029E4C();
void sub_8029F04();
int sub_802A274();
int sub_802A2BC();
float *__fastcall sub_802A35C(float *result, float *a2);
float *__fastcall sub_802A3AE(float *result);
_DWORD *__fastcall sub_802A40C(_DWORD *result);
float *__fastcall sub_802A430(float *result);
_DWORD *__fastcall sub_802A4A4(_DWORD *result);
float *__fastcall sub_802A4CC(float *result, float *a2);
int __fastcall sub_802A590(int result);
_DWORD *__fastcall sub_802A620(_DWORD *result);
int __fastcall sub_802A658(int result);
char *sub_802A73C();
int sub_802A814();
unsigned int __fastcall sub_802A840(unsigned int result);
_DWORD *__fastcall sub_802AF9C(_DWORD *result);
int sub_802B00C();
void sub_802BF18();
int sub_802FA88();
int sub_802FB08();
char *sub_802FB88();
int __fastcall sub_802FBD4(int a1);
int __fastcall sub_802FBEC(int result, int a2);
_DWORD *__fastcall sub_802FCCC(_DWORD *result);
void sub_802FD28();
int __fastcall sub_80306D4(int *a1);
int sub_80306FC();
char *__fastcall sub_8030774(char *result);
void sub_803078C();
float *sub_803085C();
int sub_80308EC();
int __fastcall sub_8030A64(int result);
int __fastcall sub_8030A94(int a1);
float *__fastcall sub_8030B00(float *result);
void __fastcall sub_8030B88(int a1);
int __fastcall sub_8030C20(int result);
int __fastcall sub_8030CF4(float *a1);
int __fastcall sub_8030E80(int a1, int a2);
void sub_803114C();
float *sub_8031260();
int __fastcall sub_80312C8(int result);
int *sub_803137C();
int __fastcall sub_803138C(int result);
void sub_80313C4();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_8002230; // weak
_UNKNOWN loc_80030FC; // weak
_UNKNOWN loc_800311A; // weak
int dword_8004C80 = 3829865; // weak
int dword_8005F74 = 19279; // weak
_UNKNOWN loc_80064B4; // weak
_UNKNOWN loc_80064CC; // weak
_UNKNOWN loc_80064D0; // weak
_UNKNOWN loc_80064D4; // weak
_UNKNOWN loc_800650C; // weak
_UNKNOWN loc_8006510; // weak
_UNKNOWN loc_800652C; // weak
_UNKNOWN loc_8006568; // weak
_UNKNOWN loc_8006594; // weak
_UNKNOWN loc_8006598; // weak
_UNKNOWN loc_80065C8; // weak
_UNKNOWN loc_80065E0; // weak
_UNKNOWN loc_80065E4; // weak
_UNKNOWN loc_8006608; // weak
_UNKNOWN loc_8006624; // weak
int dword_80075E8 = 19279; // weak
int dword_80076E0 = 19279; // weak
int dword_8007B50 = 16707; // weak
int dword_8007EC4 = 19279; // weak
int dword_8008080 = 19279; // weak
const char asc_800845C[] = "["; // idb
int dword_80086A0 = 15732; // weak
int dword_80087B0 = 19279; // weak
_UNKNOWN loc_8008838; // weak
_UNKNOWN loc_8008968; // weak
int dword_8009C1C = 95; // weak
int dword_8009F44 = 19279; // weak
int dword_800A0FC = 19279; // weak
int dword_800A8F8 = 20779; // weak
int dword_800AE8C[7] =
{
  1852989783,
  979857001,
  1414614304,
  1852383316,
  1696625769,
  -1125158286,
  658817
}; // weak
_UNKNOWN loc_800B590; // weak
int dword_800D374[3] = { -427259417, -1863996260, -1750211187 }; // weak
int dword_800D380[5] = { -375283482, -1998156630, -1618287216, 226606319, 10 }; // weak
int dword_800D438[5] = { -375283482, -1528460118, -1514870607, 226606319, 10 }; // weak
int dword_800E0A4[8] =
{
  -495430565,
  -1746759546,
  -2036866426,
  1569101794,
  1129595168,
  540697709,
  220230437,
  10
}; // weak
int dword_800E734 = 19279; // weak
int dword_800E920 = 16707; // weak
_UNKNOWN loc_800ECA4; // weak
_UNKNOWN loc_800ECE4; // weak
_UNKNOWN loc_800ED24; // weak
_UNKNOWN loc_800ED9C; // weak
_UNKNOWN loc_800EDE0; // weak
_UNKNOWN loc_800EE2C; // weak
_UNKNOWN loc_800EE70; // weak
_UNKNOWN loc_800EEC4; // weak
_UNKNOWN loc_800EF28; // weak
_UNKNOWN loc_800EFA4; // weak
_UNKNOWN loc_800F038; // weak
int dword_800F194 = -495431077; // weak
int dword_800F204 = 2573; // weak
int dword_800F664 = 19279; // weak
int dword_800F698 = 44; // weak
_UNKNOWN loc_8010002; // weak
int dword_80101D4 = 32044; // weak
_UNKNOWN loc_8016700; // weak
_UNKNOWN loc_80170D4; // weak
int dword_8018B58[7] = { 1680146945, 2087921020, 628912933, 1931836531, 1751655804, 1747287139, 868 }; // weak
int dword_8018B74[8] =
{
  1680146945,
  2087921020,
  628912933,
  1931836531,
  1751655804,
  1747287139,
  807732068,
  30770
}; // weak
_UNKNOWN loc_8018E1C; // weak
int dword_801A3E8 = 19279; // weak
_UNKNOWN loc_801B814; // weak
int dword_801BAC4 = -805344781; // weak
_UNKNOWN loc_801C4F0; // weak
_UNKNOWN loc_801C510; // weak
int dword_801CB30 = 513; // weak
int dword_801CB34[2] = { 1751655683, 120 }; // weak
int dword_801CB3C = 124; // weak
_UNKNOWN sub_801DA60; // weak
int dword_801DA7C[7] = { -1796666867, -1197742207, -374370585, -1897426526, 540876935, 168650277, 0 }; // weak
_UNKNOWN unk_801DAA4; // weak
int dword_801DADC[8] =
{
  -1092089331,
  -1165498989,
  -441084697,
  -1662612594,
  -2003442039,
  549224677,
  1713709117,
  2573
}; // weak
int dword_801DAFC[8] =
{
  -1494808051,
  -1849825349,
  -441084697,
  -1662612594,
  -2003442039,
  549224677,
  1713709117,
  2573
}; // weak
int dword_801DB24[8] =
{
  -1176172019,
  -1849825354,
  -424307481,
  -1662615115,
  -2003442039,
  549224677,
  1713709117,
  2573
}; // weak
int dword_801DB44[8] =
{
  -1494808051,
  -1849825349,
  -424307481,
  -1662615115,
  -2003442039,
  549224677,
  1713709117,
  2573
}; // weak
int dword_801DCA8[7] =
{
  -442979351,
  1025543054,
  543434016,
  -1900157908,
  546016997,
  1680154685,
  658720
}; // weak
_UNKNOWN loc_801DD78; // weak
_UNKNOWN loc_801DD88; // weak
_UNKNOWN loc_801DD9C; // weak
_UNKNOWN loc_801DDAC; // weak
_UNKNOWN loc_801DDBC; // weak
_UNKNOWN loc_801DDCC; // weak
_UNKNOWN loc_801DDDC; // weak
_UNKNOWN loc_801DDEC; // weak
int dword_801E114[4] = { -424307481, -1964531535, -2122258762, 2573 }; // weak
int dword_801E1E8[7] =
{
  -428642974,
  -1864007524,
  -1702827634,
  -424694040,
  -1746291049,
  540876980,
  25637
}; // weak
int dword_801EC00 = 48; // weak
char byte_801F2DC = '-'; // weak
char byte_801F2E0 = '+'; // weak
char byte_801F2E4 = ' '; // weak
_UNKNOWN loc_801FB3A; // weak
_UNKNOWN loc_801FB50; // weak
_UNKNOWN loc_8020680; // weak
int dword_8020B00 = 2573; // weak
int dword_8021310 = 8224; // weak
int dword_8021314 = 2573; // weak
int dword_8021794 = 2573; // weak
int dword_80218D4 = 2573; // weak
int dword_8021928 = 2573; // weak
int dword_802192C = 58; // weak
int dword_8021930 = 47; // weak
int dword_8021934 = 8228; // weak
_UNKNOWN loc_8021A2C; // weak
int dword_8021D48[5] = { 757932081, -1866471392, -410213912, -2132363638, 658817 }; // weak
int dword_8021D5C[5] = { 757932082, 1128546592, -427325463, 168671136, 0 }; // weak
int dword_80220C0[9] =
{
  -2132205516,
  -1735400058,
  -408380955,
  -1796757573,
  -1466309195,
  -442003738,
  539014792,
  622862397,
  658788
}; // weak
int dword_80220E4[3] = { -1176166347, -1849825354, -408437785 }; // weak
_UNKNOWN loc_802212C; // weak
_UNKNOWN loc_8022150; // weak
_UNKNOWN loc_8022170; // weak
_UNKNOWN loc_802218C; // weak
int dword_80228F0[5] = { -374110747, -1176130153, -1164122442, -442390298, 36796 }; // weak
int dword_8022918[5] = { -424232475, -2014987620, -2019236474, -442390298, 36796 }; // weak
int dword_80229A0[8] =
{
  -423711000,
  -1964662633,
  -1618287201,
  -444100889,
  -2132436306,
  540876988,
  168650277,
  0
}; // weak
int dword_80229F0[4] = { -440755227, 1718655662, 622869792, 658790 }; // weak
_UNKNOWN unk_8022AA0; // weak
_UNKNOWN unk_8022BC4; // weak
int dword_8022C04[4] = { -425411868, -1461283944, -1883445855, 0 }; // weak
int dword_8022C14[4] = { -443174427, -1461287538, -1883445855, 0 }; // weak
int dword_8022C24[2] = { -444497688, 38540 }; // weak
int dword_8022C2C[3] = { -396004255, -1931116160, 150 }; // weak
_UNKNOWN loc_80238D4; // weak
int dword_8026880[3] = { 527752680, -1970553525, 1723154032 }; // weak
int dword_802688C[6] = { 251003720, -1185467039, -1642217082, 295237857, -1802577559, -377020773 }; // weak
int dword_80268A4[4] = { -551004722, 227123596, 1749214911, 254646593 }; // weak
int dword_80268B4[4] = { 381375664, -714471086, 950351408, -1633468225 }; // weak
int dword_80268C4[4] = { -69733503, -2110135428, -2013319269, 1145278004 }; // weak
_UNKNOWN unk_80268D4; // weak
char aBeginCertifica_0[1225] = "-----BEGIN CERTIFICATE-----\nMIIDWjCCAkKgAwIBAgIVAMF7n3v/PfmjDpMgBglQ8WnV1RziMA0GCSqGSIb3DQEB\nCwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t\nIEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0yNDAxMTkwMzEw\nMzVaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh\ndGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDEGpsgZppFoNQ1yr+5\nObgc2c0k9Ms2RTzZvwl81O1qctxwizeVKF5bMws9ILmd3T2tHEVIvKP63oVSv0Kl\nRMtqlTSTWWeNVv+k+ezbGbdUlbsIP1PsY+dMLkPcAApXl5uqydSYtv5D3FY9Iazu\njZZQh+aLRxv81L9KLDJiv+WRzhdOnBwzU1Pl9SBTitZ+brLl5nIWTnufk5nMKO7m\npj2tjOZrkEHkaUUoY0dtd8SwTCLZDHRn6127GgY66Or7oCtddpzs5sLz5c/p4ZT3\n7ciILh5wVF6SSKP2IMVPt5+2IsKf8rn6+p733lNJXk4OiRBmCmKVv/XJ/thpzGcY\nAaoZAgMBAAGjYDBeMB8GA1UdIwQYMBaAFCijkDWFQrnESVOzFF5W4HHDhfEhMB0G\nA1UdDgQWBBSUxIPiTyDCvFeeT5WCtIR3cPTR3DAMBgNVHRMBAf8EAjAAMA4GA1Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n"; // weak
int dword_80276A8[3] = { 2000171623, 1215788886, 810578021 }; // weak
int dword_8027B3C[61] =
{
  33686018,
  538976258,
  538976288,
  35659808,
  33686018,
  -1869610494,
  -1869574000,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  33686018,
  -2004352510,
  -2004318072,
  134744072,
  134744072,
  134744072,
  134744072,
  134744072,
  33686018,
  64,
  134382353,
  -1377423815,
  -1497569885,
  1352840166,
  -1092074682,
  -1165498989,
  -393497114,
  -434072145,
  -2098745675,
  -1332353351,
  -423970588,
  -1125801043,
  -1565268314,
  -460017690,
  -2132571202,
  808333456,
  808333613,
  546406627,
  2573,
  -1796797939,
  -1598953803,
  -408974619,
  1025542030,
  744891680,
  -407132441,
  -1964666435,
  -2020677729,
  622869792,
  -1494799258,
  -1849825349,
  -408974619,
  540182414,
  1713709117,
  -1229331156,
  -443433497,
  -1897422966,
  540876935,
  168650277,
  0
}; // weak
int dword_8028FE4[20] =
{
  539634218,
  1601071458,
  1936090735,
  723547237,
  1096044320,
  1313166175,
  1095786308,
  1398754115,
  541416009,
  589635645,
  1646275704,
  1935634025,
  543521385,
  589635645,
  -450876296,
  -1528461689,
  -1583290745,
  780970729,
  774778414,
  658734
}; // weak
_UNKNOWN *off_802932C = (_UNKNOWN *)0x802A3FC; // weak
int dword_8029390 = 134375725; // weak
_UNKNOWN *off_8029400 = (_UNKNOWN *)0x8026A08; // weak
int dword_8029468[6] = { 134376135, 8448, 134376189, 134361825, 134376201, 8448 }; // weak
int dword_80294B0[9] =
{
  134376289,
  134251305,
  134376305,
  8448,
  134376321,
  134279325,
  134376337,
  8448,
  134376377
}; // weak
int dword_8029514[12] =
{
  134357937,
  134376511,
  8448,
  134376566,
  134358029,
  134376574,
  8448,
  134376641,
  134362233,
  134376651,
  8448,
  134376685
}; // weak
int dword_8029564[3] = { 134357569, 134376730, 8448 }; // weak
int dword_80295B4 = 134347693; // weak
int dword_80297E4[7] =
{
  1124936973,
  1863145741,
  -1743944947,
  -1072845811,
  -418524403,
  202242317,
  789454094
}; // weak
int dword_8029834[18] =
{
  -2013042941,
  -872175101,
  319024899,
  1560557316,
  417890820,
  -150679532,
  1191517956,
  -1710919675,
  -301612283,
  1124472837,
  -1722279708,
  -267991802,
  1208425478,
  -1610124281,
  -150484217,
  1325933319,
  -1526171128,
  -83308280
}; // weak
int dword_802987C[17] =
{
  1342776840,
  -1542882807,
  -167129847,
  1175068169,
  -1794478582,
  -519390454,
  738920202,
  1946898443,
  -1173645557,
  -32777205,
  1057758987,
  2114739980,
  -1173578484,
  -183707636,
  416420108,
  1645037584,
  -1794278387
}; // weak
int dword_80298C0[22] =
{
  -972182003,
  -183640563,
  555720910,
  1292777230,
  1963876622,
  -1693546482,
  -1056002546,
  -485567986,
  84866062,
  604967951,
  34615823,
  418971927,
  66331859,
  151250979,
  738417941,
  -2141517872,
  1057096767,
  21240255,
  1209011000,
  346623042,
  1683626497,
  1260912900
}; // weak
int dword_8029918[21] =
{
  17048360,
  1385038876,
  -1881603649,
  327686659,
  -858993211,
  541459261,
  1966088988,
  521931795,
  34743328,
  705442049,
  35458068,
  204603650,
  437786714,
  -198505421,
  18618395,
  1259090945,
  437004184,
  1748634677,
  16915468,
  1884949558,
  204937752
}; // weak
int dword_802996C[108] =
{
  437021786,
  809110584,
  16849992,
  878316601,
  205134348,
  437005402,
  -1072493420,
  69211176,
  -1778312444,
  214194700,
  1510799386,
  -90567480,
  1985747724,
  336138836,
  453116192,
  1259101441,
  437011296,
  1851395166,
  207559180,
  438579546,
  -2142565185,
  -1072034770,
  794563340,
  201465883,
  1510785306,
  -1038480294,
  1095897868,
  19996692,
  1998851108,
  805638987,
  1259112474,
  436994728,
  572132588,
  590358808,
  -48531376,
  806950968,
  -1871112165,
  202983449,
  209458203,
  2098880617,
  442525964,
  -2073490306,
  1510793242,
  1680027716,
  471077757,
  35921951,
  207945986,
  487331882,
  1711342098,
  201599500,
  18551826,
  2048527464,
  440936764,
  2119830633,
  214440460,
  1009227819,
  -922681060,
  208157196,
  -905903588,
  212085260,
  -870695911,
  -1058006516,
  740497449,
  812669566,
  1510747418,
  773459052,
  813455884,
  327215139,
  538914880,
  16974852,
  1146752234,
  216799756,
  437016666,
  1549405422,
  217061900,
  437013594,
  1348078834,
  -2001198324,
  483142714,
  213451009,
  437006426,
  878316730,
  214047244,
  332170778,
  26939922,
  472059075,
  78451593,
  201400347,
  1510745626,
  656076916,
  209082892,
  1510746138,
  -1608315784,
  684206988,
  19140984,
  -1067807484,
  201726476,
  588039258,
  303796360,
  806966277,
  1259112730,
  440151816,
  173673610,
  210442764,
  436997210,
  -1540682612,
  454141991,
  1510771969
}; // weak
int dword_8029B4C[9] =
{
  839528968,
  839791116,
  688271876,
  1762404653,
  35651844,
  1020920095,
  151066927,
  640230417,
  511772233
}; // weak
_UNKNOWN loc_8029F0C; // weak
_UNKNOWN loc_802ADAC; // weak
char byte_20000000; // weak
char byte_20000002; // weak
int dword_20000004; // weak
int dword_20000008; // weak
int dword_2000000C; // weak
int dword_20000010; // weak
_DWORD dword_20000014[2]; // weak
int dword_2000001C; // weak
int dword_20000020; // weak
int dword_20000024; // weak
__int16 word_20000028; // weak
__int16 word_2000002A; // weak
int dword_2000002C; // weak
char byte_20000030; // weak
char byte_20000031; // weak
char byte_20000032; // weak
int dword_20000034; // weak
_UNKNOWN unk_20000038; // weak
char byte_2000003C; // weak
char byte_2000003D; // weak
int dword_20000040; // weak
int dword_20000044; // weak
int dword_20000048; // weak
int dword_2000004C; // weak
int dword_20000050; // weak
int dword_20000054; // weak
__int16 word_20000058; // weak
int dword_2000005C; // weak
int dword_20000060; // weak
int (*off_20000064)(void); // weak
int (*off_20000068)(void); // weak
int dword_2000006C; // weak
int dword_20000070; // weak
__int16 word_20000074; // weak
__int16 word_20000076; // weak
__int16 word_20000078; // weak
__int16 word_2000007A; // weak
__int16 word_2000007C; // weak
__int16 word_2000007E; // weak
__int16 word_20000080; // weak
__int16 word_20000082; // weak
__int16 word_20000084; // weak
__int16 word_20000086; // weak
__int16 word_20000088; // weak
__int16 word_2000008A[115]; // weak
__int16 word_20000170; // weak
__int16 word_20000172[115]; // weak
__int16 word_20000258; // weak
_UNKNOWN unk_2000025A; // weak
__int16 word_20000262; // weak
int dword_20000264; // weak
int dword_20000268; // weak
int dword_2000026C; // weak
char byte_20000270; // weak
int dword_20000274; // weak
char byte_2000028C; // weak
int dword_20000290; // weak
char byte_20000294; // weak
int dword_20000298; // weak
int dword_2000029C; // weak
int dword_200002A0; // weak
char byte_200002A4; // weak
char byte_200002A5; // weak
char byte_200002A6; // weak
char byte_200002A7; // weak
char byte_200002A8; // weak
char byte_200002A9; // weak
char byte_200002AA; // weak
char byte_200002AB; // weak
char byte_200002AD; // weak
char byte_200002AE; // weak
char byte_200002AF; // weak
char byte_200002B0; // weak
char byte_200002B1; // weak
char byte_200002B2; // weak
char byte_200002B3; // weak
char byte_200002B4; // weak
char byte_200002B5; // weak
char byte_200002B6; // weak
char byte_200002B7; // weak
char byte_200002B8; // weak
char byte_200002B9; // weak
char byte_200002BA; // weak
char byte_200002BB; // weak
char byte_200002BC; // weak
char byte_200002BD; // weak
char byte_200002BE; // weak
char byte_200002BF; // weak
char byte_200002C0; // weak
char byte_200002C1; // weak
char byte_200002C2; // weak
char byte_200002C3; // weak
char byte_200002C4; // weak
char byte_200002C5; // weak
char byte_200002C6; // weak
char byte_200002C7; // weak
char byte_200002C8; // weak
char byte_200002C9; // weak
char byte_200002CA; // weak
char byte_200002CB; // weak
char byte_200002CC; // weak
char byte_200002CD; // weak
char byte_200002CE; // weak
float flt_200002D0; // weak
float flt_200002D4; // weak
float flt_200002D8; // weak
int dword_200002DC; // weak
int dword_200002E0; // weak
int dword_200002E4; // weak
int dword_200002E8; // weak
int dword_200002EC; // weak
float flt_200002F0; // weak
float flt_200002F4; // weak
int dword_200002F8; // weak
int dword_200002FC; // weak
float flt_20000300; // weak
float flt_20000304; // weak
int dword_20000308; // weak
float flt_2000030C; // weak
float flt_20000310; // weak
float flt_20000314; // weak
int dword_20000318; // weak
int dword_2000031C; // weak
float flt_20000320; // weak
int dword_20000324; // weak
int dword_20000328; // weak
float flt_2000032C; // weak
float flt_20000330; // weak
float flt_20000334; // weak
float flt_20000338; // weak
int dword_2000033C; // weak
float flt_20000340; // weak
float flt_20000344; // weak
int dword_20000348; // weak
int dword_2000034C; // weak
float flt_20000350; // weak
float flt_20000354; // weak
float flt_20000358; // weak
float flt_2000035C; // weak
float flt_20000360; // weak
float flt_20000364; // weak
float flt_20000368; // weak
int dword_2000036C; // weak
int dword_20000370; // weak
int dword_20000374; // weak
int dword_20000378; // weak
float flt_2000037C; // weak
int dword_20000380; // weak
int dword_20000384; // weak
int dword_20000388; // weak
float flt_2000038C; // weak
float flt_20000390; // weak
float flt_20000394; // weak
float flt_20000398; // weak
int dword_2000039C; // weak
float flt_200003A0; // weak
int dword_200003A4; // weak
float flt_200003A8; // weak
int dword_200003AC; // weak
int dword_200003B8; // weak
int dword_200003BC; // weak
int dword_200003C0; // weak
int dword_200003C4; // weak
int dword_200003C8; // weak
int dword_200003CC; // weak
int dword_200003D0; // weak
int dword_200003D4; // weak
int dword_200003D8; // weak
int dword_200003DC; // weak
int dword_200003E0; // weak
int dword_200003E4; // weak
int dword_200003E8; // weak
int dword_200003EC; // weak
int dword_200003F0; // weak
int dword_200003F4; // weak
int dword_200003F8; // weak
int dword_200003FC; // weak
int dword_20000400; // weak
int dword_20000404; // weak
float flt_20000408; // weak
float flt_2000040C; // weak
float flt_20000410; // weak
float flt_20000414; // weak
int dword_20000418; // weak
float flt_20000420; // weak
int dword_20000424; // weak
int dword_20000428; // weak
int dword_2000042C; // weak
int dword_20000430; // weak
int dword_20000434; // weak
int dword_20000438; // weak
int dword_2000043C; // weak
int dword_20000440; // weak
int dword_20000444; // weak
int dword_20000448; // weak
int dword_2000044C; // weak
int dword_20000450; // weak
int dword_20000454; // weak
int dword_20000458; // weak
int dword_2000045C; // weak
int dword_20000460; // weak
int dword_20000464; // weak
int dword_20000468; // weak
int dword_2000046C; // weak
int dword_20000470; // weak
int dword_20000474; // weak
char byte_20000478; // weak
char byte_20000479; // weak
char byte_2000047A; // weak
char byte_2000047B; // weak
char byte_2000047C; // weak
char byte_2000047D; // weak
char byte_2000047E; // weak
char byte_2000047F; // weak
char byte_20000480; // weak
int dword_20000488; // weak
int dword_2000048C; // weak
int dword_20000490; // weak
int dword_20000494; // weak
int dword_20000498; // weak
int dword_2000049C; // weak
int dword_200004A0; // weak
int dword_200004A4; // weak
char byte_200004A8; // weak
char byte_200004A9; // weak
char byte_200004AA; // weak
char byte_200004AB; // weak
char byte_200004AC; // weak
char byte_200004AD; // weak
char byte_200004AE; // weak
char byte_200004AF; // weak
char byte_200004B0; // weak
char byte_200004B1; // weak
char byte_200004B2; // weak
char byte_200004B3; // weak
__int16 word_200004B4; // weak
__int16 word_200004B6; // weak
__int16 word_200004B8; // weak
char byte_200004BA; // weak
char byte_200004BB; // weak
_WORD word_200004BC[3]; // weak
__int16 word_200004C2; // weak
__int16 word_200004C4; // weak
_BYTE algn_200004C6[2]; // weak
__int16 word_200004C8; // weak
__int16 word_200004CA; // weak
__int16 word_200004CC[3]; // weak
_WORD word_200004CE; // weak
_WORD word_200004D0; // weak
char byte_200004D2; // weak
char byte_200004D3; // weak
char byte_200004D4; // weak
float flt_200004D8; // weak
int dword_200004DC; // weak
int dword_200004E0; // weak
float flt_200004E4; // weak
int dword_200004E8; // weak
int dword_200004EC; // weak
int dword_200004F0; // weak
int dword_200004F4; // weak
int dword_200004F8; // weak
int dword_200004FC; // weak
char byte_20000500; // weak
char byte_20000501; // weak
char byte_20000502; // weak
char byte_20000503; // weak
char byte_20000504; // weak
char byte_20000505; // weak
char byte_20000506; // weak
char byte_20000507; // weak
char byte_20000508; // weak
char byte_20000509; // weak
char byte_2000050A; // weak
char byte_2000050B; // weak
char byte_2000050C; // weak
__int16 word_2000050D; // weak
char byte_20000511; // weak
char byte_20000512; // weak
char byte_20000513; // weak
char byte_20000516; // weak
char byte_20000517; // weak
__int16 word_20000518; // weak
__int16 word_2000051A; // weak
char byte_2000051C; // weak
char byte_20000520; // weak
__int16 word_20000522; // weak
__int16 word_20000524; // weak
__int16 word_20000526; // weak
char byte_20000528; // weak
char byte_20000529; // weak
char byte_2000052A; // weak
int dword_2000052C; // weak
_UNKNOWN unk_20000530; // weak
int dword_200008B4; // weak
int dword_200008B8; // weak
char byte_200008C1; // weak
float flt_200008C4; // weak
char byte_200008C8; // weak
char byte_200008C9; // weak
__int16 word_200008CA; // weak
int dword_200008CC; // weak
_DWORD dword_200008D0[3]; // weak
_DWORD dword_200008DC[3]; // weak
_DWORD dword_200008E8[4]; // weak
char byte_200008F8; // weak
char byte_200008F9; // weak
char byte_200008FA; // weak
char byte_200008FB; // weak
__int16 word_200008FC; // weak
_WORD word_200008FE; // weak
__int16 word_20000900; // weak
int dword_20000904; // weak
__int64 qword_20000908; // weak
char byte_20000910; // weak
char byte_20000911; // weak
_WORD word_20000912; // weak
char byte_20000914; // weak
char byte_20000915; // weak
char byte_20000916; // weak
char byte_20000917; // weak
_WORD word_20000918[2]; // weak
__int16 word_2000091C; // weak
__int16 word_2000091E; // weak
__int16 word_20000920; // weak
_BYTE algn_20000922[2]; // weak
__int16 word_20000924; // weak
_BYTE algn_20000926[2]; // weak
__int16 word_20000928; // weak
char byte_2000092A; // weak
_WORD word_2000092C; // weak
char byte_2000092E; // weak
char byte_2000092F; // weak
char byte_20000930; // weak
char byte_20000931; // weak
_BYTE algn_20000932[2]; // weak
__int16 word_20000934; // weak
__int16 word_20000936; // weak
char byte_20000938; // weak
char byte_20000939; // weak
char byte_2000093A; // weak
char byte_2000093B; // weak
char byte_2000093C; // weak
char byte_2000093D; // weak
char byte_2000093E; // weak
char byte_2000093F; // weak
char byte_20000940; // weak
char byte_20000941; // weak
char byte_20000942; // weak
char byte_20000943; // weak
char byte_20000944; // weak
char byte_20000945; // weak
char byte_20000946; // weak
char byte_20000947; // weak
char byte_20000948; // weak
char byte_20000949; // weak
char byte_2000094A; // weak
char byte_2000094B; // weak
_WORD word_2000094C[3]; // weak
__int16 word_20000952; // weak
_BYTE algn_20000954[4]; // weak
__int16 word_20000958; // weak
__int16 word_2000095A; // weak
_WORD word_2000095C; // weak
__int16 word_2000095E; // weak
__int16 word_20000960; // weak
_UNKNOWN unk_20000962; // weak
char byte_20000967; // weak
char byte_20000968; // weak
char byte_20000969; // weak
_DWORD dword_2000096C[10]; // weak
char byte_20000995[]; // weak
char byte_20000996; // weak
__int16 word_20000997; // weak
__int16 word_2000099A; // weak
int dword_2000099C; // weak
int dword_200009A0; // weak
unsigned __int8 byte_200009A4[2048]; // weak
unsigned __int8 byte_200011A4[1024]; // weak
__int16 word_200015A4; // weak
char byte_200015A6; // weak
char byte_200015A7; // weak
int dword_200015A8; // weak
char byte_200015AC; // weak
char byte_200015AD; // weak
char byte_200015AE; // weak
char byte_200015AF; // weak
char byte_200015B0; // weak
char byte_200015B1; // weak
char byte_200015B2; // weak
char byte_200015B3; // weak
char byte_200015B4; // weak
char byte_200015B5; // weak
__int16 word_200015B6; // weak
__int16 word_200015B8; // weak
char byte_200015BA; // weak
__int16 word_200015BC; // weak
int dword_200015C0; // weak
int dword_200015C4; // weak
int dword_200015C8; // weak
int dword_200015CC; // weak
int dword_200015D0; // weak
int dword_200015D4; // weak
int dword_200015D8; // weak
char byte_200015DC; // weak
char byte_200015DD; // weak
char byte_200015DE; // weak
char byte_200015DF; // weak
char byte_200015E0; // weak
char byte_200015E1; // weak
char byte_200015E2; // weak
char byte_200015E3; // weak
char byte_200015E4; // weak
char byte_200015E5; // weak
char byte_200015E6; // weak
char byte_200015E7; // weak
char byte_200015E8; // weak
char byte_200015E9; // weak
char byte_200015EA; // weak
char byte_200015EB; // weak
char byte_200015EC; // weak
char byte_200015EE; // weak
char byte_200015EF; // weak
char byte_200015F0; // weak
char byte_200015F1; // weak
__int16 word_200015F2; // weak
__int16 word_200015F4; // weak
__int16 word_200015F6; // weak
__int16 word_200015F8; // weak
_WORD word_200015FA; // weak
_WORD word_200015FC; // weak
__int16 word_200015FE; // weak
__int16 word_20001600; // weak
int dword_20001604; // weak
int dword_20001608; // weak
int dword_2000160C; // weak
int dword_2000161C; // weak
int dword_20001630; // weak
int dword_20001634; // weak
int dword_20001638; // weak
int dword_2000163C; // weak
int dword_20001644; // weak
int dword_20001648; // weak
int dword_2000164C; // weak
int dword_20001650; // weak
int dword_20001654; // weak
int dword_20001658; // weak
int dword_2000165C; // weak
int dword_20001660; // weak
int dword_20001664; // weak
int dword_20001668; // weak
int dword_2000166C; // weak
int dword_20001670; // weak
int dword_20001674; // weak
int dword_20001678; // weak
int dword_2000167C; // weak
int dword_20001680; // weak
_DWORD dword_20001684; // weak
int dword_20001688; // weak
int dword_2000168C; // weak
int dword_20001690; // weak
int dword_20001694; // weak
int dword_20001698; // weak
int dword_2000169C; // weak
int dword_200016A8; // weak
int dword_200016AC; // weak
char byte_200016B4; // weak
int dword_200016B8; // weak
int dword_200016BC; // weak
int dword_200016C0; // weak
_UNKNOWN unk_200016C4; // weak
int dword_200016C8; // weak
int dword_200016CC; // weak
int dword_200016D0; // weak
int dword_200016D4; // weak
int dword_200016D8; // weak
int dword_200016DC; // weak
int dword_200016E0; // weak
int dword_200016E4; // weak
int dword_200016E8; // weak
int dword_200016F0; // weak
int dword_20001728; // weak
int dword_2000172C; // weak
int dword_20001730; // weak
int dword_20001734; // weak
int dword_20001738; // weak
int dword_2000173C; // weak
int dword_20001740; // weak
int dword_20001744; // weak
int dword_200017B8; // weak
int dword_200017BC; // weak
int dword_200017C0; // weak
int dword_200017C4; // weak
int dword_200017C8; // weak
int dword_200017CC; // weak
int dword_200017D0; // weak
int dword_200017D4; // weak
int dword_20001848; // weak
int dword_2000184C; // weak
int dword_20001850; // weak
int dword_20001944; // weak
int dword_20001948; // weak
int dword_2000194C; // weak
int dword_20001950; // weak
int dword_20001954; // weak
int dword_20001958; // weak
int dword_2000195C; // weak
int dword_20001968; // weak
int dword_2000196C; // weak
int dword_20001970; // weak
int dword_20001974; // weak
int dword_20001978; // weak
int dword_2000197C; // weak
int dword_20001980; // weak
int dword_2000198C; // weak
int dword_20001990; // weak
int dword_20001994; // weak
int dword_20001998; // weak
int dword_2000199C; // weak
int dword_200019A0; // weak
int dword_200019A4; // weak
int dword_200019B0; // weak
int dword_200019B4; // weak
int dword_200019BC; // weak
int dword_200019C0; // weak
int dword_200019C8; // weak
_DWORD dword_20001A04[4]; // weak
int dword_20001A14; // weak
int dword_20001A18; // weak
int dword_20001A1C; // weak
int dword_20001A20; // weak
int dword_20001A60; // weak
int dword_20001A64; // weak
int dword_20001A68; // weak
int dword_20001AAC; // weak
int dword_20001AB0; // weak
int dword_20001AB4; // weak
int dword_20001AB8; // weak
int dword_20001ABC; // weak
int dword_20001AC0; // weak
int dword_20001AC4; // weak
int dword_20001AF8; // weak
int dword_20001AFC; // weak
int dword_20001B00; // weak
int dword_20001B04; // weak
int dword_20001B08; // weak
int dword_20001B0C; // weak
int dword_20001B10; // weak
int dword_20001B44; // weak
int dword_20001B90; // weak
int dword_20001BDC; // weak
int dword_20001BE0; // weak
int dword_20001BE4; // weak
int dword_20001BE8; // weak
int dword_20001BEC; // weak
int dword_20001BF0; // weak
int dword_20001BF4; // weak
int dword_20001BF8; // weak
int dword_20001BFC; // weak
int dword_20001C00; // weak
float flt_20001C04; // weak
int dword_20001C08; // weak
float flt_20001C0C; // weak
int dword_20001C10; // weak
float flt_20001C14; // weak
float flt_20001C18; // weak
int dword_20001C1C; // weak
int dword_20001C20; // weak
int dword_20001C24; // weak
int dword_20001C28; // weak
float flt_20001C2C; // weak
float flt_20001C30; // weak
float flt_20001C34; // weak
__int16 word_20001C38; // weak
__int16 word_20001C3A; // weak
__int16 word_20001C3C; // weak
__int16 word_20001C3E; // weak
__int16 word_20001C40; // weak
__int16 word_20001C42; // weak
__int16 word_20001C44; // weak
__int16 word_20001C46; // weak
__int16 word_20001C48; // weak
__int16 word_20001C4A; // weak
__int16 word_20001C4C; // weak
__int16 word_20001C4E; // weak
__int16 word_20001C50; // weak
__int16 word_20001C52; // weak
int dword_20001C54; // weak
int dword_20001C58; // weak
int dword_20001C5C; // weak
int dword_20001C60; // weak
int dword_20001C64; // weak
int dword_20001C68; // weak
int dword_20001C6C; // weak
int dword_20001C70; // weak
int dword_20001C74; // weak
int dword_20001C7C; // weak
int dword_20001CB4; // weak
int dword_20001CB8; // weak
int dword_20001CBC; // weak
int dword_20001CC0; // weak
int dword_20001CC4; // weak
int dword_20001CC8; // weak
int dword_20001CCC; // weak
int dword_20001CD0; // weak
int dword_20001CD4; // weak
int dword_20001CDC; // weak
int dword_20001D14; // weak
int dword_20001D18; // weak
int dword_20001D1C; // weak
int dword_20001D20; // weak
int dword_20001D24; // weak
int dword_20001D28; // weak
int dword_20001D2C; // weak
int dword_20001D30; // weak
int dword_20001D34; // weak
int dword_20001D3C; // weak
int dword_20001D74; // weak
int dword_20001D78; // weak
int dword_20001D7C; // weak
int dword_20001D80; // weak
int dword_20001D84; // weak
int dword_20001D88; // weak
int dword_20001D8C; // weak
int dword_20001D90; // weak
int dword_20001D94; // weak
int dword_20001D9C; // weak
int dword_20001DD4; // weak
int dword_20001DD8; // weak
int dword_20001DDC; // weak
int dword_20001DE0; // weak
int dword_20001DE4; // weak
int dword_20001DE8; // weak
int dword_20001DEC; // weak
int dword_20001DF0; // weak
int dword_20001DF4; // weak
int dword_20001DFC; // weak
int dword_20001E34; // weak
int dword_20001E38; // weak
int dword_20001E3C; // weak
int dword_20001E40; // weak
int dword_20001E44; // weak
int dword_20001E48; // weak
int dword_20001E4C; // weak
char byte_20001E50; // weak
char byte_20001E51; // weak
int dword_20001E54; // weak
char byte_20001E58; // weak
int dword_20001E5C; // weak
int dword_20001E60; // weak
int dword_20001E64; // weak
char byte_20001E6C; // weak
int dword_20001E70; // weak
char byte_20001E74; // weak
int dword_20001E88; // weak
int dword_20001EA0; // weak
int dword_20001EA4; // weak
int dword_20001EA8; // weak
int dword_20001EAC; // weak
int dword_20001EB0; // weak
int dword_20001EB4; // weak
int dword_20001EB8; // weak
char byte_20001EBC; // weak
char byte_20001EBD; // weak
int dword_20001EC0; // weak
char byte_20001EC4; // weak
int dword_20001EC8; // weak
int dword_20001ECC; // weak
int dword_20001ED0; // weak
char byte_20001ED8; // weak
int dword_20001EDC; // weak
char byte_20001EE0; // weak
int dword_20001EF4; // weak
int dword_20001F0C; // weak
int dword_20001F10; // weak
int dword_20001F14; // weak
int dword_20001F18; // weak
int dword_20001F1C; // weak
int dword_20001F20; // weak
int dword_20001F24; // weak
char byte_20001F28; // weak
char byte_20001F29; // weak
int dword_20001F2C; // weak
char byte_20001F30; // weak
int dword_20001F34; // weak
int dword_20001F38; // weak
int dword_20001F3C; // weak
char byte_20001F44; // weak
int dword_20001F48; // weak
char byte_20001F4C; // weak
int dword_20001F60; // weak
int dword_20001F78; // weak
int dword_20001F7C; // weak
int dword_20001F80; // weak
int dword_20001F84; // weak
int dword_20001F88; // weak
int dword_20001F8C; // weak
int dword_20001F90; // weak
char byte_20001F94; // weak
char byte_20001F95; // weak
int dword_20001F98; // weak
char byte_20001F9C; // weak
int dword_20001FA0; // weak
int dword_20001FA4; // weak
int dword_20001FA8; // weak
char byte_20001FB0; // weak
int dword_20001FB4; // weak
char byte_20001FB8; // weak
int dword_20001FCC; // weak
int dword_20001FE4; // weak
int dword_20001FE8; // weak
int dword_20001FEC; // weak
int dword_20001FF0; // weak
int dword_20001FF4; // weak
int dword_20001FF8; // weak
int dword_20001FFC; // weak
char byte_20002000; // weak
char byte_20002001; // weak
int dword_20002004; // weak
char byte_20002008; // weak
int dword_2000200C; // weak
int dword_20002010; // weak
int dword_20002014; // weak
char byte_2000201C; // weak
int dword_20002020; // weak
char byte_20002024; // weak
int dword_20002028; // weak
int dword_2000202C; // weak
int dword_20002030; // weak
int dword_20002034; // weak
int dword_20002038; // weak
__int16 word_20002050; // weak
__int16 word_20002052; // weak
__int16 word_20002054; // weak
int dword_2000205C; // weak
int dword_20002060; // weak
int dword_20002064; // weak
int dword_20002068; // weak
char byte_2000206C; // weak
char byte_2000206D; // weak
char byte_2000206E; // weak
int dword_20002070; // weak
int dword_20002074; // weak
int dword_20002078; // weak
int dword_2000207C; // weak
int dword_20002090; // weak
int dword_20002094; // weak
int dword_20002098; // weak
int dword_200020C0; // weak
int dword_200020C4; // weak
int dword_200020C8; // weak
int dword_200020CC; // weak
int dword_200020D0; // weak
int dword_200020D4; // weak
int dword_200020D8; // weak
int dword_200020DC; // weak
int dword_200020E0; // weak
int dword_200020E4; // weak
int dword_2000210C; // weak
int dword_20002120[5]; // weak
int dword_20002134[5]; // weak
int dword_20002148; // weak
int dword_2000214C; // weak
int dword_20002150; // weak
int dword_20002154; // weak
int dword_20002158; // weak
int dword_20002160; // weak
int dword_20002164; // weak
int dword_20002168; // weak
int dword_20002170; // weak
int dword_20002174; // weak
int dword_20002178; // weak
int dword_2000217C; // weak
int dword_20002180; // weak
int dword_20002184; // weak
int dword_20002188; // weak
int dword_2000218C; // weak
int dword_20002190; // weak
int dword_200021BC[]; // weak
int dword_200021C0; // weak
int dword_200021C4; // weak
int dword_200021C8; // weak
int dword_20002230; // weak
_UNKNOWN unk_20002234; // weak
__int16 word_20002434; // weak
float flt_20002438; // weak
float flt_2000243C; // weak
float flt_20002440; // weak
float flt_20002444; // weak
float flt_20002448; // weak
float flt_2000244C; // weak
float flt_20002450; // weak
float flt_20002454; // weak
int dword_20002458; // weak
float flt_2000245C; // weak
float flt_20002460; // weak
float flt_20002464; // weak
float flt_20002468[60]; // weak
_DWORD dword_20002558[25]; // weak
int dword_200025BC; // weak
float flt_200025C0; // weak
float flt_200025C4; // weak
float flt_200025C8; // weak
float flt_200025CC; // weak
float flt_200025D0; // weak
float flt_200025D4[15]; // weak
int dword_20002610; // weak
float flt_20002614; // weak
float flt_2000261C; // weak
int dword_20002624; // weak
int dword_20002630; // weak
_UNKNOWN unk_20002660; // weak
int dword_200026B8; // weak
int dword_200026BC; // weak
char byte_200026D8; // weak
float flt_200026DC; // weak
int dword_200026E8; // weak
_UNKNOWN unk_20002738; // weak
int dword_20002748; // weak
float flt_20002768; // weak
float flt_2000276C; // weak
int dword_20002770; // weak
int dword_20002774; // weak
int dword_20002778; // weak
float flt_2000277C; // weak
_UNKNOWN unk_20002784; // weak
float flt_20002798; // weak
float flt_200027A4; // weak
_UNKNOWN unk_200027AC; // weak
float flt_200027B0; // weak
float flt_200027B4; // weak
float flt_200027B8; // weak
int dword_200027C0; // weak
float flt_200027C8[5]; // weak
float flt_200027DC; // weak
float flt_200027E8[6]; // weak
float flt_20002800; // weak
float flt_20002804; // weak
float flt_20002808; // weak
float flt_20002810; // weak
float flt_2000281C; // weak
float flt_20002820; // weak
float flt_20002830; // weak
float flt_20002864; // weak
float flt_20002868; // weak
float flt_20002870; // weak
float flt_2000287C; // weak
float flt_20002880; // weak
float flt_20002894[2]; // weak
float flt_2000289C; // weak
float flt_200028A8; // weak
float flt_200028AC[5]; // weak
int dword_200028C0; // weak
int dword_200028C4; // weak
int dword_200028C8; // weak
int dword_200028CC; // weak
int dword_200028D0; // weak
_DWORD dword_200028F8[250]; // weak
_UNKNOWN unk_20002CE0; // weak
float flt_20002E6C; // weak
int dword_20002E74; // weak
__int16 word_20002E78; // weak
int dword_20002E7A; // weak
int dword_20002E7E; // weak
int dword_20002E82; // weak
__int16 word_20002E86; // weak
int dword_20002E88; // weak
int dword_20002E8C; // weak
int dword_20002E90; // weak
__int16 word_20002E95; // weak
int dword_20002E97; // weak
int dword_20002E9B; // weak
int dword_20002E9F; // weak
int dword_20002EA3; // weak
int dword_20002EA7; // weak
int dword_20002EAB; // weak
int dword_20002EAF; // weak
int dword_20002EB3; // weak
int dword_20002EB7; // weak
int dword_20002EBB; // weak
__int16 word_20002EBF; // weak
__int16 word_20002EC1; // weak
int dword_20002EC4[]; // weak
int dword_20002EC8; // weak
int dword_20002ECC; // weak
int dword_20002ED0; // weak
int dword_20002ED4[]; // weak
int dword_20002EDC; // weak
int dword_20002EE0; // weak
int dword_20002EE4[]; // weak
int dword_20002EEC; // weak
int dword_20002EF0[]; // weak
int dword_20002EF8; // weak
int dword_20002EFC[]; // weak
int dword_20002F00; // weak
int dword_20002F04; // weak
__int16 word_20002F08; // weak
__int16 word_20002F0A; // weak
__int16 word_20002F0C; // weak
int dword_20002F10; // weak
int dword_20002F14; // weak
int dword_20002F18; // weak
char byte_20002F1C; // weak
char byte_20002F1D; // weak
_UNKNOWN unk_20002F30; // weak
_BYTE byte_20002F44[20]; // weak
__int16 word_20002F58; // weak
__int16 word_20002F5A; // weak
__int16 word_20002F5C; // weak
char byte_20002F5F[]; // weak
char byte_20002F60; // weak
char byte_20002F61; // weak
char byte_20002F62; // weak
__int16 word_20002F63; // weak
__int16 word_20002F65; // weak
__int16 word_20002F67; // weak
char byte_20002F6B; // weak
char byte_20002F6C; // weak
__int16 word_20002F6D; // weak
__int16 word_20002F6F; // weak
__int16 word_20002F71; // weak
char byte_20002F75; // weak
char byte_20002F76; // weak
__int16 word_20002F77; // weak
__int16 word_20002F79; // weak
__int16 word_20002F7B; // weak
char byte_20002F7F; // weak
char byte_20002F80; // weak
__int16 word_20002F81; // weak
__int16 word_20002F83; // weak
__int16 word_20002F85; // weak
char byte_20002F89; // weak
char byte_20002F8A; // weak
__int16 word_20002F8B; // weak
__int16 word_20002F8D; // weak
__int16 word_20002F8F; // weak
char byte_20002F93; // weak
__int16 word_20002F95; // weak
__int16 word_20002F97; // weak
__int16 word_20002F99; // weak
__int16 word_20002FC5; // weak
int dword_20002FC7; // weak
int dword_20002FCB; // weak
char byte_20002FCF; // weak
char byte_20002FD0; // weak
char byte_20002FD1; // weak
char byte_20002FD2; // weak
char byte_20002FD3; // weak
char byte_20002FD4; // weak
char byte_20002FD5; // weak
char byte_20002FD6; // weak
__int16 word_20002FD7; // weak
char byte_20002FD9; // weak
char byte_20002FDA; // weak
char byte_20002FDB[32]; // weak
char byte_20002FFB[64]; // weak
char byte_2000303B; // weak
char byte_2000303C; // weak
char byte_2000303D; // weak
char byte_2000303E; // weak
int dword_20003040; // weak
int dword_20003044; // weak
int dword_20003048; // weak
int dword_2000304C; // weak
int dword_20003050; // weak
int dword_20003054; // weak
int dword_20003058; // weak
int dword_2000305C; // weak
int dword_20003060; // weak
char byte_20003064[]; // weak
char byte_20003065; // weak
char byte_20003066; // weak
__int16 word_20003067; // weak
__int16 word_2000306A; // weak
char byte_20003164[]; // weak
char byte_20003165; // weak
unsigned __int8 byte_20003166[254]; // weak
int dword_20003664; // weak
int dword_20003668; // weak
int dword_2000366C; // weak
int dword_20003670; // weak
_BYTE byte_20003674[256]; // weak
float flt_20003778; // weak
float flt_2000377C; // weak
float flt_20003780; // weak
float flt_20003784; // weak
int dword_20003788; // weak
float flt_20003790; // weak
float flt_20003794; // weak
float flt_20003798; // weak
float flt_2000379C; // weak
float flt_200037A0; // weak
float flt_200037A4; // weak
float flt_200037A8; // weak
float flt_200037AC; // weak
float flt_200037B0; // weak
int dword_200037B4; // weak
float flt_200037BC; // weak
float flt_200037C0; // weak
float flt_200037C8; // weak
float flt_200037CC; // weak
char byte_200037D0; // weak
char byte_200037D1; // weak
char byte_200037D4[]; // weak
char byte_200037D5; // weak
char byte_200037D6; // weak
char byte_200037D7; // weak
char byte_200037D8; // weak
char byte_200037D9; // weak
char byte_200037DA; // weak
char byte_200037DB; // weak
char byte_200037DC; // weak
__int16 word_200037DD; // weak
__int16 word_200037DF; // weak
__int16 word_200037E1; // weak
char byte_200037E3; // weak
char byte_200037E4; // weak
char byte_200037E5; // weak
_BYTE byte_20003863[128]; // weak
char byte_200038E3[26]; // weak
int dword_200038FD; // weak
int dword_20003901; // weak
int dword_20003905; // weak
char byte_20003909; // weak
char byte_2000390A[256]; // weak
char byte_20003A0A; // weak
int dword_20003A0B; // weak
int dword_20003A0F; // weak
char byte_20003A13[17]; // weak
char byte_20003A24[]; // weak
char byte_20003A25; // weak
char byte_20003A26; // weak
char byte_20003A27; // weak
char byte_20003A28; // weak
_UNKNOWN unk_20003A29; // weak
__int16 word_20003C24; // weak
char byte_20003C26; // weak
__int16 word_20003C27; // weak
__int16 word_20003C29; // weak
__int16 word_20003C2B; // weak
__int16 word_20003C2D; // weak
__int16 word_20003C2F; // weak
__int16 word_20003C31; // weak
__int16 word_20003C33; // weak
__int16 word_20003C35; // weak
__int16 word_20003C37; // weak
char byte_20003C39; // weak
char byte_20003C3A; // weak
char byte_20003C3B; // weak
char byte_20003C3C; // weak
char byte_20003C3D; // weak
char byte_20003C3E; // weak
char byte_20003C3F; // weak
char byte_20003C40; // weak
char byte_20003C41; // weak
char byte_20003C42; // weak
__int16 word_20003C43; // weak
__int16 word_20003C45; // weak
__int16 word_20003C47; // weak
__int16 word_20003C49; // weak
__int16 word_20003C4B; // weak
__int16 word_20003C4D; // weak
__int16 word_20003C4F; // weak
__int16 word_20003C51; // weak
__int16 word_20003C53; // weak
__int16 word_20003C55; // weak
__int16 word_20003C57; // weak
__int16 word_20003C59; // weak
__int16 word_20003C5B; // weak
__int16 word_20003C5D; // weak
__int16 word_20003C5F; // weak
__int16 word_20003C61; // weak
int dword_20003C63; // weak
int dword_20003C67; // weak
int dword_20003C6B; // weak
int dword_20003C6F; // weak
int dword_20003C73; // weak
int dword_20003C77; // weak
int dword_20003C7B; // weak
int dword_20003C7F; // weak
int dword_20003C83; // weak
int dword_20003C87; // weak
int dword_20003C8B; // weak
int dword_20003C8F; // weak
_UNKNOWN unk_20003C93; // weak
_UNKNOWN unk_20003D13; // weak
__int64 qword_20003D20; // weak
int dword_20003D28; // weak
int dword_20003D2C; // weak
int dword_20003D30; // weak
int dword_20003D34; // weak
__int16 word_20003D38; // weak
__int16 word_20003D3A; // weak
__int16 word_20003D3C; // weak
__int16 word_20003D3E; // weak
__int16 word_20003D40; // weak
__int16 word_20003D42; // weak
__int16 word_20003D44; // weak
__int16 word_20003D46; // weak
char byte_20003D48; // weak
char byte_20003D49; // weak
char byte_20003D4A; // weak
char byte_20003D4B; // weak
char byte_20003D4C; // weak
char byte_20003D4D; // weak
char byte_20003D4E[13]; // weak
_UNKNOWN unk_20003D5B; // weak
char byte_20003D7F; // weak
char byte_20003D80; // weak
int dword_20003D81; // weak
__int16 word_20003D85; // weak
_BYTE byte_20003E99[180]; // weak
__int16 word_20003F4D; // weak
int dword_20003F4F; // weak
__int16 word_20003F53; // weak
int dword_20003F55; // weak
__int16 word_20003F59; // weak
int dword_20003F5B; // weak
__int16 word_20003F5F; // weak
char byte_20003F61; // weak
char byte_20003F62; // weak
__int16 word_20003F63; // weak
int dword_20003F65; // weak
int dword_20003F69; // weak
int dword_20003F6D; // weak
__int16 word_20003F71; // weak
__int16 word_20003F73; // weak
int dword_20003F75; // weak
int dword_20003F79; // weak
__int16 word_20003F7D; // weak
_BYTE byte_20003F9D[128]; // weak
char byte_2000401D[]; // weak
char byte_2000401E; // weak
char byte_2000401F; // weak
char byte_20004020; // weak
char byte_20004021; // weak
char byte_20004022; // weak
char byte_20004023; // weak
char byte_20004024; // weak
char byte_20004025; // weak
char byte_20004026; // weak
char byte_20004027; // weak
char byte_20004028; // weak
char byte_20004029; // weak
__int16 word_2000409D; // weak
__int16 word_2000409F; // weak
char byte_200040A1; // weak
char byte_200040A2; // weak
char byte_200040A3; // weak
char byte_200040A4; // weak
char byte_200040A5; // weak
__int16 word_200040A6; // weak
char byte_200040A8; // weak
__int16 word_200040A9; // weak
int dword_200040AB; // weak
int dword_200040AF; // weak
int dword_200040B3; // weak
int dword_200040B7; // weak
int dword_200040BB; // weak
__int16 word_200040BF; // weak
__int16 word_200040C1; // weak
char byte_200040C3; // weak
char byte_200040C4; // weak
char byte_200040C5; // weak
int dword_200040C6; // weak
int dword_200040CA; // weak
__int16 word_200040CE; // weak
__int16 word_200040D0; // weak
int dword_200040D2; // weak
int dword_200040D6; // weak
char byte_200040DA; // weak
char byte_200040DB; // weak
int dword_200040DC; // weak
int dword_200040E0; // weak
char byte_200040E4; // weak
__int16 word_200040E5; // weak
__int16 word_200040E7; // weak
char byte_200040E9; // weak
char byte_200040EA; // weak
char byte_200040EB; // weak
__int16 word_200040EC; // weak
_UNKNOWN unk_200040EE; // weak
char byte_200040FB; // weak
char byte_200040FC; // weak
char byte_200040FD; // weak
char byte_200040FE; // weak
char byte_200040FF; // weak
char byte_20004100; // weak
char byte_20004101; // weak
_UNKNOWN unk_20004102; // weak
char byte_20004152[8]; // weak
char byte_2000415A; // weak
char byte_2000415B; // weak
char byte_2000415C; // weak
char byte_2000415D; // weak
char byte_2000415E; // weak
char byte_2000415F; // weak
char byte_20004160; // weak
char byte_20004161; // weak
char byte_20004162; // weak
_UNKNOWN unk_20004163; // weak
char byte_2000435F; // weak
char byte_20004360; // weak
int dword_20004361; // weak
int dword_20004365; // weak
int dword_20004369; // weak
char byte_2000436E[]; // weak
char byte_2000436F; // weak
char byte_20004370; // weak
char byte_20004371; // weak
__int16 word_20004372; // weak
char byte_20004374[512]; // weak
unsigned __int8 byte_20004574[1024]; // weak
char byte_20004974[1024]; // weak
char byte_20004D74[32]; // weak
char byte_20004D94[1028]; // weak
int dword_20005198; // weak
int dword_2000519C; // weak
int dword_200051A0; // weak
unsigned __int16 word_200051A4[72]; // weak
char byte_20005234; // weak
char byte_20005235; // weak
char byte_20005236; // weak
int dword_20005238; // weak
int dword_2000523C; // weak
int dword_20005240; // weak
int dword_20005244; // weak
_DWORD dword_20005260[11264]; // weak
int dword_20010EF8; // weak
int dword_20010EFC; // weak
int dword_20010F00; // weak
_UNKNOWN unk_20010F04; // weak
char byte_2001104C; // weak
char byte_2001104D; // weak
char byte_2001104E; // weak
__int16 word_2001104F; // weak
__int16 word_20011051; // weak
int dword_20011053; // weak
int dword_20011057; // weak
int dword_2001105B; // weak
int dword_2001105F; // weak
int dword_20011063; // weak
__int16 word_20011067; // weak
int dword_20011069; // weak
int dword_2001106D; // weak
unsigned __int8 byte_20011071[67]; // weak
char byte_200110B4; // weak
int dword_200110B8; // weak
int dword_200110BC; // weak
int dword_200110C0; // weak
int dword_200110C4; // weak
int dword_200110C8; // weak
int dword_200110CC; // weak
char byte_200110D0[]; // weak
char byte_200110D1; // weak
char byte_200110D2; // weak
__int16 word_200111D2; // weak
char byte_200111D4[32]; // weak
int dword_200111F4; // weak
__int16 word_200111F8; // weak
char byte_200111FA; // weak
_UNKNOWN unk_200111FB; // weak
int dword_20011208; // weak
int dword_2001120E; // weak
int dword_20011212; // weak
int dword_20011216; // weak
char byte_2001121B; // weak
__int16 word_2001121C; // weak
unsigned __int8 byte_20011220[44]; // weak
int dword_2001124C; // weak
int dword_20011250; // weak
int dword_20011254; // weak
int dword_20011258; // weak
char byte_2001125C; // weak
int dword_20011260; // weak
char byte_20011264; // weak
int dword_20011268; // weak
char byte_2001126C; // weak
char byte_2001126D; // weak
int dword_20011270; // weak
int dword_20011274; // weak
int dword_20011278; // weak
int dword_2001127C; // weak
int dword_20011280; // weak
int dword_20011284; // weak
int dword_20011288; // weak
int dword_2001128C; // weak
int dword_20011290; // weak
int dword_20011294; // weak
__int64 qword_20011298; // weak
int dword_200112A0; // weak
int dword_200112A4; // weak
char byte_200112A8[128]; // weak
_BYTE byte_20011328[936]; // weak
int dword_20011728; // weak
int dword_2001172C; // weak
int dword_20011730; // weak
int dword_20011734; // weak
_DWORD dword_20011738[5]; // weak
_BYTE byte_2001174C[12]; // weak
int dword_20011758[160]; // weak
_DWORD dword_200119D8[10]; // weak
int dword_20011A00; // weak
int dword_20011A04; // weak
int dword_20011A0C; // weak
_DWORD dword_20011A14[3]; // weak
int dword_20011A20; // weak
int dword_20011A28; // weak
int dword_20011A2C; // weak
int SYST_CSR; // weak
int SYST_RVR; // weak
int SYST_CVR; // weak
char NVIC_IPR_0; // weak
int CPUID; // weak
int ICSR; // weak
int AIRCR; // weak
int SHPR3; // weak
int CPACR; // weak
int FPCCR; // weak
int dword_E0042000; // weak


//----- (080021E0) --------------------------------------------------------
// attributes: thunk
void __fastcall sub_80021E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  sub_8020694((int)sub_8020694, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0800220C) --------------------------------------------------------
int __fastcall sub_800220C(int a1, void *a2, void *a3, void *a4)
{
  void *v4; // r4
  void *v5; // r5
  void *v6; // r6
  int v7; // r7

  _R0 = *(_DWORD *)*loc_8002230;
  __asm { MSR.W           MSP, R0 }
  _R0 = 0;
  __asm { MSR.W           CONTROL, R0 }
  __enable_irq();
  __asm { CPSIE           F }
  __dsb(0xFu);
  __isb(0xFu);
  __asm { STC             p0, c14, [R8] }
  return sub_8002234(linux_eabi_syscall(v7, 0, a2, a3, a4, v4, v5, v6));
}
// 800222A: variable 'v7' is possibly undefined
// 800222A: variable 'v4' is possibly undefined
// 800222A: variable 'v5' is possibly undefined
// 800222A: variable 'v6' is possibly undefined
// 8002234: using guessed type int __fastcall sub_8002234(_DWORD);

//----- (08002234) --------------------------------------------------------
int *sub_8002234()
{
  int *result; // r0

  result = &CPACR;
  CPACR |= 0xF00000u;
  return result;
}
// E000ED88: using guessed type int CPACR;

//----- (080022A4) --------------------------------------------------------
unsigned int sub_80022A4()
{
  return __get_CPSR();
}

//----- (08002332) --------------------------------------------------------
unsigned int __fastcall _aeabi_memcpy8(unsigned int result, unsigned int a2, unsigned int a3)
{
  int v3; // r3
  char v4; // t1

  if ( !((result | a2) << 30) )
  {
    while ( a3 >= 4 )
    {
      v3 = *(_DWORD *)a2;
      a2 += 4;
      a3 -= 4;
      *(_DWORD *)result = v3;
      result += 4;
    }
  }
  while ( a3-- != 0 )
  {
    v4 = *(_BYTE *)a2++;
    *(_BYTE *)result++ = v4;
  }
  return result;
}

//----- (08002356) --------------------------------------------------------
_BYTE *__fastcall sub_8002356(_BYTE *result, int a2, char a3)
{
  while ( a2-- != 0 )
    *result++ = a3;
  return result;
}

//----- (08002364) --------------------------------------------------------
_BYTE *__fastcall sub_8002364(_BYTE *a1, int a2)
{
  return sub_8002356(a1, a2, 0);
}

//----- (08002368) --------------------------------------------------------
_BYTE *__fastcall sub_8002368(_BYTE *a1, char a2, int a3)
{
  sub_8002356(a1, a3, a2);
  return a1;
}

//----- (0800237A) --------------------------------------------------------
int __fastcall sub_800237A(int result, unsigned __int8 *a2)
{
  _BYTE *v2; // r2
  int v4; // t1

  v2 = (_BYTE *)(result - 1);
  while ( *++v2 )
    ;
  do
  {
    v4 = *a2++;
    *v2++ = v4;
  }
  while ( v4 );
  return result;
}

//----- (08002392) --------------------------------------------------------
unsigned __int8 *__fastcall strstr(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  unsigned __int8 *result; // r0
  unsigned __int8 *v6; // t1
  unsigned __int8 *v7; // r4
  unsigned __int8 *v8; // t1

  while ( 1 )
  {
    v3 = a1;
    v4 = a2;
    do
    {
      v6 = (unsigned __int8 *)*v3++;
      result = v6;
      v8 = (unsigned __int8 *)*v4++;
      v7 = v8;
    }
    while ( result && result == v7 );
    if ( !v7 )
      break;
    if ( !result )
      return result;
    ++a1;
  }
  return a1;
}

//----- (080023B6) --------------------------------------------------------
_BYTE *__fastcall sub_80023B6(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  _BYTE *v3; // r4
  int v4; // r3

  v3 = a1;
  while ( a3-- != 0 )
  {
    v4 = *a2;
    *a1++ = v4;
    if ( v4 )
      ++a2;
  }
  return v3;
}

//----- (080023CE) --------------------------------------------------------
int __fastcall sub_80023CE(int a1, unsigned __int8 a2)
{
  int v2; // r2
  int result; // r0
  int v4; // r1
  int v5; // t1

  v2 = a2;
  result = a1 - 1;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)++result;
    v4 = v5;
    if ( v2 == v5 )
      break;
    if ( !v4 )
      return 0;
  }
  return result;
}

//----- (080023E2) --------------------------------------------------------
unsigned __int8 *__fastcall sub_80023E2(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r2

  v1 = a1 + 1;
  while ( *a1++ )
    ;
  return (unsigned __int8 *)(a1 - v1);
}

//----- (080023F0) --------------------------------------------------------
int __fastcall sub_80023F0(int a1, int a2)
{
  int i; // r2
  int v3; // r3
  int v4; // r4

  for ( i = 0; ; ++i )
  {
    v3 = *(unsigned __int8 *)(a1 + i);
    v4 = *(unsigned __int8 *)(a2 + i);
    if ( v3 != v4 || !*(_BYTE *)(a1 + i) )
      break;
  }
  return (unsigned __int8)v3 - (unsigned __int8)v4;
}

//----- (0800240C) --------------------------------------------------------
_BYTE *__fastcall sub_800240C(_BYTE *a1, unsigned __int8 *a2)
{
  _BYTE *v2; // r3
  int v3; // t1

  v2 = a1;
  do
  {
    v3 = *a2++;
    *a1++ = v3;
  }
  while ( v3 );
  return v2;
}

//----- (0800241E) --------------------------------------------------------
int __fastcall sub_800241E(int a1, int a2, unsigned int a3)
{
  int result; // r0
  unsigned int i; // r3

  result = 0;
  for ( i = 0; i < a3; ++i )
  {
    result = *(unsigned __int8 *)(a1 + i) - *(unsigned __int8 *)(a2 + i);
    if ( result || !*(_BYTE *)(a1 + i) )
      break;
  }
  return result;
}

//----- (0800243C) --------------------------------------------------------
unsigned int __fastcall sub_800243C(_BYTE *a1, _BYTE *a2)
{
  unsigned int v2; // r4
  _BYTE *i; // r2
  int v4; // r3

  if ( !a1 )
    a1 = (_BYTE *)dword_200016C0;
  v2 = 0;
  while ( *a1 )
  {
    for ( i = a2; ; ++i )
    {
      v4 = (unsigned __int8)*i;
      if ( !*i || (unsigned __int8)*a1 == v4 )
        break;
    }
    if ( (unsigned __int8)v4 | v2 )
    {
      if ( *i && v2 )
      {
        *a1++ = 0;
        break;
      }
    }
    else
    {
      v2 = (unsigned int)a1;
    }
    ++a1;
  }
  dword_200016C0 = (int)a1;
  return v2;
}
// 200016C0: using guessed type int dword_200016C0;

//----- (08002480) --------------------------------------------------------
_BYTE *__fastcall sub_8002480(_BYTE *result, char a2)
{
  _BYTE *v2; // r2

  v2 = result;
  while ( *result )
    ++result;
  while ( --result >= v2 )
  {
    if ( *result == a2 )
      return result;
  }
  return 0;
}

//----- (080024A0) --------------------------------------------------------
_BYTE *__fastcall sub_80024A0(_BYTE *result, _BYTE *a2)
{
  _BYTE *i; // r2

  while ( *result )
  {
    for ( i = a2; *i; ++i )
    {
      if ( *i == *result )
        return result;
    }
    ++result;
  }
  return 0;
}

//----- (080024C0) --------------------------------------------------------
int scanf(int a1, int a2, ...)
{
  _DWORD v3[9]; // [sp+0h] [bp-48h] BYREF
  _DWORD v4[4]; // [sp+24h] [bp-24h] BYREF
  va_list varg_r2; // [sp+40h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  v4[0] = a1;
  v4[2] = a1;
  va_copy((va_list)v3, varg_r2);
  v4[1] = -1;
  v4[3] = 0;
  v3[6] = &loc_80030FC;
  v3[7] = &loc_800311A;
  return sub_80028E0((int)v4, a2, v3);
}

//----- (080024F8) --------------------------------------------------------
int __fastcall scanf_int(int a1, int a2, unsigned int a3, int a4)
{
  int v5; // r4
  int v6; // r6
  int v8; // r7
  int v9; // r8
  unsigned int v10; // r10
  unsigned int v11; // r4
  int v13; // r0
  int v14; // r0
  signed int v15; // r0
  int v16; // r0
  _BYTE **v17; // r1
  _BYTE *v18; // r1
  _BYTE **v19; // r0
  _BYTE *v20; // r0

  v6 = *(_DWORD *)(a4 + 8);
  v5 = *(_DWORD *)(a4 + 4);
  v8 = -1;
  v9 = 0;
  do
  {
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  }
  while ( (*(int (__fastcall **)(unsigned int))(a4 + 32))(v10) );
  if ( v10 == -1 )
    return -1;
  v11 = v5 & 0xFFFFF9FF;
  if ( v6 <= 0 )
    goto LABEL_12;
  if ( (v11 & 0x40) != 0 )
  {
    if ( v10 != 43 )
    {
      if ( v10 != 45 )
        goto LABEL_11;
      v11 |= 0x400u;
    }
    ++v8;
    --v6;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
    if ( v6 <= 0 )
    {
LABEL_12:
      if ( a3 )
        goto LABEL_26;
      v14 = 10;
      goto LABEL_24;
    }
  }
LABEL_11:
  if ( v10 != 48 )
    goto LABEL_12;
  --v6;
  v11 |= 0x200u;
  ++v8;
  v13 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  v10 = v13;
  if ( v6 <= 0 || v13 != 120 && v13 != 88 )
  {
    if ( a3 )
      goto LABEL_26;
    v14 = 8;
    goto LABEL_24;
  }
  if ( !a3 || a3 == 16 )
  {
    --v6;
    v11 &= ~0x200u;
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
    v14 = 16;
LABEL_24:
    a3 = v14;
  }
LABEL_26:
  while ( v6 > 0 )
  {
    v15 = sub_80028B6(v10, a3);
    if ( v15 < 0 )
      break;
    v9 = v15 + v9 * a3;
    --v6;
    v11 |= 0x200u;
    ++v8;
    v10 = (*(int (__fastcall **)(int))(a4 + 24))(a2);
  }
  (*(void (__fastcall **)(int))(a4 + 28))(a2);
  if ( (v11 & 0x200) == 0 )
    return -2;
  if ( !(v11 << 31) )
  {
    if ( (v11 & 0x40) != 0 )
    {
      if ( (v11 & 0x400) != 0 )
        v16 = -v9;
      else
        v16 = v9;
      v17 = *(_BYTE ***)a4;
      *(_DWORD *)a4 += 4;
      v18 = *v17;
      if ( (v11 & 0x800) != 0 )
      {
        *v18 = v16;
      }
      else if ( (v11 & 8) != 0 )
      {
        *(_WORD *)v18 = v16;
      }
      else
      {
        *(_DWORD *)v18 = v16;
      }
    }
    else
    {
      v19 = *(_BYTE ***)a4;
      *(_DWORD *)a4 += 4;
      v20 = *v19;
      if ( (v11 & 0x800) != 0 )
      {
        *v20 = v9;
      }
      else if ( (v11 & 8) != 0 )
      {
        *(_WORD *)v20 = v9;
      }
      else
      {
        *(_DWORD *)v20 = v9;
      }
    }
  }
  return v8;
}

//----- (08002644) --------------------------------------------------------
int __fastcall sub_8002644(char *a1)
{
  _DWORD *v2; // r0
  int v3; // r4
  _DWORD *v4; // r5
  int result; // r0

  v2 = sub_801EA6C();
  v3 = *v2;
  v4 = v2;
  result = strtol(a1, 0, 10);
  *v4 = v3;
  return result;
}

//----- (08002764) --------------------------------------------------------
void __fastcall sub_8002764(unsigned int a1)
{
  sub_8002A38(a1, 0, 0);
}

//----- (08002814) --------------------------------------------------------
int __fastcall sub_8002814(__int64 a1)
{
  unsigned int v1; // r3
  int v2; // r2
  int result; // r0
  int v4; // r4
  int v5; // r1

  v1 = HIDWORD(a1) & 0x80000000;
  HIDWORD(a1) &= ~0x80000000;
  if ( !a1 )
    return 0;
  v2 = (HIDWORD(a1) >> 20) - 896;
  HIDWORD(a1) &= 0xFFFFFu;
  if ( v2 <= 0 )
    return 0;
  v4 = a1 >> 29;
  v5 = 8 * a1;
  result = v4 + v1 + (v2 << 23);
  if ( v5 < 0 )
  {
    ++result;
    if ( !(2 * v5) )
      return result & 0xFFFFFFFE;
  }
  return result;
}

//----- (08002878) --------------------------------------------------------
int __fastcall sub_8002878(int a1, int a2, int a3)
{
  if ( a3 < 32 )
    return a1 << a3;
  else
    return 0;
}

//----- (08002896) --------------------------------------------------------
unsigned int __fastcall ll_ushift_r(unsigned int a1, unsigned int a2, int a3)
{
  if ( a3 < 32 )
    return (a1 >> a3) | (a2 << (32 - a3));
  else
    return a2 >> (a3 - 32);
}

//----- (080028B6) --------------------------------------------------------
unsigned int __fastcall sub_80028B6(unsigned int result, unsigned int a2)
{
  if ( result < 0x3A )
    result -= 48;
  if ( (result & 0xFFFFFFDF) >= 0x41 )
    result = (result & 0xFFFFFFDF) - 55;
  if ( result >= a2 )
    return -1;
  return result;
}

//----- (080028D4) --------------------------------------------------------
int __fastcall sub_80028D4(_DWORD *a1, int a2)
{
  int v2; // r3

  v2 = *(unsigned __int8 *)*a1;
  *a1 += a2;
  return v2;
}

//----- (080028E0) --------------------------------------------------------
int __fastcall sub_80028E0(int a1, int a2, _DWORD *a3)
{
  a3[3] = a2;
  a3[5] = 134230229;
  a3[8] = 134231473;
  a3[4] = 0;
  return sub_8002DC4(a1, (int)a3);
}

//----- (080028FC) --------------------------------------------------------
int __fastcall sub_80028FC(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // r2
  int v2; // r3

  v1 = a1[1];
  if ( v1 && (v2 = **a1) != 0 )
  {
    ++*a1;
    a1[1] = v1 - 1;
    return v2;
  }
  else
  {
    a1[3] = (unsigned __int8 *)1;
    return -1;
  }
}

//----- (0800291A) --------------------------------------------------------
int __fastcall sbackspace(int *a1)
{
  int v1; // r2
  int v2; // r1

  v1 = a1[1];
  if ( !v1 )
    return -1;
  v2 = *a1;
  if ( a1[3] || a1[2] == v2 )
    return -1;
  *a1 = v2 - 1;
  a1[1] = v1 + 1;
  return 0;
}

//----- (0800293C) --------------------------------------------------------
int __fastcall strtol(char *nptr, char **endptr, int base)
{
  const char *v6; // r4
  __int16 v7; // r6
  int v8; // r5
  int v9; // t1
  int result; // r0

  v6 = nptr;
  v7 = 0;
  do
  {
    v9 = *(unsigned __int8 *)v6++;
    v8 = v9;
  }
  while ( v9 && *(unsigned __int8 *)(*(_DWORD *)sub_8002DA8() + v8) << 31 );
  if ( v8 != 43 )
  {
    if ( v8 == 45 )
      v7 = 1024;
    else
      --v6;
  }
  result = strtoul(v6, endptr, base);
  if ( endptr && *endptr == v6 )
    *endptr = nptr;
  if ( (v7 & 0x400) != 0 )
  {
    result = -result;
    if ( result > 0 )
    {
      *(_DWORD *)sub_801EA6C() = 2;
      return 0x80000000;
    }
  }
  else if ( result < 0 )
  {
    *(_DWORD *)sub_801EA6C() = 2;
    return 0x7FFFFFFF;
  }
  return result;
}

//----- (080029EC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall SVCall_handler(unsigned int a1, int a2, int a3)
{
  bool v3; // nf
  int v4; // r3
  int v5; // r1
  unsigned int v6; // r0
  unsigned int result; // r0

  v4 = a2 + 7;
  v3 = a2 + 7 < 0;
  v5 = a1 << 24;
  v6 = a1 >> 8;
  if ( v3 )
    return 0;
  result = v6 + (v4 << 23) + a3;
  if ( v5 < 0 )
  {
    ++result;
    if ( !(2 * v5) )
      result &= ~1u;
  }
  return result;
}
// 80029FC: positive sp value 4 has been found

//----- (08002A1A) --------------------------------------------------------
unsigned int __fastcall sub_8002A1A(unsigned int result, int a2, __int64 a3)
{
  if ( a3 < 0 )
  {
    ++result;
    if ( !((2 * (_DWORD)a3) | (unsigned int)(HIDWORD(a3) + ((a3 + (unsigned __int64)(unsigned int)a3) >> 32))) )
      result &= ~1u;
  }
  return result;
}

//----- (08002A38) --------------------------------------------------------
void __fastcall sub_8002A38(unsigned int a1, unsigned int a2, __int64 a3)
{
  int v4; // r2
  int v5; // r8
  __int64 v6; // r0

  if ( a2 )
    v4 = __clz(a2);
  else
    v4 = __clz(a1) + 32;
  v5 = v4;
  LODWORD(v6) = sub_8002878(a1, a2, v4);
  if ( v6 | a3 )
  {
    if ( a3 )
    {
      ll_ushift_r(a3, HIDWORD(a3), 64 - v5);
      sub_8002878(a3, SHIDWORD(a3), v5);
    }
    JUMPOUT(0x8002AAA);
  }
  JUMPOUT(0x8002A94);
}
// 8002A92: control flows out of bounds to 8002A94
// 8002AA8: control flows out of bounds to 8002AAA
// 8002A58: variable 'v6' is possibly undefined

//----- (08002AAC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall Reset_handler(int a1, int a2, __int64 a3, __int64 a4)
{
  int v5; // r4
  unsigned int v6; // r7
  __int64 v7; // r4
  int (__fastcall *v8)(_DWORD, _DWORD, _DWORD); // [sp-4h] [bp-4h]

  LODWORD(a3) = 0;
  HIDWORD(v7) = v6 >> 11;
  LODWORD(v7) = v5 | (v6 << 21);
  if ( a2 + 10 >= 0 )
    return sub_8002A1A(v7 + a4, (__PAIR64__((a2 + 10) << 20, 0) + v7 + a4) >> 32, a3);
  else
    return v8(0, 0, 0);
}
// 8002AD2: positive sp value 20 has been found
// 8002AAC: could not find valid save-restore pair for r5
// 8002AAC: could not find valid save-restore pair for r6
// 8002AAC: could not find valid save-restore pair for r8
// 8002AAC: could not find valid save-restore pair for r10
// 8002AAC: could not find valid save-restore pair for r11
// 8002AB0: variable 'v6' is possibly undefined
// 8002AB2: variable 'v5' is possibly undefined
// 8002A94: variable 'v8' is possibly undefined

//----- (08002D00) --------------------------------------------------------
int __fastcall sub_8002D00(unsigned int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r1
  bool v5; // cc
  int v6; // r2

  v2 = (a2 >> 20) & 0x7FF;
  v3 = a2 & 0xFFFFF | 0x100000;
  if ( v2 < 1023 )
    return 0;
  v5 = v2 <= 1075;
  v6 = v2 - 1075;
  if ( v5 )
    return ll_ushift_r(a1, v3, -v6);
  else
    return sub_8002878(a1, v3, v6);
}

//----- (08002D84) --------------------------------------------------------
int __fastcall ll_sshift_r(unsigned int a1, int a2, int a3)
{
  if ( a3 < 32 )
    return (a1 >> a3) | (a2 << (32 - a3));
  else
    return a2 >> (a3 - 32);
}

//----- (08002DA8) --------------------------------------------------------
char *sub_8002DA8()
{
  return "o15=%d,b_vo16=%d";
}

//----- (08002DB0) --------------------------------------------------------
int __fastcall sub_8002DB0(int a1)
{
  return *(_BYTE *)(*(_DWORD *)sub_8002DA8() + a1) & 1;
}

//----- (08002DC4) --------------------------------------------------------
int __fastcall sub_8002DC4(int a1, int a2)
{
  int v2; // r8
  int v4; // r11
  int v5; // r6
  int v6; // r0
  int v7; // r5
  int v8; // r0
  int v9; // r0
  int v10; // r7
  int v11; // r7
  int v12; // r5
  int v13; // r0
  int v14; // r5
  int v15; // r0
  int v16; // r3
  unsigned int v17; // r2
  _BYTE **v18; // r0
  _BYTE *v19; // r0
  int v20; // r9
  int v21; // r0
  int i; // r1
  int j; // r0
  int v25; // [sp+4h] [bp-54h]
  _DWORD v26[9]; // [sp+8h] [bp-50h]
  int v27; // [sp+2Ch] [bp-2Ch]
  int v28; // [sp+30h] [bp-28h]

  v27 = a1;
  v28 = a2;
  v2 = 0;
  v4 = 1;
  v5 = 0;
  v25 = a2 + 12;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        v7 = v6;
        if ( !v6 )
          return v2;
        if ( v6 == 37 )
          break;
        if ( (*(int (__fastcall **)(int))(a2 + 32))(v6) )
        {
          do
            v8 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          while ( (*(int (__fastcall **)(int))(a2 + 32))(v8) );
          (*(void (__fastcall **)(int, int))(a2 + 20))(v25, -1);
          while ( 1 )
          {
            v9 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
            if ( !(*(int (__fastcall **)(int))(a2 + 32))(v9) )
              break;
            ++v5;
          }
          (*(void (__fastcall **)(int))(a2 + 28))(v27);
        }
        else
        {
          v10 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
          if ( v10 != v7 )
          {
            (*(void (__fastcall **)(int))(a2 + 28))(v27);
            if ( v10 != -1 )
              return v2;
            goto LABEL_14;
          }
LABEL_12:
          ++v5;
        }
      }
      v11 = 0;
      v12 = 0;
      if ( (*(int (__fastcall **)(int, _DWORD))(a2 + 20))(v25, 0) == 42 )
      {
        (*(void (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        v12 = 1;
      }
      while ( 1 )
      {
        v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        if ( (unsigned int)(v13 - 48) >= 0xA )
          break;
        if ( v11 > 214748364 )
          return v2;
        v11 = v13 + 10 * v11 - 48;
        if ( v11 < 0 )
          return v2;
        v12 |= 0x10u;
      }
      if ( (v12 & 0x10) == 0 )
        v11 = 0x7FFFFFFF;
      switch ( v13 )
      {
        case 'l':
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          if ( v13 != 108 )
          {
            v12 |= 4u;
            break;
          }
LABEL_33:
          v12 |= 2u;
LABEL_38:
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          break;
        case 'L':
          v12 |= 0x20u;
          goto LABEL_38;
        case 'h':
          v13 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
          if ( v13 != 104 )
          {
            v12 |= 8u;
            break;
          }
          v12 |= 0x800u;
          goto LABEL_38;
        case 'j':
          goto LABEL_33;
        case 't':
        case 'z':
          goto LABEL_38;
      }
      *(_DWORD *)(a2 + 4) = v12;
      *(_DWORD *)(a2 + 8) = v11;
      if ( v13 == 101 )
        goto LABEL_72;
      if ( v13 <= 101 )
        break;
      if ( v13 == 111 )
      {
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 8;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
      if ( v13 > 111 )
      {
        switch ( v13 )
        {
          case 'p':
            *(_DWORD *)(a2 + 4) = v12 & 0xFFFFF7F1;
            break;
          case 's':
            goto LABEL_93;
          case 'u':
            goto LABEL_86;
          case 'x':
LABEL_88:
            *(_DWORD *)(a2 + 4) = v12 | 0x40;
            if ( (v12 & 2) != 0 )
            {
LABEL_89:
              v15 = -2;
              goto LABEL_112;
            }
            break;
          default:
            return v2;
        }
        v16 = a2;
        v17 = 16;
LABEL_92:
        v15 = scanf_int(-2, v27, v17, v16);
        goto LABEL_112;
      }
      if ( v13 == 102 || v13 == 103 )
        goto LABEL_72;
      if ( v13 == 105 )
      {
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 0;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
      if ( v13 != 110 )
        return v2;
      if ( !(v12 << 31) )
      {
        v18 = *(_BYTE ***)a2;
        *(_DWORD *)a2 += 4;
        v19 = *v18;
        if ( (v12 & 0x800) != 0 )
        {
          *v19 = v5;
        }
        else if ( (v12 & 8) != 0 )
        {
          *(_WORD *)v19 = v5;
        }
        else if ( (v12 & 2) != 0 )
        {
          *(_QWORD *)v19 = v5;
        }
        else
        {
          *(_DWORD *)v19 = v5;
        }
      }
    }
    if ( v13 == 88 )
      goto LABEL_88;
    if ( v13 <= 88 )
      break;
    if ( v13 != 91 )
    {
      if ( v13 == 97 )
        goto LABEL_72;
      if ( v13 != 99 )
      {
        if ( v13 != 100 )
          return v2;
LABEL_86:
        *(_DWORD *)(a2 + 4) = v12 | 0x40;
        v16 = a2;
        v17 = 10;
        if ( (v12 & 2) != 0 )
          goto LABEL_89;
        goto LABEL_92;
      }
    }
LABEL_93:
    v20 = 0;
    if ( v13 == 99 )
    {
      if ( (v12 & 0x10) == 0 )
        *(_DWORD *)(a2 + 8) = 1;
    }
    else if ( v13 == 91 )
    {
      v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
      if ( v21 == 94 )
      {
        v20 = 1;
        v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
      }
      if ( !*(_DWORD *)(a2 + 16) )
      {
        for ( i = 0; i < 8; ++i )
          v26[i] = 0;
      }
      while ( v21 )
      {
        if ( !*(_DWORD *)(a2 + 16) )
          v26[v21 / 32] |= 1 << (v21 % 32);
        v21 = (*(int (__fastcall **)(int, int))(a2 + 20))(v25, 1);
        if ( v21 == 93 )
        {
          if ( v20 )
          {
            for ( j = 0; j < 8; ++j )
              v26[j] = ~v26[j];
          }
          goto LABEL_111;
        }
      }
      return v2;
    }
LABEL_111:
    v15 = -2;
LABEL_112:
    if ( v15 < 0 )
    {
      if ( v15 == -1 && v4 )
        return -1;
      return v2;
    }
    if ( !(v12 << 31) )
      ++v2;
    v5 += v15;
    v4 = 0;
  }
  if ( v13 == 69 )
  {
LABEL_72:
    v15 = -2;
    goto LABEL_112;
  }
  if ( v13 > 69 )
  {
    if ( v13 != 70 && v13 != 71 )
      return v2;
    goto LABEL_72;
  }
  if ( v13 != 37 )
  {
    if ( v13 != 65 )
      return v2;
    goto LABEL_72;
  }
  v14 = (*(int (__fastcall **)(int))(a2 + 24))(v27);
  if ( v14 == 37 )
    goto LABEL_12;
  (*(void (__fastcall **)(int))(a2 + 28))(v27);
  if ( v14 != -1 )
    return v2;
LABEL_14:
  if ( !v2 )
    return -1;
  return v2;
}

//----- (080030F0) --------------------------------------------------------
unsigned int strtoul(const char *nptr, char **endptr, int base)
{
  unsigned int v4; // r0
  int v5; // r7
  unsigned int v6; // r5
  const char *v8; // r4
  int v9; // r9
  unsigned int v10; // t1
  unsigned int v11; // t1
  unsigned int v12; // r6
  int v13; // r8
  unsigned int v14; // r0
  unsigned int v15; // t1
  signed int v16; // r0
  char *v17; // r4

  v4 = *(unsigned __int8 *)nptr;
  v5 = 0;
  v6 = base;
  v8 = nptr + 1;
  v9 = 0;
  if ( v4 == 48 )
  {
    v10 = *(unsigned __int8 *)v8;
    v8 = nptr + 2;
    v4 = v10;
    v5 = 1;
    if ( v10 == 120 || v4 == 88 )
    {
      if ( !base || base == 16 )
      {
        v5 = 0;
        v6 = 16;
        v11 = *(unsigned __int8 *)v8;
        v8 = nptr + 3;
        v4 = v11;
      }
    }
    else if ( !base )
    {
      v6 = 8;
    }
  }
  else if ( !base )
  {
    v6 = 10;
  }
  v12 = 0;
  v13 = 0;
  while ( 1 )
  {
    v16 = sub_80028B6(v4, v6);
    if ( v16 < 0 )
      break;
    v14 = v16 + v6 * v13;
    v5 = 1;
    v12 = v6 * v12 + HIWORD(v14);
    v13 = (unsigned __int16)v14;
    if ( v12 >= 0x10000 )
      v9 = 1;
    v15 = *(unsigned __int8 *)v8++;
    v4 = v15;
  }
  if ( endptr )
  {
    if ( v5 )
      v17 = (char *)(v8 - 1);
    else
      v17 = (char *)nptr;
    *endptr = v17;
  }
  if ( !v9 )
    return v13 | (v12 << 16);
  *(_DWORD *)sub_801EA6C() = 2;
  return -1;
}

//----- (0800318E) --------------------------------------------------------
void __fastcall _decompress1(unsigned __int8 *src, unsigned __int8 *dst, int len)
{
  unsigned __int8 *v3; // r4
  int v4; // r5
  int v5; // t1
  int v6; // r3
  int v7; // t1
  int v8; // r2
  int v9; // t1
  unsigned __int8 v10; // t1
  int v11; // t1
  unsigned __int8 *v12; // r3
  int v13; // r2
  unsigned __int8 v14; // t1

  v3 = &dst[len];
  do
  {
    v5 = *src++;
    v4 = v5;
    v6 = v5 & 7;
    if ( (v5 & 7) == 0 )
    {
      v7 = *src++;
      v6 = v7;
    }
    v8 = v4 >> 4;
    if ( !(v4 >> 4) )
    {
      v9 = *src++;
      v8 = v9;
    }
    while ( --v6 )
    {
      v10 = *src++;
      *dst++ = v10;
    }
    if ( (v4 & 8) != 0 )
    {
      v11 = *src++;
      v12 = &dst[-v11];
      v13 = v8 + 2;
      while ( --v13 >= 0 )
      {
        v14 = *v12++;
        *dst++ = v14;
      }
    }
    else
    {
      while ( --v8 >= 0 )
        *dst++ = 0;
    }
  }
  while ( dst < v3 );
}

//----- (080031E4) --------------------------------------------------------
void sub_80031E4()
{
  JUMPOUT(0x10000C44);
}
// 80031EC: control flows out of bounds to 10000C44

//----- (080031EE) --------------------------------------------------------
void sub_80031EE()
{
  JUMPOUT(0x100076E8);
}
// 80031F6: control flows out of bounds to 100076E8

//----- (080031F8) --------------------------------------------------------
void sub_80031F8()
{
  JUMPOUT(0x10007744);
}
// 8003200: control flows out of bounds to 10007744

//----- (08003202) --------------------------------------------------------
void sub_8003202()
{
  JUMPOUT(0x10007780);
}
// 800320A: control flows out of bounds to 10007780

//----- (0800320C) --------------------------------------------------------
void sub_800320C()
{
  JUMPOUT(0x10001410);
}
// 8003214: control flows out of bounds to 10001410

//----- (08003216) --------------------------------------------------------
void sub_8003216()
{
  JUMPOUT(0x10006AD8);
}
// 800321E: control flows out of bounds to 10006AD8

//----- (08003220) --------------------------------------------------------
void sub_8003220()
{
  JUMPOUT(0x10006B78);
}
// 8003228: control flows out of bounds to 10006B78

//----- (0800322A) --------------------------------------------------------
void sub_800322A()
{
  JUMPOUT(0x1000231C);
}
// 8003232: control flows out of bounds to 1000231C

//----- (08003234) --------------------------------------------------------
void sub_8003234()
{
  JUMPOUT(0x100001C4);
}
// 800323C: control flows out of bounds to 100001C4

//----- (0800323E) --------------------------------------------------------
void sub_800323E()
{
  JUMPOUT(0x10007550);
}
// 8003246: control flows out of bounds to 10007550

//----- (08003248) --------------------------------------------------------
void sub_8003248()
{
  JUMPOUT(0x1000757C);
}
// 8003250: control flows out of bounds to 1000757C

//----- (08003252) --------------------------------------------------------
void sub_8003252()
{
  JUMPOUT(0x10001010);
}
// 800325A: control flows out of bounds to 10001010

//----- (08003266) --------------------------------------------------------
void sub_8003266()
{
  JUMPOUT(0x10000BFC);
}
// 800326E: control flows out of bounds to 10000BFC

//----- (08003270) --------------------------------------------------------
void sub_8003270()
{
  JUMPOUT(0x10000C18);
}
// 8003278: control flows out of bounds to 10000C18

//----- (0800327A) --------------------------------------------------------
void sub_800327A()
{
  JUMPOUT(0x10000B40);
}
// 8003282: control flows out of bounds to 10000B40

//----- (08003284) --------------------------------------------------------
void sub_8003284()
{
  JUMPOUT(0x10000B28);
}
// 800328C: control flows out of bounds to 10000B28

//----- (0800328E) --------------------------------------------------------
void sub_800328E()
{
  JUMPOUT(0x10005F8C);
}
// 8003296: control flows out of bounds to 10005F8C

//----- (080032A2) --------------------------------------------------------
void sub_80032A2()
{
  JUMPOUT(0x10000AA0);
}
// 80032AA: control flows out of bounds to 10000AA0

//----- (080032AC) --------------------------------------------------------
void sub_80032AC()
{
  JUMPOUT(0x10000188);
}
// 80032B4: control flows out of bounds to 10000188

//----- (080032B6) --------------------------------------------------------
int __fastcall sub_80032B6(int a1)
{
  int *v1; // r4
  int v3; // r0

  v1 = *(int **)(a1 + 40);
  if ( (v1[23] & 0x50) != 0 )
  {
    if ( (v1[23] & 0x10) != 0 )
      return nullsub_3(*(_DWORD *)(a1 + 40));
    else
      return (*(int (**)(void))(v1[21] + 52))();
  }
  else
  {
    v1[23] |= 0x200u;
    v3 = *v1;
    if ( (*(_DWORD *)*v1 & 8) != 0 )
    {
      if ( sub_8017340(v3) )
      {
        if ( (*(_DWORD *)(*v1 + 12) & 0x2000) == 0 )
        {
          v1[23] &= ~0x100u;
          if ( (v1[23] & 0x1000) == 0 )
            v1[23] |= 1u;
        }
      }
    }
    else if ( (*(_DWORD *)(v3 + 12) & 2) == 0 )
    {
      v1[23] &= ~0x100u;
      if ( (v1[23] & 0x1000) == 0 )
        v1[23] |= 1u;
    }
    return sub_8010D08(v1);
  }
}
// 800F7F2: using guessed type int __fastcall nullsub_3(_DWORD);

//----- (08003334) --------------------------------------------------------
int __fastcall sub_8003334(int a1)
{
  int v1; // r0

  v1 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v1 + 92) |= 0x40u;
  *(_DWORD *)(v1 + 96) |= 4u;
  return nullsub_3();
}
// 800F7F2: using guessed type int nullsub_3(void);

//----- (0800334E) --------------------------------------------------------
int __fastcall sub_800334E(int a1)
{
  return nullsub_4(*(_DWORD *)(a1 + 40));
}
// 800F7F0: using guessed type int __fastcall nullsub_4(_DWORD);

//----- (08003358) --------------------------------------------------------
int __fastcall sub_8003358(int *a1)
{
  int v2; // r0
  int v3; // r5
  int v5; // r5

  v2 = *a1;
  v3 = (*(_DWORD *)(v2 + 8) >> 1) & 1;
  if ( sub_8017330(v2) && !v3 )
  {
    if ( (*(_DWORD *)(*a1 + 8) & 0xD) != 1 )
    {
      a1[23] |= 0x10u;
      a1[24] |= 1u;
      return 1;
    }
    *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 2;
    *(_DWORD *)*a1 = 3;
    v5 = sub_8012948();
    while ( *(_DWORD *)(*a1 + 8) << 31 )
    {
      if ( (unsigned int)(sub_8012948() - v5) > 2 && *(_DWORD *)(*a1 + 8) << 31 )
      {
        a1[23] |= 0x10u;
        a1[24] |= 1u;
        return 1;
      }
    }
  }
  return 0;
}

//----- (080033DC) --------------------------------------------------------
int __fastcall sub_80033DC(int *a1)
{
  int v3; // r5

  if ( !sub_8017330(*a1) )
  {
    if ( (*(_DWORD *)(*a1 + 8) & 0x8000003F) != 0 )
    {
      a1[23] |= 0x10u;
      a1[24] |= 1u;
      return 1;
    }
    *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 1;
    v3 = sub_8012948();
    while ( ~*(_DWORD *)*a1 << 31 )
    {
      if ( !sub_8017330(*a1) )
        *(_DWORD *)(*a1 + 8) = (*(_DWORD *)(*a1 + 8) & 0x7FFFFFC0) + 1;
      if ( (unsigned int)(sub_8012948() - v3) > 2 && ~*(_DWORD *)*a1 << 31 )
      {
        a1[23] |= 0x10u;
        a1[24] |= 1u;
        return 1;
      }
    }
  }
  return 0;
}

//----- (08003468) --------------------------------------------------------
int __fastcall sub_8003468(int a1, int a2, int a3, int a4)
{
  _DWORD v5[9]; // [sp+4h] [bp-24h] BYREF

  v5[0] = a2;
  v5[1] = a3;
  v5[2] = a4;
  v5[3] = 127;
  v5[4] = 4;
  v5[5] = 0;
  return sub_8010888(a1, (int)v5);
}

//----- (08003488) --------------------------------------------------------
int sub_8003488()
{
  MEMORY[0x40021048] |= 4u;
  MEMORY[0x40021048] |= 1u;
  dword_20001C54 = 1073872904;
  dword_20001C58 = 5;
  dword_20001C5C = 0;
  dword_20001C60 = 0;
  dword_20001C64 = 128;
  dword_20001C68 = 256;
  dword_20001C6C = 1024;
  dword_20001C70 = 32;
  dword_20001C74 = 4096;
  sub_8011C08((int)&dword_20001C54);
  dword_20001CB4 = 1073872924;
  dword_20001CB8 = 36;
  dword_20001CBC = 0;
  dword_20001CC0 = 0;
  dword_20001CC4 = 128;
  dword_20001CC8 = 256;
  dword_20001CCC = 1024;
  dword_20001CD0 = 32;
  dword_20001CD4 = 4096;
  sub_8011C08((int)&dword_20001CB4);
  dword_20001D14 = 1073872944;
  dword_20001D18 = 37;
  dword_20001D1C = 0;
  dword_20001D20 = 0;
  dword_20001D24 = 128;
  dword_20001D28 = 256;
  dword_20001D2C = 1024;
  dword_20001D30 = 32;
  dword_20001D34 = 4096;
  sub_8011C08((int)&dword_20001D14);
  dword_20001D74 = 1073872964;
  dword_20001D78 = 38;
  dword_20001D7C = 0;
  dword_20001D80 = 0;
  dword_20001D84 = 128;
  dword_20001D88 = 256;
  dword_20001D8C = 1024;
  dword_20001D90 = 32;
  dword_20001D94 = 4096;
  sub_8011C08((int)&dword_20001D74);
  dword_20001DD4 = 1073872984;
  dword_20001DD8 = 39;
  dword_20001DDC = 0;
  dword_20001DE0 = 0;
  dword_20001DE4 = 128;
  dword_20001DE8 = 256;
  dword_20001DEC = 1024;
  dword_20001DF0 = 32;
  dword_20001DF4 = 4096;
  sub_8011C08((int)&dword_20001DD4);
  sub_8003814();
  sub_8003468((int)&dword_20001E34, 632291840, 6, 5);
  sub_8003468((int)&dword_20001E34, 210763784, 12, 5);
  sub_8003468((int)&dword_20001E34, 562036992, 18, 5);
  sub_8003468((int)&dword_20001EA0, 70254594, 6, 3);
  sub_8003468((int)&dword_20001EA0, 281018384, 12, 5);
  sub_8003468((int)&dword_20001F0C, 210763784, 6, 5);
  sub_8003468((int)&dword_20001F0C, 70254594, 12, 5);
  sub_8003468((int)&dword_20001F0C, 140509188, 18, 5);
  sub_8003468((int)&dword_20001F78, 281018384, 6, 5);
  sub_8003468((int)&dword_20001F78, 140509188, 12, 6);
  sub_8003468((int)&dword_20001F78, 70254594, 18, 6);
  sub_8003468((int)&dword_20001FE4, 704644096, 6, 7);
  sub_8003468((int)&dword_20001FE4, 845156352, 12, 7);
  sub_8003468((int)&dword_20001FE4, 915415040, 18, 7);
  dword_20001E88 = (int)&dword_20001C54;
  dword_20001C7C = (int)&dword_20001E34;
  dword_20001EF4 = (int)&dword_20001CB4;
  dword_20001CDC = (int)&dword_20001EA0;
  dword_20001F60 = (int)&dword_20001D14;
  dword_20001D3C = (int)&dword_20001F0C;
  dword_20001FCC = (int)&dword_20001D74;
  dword_20001D9C = (int)&dword_20001F78;
  dword_20002038 = (int)&dword_20001DD4;
  dword_20001DFC = (int)&dword_20001FE4;
  sub_8013970(11, 2u, 0);
  sub_8013954(11);
  sub_80111F8((int)&dword_20001E34, (int)&word_20000078, 3);
  sub_80111F8((int)&dword_20001EA0, (int)&word_20000074, 2);
  sub_80111F8((int)&dword_20001F0C, (int)&word_2000007E, 3);
  sub_80111F8((int)&dword_20001F78, (int)&word_20000084, 3);
  return sub_80111F8((int)&dword_20001FE4, (int)&word_20002050, 6);
}
// 20000074: using guessed type __int16 word_20000074;
// 20000078: using guessed type __int16 word_20000078;
// 2000007E: using guessed type __int16 word_2000007E;
// 20000084: using guessed type __int16 word_20000084;
// 20001C54: using guessed type int dword_20001C54;
// 20001C58: using guessed type int dword_20001C58;
// 20001C5C: using guessed type int dword_20001C5C;
// 20001C60: using guessed type int dword_20001C60;
// 20001C64: using guessed type int dword_20001C64;
// 20001C68: using guessed type int dword_20001C68;
// 20001C6C: using guessed type int dword_20001C6C;
// 20001C70: using guessed type int dword_20001C70;
// 20001C74: using guessed type int dword_20001C74;
// 20001C7C: using guessed type int dword_20001C7C;
// 20001CB4: using guessed type int dword_20001CB4;
// 20001CB8: using guessed type int dword_20001CB8;
// 20001CBC: using guessed type int dword_20001CBC;
// 20001CC0: using guessed type int dword_20001CC0;
// 20001CC4: using guessed type int dword_20001CC4;
// 20001CC8: using guessed type int dword_20001CC8;
// 20001CCC: using guessed type int dword_20001CCC;
// 20001CD0: using guessed type int dword_20001CD0;
// 20001CD4: using guessed type int dword_20001CD4;
// 20001CDC: using guessed type int dword_20001CDC;
// 20001D14: using guessed type int dword_20001D14;
// 20001D18: using guessed type int dword_20001D18;
// 20001D1C: using guessed type int dword_20001D1C;
// 20001D20: using guessed type int dword_20001D20;
// 20001D24: using guessed type int dword_20001D24;
// 20001D28: using guessed type int dword_20001D28;
// 20001D2C: using guessed type int dword_20001D2C;
// 20001D30: using guessed type int dword_20001D30;
// 20001D34: using guessed type int dword_20001D34;
// 20001D3C: using guessed type int dword_20001D3C;
// 20001D74: using guessed type int dword_20001D74;
// 20001D78: using guessed type int dword_20001D78;
// 20001D7C: using guessed type int dword_20001D7C;
// 20001D80: using guessed type int dword_20001D80;
// 20001D84: using guessed type int dword_20001D84;
// 20001D88: using guessed type int dword_20001D88;
// 20001D8C: using guessed type int dword_20001D8C;
// 20001D90: using guessed type int dword_20001D90;
// 20001D94: using guessed type int dword_20001D94;
// 20001D9C: using guessed type int dword_20001D9C;
// 20001DD4: using guessed type int dword_20001DD4;
// 20001DD8: using guessed type int dword_20001DD8;
// 20001DDC: using guessed type int dword_20001DDC;
// 20001DE0: using guessed type int dword_20001DE0;
// 20001DE4: using guessed type int dword_20001DE4;
// 20001DE8: using guessed type int dword_20001DE8;
// 20001DEC: using guessed type int dword_20001DEC;
// 20001DF0: using guessed type int dword_20001DF0;
// 20001DF4: using guessed type int dword_20001DF4;
// 20001DFC: using guessed type int dword_20001DFC;
// 20001E34: using guessed type int dword_20001E34;
// 20001E88: using guessed type int dword_20001E88;
// 20001EA0: using guessed type int dword_20001EA0;
// 20001EF4: using guessed type int dword_20001EF4;
// 20001F0C: using guessed type int dword_20001F0C;
// 20001F60: using guessed type int dword_20001F60;
// 20001F78: using guessed type int dword_20001F78;
// 20001FCC: using guessed type int dword_20001FCC;
// 20001FE4: using guessed type int dword_20001FE4;
// 20002038: using guessed type int dword_20002038;
// 20002050: using guessed type __int16 word_20002050;

//----- (08003720) --------------------------------------------------------
int sub_8003720()
{
  int v0; // r1
  int result; // r0

  *(float *)&dword_20001BEC = (float)((unsigned __int16)word_2000007C - (unsigned __int16)word_2000007A) * 0.21606;
  *(float *)&dword_20001C20 = (float)((unsigned __int16)word_20000084 - (unsigned __int16)word_2000007A) * 0.21606;
  *(float *)&dword_20001BF8 = (float)((unsigned __int16)word_20000078 - (unsigned __int16)word_2000007A) * 0.21606;
  v0 = (unsigned __int16)word_20000074 - (unsigned __int16)word_2000007A;
  if ( byte_20000002 )
    *(float *)&dword_20001BF0 = (float)v0 * 0.018311;
  else
    *(float *)&dword_20001BF0 = (float)v0 * -0.017577;
  *(float *)&dword_20001BF4 = (float)(unsigned __int16)word_20000080 * 0.15271;
  if ( dword_20001BF4 < 1065353216 )
    dword_20001BF4 = 1.0;
  result = (unsigned __int16)word_20000076 - (unsigned __int16)word_2000007A;
  *(float *)&dword_20001C08 = (float)result * -0.017;
  return result;
}
// 20000002: using guessed type char byte_20000002;
// 20000074: using guessed type __int16 word_20000074;
// 20000076: using guessed type __int16 word_20000076;
// 20000078: using guessed type __int16 word_20000078;
// 2000007A: using guessed type __int16 word_2000007A;
// 2000007C: using guessed type __int16 word_2000007C;
// 20000080: using guessed type __int16 word_20000080;
// 20000084: using guessed type __int16 word_20000084;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BF8: using guessed type int dword_20001BF8;
// 20001C08: using guessed type int dword_20001C08;
// 20001C20: using guessed type int dword_20001C20;

//----- (08003814) --------------------------------------------------------
int sub_8003814()
{
  dword_20001E34 = 1342177280;
  dword_20001E38 = 196608;
  dword_20001E3C = 0;
  dword_20001E44 = 0;
  dword_20001E40 = 0;
  dword_20001E48 = 1;
  dword_20001E4C = 8;
  byte_20001E50 = 0;
  byte_20001E51 = 0;
  dword_20001E54 = 3;
  byte_20001E58 = 0;
  dword_20001E5C = 0;
  dword_20001E60 = 1696;
  dword_20001E64 = 1024;
  byte_20001E6C = 1;
  dword_20001E70 = 4096;
  byte_20001E74 = 0;
  sub_8010D38((int)&dword_20001E34);
  dword_20001EA0 = 1342177536;
  dword_20001EA4 = 196608;
  dword_20001EA8 = 0;
  dword_20001EB0 = 0;
  dword_20001EAC = 0;
  dword_20001EB4 = 1;
  dword_20001EB8 = 8;
  byte_20001EBC = 0;
  byte_20001EBD = 0;
  dword_20001EC0 = 2;
  byte_20001EC4 = 0;
  dword_20001EC8 = 0;
  dword_20001ECC = 1696;
  dword_20001ED0 = 1024;
  byte_20001ED8 = 1;
  dword_20001EDC = 4096;
  byte_20001EE0 = 0;
  sub_8010D38((int)&dword_20001EA0);
  dword_20001F0C = 1342178304;
  dword_20001F10 = 196608;
  dword_20001F14 = 0;
  dword_20001F1C = 0;
  dword_20001F18 = 0;
  dword_20001F20 = 1;
  dword_20001F24 = 8;
  byte_20001F28 = 0;
  byte_20001F29 = 0;
  dword_20001F2C = 3;
  byte_20001F30 = 0;
  dword_20001F34 = 0;
  dword_20001F38 = 1696;
  dword_20001F3C = 1024;
  byte_20001F44 = 1;
  dword_20001F48 = 4096;
  byte_20001F4C = 0;
  sub_8010D38((int)&dword_20001F0C);
  dword_20001F78 = 1342178560;
  dword_20001F7C = 196608;
  dword_20001F80 = 0;
  dword_20001F88 = 0;
  dword_20001F84 = 0;
  dword_20001F8C = 1;
  dword_20001F90 = 8;
  byte_20001F94 = 0;
  byte_20001F95 = 0;
  dword_20001F98 = 3;
  byte_20001F9C = 0;
  dword_20001FA0 = 0;
  dword_20001FA4 = 1696;
  dword_20001FA8 = 1024;
  byte_20001FB0 = 1;
  dword_20001FB4 = 4096;
  byte_20001FB8 = 0;
  sub_8010D38((int)&dword_20001F78);
  dword_20001FE4 = 1342178816;
  dword_20001FE8 = 196608;
  dword_20001FEC = 0;
  dword_20001FF4 = 0;
  dword_20001FF0 = 0;
  dword_20001FF8 = 1;
  dword_20001FFC = 8;
  byte_20002000 = 0;
  byte_20002001 = 1;
  dword_20002004 = 6;
  byte_20002008 = 0;
  dword_2000200C = 0;
  dword_20002010 = 0;
  dword_20002014 = 1024;
  byte_2000201C = 1;
  dword_20002020 = 4096;
  byte_20002024 = 1;
  dword_20002028 = 20;
  dword_2000202C = 192;
  dword_20002030 = 0;
  dword_20002034 = 1;
  sub_8010D38((int)&dword_20001FE4);
  sub_80107EC((int)&dword_20001E34, 127);
  sub_80107EC((int)&dword_20001EA0, 127);
  sub_80107EC((int)&dword_20001F0C, 127);
  sub_80107EC((int)&dword_20001F78, 127);
  return sub_80107EC((int)&dword_20001FE4, 127);
}
// 20001E34: using guessed type int dword_20001E34;
// 20001E38: using guessed type int dword_20001E38;
// 20001E3C: using guessed type int dword_20001E3C;
// 20001E40: using guessed type int dword_20001E40;
// 20001E44: using guessed type int dword_20001E44;
// 20001E48: using guessed type int dword_20001E48;
// 20001E4C: using guessed type int dword_20001E4C;
// 20001E50: using guessed type char byte_20001E50;
// 20001E51: using guessed type char byte_20001E51;
// 20001E54: using guessed type int dword_20001E54;
// 20001E58: using guessed type char byte_20001E58;
// 20001E5C: using guessed type int dword_20001E5C;
// 20001E60: using guessed type int dword_20001E60;
// 20001E64: using guessed type int dword_20001E64;
// 20001E6C: using guessed type char byte_20001E6C;
// 20001E70: using guessed type int dword_20001E70;
// 20001E74: using guessed type char byte_20001E74;
// 20001EA0: using guessed type int dword_20001EA0;
// 20001EA4: using guessed type int dword_20001EA4;
// 20001EA8: using guessed type int dword_20001EA8;
// 20001EAC: using guessed type int dword_20001EAC;
// 20001EB0: using guessed type int dword_20001EB0;
// 20001EB4: using guessed type int dword_20001EB4;
// 20001EB8: using guessed type int dword_20001EB8;
// 20001EBC: using guessed type char byte_20001EBC;
// 20001EBD: using guessed type char byte_20001EBD;
// 20001EC0: using guessed type int dword_20001EC0;
// 20001EC4: using guessed type char byte_20001EC4;
// 20001EC8: using guessed type int dword_20001EC8;
// 20001ECC: using guessed type int dword_20001ECC;
// 20001ED0: using guessed type int dword_20001ED0;
// 20001ED8: using guessed type char byte_20001ED8;
// 20001EDC: using guessed type int dword_20001EDC;
// 20001EE0: using guessed type char byte_20001EE0;
// 20001F0C: using guessed type int dword_20001F0C;
// 20001F10: using guessed type int dword_20001F10;
// 20001F14: using guessed type int dword_20001F14;
// 20001F18: using guessed type int dword_20001F18;
// 20001F1C: using guessed type int dword_20001F1C;
// 20001F20: using guessed type int dword_20001F20;
// 20001F24: using guessed type int dword_20001F24;
// 20001F28: using guessed type char byte_20001F28;
// 20001F29: using guessed type char byte_20001F29;
// 20001F2C: using guessed type int dword_20001F2C;
// 20001F30: using guessed type char byte_20001F30;
// 20001F34: using guessed type int dword_20001F34;
// 20001F38: using guessed type int dword_20001F38;
// 20001F3C: using guessed type int dword_20001F3C;
// 20001F44: using guessed type char byte_20001F44;
// 20001F48: using guessed type int dword_20001F48;
// 20001F4C: using guessed type char byte_20001F4C;
// 20001F78: using guessed type int dword_20001F78;
// 20001F7C: using guessed type int dword_20001F7C;
// 20001F80: using guessed type int dword_20001F80;
// 20001F84: using guessed type int dword_20001F84;
// 20001F88: using guessed type int dword_20001F88;
// 20001F8C: using guessed type int dword_20001F8C;
// 20001F90: using guessed type int dword_20001F90;
// 20001F94: using guessed type char byte_20001F94;
// 20001F95: using guessed type char byte_20001F95;
// 20001F98: using guessed type int dword_20001F98;
// 20001F9C: using guessed type char byte_20001F9C;
// 20001FA0: using guessed type int dword_20001FA0;
// 20001FA4: using guessed type int dword_20001FA4;
// 20001FA8: using guessed type int dword_20001FA8;
// 20001FB0: using guessed type char byte_20001FB0;
// 20001FB4: using guessed type int dword_20001FB4;
// 20001FB8: using guessed type char byte_20001FB8;
// 20001FE4: using guessed type int dword_20001FE4;
// 20001FE8: using guessed type int dword_20001FE8;
// 20001FEC: using guessed type int dword_20001FEC;
// 20001FF0: using guessed type int dword_20001FF0;
// 20001FF4: using guessed type int dword_20001FF4;
// 20001FF8: using guessed type int dword_20001FF8;
// 20001FFC: using guessed type int dword_20001FFC;
// 20002000: using guessed type char byte_20002000;
// 20002001: using guessed type char byte_20002001;
// 20002004: using guessed type int dword_20002004;
// 20002008: using guessed type char byte_20002008;
// 2000200C: using guessed type int dword_2000200C;
// 20002010: using guessed type int dword_20002010;
// 20002014: using guessed type int dword_20002014;
// 2000201C: using guessed type char byte_2000201C;
// 20002020: using guessed type int dword_20002020;
// 20002024: using guessed type char byte_20002024;
// 20002028: using guessed type int dword_20002028;
// 2000202C: using guessed type int dword_2000202C;
// 20002030: using guessed type int dword_20002030;
// 20002034: using guessed type int dword_20002034;

//----- (080039A8) --------------------------------------------------------
int sub_80039A8()
{
  int v0; // r8
  double v1; // r0
  float v2; // s0
  int result; // r0

  word_20001C3C = word_20000078;
  word_20001C3A = word_2000007A;
  word_20001C38 = word_2000007C;
  word_20001C48 = word_20000084;
  word_20001C3E = word_20000074;
  word_20001C40 = word_20000076;
  word_20001C46 = word_2000007E;
  word_20001C42 = word_20000080;
  word_20001C44 = word_20000082;
  word_20001C4A = word_20000086;
  word_20001C4C = word_20000088;
  v0 = word_20002050;
  word_20001C4E = word_20002050;
  word_20001C50 = word_20002052;
  word_20001C52 = word_20002054;
  flt_20001C0C = (float)word_2000007A * 0.00073242;
  *(float *)&dword_20001C24 = (float)(word_20000086 - word_2000007A) * 0.0046762;
  *(float *)&dword_20001C28 = (float)(word_20000088 - word_2000007A) * 0.0034526;
  sub_8002764((unsigned __int16)word_2000007E);
  dword_20001BFC = sub_8002814(COERCE__INT64(v1 * 0.019293064));
  v2 = (float)((unsigned __int16)word_20000082 - (unsigned __int16)word_2000007A) * 0.06;
  *(float *)&dword_20001C00 = v2;
  sub_80187D8(v0);
  flt_20001C2C = v2;
  sub_801874C(word_20001C50);
  flt_20001C30 = v2;
  result = sub_801874C(word_20001C52);
  flt_20001C34 = v2;
  return result;
}
// 8003A50: variable 'v1' is possibly undefined
// 20000074: using guessed type __int16 word_20000074;
// 20000076: using guessed type __int16 word_20000076;
// 20000078: using guessed type __int16 word_20000078;
// 2000007A: using guessed type __int16 word_2000007A;
// 2000007C: using guessed type __int16 word_2000007C;
// 2000007E: using guessed type __int16 word_2000007E;
// 20000080: using guessed type __int16 word_20000080;
// 20000082: using guessed type __int16 word_20000082;
// 20000084: using guessed type __int16 word_20000084;
// 20000086: using guessed type __int16 word_20000086;
// 20000088: using guessed type __int16 word_20000088;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C00: using guessed type int dword_20001C00;
// 20001C0C: using guessed type float flt_20001C0C;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 20001C2C: using guessed type float flt_20001C2C;
// 20001C30: using guessed type float flt_20001C30;
// 20001C34: using guessed type float flt_20001C34;
// 20001C38: using guessed type __int16 word_20001C38;
// 20001C3A: using guessed type __int16 word_20001C3A;
// 20001C3C: using guessed type __int16 word_20001C3C;
// 20001C3E: using guessed type __int16 word_20001C3E;
// 20001C40: using guessed type __int16 word_20001C40;
// 20001C42: using guessed type __int16 word_20001C42;
// 20001C44: using guessed type __int16 word_20001C44;
// 20001C46: using guessed type __int16 word_20001C46;
// 20001C48: using guessed type __int16 word_20001C48;
// 20001C4A: using guessed type __int16 word_20001C4A;
// 20001C4C: using guessed type __int16 word_20001C4C;
// 20001C4E: using guessed type __int16 word_20001C4E;
// 20001C50: using guessed type __int16 word_20001C50;
// 20001C52: using guessed type __int16 word_20001C52;
// 20002050: using guessed type __int16 word_20002050;
// 20002052: using guessed type __int16 word_20002052;
// 20002054: using guessed type __int16 word_20002054;

//----- (08003ABC) --------------------------------------------------------
int __fastcall sub_8003ABC(int result, int a2, int a3, int a4)
{
  int i; // r4
  int v5; // r5

  for ( i = 0; ; ++i )
  {
    v5 = dword_200008E8[result];
    if ( v5 <= i )
      break;
    *(_DWORD *)(a2 + 4 * i) ^= *(_DWORD *)(a3 + 4 * (i + a4 * v5));
  }
  return result;
}
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003AE8) --------------------------------------------------------
int __fastcall sub_8003AE8(int a1, int a2, _WORD *a3, int a4, int a5)
{
  int v9; // r0
  int v10; // r1
  int i; // r0
  int j; // r7
  int k; // r4
  _DWORD v15[4]; // [sp+4h] [bp-124h] BYREF
  _BYTE v16[276]; // [sp+14h] [bp-114h] BYREF

  if ( !a2 || !a3 || !*a3 || (unsigned __int16)*a3 >= 0x400u || !a4 || !a5 )
    return 0;
  sub_8002364(v16, 240);
  memset(v15, 0, sizeof(v15));
  sub_8003BE8(a1, a4, (int)v16);
  v9 = (unsigned __int16)*a3;
  if ( v9 << 28 )
    v10 = 16 - (v9 & 0xF);
  else
    v10 = 16;
  if ( (unsigned int)(v9 + v10) > 0x400 )
    return 0;
  for ( i = 0; i < v10; ++i )
    *(_BYTE *)((unsigned __int16)*a3 + a2 + i) = v10;
  *a3 += v10;
  for ( j = 0; (unsigned __int16)*a3 > j; j += 4 * dword_200008E8[a1] )
  {
    qmemcpy((unsigned int)v15, a2 + j, 4 * dword_200008E8[a1]);
    for ( k = 0; dword_200008D0[a1] >= k; ++k )
    {
      if ( k > 0 )
      {
        sub_8003E1C(a1, (int)v15);
        sub_8003DCC(a1, (int)v15);
        if ( dword_200008D0[a1] > k )
          sub_8003C98(a1, (int)v15);
      }
      sub_8003ABC(a1, (int)v15, (int)v16, k);
    }
    qmemcpy(a2 + j, (unsigned int)v15, 4 * dword_200008E8[a1]);
  }
  return a2;
}
// 200008D0: using guessed type _DWORD dword_200008D0[3];
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003BE8) --------------------------------------------------------
int __fastcall sub_8003BE8(int a1, int a2, int a3)
{
  int v5; // r4
  int v6; // r0
  int v7; // r0
  int result; // r0
  unsigned __int8 v9; // r0
  unsigned int v10; // r0
  int v11; // r3

  v5 = 0;
  do
  {
    *(_DWORD *)(a3 + 4 * v5) = *(_DWORD *)(a2 + 4 * v5);
    ++v5;
  }
  while ( v5 < dword_200008DC[a1] );
  do
  {
    v6 = dword_200008DC[a1];
    if ( v5 % v6 )
    {
      if ( v6 > 6 && v5 % v6 == 4 )
        v7 = sub_8003E4C(*(_DWORD *)(a3 + 4 * (v5 - 1)));
      else
        v7 = *(_DWORD *)(a3 + 4 * (v5 - 1));
    }
    else
    {
      v9 = sub_8003DB8(*(_DWORD *)(a3 + 4 * (v5 - 1)));
      sub_8003E4C(v9);
      v10 = sub_8003E7C(*(_DWORD *)&aBeginCertifica_0[4 * (v5 / dword_200008DC[a1]) + 207]);
      v7 = v10 ^ v11;
    }
    *(_DWORD *)(a3 + 4 * v5) = *(_DWORD *)(a3 + 4 * (v5 - dword_200008DC[a1])) ^ v7;
    result = dword_200008E8[a1] * (dword_200008D0[a1] + 1);
    ++v5;
  }
  while ( result > v5 );
  return result;
}
// 8003C80: variable 'v11' is possibly undefined
// 200008D0: using guessed type _DWORD dword_200008D0[3];
// 200008DC: using guessed type _DWORD dword_200008DC[3];
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003C98) --------------------------------------------------------
int __fastcall sub_8003C98(int a1, int a2)
{
  int i; // r6
  int j; // r4
  int k; // r5
  int m; // r0
  int result; // r0
  _BYTE v9[4]; // [sp+0h] [bp-38h]
  int v10; // [sp+4h] [bp-34h]
  int v11; // [sp+8h] [bp-30h]
  int v12; // [sp+Ch] [bp-2Ch]
  int v13; // [sp+10h] [bp-28h]

  v10 = 16843522;
  v11 = 16974337;
  v12 = 50462977;
  v13 = 33620227;
  for ( i = 0; ; ++i )
  {
    result = dword_200008E8[a1];
    if ( result <= i )
      break;
    for ( j = 0; j < 4; ++j )
    {
      v9[j] = 0;
      for ( k = 0; k < 4; ++k )
        v9[j] ^= sub_8003D24(*(unsigned __int8 *)(a2 + k + 4 * i));
    }
    for ( m = 0; m < 4; ++m )
      *(_BYTE *)(a2 + m + 4 * i) = v9[m];
  }
  return result;
}
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003D24) --------------------------------------------------------
int __fastcall sub_8003D24(unsigned int a1)
{
  __int16 v2; // r0
  char v3; // r3
  __int16 v4; // r4
  __int16 v5; // r0
  unsigned int v6; // r3
  __int16 v7; // r4
  __int16 v8; // r0
  unsigned int v9; // r3
  __int16 v10; // r5
  __int16 v11; // r0
  unsigned int v12; // r3
  __int16 v13; // r5
  __int16 v14; // r0
  unsigned int v15; // r3
  __int16 v16; // r4
  __int16 v17; // r0
  unsigned int v18; // r3
  __int16 v19; // r4
  __int16 v20; // r0
  unsigned int v21; // r3
  __int16 v22; // r4
  char v23; // r0
  unsigned int v24; // r3

  v2 = sub_8003EA6(a1, 0);
  v4 = v2 * (v3 & 1);
  v5 = sub_8003EA6(a1, 1);
  v7 = v4 ^ (v5 * ((v6 >> 1) & 1));
  v8 = sub_8003EA6(a1, 2);
  v10 = v8 * ((v9 >> 2) & 1);
  v11 = sub_8003EA6(a1, 3);
  v13 = v10 ^ (v11 * ((v12 >> 3) & 1));
  v14 = sub_8003EA6(a1, 4);
  v16 = v7 ^ v13 ^ (v14 * ((v15 >> 4) & 1));
  v17 = sub_8003EA6(a1, 5);
  v19 = v16 ^ (v17 * ((v18 >> 5) & 1));
  v20 = sub_8003EA6(a1, 6);
  v22 = v19 ^ (v20 * ((v21 >> 6) & 1));
  v23 = sub_8003EA6(a1, 7);
  return (unsigned __int8)v22 ^ (unsigned __int8)(v23 * (v24 >> 7));
}
// 8003D32: variable 'v3' is possibly undefined
// 8003D42: variable 'v6' is possibly undefined
// 8003D54: variable 'v9' is possibly undefined
// 8003D64: variable 'v12' is possibly undefined
// 8003D78: variable 'v15' is possibly undefined
// 8003D8A: variable 'v18' is possibly undefined
// 8003D9C: variable 'v21' is possibly undefined
// 8003DAE: variable 'v24' is possibly undefined

//----- (08003DB8) --------------------------------------------------------
int __fastcall sub_8003DB8(int a1)
{
  return __ROR4__(a1, 8);
}

//----- (08003DC0) --------------------------------------------------------
int __fastcall sub_8003DC0(int a1)
{
  return (unsigned __int8)aBeginCertifica_0[a1 + 271];
}

//----- (08003DCC) --------------------------------------------------------
int __fastcall sub_8003DCC(int result, int a2)
{
  int i; // r2
  int j; // r4
  char v4; // r7
  int k; // r3

  for ( i = 1; dword_200008E8[result] > i; ++i )
  {
    for ( j = 0; j < i; ++j )
    {
      v4 = *(_BYTE *)(a2 + i);
      for ( k = 0; dword_200008E8[result] > k; ++k )
        *(_BYTE *)(a2 + i + 4 * k) = *(_BYTE *)(a2 + i + 4 * (k + 1));
      *(_BYTE *)(a2 + i + 4 * (dword_200008E8[result] - 1)) = v4;
    }
  }
  return result;
}
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003E1C) --------------------------------------------------------
int __fastcall sub_8003E1C(int a1, int a2)
{
  int i; // r3
  int j; // r2
  int v6; // r2
  int result; // r0

  for ( i = 0; ; ++i )
  {
    result = dword_200008E8[a1];
    if ( result <= i )
      break;
    for ( j = 0; j < 4; j = v6 + 1 )
      *(_BYTE *)(a2 + j + 4 * i) = sub_8003DC0(*(unsigned __int8 *)(a2 + j + 4 * i));
  }
  return result;
}
// 8003E2A: variable 'i' is possibly undefined
// 8003E36: variable 'v6' is possibly undefined
// 200008E8: using guessed type _DWORD dword_200008E8[4];

//----- (08003E4C) --------------------------------------------------------
int __fastcall sub_8003E4C(unsigned __int8 a1)
{
  unsigned __int8 v1; // r2^1
  unsigned __int8 v2; // r2^2
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r3

  sub_8003DC0(a1);
  sub_8003DC0(v1);
  sub_8003DC0(v2);
  v4 = sub_8003DC0(HIBYTE(v3));
  return v5 | (v4 << 24);
}
// 8003E58: variable 'v1' is possibly undefined
// 8003E64: variable 'v2' is possibly undefined
// 8003E70: variable 'v3' is possibly undefined
// 8003E76: variable 'v5' is possibly undefined

//----- (08003E7C) --------------------------------------------------------
unsigned int __fastcall sub_8003E7C(unsigned int a1)
{
  return (a1 << 24) | ((a1 & 0xFF00) << 8) | ((a1 & 0xFF0000) >> 8) | HIBYTE(a1);
}

//----- (08003E94) --------------------------------------------------------
int __fastcall sub_8003E94(unsigned int a1)
{
  return (unsigned __int8)(27 * (a1 >> 7)) ^ (unsigned __int8)(2 * a1);
}

//----- (08003EA6) --------------------------------------------------------
unsigned int __fastcall sub_8003EA6(unsigned int result, int a2)
{
  int v2; // r2

  v2 = a2;
  while ( v2 > 0 )
    result = sub_8003E94(result);
  return result;
}
// 8003EB6: variable 'v2' is possibly undefined

//----- (08003EBC) --------------------------------------------------------
void sub_8003EBC()
{
  unsigned int v0; // r0

  v0 = (dword_2000002C - dword_200008CC) / (unsigned int)(unsigned __int16)word_200008CA;
  if ( byte_200008C8 )
  {
    if ( byte_200008C8 == 1 )
    {
      if ( v0 >= 9 )
      {
        if ( v0 >= 0x12 )
        {
          sub_80031E4();
          byte_200008C8 = 0;
        }
        else if ( (unsigned __int8)byte_200008C9 != v0 )
        {
          byte_200008C9 = (dword_2000002C - dword_200008CC) / (unsigned int)(unsigned __int16)word_200008CA;
          goto LABEL_7;
        }
      }
      else if ( (unsigned __int8)byte_200008C9 != v0 )
      {
        byte_200008C9 = (dword_2000002C - dword_200008CC) / (unsigned int)(unsigned __int16)word_200008CA;
        goto LABEL_7;
      }
    }
    else if ( byte_200008C8 == 2 )
    {
      if ( v0 >= 0xA )
      {
        sub_80031E4();
        byte_200008C8 = 0;
      }
      else if ( (unsigned __int8)byte_200008C9 != v0 )
      {
        byte_200008C9 = (dword_2000002C - dword_200008CC) / (unsigned int)(unsigned __int16)word_200008CA;
LABEL_7:
        sub_80031E4();
      }
    }
  }
}
// 2000002C: using guessed type int dword_2000002C;
// 200008C8: using guessed type char byte_200008C8;
// 200008C9: using guessed type char byte_200008C9;
// 200008CA: using guessed type __int16 word_200008CA;
// 200008CC: using guessed type int dword_200008CC;

//----- (080040A0) --------------------------------------------------------
int __fastcall sub_80040A0(char *a1, int a2, int a3, unsigned int a4)
{
  int v5; // r3
  int v6; // r4
  int v7; // r7
  char v8; // t1
  int i; // r0
  int v10; // [sp+0h] [bp-1Ch]
  int v11; // [sp+0h] [bp-1Ch]
  _DWORD v12[6]; // [sp+4h] [bp-18h]

  v12[0] = a4;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a4 < 4 * ((a2 + 2) / 3u) )
    return 0;
  v5 = 0;
  v6 = 0;
  while ( --a2 != -1 )
  {
    v7 = v5;
    v8 = *a1++;
    ++v5;
    *((_BYTE *)v12 + v7) = v8;
    if ( v5 == 3 )
    {
      LOBYTE(v10) = aBeginCertifica_0[(LOBYTE(v12[0]) >> 2) + 143];
      BYTE1(v10) = aBeginCertifica_0[((16 * LOBYTE(v12[0])) & 0x3F) + 143 + (BYTE1(v12[0]) >> 4)];
      BYTE2(v10) = aBeginCertifica_0[((4 * BYTE1(v12[0])) & 0x3F) + 143 + (BYTE2(v12[0]) >> 6)];
      HIBYTE(v10) = aBeginCertifica_0[(BYTE2(v12[0]) & 0x3F) + 143];
      *(_DWORD *)(a3 + v6) = v10;
      v6 += 4;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    for ( i = v5; i < 3; ++i )
      *((_BYTE *)v12 + i) = 0;
    if ( v5 == 1 )
      BYTE2(v11) = 61;
    else
      BYTE2(v11) = aBeginCertifica_0[4 * (BYTE1(v12[0]) & 0xF) + 143];
    HIBYTE(v11) = 61;
    BYTE1(v11) = aBeginCertifica_0[((16 * LOBYTE(v12[0])) & 0x3F) + 143 + (BYTE1(v12[0]) >> 4)];
    LOBYTE(v11) = aBeginCertifica_0[(LOBYTE(v12[0]) >> 2) + 143];
    *(_DWORD *)(a3 + v6) = v11;
    v6 += 4;
  }
  *(_BYTE *)(a3 + v6) = 0;
  return 1;
}

//----- (08004188) --------------------------------------------------------
int *__fastcall sub_8004188(int *a1, int a2, int a3)
{
  _DWORD v7[9]; // [sp+4h] [bp-24h] BYREF

  sub_8002364(v7, 20);
  v7[0] = a2;
  v7[1] = 0;
  v7[2] = a3;
  return sub_8012760(a1, (int)v7);
}

//----- (080041AE) --------------------------------------------------------
int *__fastcall sub_80041AE(int *a1, int a2, int a3)
{
  _DWORD v7[9]; // [sp+4h] [bp-24h] BYREF

  sub_8002364(v7, 20);
  v7[0] = a2;
  v7[1] = 1114112;
  v7[2] = a3;
  return sub_8012760(a1, (int)v7);
}

//----- (080041D6) --------------------------------------------------------
int *__fastcall sub_80041D6(int *a1, int a2)
{
  _DWORD v5[8]; // [sp+0h] [bp-20h] BYREF

  sub_8002364(v5, 20);
  v5[0] = a2;
  v5[1] = 1;
  v5[2] = 2;
  v5[3] = 2;
  return sub_8012760(a1, (int)v5);
}

//----- (08004200) --------------------------------------------------------
int __fastcall sub_8004200(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !sub_80256C8(dword_20000458, 400) )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  sub_800E768((int)a1, (unsigned __int16)(v2 - 1));
  byte_200037D9 = 2;
  sub_801ADD8(
    (int)"%s %d %s\r\n",
    "8EAjAAMA4GA1Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n",
    585,
    (const char *)a1);
  return 1;
}
// 20000458: using guessed type int dword_20000458;
// 200037D9: using guessed type char byte_200037D9;

//----- (08004258) --------------------------------------------------------
int sub_8004258()
{
  int result; // r0
  unsigned __int8 *v1; // r0
  int v2; // r0
  char *v3; // r0
  int v4; // r0
  unsigned __int8 v5[148]; // [sp+4h] [bp-94h] BYREF

  sub_8002364(v5, 128);
  result = (unsigned __int8)byte_200015E9;
  if ( !byte_200015E9 )
  {
    if ( byte_200015E8 )
    {
      if ( byte_200015E8 == 1 )
      {
        if ( sub_8025570(dword_20000430, (unsigned int)v5, 400) == 1 )
        {
          sub_801ADD8((int)"\r\n%s %d %s", " %d, real max discharge power = %d.\r\n", 870, (const char *)v5);
          if ( strstr(v5, "+QIRD") )
          {
            sub_8002364(v5, 128);
            if ( sub_8025570(dword_20000430, (unsigned int)v5, 400) == 1 )
            {
              sub_801ADD8((int)"\r\n%s %d %s", " %d, real max discharge power = %d.\r\n", 876, (const char *)v5);
              sub_801F42C();
              v4 = sub_801A6EC(v5);
              byte_200015EE = byte_200015EB;
              byte_200015EF = byte_200015EA;
              if ( v4 )
                byte_200015F0 = 0;
              else
                ++byte_200015F0;
            }
            else
            {
              sub_801F42C();
            }
          }
          else
          {
            ++byte_200015F0;
          }
        }
        else
        {
          ++byte_200015F0;
          sub_801F42C();
        }
        byte_200015E8 = 0;
      }
    }
    else if ( sub_8025570(dword_20000430, (unsigned int)v5, 400) == 1 )
    {
      sub_801F42C();
      sub_801ADD8((int)"\r\n%s %d %s", " %d, real max discharge power = %d.\r\n", 826, (const char *)v5);
      v1 = strstr(v5, "+QIRD");
      if ( v1 )
      {
        v2 = sub_80023CE((int)v1, 0x2Cu);
        if ( v2 )
        {
          v3 = (char *)(sub_80023CE(v2 + 1, 0x2Cu) + 1);
          if ( v3 == (char *)1 )
          {
            ++byte_200015F0;
          }
          else
          {
            word_200015F8 = sub_8002644(v3);
            sub_801ADD8(
              (int)"\r\n%s %d %d",
              " %d, real max discharge power = %d.\r\n",
              836,
              (unsigned __int16)word_200015F8);
            if ( word_200015F8 )
            {
              if ( (unsigned __int16)word_200015F8 <= 0x68u )
                byte_200015F0 = 0;
              else
                word_200015F8 = 104;
              byte_200015E8 = 1;
              byte_200015E5 = 1;
            }
            else
            {
              ++byte_200015F0;
            }
          }
        }
        else
        {
          ++byte_200015F0;
        }
      }
      else
      {
        ++byte_200015F0;
      }
    }
    else
    {
      sub_801F42C();
    }
    result = (unsigned __int8)byte_200015F0;
    if ( (unsigned __int8)byte_200015F0 > 0x14u )
    {
      byte_200015F0 = 0;
      byte_200015E8 = 0;
      byte_200015E6 = 0;
    }
  }
  return result;
}
// 20000430: using guessed type int dword_20000430;
// 200015E5: using guessed type char byte_200015E5;
// 200015E6: using guessed type char byte_200015E6;
// 200015E8: using guessed type char byte_200015E8;
// 200015E9: using guessed type char byte_200015E9;
// 200015EA: using guessed type char byte_200015EA;
// 200015EB: using guessed type char byte_200015EB;
// 200015EE: using guessed type char byte_200015EE;
// 200015EF: using guessed type char byte_200015EF;
// 200015F0: using guessed type char byte_200015F0;
// 200015F8: using guessed type __int16 word_200015F8;

//----- (080043D0) --------------------------------------------------------
int sub_80043D0()
{
  int result; // r0
  unsigned __int8 v1[140]; // [sp+4h] [bp-8Ch] BYREF

  if ( byte_200015E7 )
    byte_200015E7 = 0;
  sub_8002364(v1, 128);
  result = (unsigned __int8)byte_200015E8;
  if ( byte_200015E8 )
  {
    if ( byte_200015E8 == 1 )
    {
      result = (unsigned __int8)byte_200015E9;
      if ( byte_200015E9 )
      {
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015EB, (unsigned __int16)word_200015F8);
        result = sub_8004200(v1);
        if ( result )
          byte_200015E9 = 0;
      }
    }
  }
  else if ( sub_80256C8(dword_2000042C, 400) == 1 || (result = sub_801B018(&word_200015FC, 0x320u)) != 0 )
  {
    result = (unsigned __int8)byte_200015E9;
    if ( byte_200015E9 )
    {
      byte_200015E5 = 1;
      sub_8002364(v1, 128);
      sprintf((int)v1, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015EB);
      result = sub_8004200(v1);
      if ( result )
        byte_200015E9 = 0;
    }
  }
  return result;
}
// 2000042C: using guessed type int dword_2000042C;
// 200015E5: using guessed type char byte_200015E5;
// 200015E7: using guessed type char byte_200015E7;
// 200015E8: using guessed type char byte_200015E8;
// 200015E9: using guessed type char byte_200015E9;
// 200015EB: using guessed type char byte_200015EB;
// 200015F8: using guessed type __int16 word_200015F8;
// 200015FC: using guessed type _WORD;

//----- (0800448C) --------------------------------------------------------
void __fastcall sub_800448C(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  if ( byte_200015E6 )
    sub_8004258();
  else
    sub_801BD70(0, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}
// 200015E6: using guessed type char byte_200015E6;

//----- (080044A0) --------------------------------------------------------
void sub_80044A0()
{
  if ( byte_200015E6 )
    sub_80043D0();
  else
    sub_801C528();
}
// 200015E6: using guessed type char byte_200015E6;

//----- (080044B4) --------------------------------------------------------
void __fastcall sub_80044B4(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3

  if ( byte_20000930 )
  {
    sub_80044A0();
    sub_800448C(v13, v14, v15, v16, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  }
  else
  {
    byte_200015EB = 1;
    byte_200015EA = 0;
    sub_8004678();
  }
}
// 80044CC: variable 'v13' is possibly undefined
// 80044CC: variable 'v14' is possibly undefined
// 80044CC: variable 'v15' is possibly undefined
// 80044CC: variable 'v16' is possibly undefined
// 20000930: using guessed type char byte_20000930;
// 200015EA: using guessed type char byte_200015EA;
// 200015EB: using guessed type char byte_200015EB;

//----- (080044EC) --------------------------------------------------------
int __fastcall sub_80044EC(int a1)
{
  int v1; // r2

  v1 = (unsigned __int8)byte_200008F9;
  switch ( byte_200008F9 )
  {
    case 0:
      if ( a1 == 43 )
      {
        byte_200008F9 = 1;
        byte_2000401D[0] = 43;
      }
      else
      {
        sub_8002364(byte_2000401D, 128);
      }
      goto LABEL_37;
    case 1:
      if ( a1 != 81 )
        goto LABEL_33;
      byte_200008F9 = 2;
      byte_2000401E = 81;
      goto LABEL_37;
    case 2:
      if ( a1 != 73 )
        goto LABEL_33;
      byte_200008F9 = 3;
      byte_2000401F = 73;
      goto LABEL_37;
    case 3:
      if ( a1 != 85 )
        goto LABEL_33;
      byte_200008F9 = 4;
      byte_20004020 = 85;
      goto LABEL_37;
    case 4:
      if ( a1 != 82 )
        goto LABEL_33;
      byte_200008F9 = 5;
      byte_20004021 = 82;
      goto LABEL_37;
    case 5:
      if ( a1 != 67 )
        goto LABEL_33;
      byte_200008F9 = 6;
      byte_20004022 = 67;
      goto LABEL_37;
    case 6:
      if ( a1 != 58 )
        goto LABEL_33;
      byte_200008F9 = 7;
      byte_20004023 = 58;
      goto LABEL_37;
    case 7:
      if ( a1 != 32 )
        goto LABEL_33;
      byte_200008F9 = 8;
      byte_20004024 = 32;
      goto LABEL_37;
    case 8:
      if ( a1 != 34 )
        goto LABEL_33;
      byte_200008F9 = 9;
      byte_20004025 = 34;
      goto LABEL_37;
    case 9:
      if ( a1 != 114 )
        goto LABEL_33;
      byte_200008F9 = 10;
      byte_20004026 = 114;
      goto LABEL_37;
    case 10:
      if ( a1 != 101 )
        goto LABEL_33;
      byte_200008F9 = 11;
      byte_20004027 = 101;
      goto LABEL_37;
    case 11:
      if ( a1 != 99 )
        goto LABEL_33;
      byte_200008F9 = 12;
      byte_20004028 = 99;
      goto LABEL_37;
    case 12:
      if ( a1 == 118 )
      {
        byte_200008F9 = 13;
        byte_20004029 = 118;
      }
      else
      {
LABEL_33:
        byte_200008F9 = 0;
        sub_8002364(byte_2000401D, 128);
      }
      goto LABEL_37;
    default:
      if ( a1 == 10 )
      {
        byte_2000401D[(unsigned __int8)byte_200008F9] = 10;
        byte_200008F9 = 0;
        return 3;
      }
      else
      {
        ++byte_200008F9;
        byte_2000401D[v1] = a1;
LABEL_37:
        if ( (unsigned __int8)byte_200008F9 >= 0x7Fu )
        {
          byte_200008F9 = 0;
          sub_8002364(byte_2000401D, 128);
        }
        return 0;
      }
  }
}
// 200008F9: using guessed type char byte_200008F9;
// 2000401E: using guessed type char byte_2000401E;
// 2000401F: using guessed type char byte_2000401F;
// 20004020: using guessed type char byte_20004020;
// 20004021: using guessed type char byte_20004021;
// 20004022: using guessed type char byte_20004022;
// 20004023: using guessed type char byte_20004023;
// 20004024: using guessed type char byte_20004024;
// 20004025: using guessed type char byte_20004025;
// 20004026: using guessed type char byte_20004026;
// 20004027: using guessed type char byte_20004027;
// 20004028: using guessed type char byte_20004028;
// 20004029: using guessed type char byte_20004029;

//----- (08004678) --------------------------------------------------------
char *sub_8004678()
{
  char *result; // r0

  result = &byte_200015DC;
  byte_200015E6 = 0;
  byte_200015E7 = 0;
  byte_200015E8 = 0;
  return result;
}
// 200015DC: using guessed type char byte_200015DC;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 200015E8: using guessed type char byte_200015E8;

//----- (08004688) --------------------------------------------------------
int sub_8004688()
{
  unsigned int v0; // r2
  unsigned int v1; // r3
  int result; // r0
  unsigned int v3; // r1

  v0 = (unsigned __int16)dword_20002E9F;
  v1 = (unsigned __int16)dword_20002E9F;
  for ( result = 1; result < 16; ++result )
  {
    v3 = *(unsigned __int16 *)((char *)&dword_20002E74 + 2 * result + 43);
    if ( v3 > v0 )
      v0 = *(unsigned __int16 *)((char *)&dword_20002E74 + 2 * result + 43);
    if ( v3 < v1 )
      v1 = *(unsigned __int16 *)((char *)&dword_20002E74 + 2 * result + 43);
  }
  word_20002EBF = v0;
  word_20002EC1 = v1;
  return result;
}
// 20002E74: using guessed type int dword_20002E74;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EBF: using guessed type __int16 word_20002EBF;
// 20002EC1: using guessed type __int16 word_20002EC1;

//----- (080046BC) --------------------------------------------------------
int __fastcall sub_80046BC(int result)
{
  if ( result )
  {
    switch ( byte_200004AC )
    {
      case 1:
        *(_BYTE *)(result + 36) = byte_2001125C;
        *(_DWORD *)(result + 24) = dword_20011288;
        *(_DWORD *)(result + 28) = dword_20011274;
        break;
      case 2:
        *(_BYTE *)(result + 36) = dword_20011260;
        *(_DWORD *)(result + 24) = dword_2001128C;
        *(_DWORD *)(result + 28) = dword_20011278;
        break;
      case 3:
        *(_BYTE *)(result + 36) = byte_20011264;
        *(_DWORD *)(result + 24) = dword_20011290;
        *(_DWORD *)(result + 28) = dword_2001127C;
        break;
      default:
        *(_BYTE *)(result + 36) = dword_20011268;
        *(_DWORD *)(result + 24) = dword_20011294;
        *(_DWORD *)(result + 28) = dword_20011280;
        break;
    }
    if ( byte_20002FD0 == 1 )
    {
      *(_BYTE *)(result + 36) = byte_2001125C + dword_20011260 + byte_20011264 + dword_20011268;
      *(_DWORD *)(result + 24) = dword_20011288 + dword_2001128C + dword_20011290 + dword_20011294;
      *(_DWORD *)(result + 28) = dword_20011274 + dword_20011278 + dword_2001127C + dword_20011280;
    }
    *(_DWORD *)(result + 20) = dword_20011270;
    *(_DWORD *)(result + 16) = dword_20011284;
    *(_DWORD *)(result + 32) = word_2001121C;
  }
  return result;
}
// 200004AC: using guessed type char byte_200004AC;
// 20002FD0: using guessed type char byte_20002FD0;
// 2001121C: using guessed type __int16 word_2001121C;
// 2001125C: using guessed type char byte_2001125C;
// 20011260: using guessed type int dword_20011260;
// 20011264: using guessed type char byte_20011264;
// 20011268: using guessed type int dword_20011268;
// 20011270: using guessed type int dword_20011270;
// 20011274: using guessed type int dword_20011274;
// 20011278: using guessed type int dword_20011278;
// 2001127C: using guessed type int dword_2001127C;
// 20011280: using guessed type int dword_20011280;
// 20011284: using guessed type int dword_20011284;
// 20011288: using guessed type int dword_20011288;
// 2001128C: using guessed type int dword_2001128C;
// 20011290: using guessed type int dword_20011290;
// 20011294: using guessed type int dword_20011294;

//----- (08004790) --------------------------------------------------------
int __fastcall sub_8004790(
        _DWORD *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        unsigned __int8 a11)
{
  int v12; // r4
  int v14; // r0

  v12 = (int)flt_200027A4;
  if ( !a1 || a11 <= 1u && byte_200004A8 )
    return 0;
  if ( !byte_200004A8 )
    return 2;
  if ( word_200004C4 && !sub_801B040(&word_200004C4, 0xAu) )
    return 1;
  if ( a8 * a9 < 0 || a7 || a6 )
    goto LABEL_21;
  if ( a9 * *a1 < 0 || *a1 * a8 < 0 )
  {
    if ( v12 < 0 )
      v12 = -v12;
    if ( v12 < 1 )
      goto LABEL_21;
  }
  if ( a10 * a9 < 0 || a10 * a8 < 0 )
LABEL_21:
    v14 = 1;
  else
    v14 = 0;
  word_200004C4 = 0;
  if ( v14 )
  {
    sub_801B040(&word_200004C4, 0xAu);
    return 1;
  }
  else
  {
    *a1 /= (int)a11;
    return 0;
  }
}
// 200004A8: using guessed type char byte_200004A8;
// 200004C4: using guessed type __int16 word_200004C4;
// 200027A4: using guessed type float flt_200027A4;

//----- (08004848) --------------------------------------------------------
int __fastcall sub_8004848(int result, int *a2)
{
  int v2; // r3
  int v3; // r3

  if ( result == 864 )
  {
    dword_20002E9F = *a2;
    result = a2[1];
    dword_20002EA3 = result;
  }
  else if ( result > 864 )
  {
    v3 = result - 867;
    if ( result == 867 )
    {
      dword_20002EB7 = *a2;
      result = a2[1];
      dword_20002EBB = result;
    }
    else if ( result > 867 )
    {
      if ( result == 874 )
      {
        dword_20002E97 = *a2;
        result = a2[1];
        dword_20002E9B = result;
      }
      else if ( result == 875 )
      {
        result = *a2;
        *(int *)((char *)&dword_20002E90 + 3) = *a2;
      }
    }
    else
    {
      result -= 865;
      if ( v3 == -2 )
      {
        dword_20002EA7 = *a2;
        result = a2[1];
        dword_20002EAB = result;
      }
      else if ( v3 == -1 )
      {
        dword_20002EAF = *a2;
        result = a2[1];
        dword_20002EB3 = result;
      }
    }
  }
  else
  {
    v2 = result - 854;
    if ( result == 854 )
    {
      dword_20002E82 = *a2;
      result = *((unsigned __int16 *)a2 + 2);
      word_20002E86 = *((_WORD *)a2 + 2);
    }
    else if ( result > 854 )
    {
      if ( result == 857 )
      {
        dword_20002E88 = *a2;
        result = a2[1];
        dword_20002E8C = result;
      }
      else if ( result == 860 )
      {
        dword_20002E90 = *a2;
        result = sub_8012948();
        dword_20000474 = result;
      }
    }
    else
    {
      result -= 849;
      if ( v2 == -5 )
      {
        dword_20002E74 = *a2;
        result = *((unsigned __int16 *)a2 + 2);
        word_20002E78 = *((_WORD *)a2 + 2);
      }
      else if ( v2 == -1 )
      {
        dword_20002E7A = *a2;
        result = a2[1];
        dword_20002E7E = result;
      }
    }
  }
  return result;
}
// 20000474: using guessed type int dword_20000474;
// 20002E74: using guessed type int dword_20002E74;
// 20002E78: using guessed type __int16 word_20002E78;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002E7E: using guessed type int dword_20002E7E;
// 20002E82: using guessed type int dword_20002E82;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E88: using guessed type int dword_20002E88;
// 20002E8C: using guessed type int dword_20002E8C;
// 20002E90: using guessed type int dword_20002E90;
// 20002E97: using guessed type int dword_20002E97;
// 20002E9B: using guessed type int dword_20002E9B;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EA3: using guessed type int dword_20002EA3;
// 20002EA7: using guessed type int dword_20002EA7;
// 20002EAB: using guessed type int dword_20002EAB;
// 20002EAF: using guessed type int dword_20002EAF;
// 20002EB3: using guessed type int dword_20002EB3;
// 20002EB7: using guessed type int dword_20002EB7;
// 20002EBB: using guessed type int dword_20002EBB;

//----- (08004918) --------------------------------------------------------
BOOL sub_8004918()
{
  return sub_80049C0(0, 773, 0);
}

//----- (08004924) --------------------------------------------------------
BOOL sub_8004924()
{
  int v1; // [sp+0h] [bp-8h] BYREF

  v1 = 1;
  return sub_80049C0((int)&v1, 768, 1);
}

//----- (08004938) --------------------------------------------------------
int sub_8004938()
{
  return sub_80049F8();
}

//----- (08004944) --------------------------------------------------------
int sub_8004944()
{
  sub_800495C();
  return sub_80049F8();
}

//----- (0800495C) --------------------------------------------------------
int sub_800495C()
{
  sub_8011F3E((int)&dword_2000205C);
  dword_2000205C = 1073768448;
  dword_20002060 = 0;
  dword_20002064 = 0;
  dword_20002068 = 0;
  byte_2000206C = 0;
  byte_2000206D = 0;
  byte_2000206E = 0;
  dword_20002070 = 17;
  dword_20002074 = 8;
  dword_20002078 = 11;
  dword_2000207C = 8;
  dword_20002090 = 4;
  dword_20002094 = 4;
  dword_20002098 = 0;
  sub_80121D8((int)&dword_2000205C);
  sub_8011F08((int)&dword_2000205C, 2, 2, 1, 1);
  sub_8012474((int)&dword_2000205C);
  sub_8011D7C((unsigned __int8 *)&dword_2000205C, 1, 1);
  return 0;
}
// 2000205C: using guessed type int dword_2000205C;
// 20002060: using guessed type int dword_20002060;
// 20002064: using guessed type int dword_20002064;
// 20002068: using guessed type int dword_20002068;
// 2000206C: using guessed type char byte_2000206C;
// 2000206D: using guessed type char byte_2000206D;
// 2000206E: using guessed type char byte_2000206E;
// 20002070: using guessed type int dword_20002070;
// 20002074: using guessed type int dword_20002074;
// 20002078: using guessed type int dword_20002078;
// 2000207C: using guessed type int dword_2000207C;
// 20002090: using guessed type int dword_20002090;
// 20002094: using guessed type int dword_20002094;
// 20002098: using guessed type int dword_20002098;

//----- (080049C0) --------------------------------------------------------
BOOL __fastcall sub_80049C0(int a1, int a2, int a3)
{
  dword_200020C0 = a2;
  dword_200020C4 = 0;
  dword_200020C8 = 0;
  dword_200020CC = a3 << 16;
  dword_200020D0 = 0;
  dword_200020D4 = 0;
  dword_200020D8 = 0;
  dword_200020DC = 0;
  dword_200020E0 = 0;
  return sub_8011E5C(&dword_2000205C, &dword_200020C0, a1) != 0;
}
// 2000205C: using guessed type int dword_2000205C;
// 200020C0: using guessed type int dword_200020C0;
// 200020C4: using guessed type int dword_200020C4;
// 200020C8: using guessed type int dword_200020C8;
// 200020CC: using guessed type int dword_200020CC;
// 200020D0: using guessed type int dword_200020D0;
// 200020D4: using guessed type int dword_200020D4;
// 200020D8: using guessed type int dword_200020D8;
// 200020DC: using guessed type int dword_200020DC;
// 200020E0: using guessed type int dword_200020E0;

//----- (080049F8) --------------------------------------------------------
int sub_80049F8()
{
  return BusFault_handler();
}
// 80049FE: using guessed type int BusFault_handler(void);

//----- (080049FE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall BusFault_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD v10[6]; // [sp-18h] [bp-18h] BYREF

  sub_8002364(v10, 24);
  v10[0] = 0;
  v10[2] = 2;
  v10[3] = 1;
  v10[4] = a2;
  v10[5] = a3;
  sub_8011EAA((int)&dword_2000205C, (int)v10);
  __asm { POP             {R4-R6,PC} }
}
// 8004A26: positive sp value 18 has been found
// 8004A26: unbalanced stack, ignored a potential tail call
// 2000205C: using guessed type int dword_2000205C;

//----- (08004A2C) --------------------------------------------------------
int __fastcall sub_8004A2C(int a1)
{
  int i; // r4
  int result; // r0
  _DWORD v3[6]; // [sp+0h] [bp-18h] BYREF

  v3[0] = 0;
  v3[1] = 0;
  sprintf((int)v3, "%02x", a1);
  for ( i = 0; i < 2; ++i )
    result = sub_801D6B0(*((unsigned __int8 *)v3 + i));
  return result;
}

//----- (08004A58) --------------------------------------------------------
BOOL sub_8004A58()
{
  int v0; // r4
  unsigned int i; // r0
  int v2; // r5

  v0 = 255;
  for ( i = 0; i < (unsigned __int8)byte_200015B3; ++i )
  {
    if ( byte_20011071[i] == 115 && byte_20011071[i + 2] == 14 )
      v0 = (unsigned __int8)i;
  }
  v2 = byte_20011071[v0 + 1];
  if ( v0 == 255 || (unsigned __int8)byte_200015B3 - v0 < v2 )
    return 0;
  if ( byte_20011071[v0 - 1 + v2] == sub_80104CC((int)&byte_20011071[v0], (unsigned __int8)(v2 - 1)) )
    return byte_20011071[v0 + 5] == 0;
  return 0;
}
// 200015B3: using guessed type char byte_200015B3;
// 20011071: using guessed type unsigned __int8 byte_20011071[67];

//----- (08004AC0) --------------------------------------------------------
BOOL __fastcall sub_8004AC0(_BYTE *a1, unsigned int a2)
{
  if ( !a1 )
    return 0;
  if ( a2 > 0x8A )
    return 0;
  if ( a1[4] != 16 )
    return 0;
  if ( *a1 == 115 )
    return (unsigned __int8)a1[a2 - 1] == sub_80104CC((int)a1, (unsigned __int8)(a2 - 1));
  return 0;
}

//----- (08004B08) --------------------------------------------------------
int sub_8004B08()
{
  int v0; // r1
  int v1; // r0
  __int16 v2; // r0
  __int16 v4; // r0

  v0 = 0;
  v1 = (int)(float)(flt_200027A4 - flt_200004D8);
  if ( v1 < 0 )
    v1 = -v1;
  if ( (unsigned __int16)v1 > 0x1Eu || flt_200004D8 == 0.0 )
    word_200004C2 = 0;
  else
    v0 = 1;
  if ( byte_200004AA != 1 )
    goto LABEL_10;
  if ( v0 )
  {
    v2 = sub_800FBF0();
    if ( sub_8018720(&word_200004C2, (unsigned __int16)(1000 * v2)) )
      goto LABEL_10;
  }
  v4 = sub_800FBF0();
  if ( sub_8018720(&word_200004B6, (unsigned __int16)(1000 * (v4 + 3))) )
  {
    byte_200004AA = 2;
LABEL_10:
    byte_200004AA = 2;
    return 1;
  }
  return 0;
}
// 200004AA: using guessed type char byte_200004AA;
// 200004B6: using guessed type __int16 word_200004B6;
// 200004C2: using guessed type __int16 word_200004C2;
// 200004D8: using guessed type float flt_200004D8;
// 200027A4: using guessed type float flt_200027A4;

//----- (08004BA0) --------------------------------------------------------
__int64 sub_8004BA0()
{
  unsigned __int8 *v0; // r0
  unsigned int v1; // r6
  int v2; // r0
  signed int v3; // r2
  _BYTE *v4; // r0
  __int64 v6; // [sp+0h] [bp-20h] BYREF
  int v7; // [sp+8h] [bp-18h]
  int v8; // [sp+Ch] [bp-14h]

  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( (unsigned int)(unsigned __int8)dword_20011298 - 48 >= 0xA )
  {
    dword_20011298 = 0;
    dword_2001129C = 0;
    dword_200112A0 = 0;
    dword_200112A4 = 0;
  }
  if ( !(_BYTE)dword_20011298 && sub_80023E2((unsigned __int8 *)byte_200112A8) )
  {
    v0 = strstr((unsigned __int8 *)byte_200112A8, (unsigned __int8 *)&dword_8004C80);
    if ( v0 )
    {
      v1 = (unsigned int)(v0 + 3);
      v2 = sub_80023CE((int)(v0 + 3), 0x2Cu);
      if ( v2 )
      {
        v3 = v2 - v1;
        if ( (int)(v2 - v1) <= 16 && v3 > 4 )
        {
          qmemcpy((unsigned int)&v6, v1, v3);
          v4 = sub_8002480(&v6, 46);
          if ( v4 )
          {
            if ( (unsigned int)(v4 - (_BYTE *)&v6) < 0x10 )
            {
              dword_20011298 = 0;
              dword_2001129C = 0;
              dword_200112A0 = 0;
              dword_200112A4 = 0;
              qmemcpy((unsigned int)&dword_20011298, (unsigned int)&v6, v4 - (_BYTE *)&v6);
              sub_800237A((int)&dword_20011298, ".255");
            }
          }
        }
      }
    }
    sub_801ADD8(
      (int)"%s %d g_dev_net_info:%s\r\n",
      ",b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cpc=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d,b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
      1390,
      byte_200112A8);
    sub_801ADD8(
      (int)"%s %d g_szMonitorIP:%s\r\n",
      ",b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cpc=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d,b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
      1391,
      (const char *)&dword_20011298);
  }
  if ( byte_200015E6 )
  {
    word_200015FE = 0;
    return v6;
  }
  if ( !sub_80023E2((unsigned __int8 *)&dword_20011298)
    || strstr((unsigned __int8 *)&dword_20011298, ".255")
    || !sub_801B040(&word_200015FE, 0xB4u) )
  {
    return v6;
  }
  sub_8004E5C();
  return v6;
}
// 8004C80: using guessed type int dword_8004C80;
// 200015E6: using guessed type char byte_200015E6;
// 200015FE: using guessed type __int16 word_200015FE;
// 20011298: using guessed type int dword_20011298;
// 2001129C: using guessed type int dword_2001129C;
// 200112A0: using guessed type int dword_200112A0;
// 200112A4: using guessed type int dword_200112A4;

//----- (08004CCC) --------------------------------------------------------
void __fastcall sub_8004CCC(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  __int64 v13; // r0
  int v14; // [sp+0h] [bp-20h]
  int v15; // [sp+4h] [bp-1Ch]

  v14 = a3;
  v15 = a4;
  if ( byte_200015DE )
  {
    sub_801ADD8(
      (int)"%s %d choose_meter=%d, rechrg_mode=%d g_ct_type=%d\r\n",
      "power = %d.\r\n",
      1009,
      (unsigned __int8)byte_20002FD1,
      (unsigned __int8)byte_20002FD0,
      (unsigned __int8)byte_200015E4);
    byte_200015DE = 0;
    byte_200015E7 = 0;
    byte_200015E8 = 0;
    byte_200015DF = 0;
    byte_200015E6 = 0;
    byte_200015E4 = 0;
    sub_8002364(byte_20011220, 120);
    sub_800591C(0x372u, &byte_20002FD1, 1u);
    sub_8002364(&dword_20005238, 40);
  }
  if ( byte_20000930 )
  {
    v13 = sub_800FC1C();
    if ( (unsigned __int8)byte_20000931 < 0x50u )
    {
      LODWORD(v13) = (unsigned __int8)byte_20002FD1;
      if ( byte_20002FD1 )
      {
        if ( byte_20002FD1 != 2 && byte_20002FD1 != 7 )
          sub_8019FF8();
      }
      else
      {
        sub_80044B4(v13, SHIDWORD(v13), v14, v15, a5, a6, a7, a8, a9, a10, a11, a12, a13);
      }
    }
    else
    {
      byte_200015E6 = 0;
    }
  }
  else
  {
    sub_8002364(byte_200112A8, 128);
    byte_200015E7 = 0;
    byte_200015E8 = 0;
    byte_200015DF = 0;
    byte_200015E6 = 0;
  }
}
// 8004D64: variable 'v14' is possibly undefined
// 8004D64: variable 'v15' is possibly undefined
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 200015DE: using guessed type char byte_200015DE;
// 200015DF: using guessed type char byte_200015DF;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 200015E8: using guessed type char byte_200015E8;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD1: using guessed type char byte_20002FD1;
// 20005238: using guessed type int dword_20005238;
// 20011220: using guessed type unsigned __int8 byte_20011220[44];

//----- (08004DB8) --------------------------------------------------------
BOOL __fastcall sub_8004DB8(unsigned __int8 *a1)
{
  if ( !a1 )
    return 0;
  if ( *(unsigned __int16 *)a1 > 0x63u )
    return 0;
  if ( (unsigned int)a1[2] - 1 >= 0xC )
    return 0;
  if ( (unsigned int)a1[3] - 1 >= 0x1F )
    return 0;
  if ( a1[5] > 0x18u )
    return 0;
  if ( a1[6] <= 0x3Cu )
    return a1[7] <= 0x3Cu;
  return 0;
}

//----- (08004E04) --------------------------------------------------------
BOOL __fastcall sub_8004E04(unsigned int a1)
{
  if ( !byte_200004D3 && !byte_200004D4 && !byte_200004D2 )
    return 0;
  if ( byte_200004D3 != byte_20005235 || byte_200004D4 != byte_20005236 )
    return 0;
  return word_200051A4[3 * (unsigned __int8)byte_200004D2] <= a1
      && word_200051A4[3 * (unsigned __int8)byte_200004D2 + 3] > a1;
}
// 200004D2: using guessed type char byte_200004D2;
// 200004D3: using guessed type char byte_200004D3;
// 200004D4: using guessed type char byte_200004D4;
// 200051A4: using guessed type unsigned __int16 word_200051A4[72];
// 20005235: using guessed type char byte_20005235;
// 20005236: using guessed type char byte_20005236;

//----- (08004E5C) --------------------------------------------------------
_BYTE *sub_8004E5C()
{
  byte_200015DF = 0;
  sub_8002364(byte_200112A8, 128);
  dword_20011298 = 0;
  dword_2001129C = 0;
  dword_200112A0 = 0;
  dword_200112A4 = 0;
  return sub_8002364(byte_200111D4, 32);
}
// 200015DF: using guessed type char byte_200015DF;
// 20011298: using guessed type int dword_20011298;
// 2001129C: using guessed type int dword_2001129C;
// 200112A0: using guessed type int dword_200112A0;
// 200112A4: using guessed type int dword_200112A4;

//----- (08004E8C) --------------------------------------------------------
int sub_8004E8C()
{
  dword_20001944 = 1073807872;
  dword_20001948 = 0;
  dword_2000194C = 64;
  dword_20001954 = 0;
  dword_20001950 = 196608;
  dword_20001958 = 0;
  dword_2000195C = 0;
  if ( sub_8011328((int)&dword_20001944) )
    sub_8005C1C();
  return sub_801164C((int)&dword_20001944);
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20001944: using guessed type int dword_20001944;
// 20001948: using guessed type int dword_20001948;
// 2000194C: using guessed type int dword_2000194C;
// 20001950: using guessed type int dword_20001950;
// 20001954: using guessed type int dword_20001954;
// 20001958: using guessed type int dword_20001958;
// 2000195C: using guessed type int dword_2000195C;

//----- (08004EC4) --------------------------------------------------------
int sub_8004EC4()
{
  int result; // r0

  dword_20001968 = 1073807880;
  dword_2000196C = 256;
  dword_20001970 = 112;
  dword_20001978 = 0;
  dword_20001974 = 458752;
  dword_2000197C = 0;
  dword_20001980 = 0;
  if ( sub_8011328((int)&dword_20001968) )
    sub_8005C1C();
  result = sub_801164C((int)&dword_20001968);
  if ( result )
    sub_8005C1C();
  return result;
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20001968: using guessed type int dword_20001968;
// 2000196C: using guessed type int dword_2000196C;
// 20001970: using guessed type int dword_20001970;
// 20001974: using guessed type int dword_20001974;
// 20001978: using guessed type int dword_20001978;
// 2000197C: using guessed type int dword_2000197C;
// 20001980: using guessed type int dword_20001980;

//----- (08004F08) --------------------------------------------------------
int sub_8004F08()
{
  dword_2000198C = 1073807884;
  dword_20001990 = 0;
  dword_20001994 = 80;
  dword_2000199C = 0;
  dword_20001998 = 196608;
  dword_200019A0 = 0;
  dword_200019A4 = 0;
  if ( sub_8011328((int)&dword_2000198C) )
    sub_8005C1C();
  return sub_801164C((int)&dword_2000198C);
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 2000198C: using guessed type int dword_2000198C;
// 20001990: using guessed type int dword_20001990;
// 20001994: using guessed type int dword_20001994;
// 20001998: using guessed type int dword_20001998;
// 2000199C: using guessed type int dword_2000199C;
// 200019A0: using guessed type int dword_200019A0;
// 200019A4: using guessed type int dword_200019A4;

//----- (08004F40) --------------------------------------------------------
int sub_8004F40()
{
  sub_8004E8C();
  sub_8004EC4();
  return sub_8004F08();
}

//----- (08004F52) --------------------------------------------------------
int __fastcall sub_8004F52(int a1, __int16 a2, int a3, __int16 a4)
{
  if ( (unsigned __int16)a1 != (unsigned __int16)a3 )
    return (unsigned __int16)a1 - (unsigned __int16)a3;
  if ( BYTE2(a1) != BYTE2(a3) )
    return BYTE2(a1) - BYTE2(a3);
  if ( HIBYTE(a1) != HIBYTE(a3) )
    return HIBYTE(a1) - HIBYTE(a3);
  if ( (unsigned __int8)a2 == (unsigned __int8)a4 )
    return HIBYTE(a2) - HIBYTE(a4);
  return (unsigned __int8)a2 - (unsigned __int8)a4;
}

//----- (08004FA2) --------------------------------------------------------
int __fastcall sub_8004FA2(int result, int a2, unsigned int a3)
{
  unsigned int i; // r3

  if ( result && a2 && a3 )
  {
    for ( i = 0; i < a3; ++i )
      *(_BYTE *)(result + i) = *(_BYTE *)(a3 - i + a2 - 1);
  }
  return result;
}

//----- (08004FC8) --------------------------------------------------------
unsigned int __fastcall sub_8004FC8(float *a1)
{
  unsigned int v2; // r4
  unsigned int result; // r0
  unsigned int v4; // r5
  int v5; // r1

  v2 = 255;
  result = (unsigned __int8)byte_20002F1C;
  v4 = (unsigned __int8)byte_20002F1D | ((unsigned __int8)byte_20002F1C << 8);
  if ( a1 )
  {
    result = (unsigned __int8)byte_20002F60;
    if ( byte_20002F60 == 5 )
    {
      result = (unsigned __int8)byte_20005235;
      if ( (unsigned __int8)byte_20005235 != 255 )
      {
        result = (unsigned __int8)byte_20005234;
        if ( byte_20005234 )
        {
          if ( (unsigned __int8)byte_20005234 <= 0x18u )
          {
            result = sub_8004E04((unsigned __int8)byte_20002F1D | ((unsigned __int8)byte_20002F1C << 8));
            if ( result )
            {
              result = (unsigned int)&byte_200004D2;
              v2 = (unsigned __int8)byte_200004D2;
            }
            if ( v2 == 255 )
            {
              v5 = 0;
              while ( 1 )
              {
                result = word_200051A4[3 * v5];
                if ( result <= v4 )
                {
                  result = word_200051A4[3 * v5 + 3];
                  if ( result > v4 )
                    break;
                }
                if ( (unsigned int)++v5 >= 0x18 )
                  goto LABEL_14;
              }
              v2 = (unsigned __int8)v5;
              result = sub_8017398(v5);
            }
LABEL_14:
            if ( v2 < 0x18 )
            {
              result = sub_801036C(*(_DWORD *)&word_200051A4[3 * v2], word_200051A4[3 * v2 + 2]);
              *a1 = (float)(int)result;
            }
          }
        }
      }
    }
  }
  return result;
}
// 200004D2: using guessed type char byte_200004D2;
// 20002F1C: using guessed type char byte_20002F1C;
// 20002F1D: using guessed type char byte_20002F1D;
// 20002F60: using guessed type char byte_20002F60;
// 200051A4: using guessed type unsigned __int16 word_200051A4[72];
// 20005234: using guessed type char byte_20005234;
// 20005235: using guessed type char byte_20005235;

//----- (08005090) --------------------------------------------------------
int *__fastcall sub_8005090(int *result)
{
  int v1; // r2
  int v2; // r1

  v1 = *result;
  if ( (unsigned int)*result >= 0x40020408 )
    v2 = 1073874976;
  else
    v2 = 1073874944;
  result[18] = v2 + (result[17] & 0xFFFFFFFC);
  result[19] = 1073875072;
  result[20] = 1 << ((((unsigned int)(unsigned __int8)v1 - 8) / 0x14) & 0x1F);
  return result;
}

//----- (080050D0) --------------------------------------------------------
int __fastcall sub_80050D0(int result)
{
  int v1; // r1

  v1 = *(unsigned __int8 *)(result + 4) - 1;
  *(_DWORD *)(result + 84) = 4 * v1 + 1073875200;
  *(_DWORD *)(result + 88) = 1073875264;
  *(_DWORD *)(result + 92) = 1 << (v1 & 0x1F);
  return result;
}

//----- (080050F4) --------------------------------------------------------
int __fastcall sub_80050F4(int *a1, int a2, int a3, int a4)
{
  int result; // r0

  *(_DWORD *)(a1[19] + 4) = a1[20];
  if ( a1[21] )
    *(_DWORD *)(a1[22] + 4) = a1[23];
  *(_DWORD *)(a1[16] + 4) = 1 << (a1[17] & 0x1F);
  *(_DWORD *)(*a1 + 4) = a4;
  if ( a1[2] == 16 )
  {
    *(_DWORD *)(*a1 + 8) = a3;
    result = *a1;
    *(_DWORD *)(result + 12) = a2;
  }
  else
  {
    *(_DWORD *)(*a1 + 8) = a2;
    result = *a1;
    *(_DWORD *)(result + 12) = a3;
  }
  return result;
}

//----- (08005138) --------------------------------------------------------
int sub_8005138()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_2000210C = 1342179328;
  sub_80118FC((int)&dword_2000210C);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 2;
  v8 = 2;
  v9 = 0;
  sub_8011728((int)&dword_2000210C, (int)&v1, 0);
  sub_8011728((int)&dword_2000210C, (int)&v1, 16);
  sub_80119EE(&dword_2000210C, 0);
  if ( byte_20000002 )
    return sub_80119BC(&dword_2000210C, 0, 0, 11);
  else
    return sub_80119BC(&dword_2000210C, 0, 0, 311);
}
// 20000002: using guessed type char byte_20000002;
// 2000210C: using guessed type int dword_2000210C;

//----- (080051B8) --------------------------------------------------------
int sub_80051B8()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_20002120[0] = 1342180352;
  sub_80118FC((int)dword_20002120);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 1;
  v9 = 1;
  sub_8011728((int)dword_20002120, (int)&v1, 0);
  return sub_80119EE(dword_20002120, 0);
}
// 20002120: using guessed type int dword_20002120[5];

//----- (0800520C) --------------------------------------------------------
int sub_800520C()
{
  int v1; // [sp+4h] [bp-34h] BYREF
  char v2; // [sp+8h] [bp-30h]
  char v3; // [sp+9h] [bp-2Fh]
  int v4; // [sp+Ch] [bp-2Ch]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  int v7; // [sp+18h] [bp-20h]
  int v8; // [sp+1Ch] [bp-1Ch]
  int v9; // [sp+20h] [bp-18h]

  sub_8002364(&v1, 48);
  dword_20002134[0] = 1342181376;
  sub_80118FC((int)dword_20002134);
  v1 = 2;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 2;
  v8 = 2;
  v9 = 0;
  if ( sub_8011728((int)dword_20002134, (int)&v1, 0) )
    sub_8005C1C();
  sub_80119EE(dword_20002134, 0);
  if ( byte_20000002 )
    return sub_80119BC(dword_20002134, 0, 0, 3800);
  else
    return sub_80119BC(dword_20002134, 0, 0, 3500);
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20000002: using guessed type char byte_20000002;
// 20002134: using guessed type int dword_20002134[5];

//----- (0800528C) --------------------------------------------------------
int sub_800528C()
{
  sub_8005138();
  sub_80051B8();
  return sub_800520C();
}

//----- (080052A0) --------------------------------------------------------
int __fastcall sub_80052A0(int a1)
{
  return sub_80119BC(dword_20002134, 0, 0, a1);
}
// 20002134: using guessed type int dword_20002134[5];

//----- (080052B0) --------------------------------------------------------
int __fastcall sub_80052B0(int a1)
{
  return sub_80119BC(&dword_2000210C, 0, 0, a1);
}
// 2000210C: using guessed type int dword_2000210C;

//----- (080052C4) --------------------------------------------------------
int sub_80052C4(const char *a1, ...)
{
  int result; // r0
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  result = (unsigned __int8)byte_200037D5;
  if ( byte_200037D5 == 1 )
  {
    sub_801E9AC((int)a1, (int)varg_r1);
    return 0;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200037D5: using guessed type char byte_200037D5;

//----- (080052E8) --------------------------------------------------------
int __fastcall sub_80052E8(int a1)
{
  return a1 + 5;
}

//----- (0800536C) --------------------------------------------------------
int sub_800536C()
{
  sub_8012748(1024);
  return sub_8012748(2048);
}

//----- (08005382) --------------------------------------------------------
int sub_8005382()
{
  sub_8012748(128);
  return sub_8012748(256);
}

//----- (08005398) --------------------------------------------------------
int __fastcall sub_8005398(int a1)
{
  int result; // r0
  int v2; // r0
  int v3; // [sp+0h] [bp-8h] BYREF

  v3 = 1;
  if ( a1 == 2 )
  {
    v3 = 2;
  }
  else if ( !a1 )
  {
    v3 = 0;
  }
  result = (unsigned __int8)v3;
  if ( (unsigned __int8)v3 != 1 )
  {
    sub_80031E4();
    sub_8005AA4(0);
    v2 = sub_8005A84(90);
    sub_801F610(v2);
    sub_800591C(0x90u, &byte_2000050B, 1u);
    sub_800591C(0, &v3, 1u);
    sub_802325C();
  }
  return result;
}
// 801F610: using guessed type int __fastcall sub_801F610(_DWORD);
// 2000050B: using guessed type char byte_2000050B;

//----- (080053F8) --------------------------------------------------------
int __fastcall sub_80053F8(int a1)
{
  switch ( a1 )
  {
    case 3:
      sub_8002364(&byte_2000303C, 40);
      break;
    case 2:
      dword_2000304C = 0;
      dword_20003050 = 0;
      dword_20003054 = 0;
      dword_20003058 = 0;
      dword_2000305C = 0;
      dword_20003060 = 0;
      break;
    case 1:
      dword_20003058 = 0;
      dword_2000305C = 0;
      dword_20003060 = 0;
      break;
  }
  return sub_800590C();
}
// 2000303C: using guessed type char byte_2000303C;
// 2000304C: using guessed type int dword_2000304C;
// 20003050: using guessed type int dword_20003050;
// 20003054: using guessed type int dword_20003054;
// 20003058: using guessed type int dword_20003058;
// 2000305C: using guessed type int dword_2000305C;
// 20003060: using guessed type int dword_20003060;

//----- (08005438) --------------------------------------------------------
int __fastcall sub_8005438(unsigned int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v6; // [sp+0h] [bp-10h] BYREF

  v6 = a4;
  if ( byte_20000000 )
    return sub_8023A34(a1);
  v6 = 0;
  do
    result = sub_801B018(&v6, a1);
  while ( !result );
  return result;
}
// 20000000: using guessed type char byte_20000000;

//----- (08005464) --------------------------------------------------------
int sub_8005464()
{
  if ( (unsigned int)(unsigned __int8)byte_20002FD9 - 30 >= 0x47 )
    byte_20002FD9 = 90;
  return (unsigned __int8)byte_20002FD9;
}
// 20002FD9: using guessed type char byte_20002FD9;

//----- (08005494) --------------------------------------------------------
int sub_8005494()
{
  int result; // r0

  result = 1010;
  if ( (unsigned __int8)byte_20002FD6 == 170 )
    return (unsigned __int16)word_20002FD7;
  if ( byte_20002FD1 != 1 )
  {
    if ( byte_20002FD1 == 5 )
    {
      return 2222;
    }
    else if ( byte_20002FD1 == 6 )
    {
      return 2223;
    }
  }
  return result;
}
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FD6: using guessed type char byte_20002FD6;
// 20002FD7: using guessed type __int16 word_20002FD7;

//----- (080054C8) --------------------------------------------------------
int __fastcall sub_80054C8(int a1, int a2, int a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  int v28; // r2
  int v29; // r3
  int v30; // r1
  int v31; // r2
  int v32; // r3
  int v33; // r1
  int v34; // r2
  int v35; // r3
  int v36; // r1
  int v37; // r2
  int v38; // r3
  int v39; // r1
  int v40; // r2
  int v41; // r3
  int v42; // r1
  int v43; // r2
  int v44; // r3
  int v45; // r1
  int v46; // r2
  int v47; // r3
  int v48; // r1
  int v49; // r2
  int v50; // r3
  char v51; // r0
  char v52; // r0
  int v53; // r0
  char v54; // r0
  int v56; // [sp+0h] [bp-30h] BYREF
  int v57; // [sp+4h] [bp-2Ch] BYREF

  v56 = a3;
  v57 = 0;
  sub_8005860(0x90u);
  sub_8005860(0x92u);
  if ( (unsigned __int8)byte_2000050B == 255 )
    byte_2000050B = 0;
  sub_8005860(0x150u);
  if ( (unsigned __int8)byte_20000509 == 255 )
    byte_20000509 = 0;
  sub_8005860(0);
  sub_8017310();
  if ( (unsigned __int8)v56 == 1 )
  {
    sub_8005860(1u);
    sub_8005438(1u, v3, v4, v5);
    sub_8005860(0x100u);
    sub_8005438(1u, v6, v7, v8);
    sub_8005860(0x200u);
    sub_8005438(1u, v9, v10, v11);
    sub_8005860(0x300u);
    sub_8005438(1u, v12, v13, v14);
    sub_8005860(0x400u);
    sub_8005438(1u, v15, v16, v17);
    sub_8005860(0x500u);
    sub_8005438(1u, v18, v19, v20);
    sub_8005860(0x800u);
    sub_8005438(1u, v21, v22, v23);
    sub_8005860(0x900u);
  }
  sub_8017310();
  if ( (unsigned __int16)word_20002F5A < 0x78u )
  {
    if ( (unsigned __int8)v56 == 2 )
    {
      sub_8005860(0x500u);
      sub_8005438(1u, v24, v25, v26);
    }
    sprintf((int)&unk_20002F30, "AC01");
    word_20002F58 = 13;
    word_20002F5A = 151;
    word_20002F5C = MEMORY[0x8001000];
    byte_20000516 = 100;
    byte_20000517 = 12;
    byte_20000512 = 1;
    byte_20000513 = 1;
    word_20000518 = 2500;
    word_2000051A = 2500;
    byte_2000051C = 0;
    byte_20002F5F[0] = 0;
    byte_20002FD3 = 0;
    byte_20002F60 = 1;
    word_20002FC5 = 1;
    dword_20002FC7 = 0;
    dword_20002FCB = 0;
    byte_20002FD0 = 1;
    byte_20002FD1 = 4;
    qmemcpy((unsigned int)&byte_20002FDB, (unsigned int)"SM471", 0x20u);
    qmemcpy((unsigned int)&byte_20002FFB, (unsigned int)"Hame147258", 0x40u);
    byte_2000303B = 0;
    byte_20000508 = 0;
    sub_8017310();
    sub_8005AD0(1, (int)&unk_20002F30, 0x2Fu);
    sub_8005438(1u, v27, v28, v29);
    sub_8017310();
    sub_8005AD0(256, (int)&byte_20000511, 5u);
    sub_8005438(1u, v30, v31, v32);
    sub_8017310();
    sub_8005AD0(512, (int)&byte_20000516, 7u);
    sub_8005438(1u, v33, v34, v35);
    sub_8017310();
    sub_8005AD0(768, (int)byte_20002F5F, 0x7Cu);
    sub_8005438(1u, v36, v37, v38);
    sub_8017310();
    sub_8005AD0(1024, (int)&byte_20002FDB, 0x61u);
    sub_8005438(1u, v39, v40, v41);
    sub_8017310();
    sub_8005AD0(1280, (int)&byte_2000303C, 0x28u);
    sub_8005438(1u, v42, v43, v44);
    sub_8017310();
    sub_8005AD0(2048, (int)&word_2000050D, 4u);
    sub_8005438(1u, v45, v46, v47);
    sub_8017310();
    sub_8005AD0(2304, (int)&byte_20000508, 1u);
    sub_8005438(1u, v48, v49, v50);
    sub_8017310();
    v56 = 1;
    sub_8005AD0(0, (int)&v56, 1u);
  }
  sub_8005860(0x480u);
  sub_8005AD0(1152, (int)&v57, 1u);
  v51 = byte_20002FD1;
  if ( (unsigned __int8)byte_20002FD1 >= 8u )
    v51 = 0;
  byte_20002FD1 = v51;
  v52 = byte_20002FD0;
  if ( (unsigned __int8)byte_20002FD0 > 1u )
    v52 = 1;
  byte_20002FD0 = v52;
  v53 = (unsigned __int8)byte_20002FD2;
  if ( (unsigned __int8)byte_20002FD2 > 4u )
    v53 = 0;
  byte_200004AC = v53;
  byte_200004BA = v53 == 0;
  v54 = byte_20002FD4;
  if ( byte_20002FD4 != 2 )
    v54 = byte_20002FDA;
  byte_20002FDA = v54;
  sub_8005464();
  word_20002F5C = MEMORY[0x8001000];
  word_20002F5A = 151;
  return 0;
}
// 8005532: variable 'v3' is possibly undefined
// 8005532: variable 'v4' is possibly undefined
// 8005532: variable 'v5' is possibly undefined
// 8005544: variable 'v6' is possibly undefined
// 8005544: variable 'v7' is possibly undefined
// 8005544: variable 'v8' is possibly undefined
// 8005556: variable 'v9' is possibly undefined
// 8005556: variable 'v10' is possibly undefined
// 8005556: variable 'v11' is possibly undefined
// 800556A: variable 'v12' is possibly undefined
// 800556A: variable 'v13' is possibly undefined
// 800556A: variable 'v14' is possibly undefined
// 800557E: variable 'v15' is possibly undefined
// 800557E: variable 'v16' is possibly undefined
// 800557E: variable 'v17' is possibly undefined
// 800558E: variable 'v18' is possibly undefined
// 800558E: variable 'v19' is possibly undefined
// 800558E: variable 'v20' is possibly undefined
// 80055A0: variable 'v21' is possibly undefined
// 80055A0: variable 'v22' is possibly undefined
// 80055A0: variable 'v23' is possibly undefined
// 80055DA: variable 'v24' is possibly undefined
// 80055DA: variable 'v25' is possibly undefined
// 80055DA: variable 'v26' is possibly undefined
// 8005668: variable 'v27' is possibly undefined
// 8005668: variable 'v28' is possibly undefined
// 8005668: variable 'v29' is possibly undefined
// 800567E: variable 'v30' is possibly undefined
// 800567E: variable 'v31' is possibly undefined
// 800567E: variable 'v32' is possibly undefined
// 8005694: variable 'v33' is possibly undefined
// 8005694: variable 'v34' is possibly undefined
// 8005694: variable 'v35' is possibly undefined
// 80056AC: variable 'v36' is possibly undefined
// 80056AC: variable 'v37' is possibly undefined
// 80056AC: variable 'v38' is possibly undefined
// 80056C6: variable 'v39' is possibly undefined
// 80056C6: variable 'v40' is possibly undefined
// 80056C6: variable 'v41' is possibly undefined
// 80056DA: variable 'v42' is possibly undefined
// 80056DA: variable 'v43' is possibly undefined
// 80056DA: variable 'v44' is possibly undefined
// 80056F0: variable 'v45' is possibly undefined
// 80056F0: variable 'v46' is possibly undefined
// 80056F0: variable 'v47' is possibly undefined
// 8005708: variable 'v48' is possibly undefined
// 8005708: variable 'v49' is possibly undefined
// 8005708: variable 'v50' is possibly undefined
// 200004AC: using guessed type char byte_200004AC;
// 200004BA: using guessed type char byte_200004BA;
// 20000508: using guessed type char byte_20000508;
// 20000509: using guessed type char byte_20000509;
// 2000050B: using guessed type char byte_2000050B;
// 2000050D: using guessed type __int16 word_2000050D;
// 20000511: using guessed type char byte_20000511;
// 20000512: using guessed type char byte_20000512;
// 20000513: using guessed type char byte_20000513;
// 20000516: using guessed type char byte_20000516;
// 20000517: using guessed type char byte_20000517;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 2000051C: using guessed type char byte_2000051C;
// 20002F58: using guessed type __int16 word_20002F58;
// 20002F5A: using guessed type __int16 word_20002F5A;
// 20002F5C: using guessed type __int16 word_20002F5C;
// 20002F60: using guessed type char byte_20002F60;
// 20002FC5: using guessed type __int16 word_20002FC5;
// 20002FC7: using guessed type int dword_20002FC7;
// 20002FCB: using guessed type int dword_20002FCB;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FD2: using guessed type char byte_20002FD2;
// 20002FD3: using guessed type char byte_20002FD3;
// 20002FD4: using guessed type char byte_20002FD4;
// 20002FDA: using guessed type char byte_20002FDA;
// 20002FDB: using guessed type char byte_20002FDB;
// 20002FFB: using guessed type char byte_20002FFB;
// 2000303B: using guessed type char byte_2000303B;
// 2000303C: using guessed type char byte_2000303C;

//----- (080057C4) --------------------------------------------------------
BOOL __fastcall sub_80057C4(unsigned int a1, int a2, __int16 a3)
{
  int v5; // r4
  __int16 v6; // r6
  int v7; // r5
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v12; // [sp+4h] [bp-2Ch] BYREF

  v5 = 0;
  v6 = 160;
  v12 = 0;
  if ( a1 >= 0x10000 )
    v6 = 162;
  LOBYTE(v12) = BYTE1(a1);
  BYTE1(v12) = a1;
  if ( sub_80256C8(dword_20000464, 1000) )
  {
    sub_801292E(1207961600, 4096, 0);
    v7 = sub_8013630((int)&dword_20002170, v6, (int)&v12, 2, 0x32u);
    v5 = sub_80134E4((int)&dword_20002170, v6, a2, a3, 0x32u) | v7;
    sub_8005438(1u, v8, v9, v10);
    sub_801292E(1207961600, 4096, 1);
    sub_8025188(dword_20000464, 0, 0, 0);
  }
  return v5 == 0;
}
// 800582E: variable 'v8' is possibly undefined
// 800582E: variable 'v9' is possibly undefined
// 800582E: variable 'v10' is possibly undefined
// 20000464: using guessed type int dword_20000464;
// 20002170: using guessed type int dword_20002170;

//----- (08005860) --------------------------------------------------------
int __fastcall sub_8005860(unsigned int a1)
{
  return IRQ_11_handler(a1, a1 >> 8);
}
// 8005878: using guessed type int __fastcall IRQ_11_handler(_DWORD, _DWORD);

//----- (08005878) --------------------------------------------------------
#error "80058A0: call analysis failed (funcsize=34)"

//----- (080058E0) --------------------------------------------------------
int __fastcall sub_80058E0(unsigned int a1)
{
  if ( a1 >= 0xA )
    return sub_800591C(0x302u, &byte_20002F61, 0x64u);
  else
    return sub_800591C(10 * a1 + 770, &byte_20002F5F[10 * a1 + 2], 0xAu);
}
// 20002F61: using guessed type char byte_20002F61;

//----- (0800590C) --------------------------------------------------------
int sub_800590C()
{
  return sub_800591C(0x500u, &byte_2000303C, 0x28u);
}
// 2000303C: using guessed type char byte_2000303C;

//----- (0800591C) --------------------------------------------------------
int __fastcall sub_800591C(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v5; // r5
  int result; // r0
  unsigned int v7; // r6
  int v8; // r1
  int v9; // r2
  int v10; // r3
  __int16 v11; // r8
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // [sp+4h] [bp-2Ch] BYREF
  _DWORD v19[10]; // [sp+8h] [bp-28h] BYREF

  v5 = a3;
  result = 0;
  v19[0] = 0;
  v18 = 0;
  v7 = 0;
  if ( a3 <= 0x10000 )
  {
    do
    {
      if ( !v5 )
        return 1;
      BYTE2(v19[0]) = *a2;
      v18 = BYTE2(v19[0]) + 1;
      if ( sub_80256C8(dword_20000464, 1000) )
      {
        sub_801292E(1207961600, 4096, 0);
        sub_8005438(1u, v8, v9, v10);
        if ( a1 < 0x10000 )
          v11 = 160;
        else
          v11 = 162;
        LOBYTE(v19[0]) = BYTE1(a1);
        BYTE1(v19[0]) = a1;
        sub_8013630((int)&dword_20002170, v11, (int)v19, 3, 0x32u);
        sub_8005438(5u, v12, v13, v14);
        sub_8013630((int)&dword_20002170, v11, (int)v19, 2, 0x32u);
        sub_80134E4((int)&dword_20002170, v11, (int)&v18, 1, 0x32u);
        sub_8005438(1u, v15, v16, v17);
        sub_801292E(1207961600, 4096, 1);
        sub_8025188(dword_20000464, 0, 0, 0);
      }
      if ( BYTE2(v19[0]) == (unsigned __int8)v18 )
      {
        --v5;
        ++a2;
        ++a1;
      }
      else
      {
        v7 = (unsigned __int8)(v7 + 1);
      }
    }
    while ( v7 <= 3 );
    sub_8018434(66, 0, 0, 0);
    if ( sub_80256C8(dword_20000464, 1000) )
    {
      sub_8017270();
      sub_8025188(dword_20000464, 0, 0, 0);
    }
    else
    {
      sub_8025188(dword_20000464, 0, 0, 0);
      sub_8017270();
    }
    return 0;
  }
  return result;
}
// 8005966: variable 'v8' is possibly undefined
// 8005966: variable 'v9' is possibly undefined
// 8005966: variable 'v10' is possibly undefined
// 8005998: variable 'v12' is possibly undefined
// 8005998: variable 'v13' is possibly undefined
// 8005998: variable 'v14' is possibly undefined
// 80059BE: variable 'v15' is possibly undefined
// 80059BE: variable 'v16' is possibly undefined
// 80059BE: variable 'v17' is possibly undefined
// 20000464: using guessed type int dword_20000464;
// 20002170: using guessed type int dword_20002170;

//----- (08005A54) --------------------------------------------------------
unsigned int __fastcall sub_8005A54(unsigned int result)
{
  if ( result <= 2 )
  {
    byte_20002FDA = result;
    byte_20002FD4 = result;
    sub_800591C(0x37Bu, &byte_20002FDA, 1u);
    return sub_800591C(0x375u, &byte_20002FD4, 1u);
  }
  return result;
}
// 20002FD4: using guessed type char byte_20002FD4;
// 20002FDA: using guessed type char byte_20002FDA;

//----- (08005A84) --------------------------------------------------------
int __fastcall sub_8005A84(int result)
{
  if ( (unsigned int)(result - 30) < 0x47 )
  {
    byte_20002FD9 = result;
    return sub_800591C(0x37Au, &byte_20002FD9, 1u);
  }
  return result;
}
// 20002FD9: using guessed type char byte_20002FD9;

//----- (08005AA4) --------------------------------------------------------
unsigned int __fastcall sub_8005AA4(unsigned int result)
{
  if ( result <= 4 )
  {
    byte_200004AC = result;
    if ( result )
    {
      byte_200004BA = 0;
      byte_200004BB = 3;
    }
    return DebugMonitor_handler(883, &byte_200004AC, 1);
  }
  return result;
}
// 8005AC0: using guessed type int __fastcall DebugMonitor_handler(_DWORD, _DWORD, _DWORD);
// 200004AC: using guessed type char byte_200004AC;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;

//----- (08005AD0) --------------------------------------------------------
void __fastcall sub_8005AD0(int a1, int a2, unsigned int a3)
{
  if ( a3 > 0x10000 )
    JUMPOUT(0x8005AEA);
  JUMPOUT(0x8005BA0);
}
// 8005AE8: control flows out of bounds to 8005AEA
// 8005AF2: control flows out of bounds to 8005BA0

//----- (08005B6C) --------------------------------------------------------
int __fastcall IRQ_40_handler(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7)
{
  sub_801292E(a1, a2, a3);
  if ( BYTE2(a7) != a6 )
    JUMPOUT(0x8005B88);
  return IRQ_23_handler();
}
// 8005B80: control flows out of bounds to 8005B88
// 8005B82: using guessed type int IRQ_23_handler(void);

//----- (08005B82) --------------------------------------------------------
#error "8005B36: call analysis failed (funcsize=62)"

//----- (08005BB0) --------------------------------------------------------
unsigned int __fastcall sub_8005BB0(unsigned int result)
{
  if ( result <= 1 )
  {
    byte_20002FD0 = result;
    return sub_800591C(0x371u, &byte_20002FD0, 1u);
  }
  return result;
}
// 20002FD0: using guessed type char byte_20002FD0;

//----- (08005BCC) --------------------------------------------------------
int __fastcall sub_8005BCC(__int16 a1)
{
  byte_20002FD6 = -86;
  word_20002FD7 = a1;
  sub_800591C(0x377u, &byte_20002FD6, 1u);
  return sub_800591C(0x378u, &word_20002FD7, 2u);
}
// 20002FD6: using guessed type char byte_20002FD6;
// 20002FD7: using guessed type __int16 word_20002FD7;

//----- (08005BFC) --------------------------------------------------------
int __fastcall sub_8005BFC(int a1, int a2)
{
  int result; // r0

  dword_200004EC += a1;
  dword_200004F0 += a2;
  result = a2 - a1;
  dword_20001C1C = result;
  return result;
}
// 200004EC: using guessed type int dword_200004EC;
// 200004F0: using guessed type int dword_200004F0;
// 20001C1C: using guessed type int dword_20001C1C;

//----- (08005C20) --------------------------------------------------------
int sub_8005C20()
{
  __int64 v0; // r4
  int result; // r0

  v0 = 0;
  sub_800F8E4();
  if ( word_20003C59 || word_20003C5D || (result = qword_20003D20 | HIDWORD(qword_20003D20), qword_20003D20) )
  {
    if ( byte_200008FA )
    {
      if ( byte_200008FA == 1 )
      {
        v0 = (unsigned __int16)word_20003C5D;
        byte_200008FA = 2;
      }
      else if ( byte_200008FA == 2 )
      {
        v0 = qword_20003D20;
        byte_200008FA = 3;
      }
      else
      {
        byte_200008FA = 0;
      }
    }
    else
    {
      v0 = (unsigned __int16)word_20003C59;
      byte_200008FA = 1;
    }
    result = v0 | HIDWORD(v0);
    if ( v0 )
      JUMPOUT(0x8018E38);
  }
  return result;
}
// 8005C60: control flows out of bounds to 8018E38
// 200008FA: using guessed type char byte_200008FA;
// 20003C59: using guessed type __int16 word_20003C59;
// 20003C5D: using guessed type __int16 word_20003C5D;
// 20003D20: using guessed type __int64 qword_20003D20;

//----- (08005C90) --------------------------------------------------------
int sub_8005C90()
{
  int v0; // s0

  return v0;
}
// 8005C90: variable 'v0' is possibly undefined

//----- (08005CA4) --------------------------------------------------------
int __fastcall sub_8005CA4(int *a1)
{
  unsigned int v1; // r1
  int v2; // r2
  int result; // r0
  unsigned int v4; // r2

  v1 = 1073783808;
  v2 = *a1;
  if ( *a1 == 1073768448 )
    v1 = 1073784656;
  if ( v2 == 1073769472 )
    v1 += 1696;
  a1[16] = v1;
  *(_DWORD *)(v2 + 128) = *(_DWORD *)(v2 + 128) & 0xFFE0FFFF | (*((unsigned __int16 *)a1 + 26) << 16);
  a1[17] = v1 + 112;
  *(_DWORD *)(*a1 + 128) = *(_DWORD *)(*a1 + 128) & 0xF0FFFFFF | (*((unsigned __int8 *)a1 + 56) << 24);
  a1[18] = v1 + 176;
  a1[19] = v1 + 392;
  a1[20] = v1 + 608;
  a1[21] = v1 + 632;
  result = 0;
  v4 = v1 + 848;
  while ( v1 < v4 )
  {
    *(_DWORD *)v1 = 0;
    v1 += 4;
  }
  return result;
}

//----- (08005D18) --------------------------------------------------------
unsigned int __fastcall sub_8005D18(int a1, int *a2, int a3, int a4)
{
  __int64 v4; // kr00_8
  int v5; // r4
  int v6; // r5
  int v7; // r4
  int v8; // r5
  int *v9; // r3
  int *v10; // r3
  unsigned int result; // r0

  v4 = *(_QWORD *)(a2 + 1);
  v5 = a2[4] | HIDWORD(v4);
  v6 = *a2;
  if ( (_DWORD)v4 )
    v7 = v5 | v6 | 0x40000000;
  else
    v7 = v5 | (v6 << 18);
  v8 = a2[7] | a2[6] | a2[5] | (*((unsigned __int8 *)a2 + 32) << 24) | a2[3];
  v9 = (int *)(*(_DWORD *)(a1 + 84) + 72 * a4);
  *v9 = v7;
  v9[1] = v8;
  v10 = v9 + 2;
  for ( result = 0; *((unsigned __int8 *)dword_80268B4 + HIWORD(a2[3])) > result; result += 4 )
    *v10++ = *(unsigned __int8 *)(a3 + result)
           | (*(unsigned __int8 *)(a3 + result + 3) << 24)
           | (*(unsigned __int8 *)(a3 + result + 2) << 16)
           | (*(unsigned __int8 *)(a3 + result + 1) << 8);
  return result;
}
// 80268B4: using guessed type int dword_80268B4[4];

//----- (08005D8C) --------------------------------------------------------
int sub_8005D8C()
{
  int result; // r0

  if ( byte_2000028C == 1 || byte_2000028C == 3 )
  {
    MEMORY[0x40022000] &= ~0x200u;
    MEMORY[0x40022000] |= 0x800u;
    MEMORY[0x40022000] &= ~0x800u;
    MEMORY[0x40022000] |= 0x200u;
  }
  if ( byte_2000028C == 2 || byte_2000028C == 3 )
  {
    MEMORY[0x40022000] |= 0x1000u;
    MEMORY[0x40022000] &= ~0x1000u;
    MEMORY[0x40022000] |= 0x400u;
  }
  result = 0;
  byte_2000028C = 0;
  return result;
}
// 2000028C: using guessed type char byte_2000028C;

//----- (08005DE8) --------------------------------------------------------
int __fastcall sub_8005DE8(int a1)
{
  int result; // r0

  if ( (MEMORY[0x40022020] & 0x400000) != 0 )
  {
    if ( a1 << 31 )
      MEMORY[0x40022014] |= 4u;
    if ( (a1 & 2) != 0 )
      MEMORY[0x40022014] |= 0x8000u;
  }
  else
  {
    MEMORY[0x40022014] |= 0x8004u;
  }
  result = MEMORY[0x40022014] | 0x10000;
  MEMORY[0x40022014] |= 0x10000u;
  return result;
}

//----- (08005E24) --------------------------------------------------------
int __fastcall sub_8005E24(unsigned __int8 a1, int a2)
{
  int result; // r0

  if ( (MEMORY[0x40022020] & 0x400000) != 0 )
  {
    if ( a2 << 31 )
      MEMORY[0x40022014] &= ~0x800u;
    else
      MEMORY[0x40022014] |= 0x800u;
  }
  else
  {
    MEMORY[0x40022014] &= ~0x800u;
  }
  MEMORY[0x40022014] = MEMORY[0x40022014] & 0xFFFFFC07 | (8 * a1);
  MEMORY[0x40022014] |= 2u;
  result = MEMORY[0x40022014] | 0x10000;
  MEMORY[0x40022014] |= 0x10000u;
  return result;
}

//----- (08005E70) --------------------------------------------------------
_DWORD *__fastcall sub_8005E70(_DWORD *result, int a2, int a3, int a4)
{
  MEMORY[0x40022014] |= 1u;
  *result = a3;
  __isb(0xFu);
  result[1] = a4;
  return result;
}

//----- (08005E8C) --------------------------------------------------------
_DWORD *__fastcall sub_8005E8C(_DWORD *result, int *a2)
{
  int v2; // r2
  int v4; // r4

  LOBYTE(v2) = 64;
  MEMORY[0x40022014] |= 0x40000u;
  _R3 = __get_CPSR();
  __disable_irq();
  do
  {
    v4 = *a2++;
    *result++ = v4;
    v2 = (unsigned __int8)(v2 - 1);
  }
  while ( v2 );
  __asm { MSR.W           PRIMASK, R3 }
  return result;
}

//----- (08005EB8) --------------------------------------------------------
int __fastcall sub_8005EB8(unsigned int a1)
{
  int v2; // r5
  int v4; // r0

  v2 = sub_8012948();
  while ( (~MEMORY[0x40022010] & 0x10000) == 0 )
  {
    if ( sub_8012948() - v2 > a1 )
      return 3;
  }
  v4 = MEMORY[0x40022010] & 0xC3FA;
  if ( (MEMORY[0x40022010] & 0xC3FA) != 0 )
  {
    dword_20000274 |= v4;
    if ( 16 * v4 )
      MEMORY[0x40022010] = MEMORY[0x40022010] & 0xC3FA;
    return 1;
  }
  else
  {
    if ( !(~MEMORY[0x40022010] << 31) )
      MEMORY[0x40022010] = 1;
    return 0;
  }
}
// 8005F04: masking with 0xFFFFFFF was optimized away because r0.4 <= 0xC3FA
// 20000274: using guessed type int dword_20000274;

//----- (08005F24) --------------------------------------------------------
int __fastcall sub_8005F24(int a1)
{
  unsigned int v2; // r4

  LOBYTE(v2) = 0;
  do
  {
    if ( a1 )
    {
      if ( sub_800DFB4("AT+QBLEADVSTART", (unsigned __int8 *)&dword_8005F74, 0, 1200) )
        return 1;
    }
    else if ( sub_800DFB4("AT+QBLEADVSTOP", (unsigned __int8 *)&dword_8005F74, 0, 1200) )
    {
      return 1;
    }
    v2 = (unsigned __int8)(v2 + 1);
    sub_8023A34(100);
  }
  while ( v2 < 3 );
  return 0;
}
// 8005F74: using guessed type int dword_8005F74;

//----- (08005F98) --------------------------------------------------------
int __fastcall sub_8005F98(int a1, int a2)
{
  unsigned int v4; // r4
  unsigned __int8 v6[80]; // [sp+0h] [bp-50h] BYREF

  sub_8002364(v6, 64);
  v4 = 0;
  sprintf((int)v6, "AT+QBLEADVPARAM=%d,%d", a1, a2);
  while ( v4 < 3 )
  {
    if ( sub_800DFB4(v6, "OK", 0, 300) )
      return 1;
    v4 = (unsigned __int8)(v4 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (08006000) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_8006000(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v14; // r1
  int v15; // r2
  int v16; // r12
  int v17; // r0
  unsigned int v18; // r0
  int v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r0
  unsigned int v22; // r8
  char *v23; // r7
  int v24; // r4
  int v25; // r4
  int v26; // r0
  int v27; // r0
  unsigned __int8 *v28; // r0
  int v29; // r10
  unsigned int v30; // r6
  unsigned int v31; // r7
  unsigned int v32; // r0
  int v33; // r4
  int v34; // t1
  unsigned int v35; // r0
  int v36; // r1
  int v37; // r5
  unsigned int v38; // r1
  unsigned __int16 v39; // r0
  unsigned int v40; // r0
  int v41; // r4
  int v42; // r0
  unsigned __int8 *v43; // r6
  unsigned int v44; // r4
  unsigned int v45; // r0
  unsigned __int8 *v46; // r0
  __int16 v47; // r0
  int v48; // r0
  int v49; // [sp-C8h] [bp-1B8h]
  _BYTE v50[128]; // [sp-B8h] [bp-1A8h] BYREF
  _DWORD v51[2]; // [sp-38h] [bp-128h] BYREF
  int v52; // [sp-30h] [bp-120h] BYREF
  int v53; // [sp-2Ch] [bp-11Ch]
  int v54; // [sp-28h] [bp-118h]
  int v55; // [sp-24h] [bp-114h] BYREF
  int v56; // [sp-20h] [bp-110h] BYREF
  int v57; // [sp-1Ch] [bp-10Ch]
  int v58; // [sp-18h] [bp-108h]
  int v59; // [sp-14h] [bp-104h]
  int v60; // [sp-10h] [bp-100h] BYREF
  unsigned __int8 *v61; // [sp-Ch] [bp-FCh]

  v60 = 255;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  if ( !a1 || *(_BYTE *)(a1 + 2) != 35 )
LABEL_5:
    __asm { POP.W           {R4-R11,PC} }
  sub_80052C4("### [BLE] Recv cmd: %#x\r\n", *(unsigned __int8 *)(a1 + 3));
  v14 = sub_8007280(a1, *(unsigned __int8 *)(a1 + 1) - 1);
  v15 = *(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 1);
  if ( v15 != v14 )
  {
    sub_80052C4("### [BLE] Data crc error: %#x, %#x.\r\n", v14, v15);
    goto LABEL_5;
  }
  word_200037E1 = 0;
  byte_200037D8 = 1;
  v16 = *(unsigned __int8 *)(a1 + 3);
  v61 = (unsigned __int8 *)&byte_2000415F;
  switch ( v16 )
  {
    case 2:
      v55 = 0;
      sub_80052C4("[BLE] Get server type: %d.\r\n", *(unsigned __int8 *)(a1 + 4));
      v17 = *(unsigned __int8 *)(a1 + 4);
      if ( !*(_BYTE *)(a1 + 4) || v17 == 1 || v17 == 2 )
      {
        sub_80057C4(0x441u, (int)&v55, 1);
        if ( *(unsigned __int8 *)(a1 + 4) != (unsigned __int8)v55 || (unsigned __int8)v55 == 255 )
        {
          byte_2000303B = *(_BYTE *)(a1 + 4);
          sub_800591C(0x441u, &byte_2000303B, 1u);
        }
      }
      else
      {
        byte_2000303B = 0;
      }
      sub_80052C4("[BLE] Set server type: %d.\r\n", (unsigned __int8)byte_2000303B);
      goto LABEL_5;
    case 3:
      sub_80052C4((const char *)sub_8006494, 2500, &byte_2000050B, 516);
      sub_800795C();
      sub_800729C(3, (unsigned int)&word_2000409D, 0x65u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 4:
      sub_8002364(v50, 152);
      sub_800FD78();
      sub_80052C4((const char *)&loc_80064B4);
      v18 = sprintf((int)v50, (const char *)&loc_80064D4);
      sub_800729C(4, (unsigned int)v50, v18);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      sub_80052C4(
        loc_800650C,
        &dword_20003A0B,
        byte_200038E3,
        &unk_20004152,
        *(unsigned __int16 *)(loc_80064D0 + 0x2A),
        *(unsigned __int8 *)(loc_80064CC + 6),
        &dword_200038FD);
      goto LABEL_5;
    case 5:
      sub_80074A8((unsigned __int8 *)a1);
      goto LABEL_5;
    case 6:
      sub_80052C4((const char *)&loc_8006510, *(unsigned __int8 *)(a1 + 4), &byte_2000050B, 516);
      v19 = *(unsigned __int8 *)(a1 + 4);
      if ( v19 == 1 )
      {
        sub_8007C0C(1);
      }
      else if ( v19 == 2 )
      {
        sub_8007C0C(2);
      }
      goto LABEL_5;
    case 8:
      sub_80052C4((const char *)&loc_800652C, (unsigned __int8)byte_20000930, byte_20002FDB, 516);
      if ( byte_20000930 )
      {
        v20 = sub_80023E2((unsigned __int8 *)byte_20002FDB);
        sub_800729C(8, (unsigned int)byte_20002FDB, (unsigned int)v20);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
      }
      goto LABEL_5;
    case 9:
      sub_80052C4((const char *)&loc_8006568, *(unsigned __int8 *)(a1 + 4), &byte_2000050B, 516);
      v21 = *(unsigned __int8 *)(a1 + 4);
      if ( *(_BYTE *)(a1 + 4) )
      {
        if ( v21 == 1 )
        {
          byte_20002F60 = 1;
          v22 = *(unsigned __int8 *)(a1 + 5);
          if ( v22 < 0xA )
          {
            v23 = &byte_20002F5F[10 * v22];
            *((_WORD *)v23 + 3) = _byteswap_ushort(*(_WORD *)(a1 + 6));
            *((_WORD *)v23 + 4) = _byteswap_ushort(*(_WORD *)(a1 + 8));
            v23[2] = *(_BYTE *)(a1 + 10);
            *((_WORD *)v23 + 2) = *(unsigned __int8 *)(a1 + 11) | (*(unsigned __int8 *)(a1 + 12) << 8);
            v23[3] = *(_BYTE *)(a1 + 13);
            sub_80058E0(v22);
            sub_80052C4(
              loc_8006594,
              v22,
              *(unsigned __int8 *)(a1 + 6),
              *(unsigned __int8 *)(a1 + 7),
              *(unsigned __int8 *)(a1 + 8),
              *(unsigned __int8 *)(a1 + 9),
              (unsigned __int8)v23[2],
              *((__int16 *)v23 + 2),
              (unsigned __int8)v23[3]);
          }
        }
        else if ( v21 == 5 )
        {
          byte_20002F60 = 5;
          byte_200015A6 = 1;
          sub_80052C4((const char *)&loc_8006598, *(unsigned __int8 *)(a1 + 5));
        }
      }
      else
      {
        byte_20002F60 = *(_BYTE *)(a1 + 4);
      }
      sub_800729C(9, (unsigned int)&byte_20002F60, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      sub_800591C(0x301u, &byte_20002F60, 1u);
      goto LABEL_5;
    case 10:
      sub_80052C4((const char *)&loc_80065C8, 2500, &byte_2000050B, 516);
      sub_80078B0();
      sub_800729C(10, (unsigned int)&unk_20004102, 0x50u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 11:
      LOWORD(v54) = (*(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8)) - 2000;
      HIWORD(v54) = *(_WORD *)(a1 + 6);
      *(_WORD *)((char *)&v55 + 1) = *(_WORD *)(a1 + 8);
      v24 = *(unsigned __int8 *)(a1 + 10);
      HIBYTE(v55) = v24;
      sub_80052C4(loc_80065E0, (unsigned __int16)v54, BYTE2(v54), HIBYTE(v54), BYTE1(v55), BYTE2(v55), v24);
      sub_802085C((unsigned __int8)v54, BYTE2(v54), HIBYTE(v54));
      sub_8020888(BYTE1(v55), BYTE2(v55), v24);
      sub_8010328((int)&v52);
      sub_800729C(11, (unsigned int)&v52, 8u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 12:
      if ( *(_BYTE *)(a1 + 4) == 10 && *(_BYTE *)(a1 + 5) == 11 && *(_BYTE *)(a1 + 6) == 12 )
      {
        v25 = *(unsigned __int8 *)(a1 + 7);
        sub_80052C4((const char *)&loc_80065E4, v25, &byte_2000050B, 516);
        if ( v25 )
        {
          if ( v25 == 1 )
          {
            sub_80031E4();
            sub_801F610(v27);
            sub_801EA00();
          }
          if ( v25 == 2 )
          {
            sub_8007B28();
            sub_80031E4();
            sub_801F610(v26);
            sub_801EA00();
          }
        }
        else
        {
          sub_80080B4(0);
        }
      }
      goto LABEL_5;
    case 13:
      sub_80052C4((const char *)&loc_8006608, 2500, &byte_2000050B, 516);
      sub_8007B70();
      sub_800729C(13, loc_8006624, 0x13u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 14:
      JUMPOUT(0x8006628);
    case 15:
      if ( *(_BYTE *)(a1 + 4) == 1 )
      {
        sub_80052C4("[BLE] Setting eps enable.\r\n", 2500, &byte_2000050B, 516);
        sub_80031EE();
      }
      else if ( !*(_BYTE *)(a1 + 4) )
      {
        sub_80052C4("[BLE] Setting eps disable.\r\n", 2500, &byte_2000050B, 516);
        sub_80031EE();
      }
      sub_800729C(15, (unsigned int)byte_20002F5F, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 16:
      if ( *(_BYTE *)(a1 + 4) == 10 && *(_BYTE *)(a1 + 5) == 11 && *(_BYTE *)(a1 + 6) == 12 && byte_20000930 )
      {
        if ( !*(_BYTE *)(a1 + 7) )
          sub_8007C20(0);
        if ( *(_BYTE *)(a1 + 7) == 1 )
          sub_8007C20(1);
      }
      goto LABEL_156;
    case 17:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_156;
      sub_8008028();
      v28 = sub_80023E2((unsigned __int8 *)&dword_200038FD);
      sub_800729C(17, (unsigned int)&dword_200038FD, (unsigned int)v28);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 18:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_156;
      sub_8007B28();
      goto LABEL_5;
    case 19:
      sub_80052C4("[BLE] Getting err code info.\r\n", 2500, &byte_2000050B, 516);
      sub_800729C(19, (unsigned int)&dword_20003D81, 0x118u);
      sub_80052C4("[BLE] err info len = %d, tx len = %d.\r\n", 280, (unsigned __int8)byte_20004160);
      sub_8007710(v61, 285);
      goto LABEL_5;
    case 20:
      sub_80052C4("[BLE] Getting bms data info.\r\n", 2500, &byte_2000050B, 516);
      sub_8007A98();
      sub_800729C(20, (unsigned int)&word_20003F4D, 0x50u);
      sub_80052C4("[BLE] bms info len = %d, tx len = %d.\r\n", 80, (unsigned __int8)byte_20004160);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 21:
      v29 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( byte_2000050B == 2 )
      {
        sub_800729C(21, (unsigned int)&byte_2000050B, 1u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
      }
      else if ( v29 == 800 )
      {
        byte_2000050B = 1;
        word_2000051A = 800;
        sub_800591C(0x204u, &word_2000051A, 2u);
        sub_800591C(0x90u, &byte_2000050B, 1u);
        sub_800729C(21, (unsigned int)&byte_2000050B, 1u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
        sub_800E860();
      }
      else if ( v29 == 2500 )
      {
        byte_2000050B = 0;
        word_2000051A = 2500;
        sub_800591C(0x204u, &word_2000051A, 2u);
        sub_800591C(0x90u, &byte_2000050B, 1u);
        sub_800729C(21, (unsigned int)&byte_2000050B, 1u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
      }
      sub_80052C4(".\r\n[HTTP] AC wifi strength: %d.\r\n", v29);
      goto LABEL_5;
    case 22:
      v30 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( v30 <= 0x9C4 )
      {
        word_20000518 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
        sub_800591C(0x202u, &word_20000518, 2u);
        sub_800729C(22, (unsigned int)&word_20000518, 2u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
      }
      sub_80052C4(
        " power1: %d, power2: %d, power3: %d.\r\n[HTTP] P1 wifi strength: %d, AC wifi strength: %d.\r\n",
        v30,
        *(unsigned __int8 *)(a1 + 4),
        *(unsigned __int8 *)(a1 + 5),
        (unsigned __int16)word_20000518,
        v49);
      goto LABEL_5;
    case 23:
      v31 = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
      if ( v31 > 0x9C4 )
        goto LABEL_86;
      if ( byte_2000050B != 1 || v31 <= 0x320 )
      {
        word_2000051A = *(unsigned __int8 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 5) << 8);
        sub_800591C(0x204u, &word_2000051A, 2u);
        sub_800729C(23, (unsigned int)&word_2000051A, 2u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
LABEL_86:
        sub_80052C4(
          "\r\n",
          v31,
          *(unsigned __int8 *)(a1 + 4),
          *(unsigned __int8 *)(a1 + 5),
          (unsigned __int16)word_2000051A);
      }
      goto LABEL_5;
    case 24:
      v32 = *(unsigned __int8 *)(a1 + 4);
      v60 = v32;
      if ( (unsigned __int8)byte_20002FD1 != v32 && v32 < 8 )
      {
        sub_80191AC();
        byte_20002FD1 = v60;
        byte_200015DE = 1;
      }
      if ( byte_20002FD1 == 2 )
      {
        byte_200015AC = 1;
        byte_200015AD = 0;
      }
      else if ( byte_20002FD1 == 7 )
      {
        byte_200015AD = 1;
        byte_200015AC = 0;
      }
      else
      {
        byte_200015AC = 0;
        byte_200015AD = 0;
      }
      byte_200015AE = 0;
      v34 = *(_DWORD *)(a1 + 5);
      v33 = a1 + 5;
      v56 = v34;
      v57 = *(_DWORD *)(v33 + 4);
      v58 = *(_DWORD *)(v33 + 8);
      if ( sub_80023F0((int)&v56, (int)&dword_20004361) )
      {
        dword_20004361 = v56;
        dword_20004365 = v57;
        dword_20004369 = v58;
        sub_80191AC();
      }
      goto LABEL_5;
    case 25:
      v35 = *(unsigned __int8 *)(a1 + 4);
      v60 = v35;
      if ( (unsigned __int8)byte_20002FD0 != v35 && v35 <= 1 )
      {
        sub_8005BB0(v35);
        sub_80191AC();
      }
      goto LABEL_5;
    case 26:
      v55 = (int)flt_200027A4;
      sub_8002364(v51, 20);
      v51[0] = dword_20002EC4;
      v51[1] = dword_20002EC8;
      v52 = dword_20002ECC;
      v53 = dword_20002ED0;
      LOWORD(v54) = v55;
      sub_800729C(26, (unsigned int)v51, 0x12u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_5;
    case 27:
      v55 = 0;
      v36 = *(unsigned __int8 *)(a1 + 4);
      if ( v36 == 170 )
      {
        if ( byte_20000930 )
        {
          v55 = 1;
          sub_800729C(27, (unsigned int)&v55, 1u);
          sub_8007710(v61, (unsigned __int8)byte_20004160);
          if ( sub_8007430(a1, 0) )
          {
            v39 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000390A);
            sub_8007DE0(byte_2000390A, v39, 0);
          }
        }
      }
      else if ( v36 == 10 )
      {
        if ( byte_20000930 )
        {
          v55 = 1;
          sub_800729C(27, (unsigned int)&v55, 1u);
          sub_8007710(v61, (unsigned __int8)byte_20004160);
          v37 = (unsigned __int16)(*(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 3)
                                 + (*(unsigned __int8 *)(*(unsigned __int8 *)(a1 + 1) + a1 - 2) << 8));
          sub_80052C4("[BLE] Set url port = %d.\r\n", v37);
          if ( sub_8007430(a1, 1) )
          {
            v38 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_2000390A);
            sub_8007DE0(byte_2000390A, v38, v37);
          }
        }
      }
      goto LABEL_5;
    case 28:
      sub_80052C4("[BLE] Getting event log info.\r\n", 2500, &byte_2000050B, 516);
      sub_800729C(28, (unsigned int)byte_20003E99, 0xB4u);
      sub_80052C4("[BLE] event info len = %d, tx len = %d.\r\n", 180, (unsigned __int8)byte_20004160);
      sub_8007710(v61, 185);
      goto LABEL_5;
    case 29:
      sub_80191AC();
      goto LABEL_5;
    case 30:
      v40 = *(unsigned __int8 *)(a1 + 4);
      v60 = v40;
      sub_8005AA4(v40);
      goto LABEL_5;
    case 31:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_5;
      sub_80052C4("[BLE] Info active upgrade.\r\n", 2500, &byte_2000050B, 516);
      byte_200015A7 = 1;
      sub_800729C(31, (unsigned int)&byte_200015A7, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    case 32:
      if ( *(_BYTE *)(a1 + 4) != 10 || *(_BYTE *)(a1 + 5) != 11 || *(_BYTE *)(a1 + 6) != 12 )
        goto LABEL_156;
      v41 = *(unsigned __int8 *)(a1 + 7);
      sub_80052C4("[BLE] Setting parallel machine, enable = %d.\r\n", v41);
      switch ( v41 )
      {
        case 2:
          if ( byte_20002FD3 != 1 )
          {
            sub_80052C4("[BLE] !!! Parallel machine not ready.\r\n");
            sub_800729C(32, (unsigned int)&byte_20002FD3, 1u);
            sub_8007710(v61, (unsigned __int8)byte_20004160);
            goto LABEL_156;
          }
          sub_80052C4("[BLE] Parallel machine ON.\r\n");
          sub_80031F8();
          break;
        case 1:
          sub_80052C4("[BLE] Parallel machine Ready.\r\n");
          sub_80031F8();
          break;
        case 0:
          if ( byte_20002FD3 != 1 )
          {
            sub_80052C4("[BLE] !!! Parallel machine Not ready.\r\n");
            sub_800729C(32, (unsigned int)&byte_20002FD3, 1u);
            sub_8007710(v61, (unsigned __int8)byte_20004160);
            goto LABEL_156;
          }
          sub_80052C4("[BLE] Parallel machine OFF.\r\n");
          sub_80031F8();
          break;
      }
      sub_800729C(32, (unsigned int)&byte_20002FD3, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
LABEL_156:
      JUMPOUT(0x8006658);
    case 33:
      v52 = 0;
      v53 = 0;
      v54 = 0;
      v55 = 0;
      v42 = *(unsigned __int8 *)(a1 + 4);
      if ( v42 == 10 )
      {
        v43 = (unsigned __int8 *)(a1 + 5);
        v44 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 6);
        if ( v44 < 0x10 )
        {
          sub_8002364(byte_20003A13, 16);
          sub_80023B6(byte_20003A13, v43, v44);
          sub_80052C4("[BLE] Receive ip_len = %d, meter_ip: %s.\r\n", v44, byte_20003A13);
          byte_200037D4[v44 + 575] = 0;
          sub_80057C4(0x3500u, (int)&v52, 16);
          if ( sub_80023F0((int)byte_20003A13, (int)&v52) )
          {
            sub_80052C4("[BLE] *** Receive ip: %s, read ip: %s.\r\n", byte_20003A13, (const char *)&v52);
            sub_800591C(0x3500u, byte_20003A13, 0x10u);
          }
          sub_800729C(33, (unsigned int)byte_20003A13, 0x10u);
          sub_8007710(v61, (unsigned __int8)byte_20004160);
        }
        else
        {
          sub_80052C4("[BLE] !!! IP len is too long.\r\n", 2500, &byte_2000050B, 516);
        }
      }
      else if ( v42 == 11 )
      {
        sub_80057C4(0x3500u, (int)byte_20003A13, 16);
        sub_80052C4("[BLE] Read ip: %s.\r\n", byte_20003A13);
        sub_800729C(33, (unsigned int)byte_20003A13, 0x10u);
        sub_8007710(v61, (unsigned __int8)byte_20004160);
      }
      goto LABEL_156;
    case 34:
      v45 = *(unsigned __int8 *)(a1 + 4);
      v60 = v45;
      sub_8005A54(v45);
      sub_800729C(34, (unsigned int)&v60, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    case 35:
      if ( *(_BYTE *)(a1 + 4) == 1 )
      {
        sub_80052C4("[BLE] Setting generator enable.\r\n", 2500, &byte_2000050B, 516);
        byte_20002FD5 = 1;
      }
      else if ( !*(_BYTE *)(a1 + 4) )
      {
        sub_80052C4("[BLE] Setting generator disable.\r\n", 2500, &byte_2000050B, 516);
        byte_20002FD5 = 0;
      }
      sub_800729C(15, (unsigned int)&byte_20002FD5, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    case 36:
      v46 = sub_80023E2((unsigned __int8 *)byte_200112A8);
      sub_800729C(36, (unsigned int)byte_200112A8, (unsigned int)(v46 + 1));
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    case 37:
      v47 = _byteswap_ushort(*(_WORD *)(a1 + 4));
      v55 = *(unsigned __int8 *)(a1 + 5) | (*(unsigned __int8 *)(a1 + 4) << 8);
      sub_8005BCC(v47);
      sub_800729C(37, (unsigned int)&v55, 2u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    case 38:
      v48 = *(unsigned __int8 *)(a1 + 4);
      v60 = v48;
      sub_8005A84(v48);
      sub_800729C(38, (unsigned int)&v60, 1u);
      sub_8007710(v61, (unsigned __int8)byte_20004160);
      goto LABEL_156;
    default:
      goto LABEL_5;
  }
}
// 800604E: positive sp value CC has been found
// 80063E8: control flows out of bounds to 8006628
// 80066B4: control flows out of bounds to 8006658
// 80063A2: variable 'v26' is possibly undefined
// 80063C0: variable 'v27' is possibly undefined
// 8006862: variable 'v49' is possibly undefined
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8006494: using guessed type int sub_8006494();
// 801F610: using guessed type int __fastcall sub_801F610(_DWORD);
// 2000050B: using guessed type char byte_2000050B;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 20000930: using guessed type char byte_20000930;
// 200015A6: using guessed type char byte_200015A6;
// 200015A7: using guessed type char byte_200015A7;
// 200015AC: using guessed type char byte_200015AC;
// 200015AD: using guessed type char byte_200015AD;
// 200015AE: using guessed type char byte_200015AE;
// 200015DE: using guessed type char byte_200015DE;
// 200027A4: using guessed type float flt_200027A4;
// 20002EC4: using guessed type int dword_20002EC4;
// 20002EC8: using guessed type int dword_20002EC8;
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FD3: using guessed type char byte_20002FD3;
// 20002FD5: using guessed type char byte_20002FD5;
// 2000303B: using guessed type char byte_2000303B;
// 200037D8: using guessed type char byte_200037D8;
// 200037E1: using guessed type __int16 word_200037E1;
// 200038FD: using guessed type int dword_200038FD;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003D81: using guessed type int dword_20003D81;
// 20003E99: using guessed type _BYTE byte_20003E99[180];
// 20003F4D: using guessed type __int16 word_20003F4D;
// 2000409D: using guessed type __int16 word_2000409D;
// 2000415F: using guessed type char byte_2000415F;
// 20004160: using guessed type char byte_20004160;
// 20004361: using guessed type int dword_20004361;
// 20004365: using guessed type int dword_20004365;
// 20004369: using guessed type int dword_20004369;

//----- (08006498) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall IRQ_86_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4
  unsigned int v14; // r5
  int v15; // r6
  int v16; // r7
  char v17; // r8
  int v18; // r7
  unsigned int v19; // r1
  unsigned int v20; // r6
  int v21; // r4
  int v22; // r3
  int v23; // r4
  int v24; // r3
  int v25; // r3
  int v26; // r6
  int v27; // r4
  int v28; // r6
  unsigned int v29; // r1
  unsigned int v30; // r5
  int v31; // r3
  int v32; // r0
  unsigned int v33; // r6
  int v34; // r3
  int v35; // r7
  int v36; // r5
  int v37; // r4
  unsigned int v38; // r5
  int v39; // r3
  unsigned int v40; // r1
  unsigned int v41; // r6
  int v42; // r4
  int v43; // r4
  unsigned int v44; // r5
  unsigned __int8 *v45; // [sp-Ch] [bp-Ch]

  MEMORY[0xB1] = v16;
  v18 = *(_DWORD *)(v15 + 116);
  *(_BYTE *)(v13 + 12) = 116;
  *(_DWORD *)(v15 + 20) = v13;
  *(_BYTE *)(v15 + 21) = v13;
  MEMORY[0xB1] = v18;
  v19 = *(_DWORD *)(v14 + 100);
  v20 = v14 >> 20;
  v21 = *(unsigned __int8 *)((v14 >> 20) + 5);
  *(_DWORD *)((v14 >> 20) + 0x54) = 0;
  MEMORY[0x81] = v19;
  MEMORY[0x51] = 61;
  *(_BYTE *)(v21 + 12) = -38;
  MEMORY[0x1A] = v21;
  *(_BYTE *)(v21 + 25) = -38;
  *(_BYTE *)(25 - a4) = v18;
  *(_BYTE *)(v21 + 9) = -38;
  *(_DWORD *)((v14 >> 20) + 0x54) = v14 >> 20;
  *(_DWORD *)(v21 + 64) = -53;
  MEMORY[0x2B] = v21;
  v22 = *(__int16 *)(v21 - 53);
  *(_DWORD *)((v14 >> 20) + 0x54) = v14 >> 20;
  *(_BYTE *)(v21 + 12) = 89;
  v23 = *(unsigned __int16 *)(v21 + 10);
  v24 = -v22;
  MEMORY[0x71] = v14 >> 20;
  *(_BYTE *)(v23 + 17) = v24;
  MEMORY[0xFFFFFF62] = v18;
  *(_DWORD *)(v20 + 84) = 0;
  *(_DWORD *)(v20 + 84) = v24;
  MEMORY[0xFFFFFFE0] = -116;
  *(_DWORD *)(v23 + 68) = v19;
  *(_BYTE *)(v23 + 28) = 93;
  *(_DWORD *)((v19 >> 8) + 0x64) = v19;
  *(_DWORD *)((v19 >> 8) + 0x14) = v14 >> 20;
  *(_DWORD *)((v19 >> 8) + 0x54) = v19 >> 8;
  v25 = *(_DWORD *)(v23 + 116);
  v26 = *(_DWORD *)((v19 >> 8) + 0x64);
  *(_DWORD *)(v23 + 52) = v19 >> 8;
  v27 = *(__int16 *)(v26 + (v19 >> 8));
  v28 = *(_DWORD *)(v27 + 0x44);
  *(_DWORD *)(v27 + 116) = v19;
  *(_BYTE *)(v27 + 28) = 44;
  MEMORY[0x84] = v19;
  v29 = MEMORY[0x40];
  MEMORY[0x34] = v28;
  MEMORY[0x74] = 32;
  v30 = (unsigned int)MEMORY[0x40] >> 8;
  v31 = -v25;
  MEMORY[0xFFFFFFE0] = v31;
  v32 = *(_DWORD *)(v27 + 80);
  *(_DWORD *)(v30 + 0x44) = *(_DWORD *)(v28 + 116);
  *(_BYTE *)(v27 + 20) = v32;
  *(_DWORD *)(v28 + 84) = v31;
  *(_DWORD *)(v30 + 68) = *(_DWORD *)(v31 + 84);
  *(_DWORD *)(v27 + 64) = v30;
  v33 = v30 >> 20;
  *(_WORD *)(v29 + 62) = v27;
  v34 = -v31;
  MEMORY[0x54] = v34;
  *(_DWORD *)(v27 + 52) = v30;
  v35 = *(_DWORD *)(v30 + 84);
  v36 = *(_DWORD *)(v30 + 116);
  *(_DWORD *)(v27 + 84) = v27;
  *(_BYTE *)(v27 + 21) = v34;
  *(_BYTE *)(v33 + 9) = 44;
  *(_BYTE *)(v36 + 17) = v35;
  *(_DWORD *)(v27 + 52) = v36;
  v37 = *(__int16 *)(v33 + v36);
  v38 = v29 >> 8;
  v39 = -v34;
  MEMORY[0xB1] = v35;
  *(_DWORD *)(v33 + 84) = v39;
  v40 = *(_DWORD *)((v29 >> 8) + 0x64);
  v41 = v38 >> 20;
  *(_WORD *)(v35 + 58) = 116;
  MEMORY[0x54] = -v39;
  *(_DWORD *)(v37 + 84) = v37;
  *(_DWORD *)((v38 >> 20) + 0x54) = v38 >> 20;
  v42 = *(_DWORD *)(v38 + 116);
  *(_DWORD *)(v42 + 84) = v42;
  MEMORY[0xB1] = v42;
  *(_DWORD *)((v38 >> 20) + 0x54) = v38 >> 20;
  v43 = *(_DWORD *)((v40 >> 8) + 0x74);
  *(_DWORD *)(v43 + 84) = v43;
  *(_DWORD *)(v43 + 100) = v38 >> 20;
  v44 = v40 >> 8;
  sub_80052C4("[BLE] Setting work mode auto change, en = %d.\r\n", v40);
  if ( *(_BYTE *)(v43 - 34) == 1 )
  {
    *(_BYTE *)(v41 + 112) = v17;
    if ( byte_200015E6 == 1 )
    {
      *(_BYTE *)(v41 + 1) = v35;
    }
    else if ( !byte_200015E6 || byte_200015E6 == 2 )
    {
      *(_BYTE *)(v41 + 1) = v17;
    }
  }
  else
  {
    *(_BYTE *)(v41 + 112) = v35;
  }
  sub_800591C(0x370u, &byte_20002FCF, 1u);
  sub_800729C(14, (unsigned int)&byte_20002FCF, 1u);
  sub_8007710(v45, *(unsigned __int8 *)(v44 + 14));
  __asm { POP.W           {R4-R11,PC} }
}
// 800604E: positive sp value CC has been found
// 800649A: variable 'v16' is possibly undefined
// 800649E: variable 'v15' is possibly undefined
// 80064A2: variable 'v13' is possibly undefined
// 80064C2: variable 'v14' is possibly undefined
// 8006654: variable 'v45' is possibly undefined
// 800665A: variable 'v17' is possibly undefined
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200015E6: using guessed type char byte_200015E6;
// 20002FCF: using guessed type char byte_20002FCF;

//----- (08007038) --------------------------------------------------------
int sub_8007038()
{
  int result; // r0
  unsigned __int8 *v1; // r0
  bool v2; // zf
  int v3; // r1
  int v4; // r1
  int v5; // r1
  int v6; // r1

  if ( byte_20004360 )
    return 1;
  if ( (unsigned __int8)byte_20000911 > 5u )
  {
    byte_20000911 = 0;
    byte_20000910 = 11;
  }
  switch ( byte_20000910 )
  {
    case 0:
      if ( sub_80075BC() )
      {
        v1 = strstr((unsigned __int8 *)byte_20003A24, "+QBLEADDR:");
        if ( !v1 )
          goto LABEL_49;
        v2 = v1[12] == 58;
        while ( 1 )
        {
          if ( !v2 )
            goto LABEL_49;
          v3 = v1[15];
          v2 = v3 == 58;
          if ( v3 == 58 )
          {
            v4 = v1[18];
            v2 = v4 == 58;
            if ( v4 == 58 )
            {
              v5 = v1[21];
              v2 = v5 == 58;
              if ( v5 == 58 )
              {
                v6 = v1[24];
                v2 = v6 == 58;
                if ( v6 == 58 )
                  break;
              }
            }
          }
        }
        sprintf(
          (int)&unk_20004152,
          "%c%c%c%c%c%c%c%c%c%c%c%c",
          v1[10],
          v1[11],
          v1[13],
          v1[14],
          v1[16],
          v1[17],
          v1[19],
          v1[20],
          v1[22],
          v1[23],
          v1[25],
          v1[26]);
        byte_2000415E = 0;
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 1:
      if ( sub_8007560(2) )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 2:
      if ( sub_80076A8() )
      {
        byte_20000910 = 4;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000910;
      }
      goto LABEL_49;
    case 3:
      if ( sub_8007608() )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 4:
      if ( sub_80077E0("ff00") )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 5:
      if ( sub_80078F8("ff01") )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 6:
      if ( sub_80078F8("ff02") )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 7:
      if ( sub_80078F8("ff06") )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 8:
      if ( sub_8005F98(150, 150) )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 9:
      if ( sub_8005F24(1) )
      {
        ++byte_20000910;
        byte_20000911 = 0;
      }
      else
      {
        ++byte_20000911;
      }
      goto LABEL_49;
    case 10:
      if ( sub_80072DC() )
      {
        byte_20004360 = 1;
        sub_8008028();
        sub_800FD78();
        byte_20000910 = 0;
        byte_20000911 = 0;
        result = 1;
      }
      else
      {
        ++byte_20000911;
LABEL_49:
        result = 0;
      }
      break;
    case 11:
      byte_20000910 = 0;
      byte_20004360 = 0;
      sub_80052C4("Please check ble!\r\n");
      sub_8018F5C(4, 406);
      sub_80080B4(0);
      goto LABEL_49;
    default:
      goto LABEL_49;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20000910: using guessed type char byte_20000910;
// 20000911: using guessed type char byte_20000911;
// 2000415E: using guessed type char byte_2000415E;
// 20004360: using guessed type char byte_20004360;

//----- (08007280) --------------------------------------------------------
int __fastcall sub_8007280(int a1, int a2)
{
  int v3; // r2
  int result; // r0

  v3 = 0;
  result = 0;
  if ( a1 )
  {
    while ( v3 < a2 )
      result ^= *(unsigned __int8 *)(a1 + v3++);
  }
  return result;
}

//----- (0800729C) --------------------------------------------------------
int __fastcall sub_800729C(int result, unsigned int a2, unsigned int a3)
{
  if ( a2 )
  {
    if ( a3 < 0x1FC )
    {
      byte_2000415F = 115;
      byte_20004160 = a3 + 5;
      byte_20004161 = 35;
      byte_20004162 = result;
      qmemcpy((unsigned int)&unk_20004163, a2, a3);
      result = sub_8007280((int)&byte_2000415F, (unsigned __int8)byte_20004160 - 1);
      *((_BYTE *)&unk_20004152 + a3 + 17) = result;
    }
  }
  return result;
}
// 2000415F: using guessed type char byte_2000415F;
// 20004160: using guessed type char byte_20004160;
// 20004161: using guessed type char byte_20004161;
// 20004162: using guessed type char byte_20004162;

//----- (080072DC) --------------------------------------------------------
int sub_80072DC()
{
  unsigned __int8 i; // r4
  int result; // r0

  for ( i = 0; i < 9u; ++i )
  {
    if ( byte_200037D6 == 1 || byte_2000435F == 1 )
    {
      sub_80052C4("[BLE] Wait for urc or set wifi, don't check ble state!\r\n");
      return 1;
    }
    if ( sub_800DFB4("AT+QBLESTAT", "+QBLESTAT:", 0, 600) )
    {
      if ( strstr((unsigned __int8 *)byte_20003A24, "+QBLESTAT:ADVERTISING") )
      {
        result = 1;
        byte_20004360 = 1;
        return result;
      }
      if ( strstr((unsigned __int8 *)byte_20003A24, "+QBLESTAT:CONNECTED") )
      {
        byte_20004360 = 2;
        return 1;
      }
      if ( strstr((unsigned __int8 *)byte_20003A24, "+QBLESTAT:DISCONNECTED") )
      {
        byte_20004360 = 3;
        return 1;
      }
    }
    sub_8023A34(500);
  }
  sub_80052C4("[BLE] State disnormal!\r\n");
  result = 0;
  byte_20004360 = 0;
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200037D6: using guessed type char byte_200037D6;
// 2000435F: using guessed type char byte_2000435F;
// 20004360: using guessed type char byte_20004360;

//----- (08007430) --------------------------------------------------------
int __fastcall sub_8007430(int a1, int a2)
{
  unsigned int v2; // r5
  unsigned int v3; // r4

  if ( !a1 )
    return 0;
  v2 = a1 + 5;
  if ( a2 == 1 )
    v3 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 8);
  else
    v3 = (unsigned __int8)(*(_BYTE *)(a1 + 1) - 6);
  if ( v3 >= 0xFF )
    return 0;
  sub_8002364(byte_2000390A, 256);
  qmemcpy((unsigned int)byte_2000390A, v2, v3);
  sub_80052C4("Receive ota url: %s, url_len = %d.\r\n", byte_2000390A, v3);
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);

//----- (080074A8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_80074A8(unsigned __int8 *result)
{
  unsigned __int8 *v1; // r4
  unsigned int v2; // r7
  unsigned __int8 *v3; // r0
  unsigned int v4; // r6
  unsigned int v5; // r5
  unsigned int v6; // r4

  v1 = result;
  if ( result )
  {
    v2 = (unsigned int)(result + 4);
    v3 = strstr(result, "<.,.>");
    v4 = (unsigned __int8)((_BYTE)v3 - v2);
    v5 = (unsigned int)(v3 + 5);
    result = (unsigned __int8 *)(&v1[v1[1]] - (v3 + 5) - 1);
    v6 = (unsigned __int8)result;
    if ( v4 < 0x20 && (unsigned __int8)result < 0x40u )
    {
      sub_8002364(byte_20002FDB, 32);
      qmemcpy((unsigned int)byte_20002FDB, v2, v4);
      sub_8002364(byte_20002FFB, 64);
      qmemcpy((unsigned int)byte_20002FFB, v5, v6);
      byte_2000435F = 1;
      byte_20000931 = 0;
      byte_20000930 = 0;
      byte_200037D4[0] = 2;
      byte_200037D6 = 0;
      sub_80052C4("Waiting for wifi setting...\r\n");
      return sub_8004E5C();
    }
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 200037D6: using guessed type char byte_200037D6;
// 2000435F: using guessed type char byte_2000435F;

//----- (08007560) --------------------------------------------------------
int __fastcall sub_8007560(int a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  sprintf((int)v4, "AT+QBLEINIT=%d", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DFB4(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (080075BC) --------------------------------------------------------
int sub_80075BC()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DFB4("AT+QBLEADDR?", "+QBLEADDR:", (unsigned __int8 *)&dword_80075E8, 300) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  while ( v0 < 3 );
  return 0;
}
// 80075E8: using guessed type int dword_80075E8;

//----- (08007608) --------------------------------------------------------
int sub_8007608()
{
  unsigned int v0; // r4
  unsigned __int8 v2[76]; // [sp+Ch] [bp-4Ch] BYREF

  sub_8002364(v2, 64);
  v0 = 0;
  sprintf(
    (int)v2,
    "AT+QBLENAME=MST_ACCP_%c%c%c%c",
    (unsigned __int8)byte_2000415A,
    (unsigned __int8)byte_2000415B,
    (unsigned __int8)byte_2000415C,
    (unsigned __int8)byte_2000415D);
  while ( v0 < 3 )
  {
    if ( sub_800DFB4(v2, "OK", 0, 300) )
    {
      sub_800DFB4("AT+QBLENAME?", "+QBLENAME:", "OK", 300);
      return 1;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  return 0;
}
// 2000415A: using guessed type char byte_2000415A;
// 2000415B: using guessed type char byte_2000415B;
// 2000415C: using guessed type char byte_2000415C;
// 2000415D: using guessed type char byte_2000415D;

//----- (080076A8) --------------------------------------------------------
int sub_80076A8()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DFB4("AT+QBLENAME?", "+QBLENAME:", (unsigned __int8 *)&dword_80076E0, 300)
      && strstr((unsigned __int8 *)byte_20003A24, "MST_ACCP_") )
    {
      return 1;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  while ( v0 < 3 );
  return 0;
}
// 80076E0: using guessed type int dword_80076E0;

//----- (08007710) --------------------------------------------------------
_BYTE *__fastcall sub_8007710(unsigned __int8 *a1, int a2)
{
  _BYTE *result; // r0
  unsigned __int8 v5[80]; // [sp+0h] [bp-50h] BYREF

  result = sub_8002364(v5, 64);
  if ( a1 )
  {
    result = (_BYTE *)sub_80256C8(dword_20000458, 500);
    if ( result )
    {
      sprintf((int)v5, "AT+QBLEGATTSNTFY=ff02,%d,", a2);
      sub_800E77E(v5);
      sub_800823C(a1, (unsigned __int16)a2);
      sub_800E768((int)"\r\n", 2);
      return (_BYTE *)sub_8025188(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;

//----- (08007788) --------------------------------------------------------
_BYTE *__fastcall sub_8007788(unsigned __int8 *a1, int a2)
{
  _BYTE *result; // r0
  unsigned __int8 v5[76]; // [sp+4h] [bp-4Ch] BYREF

  result = sub_8002364(v5, 64);
  if ( a1 )
  {
    sprintf((int)v5, "AT+QBLEGATTSNTFY=ff02,%d,", a2);
    sub_800E77E(v5);
    sub_800823C(a1, (unsigned __int16)a2);
    return (_BYTE *)sub_800E768((int)"\r\n", 2);
  }
  return result;
}

//----- (080077E0) --------------------------------------------------------
int __fastcall sub_80077E0(const char *a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  if ( !a1 )
    return 0;
  sprintf((int)v4, "AT+QBLEGATTSSRV=%s", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DFB4(v4, "OK", 0, 600) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (08007844) --------------------------------------------------------
int sub_8007844()
{
  int result; // r0
  int v1; // r0

  result = (unsigned __int8)byte_200015B4;
  if ( byte_200015B4 && !byte_200037D7 )
  {
    result = (unsigned __int8)byte_200015B1;
    if ( !byte_200015B1 )
    {
      byte_200015B4 = byte_200015B1;
      sub_80031E4();
      sub_801F610(v1);
      sub_801EA00();
    }
  }
  else if ( byte_200037DC == 7 && !byte_200015B4 )
  {
    result = (unsigned __int8)byte_200037D6;
    if ( !byte_200037D6 )
    {
      result = sub_801B040(&word_20000912, 0x3Cu);
      if ( result )
        return sub_80072DC();
    }
  }
  return result;
}
// 8007890: variable 'v1' is possibly undefined
// 801F610: using guessed type int __fastcall sub_801F610(_DWORD);
// 20000912: using guessed type _WORD word_20000912;
// 200015B1: using guessed type char byte_200015B1;
// 200015B4: using guessed type char byte_200015B4;
// 200037D6: using guessed type char byte_200037D6;
// 200037D7: using guessed type char byte_200037D7;
// 200037DC: using guessed type char byte_200037DC;

//----- (080078B0) --------------------------------------------------------
char *sub_80078B0()
{
  unsigned int i; // r1
  char *v1; // r2
  char *result; // r0
  __int16 v3; // r3
  __int16 v4; // r3

  for ( i = 0; i < 0xA; i = (unsigned __int8)(i + 1) )
  {
    v1 = &byte_20002F5F[10 * i];
    result = (char *)&unk_20004102 + 8 * i;
    v3 = *((_WORD *)v1 + 3);
    result[1] = v3;
    *result = HIBYTE(v3);
    v4 = *((_WORD *)v1 + 4);
    result[3] = v4;
    result[2] = HIBYTE(v4);
    result[4] = v1[2];
    *(_WORD *)(result + 5) = *((_WORD *)v1 + 2);
    result[7] = v1[3];
  }
  return result;
}

//----- (080078F8) --------------------------------------------------------
int __fastcall sub_80078F8(const char *a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  if ( !a1 )
    return 0;
  sprintf((int)v4, "AT+QBLEGATTSCHAR=%s", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DFB4(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (0800795C) --------------------------------------------------------
int sub_800795C()
{
  int result; // r0

  sub_800F8E4();
  word_2000409D = word_20003C45;
  word_2000409F = word_20003C47;
  byte_200040A1 = byte_20003C39;
  byte_200040A2 = byte_20000930;
  byte_200040A3 = 1;
  byte_200040A4 = byte_20003C3A;
  byte_200040A5 = byte_20003C3B;
  word_200040A6 = word_20003C49;
  byte_200040A8 = byte_20003C3C;
  word_200040A9 = word_20003C43;
  dword_200040AB = dword_20003C63;
  dword_200040AF = dword_2000304C;
  dword_200040B3 = dword_20003C6B;
  dword_200040B7 = dword_20003C6F;
  dword_200040BB = dword_20003C7B;
  word_200040BF = word_20003C59;
  word_200040C1 = word_20003C5B;
  byte_200040C3 = byte_20003C3D;
  byte_200040C4 = byte_20003C3E;
  byte_200040C5 = byte_20003C3F;
  dword_200040C6 = dword_20003C7F;
  dword_200040CA = dword_20003C83;
  word_200040CE = word_20003C61;
  word_200040D0 = dword_20003C87;
  dword_200040D2 = dword_20003C8B;
  dword_200040D6 = dword_20003C8F;
  byte_200040DA = byte_20003C40;
  byte_200040DB = byte_20003C41;
  dword_200040DC = dword_20003C73;
  dword_200040E0 = dword_20003C77;
  byte_200040E4 = byte_20003C42;
  word_200040E5 = word_20003D38;
  word_200040E7 = word_20003D3A;
  byte_200040E9 = byte_200015E4;
  byte_200040EA = byte_200004AC;
  byte_200040EB = byte_20002FD0;
  word_200040EC = word_20003D44;
  byte_200040FB = byte_200004BB;
  qmemcpy((unsigned int)&unk_200040EE, (unsigned int)&dword_200038FD, 0xDu);
  byte_200040FC = sub_800FBCC();
  byte_200040FD = byte_20003D7F;
  byte_200040FE = byte_20003D80;
  byte_200040FF = (unsigned __int16)sub_8005494() >> 8;
  byte_20004100 = sub_8005494();
  result = (unsigned __int8)byte_20002FD9;
  byte_20004101 = byte_20002FD9;
  return result;
}
// 200004AC: using guessed type char byte_200004AC;
// 200004BB: using guessed type char byte_200004BB;
// 20000930: using guessed type char byte_20000930;
// 200015E4: using guessed type char byte_200015E4;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD9: using guessed type char byte_20002FD9;
// 2000304C: using guessed type int dword_2000304C;
// 200038FD: using guessed type int dword_200038FD;
// 20003C39: using guessed type char byte_20003C39;
// 20003C3A: using guessed type char byte_20003C3A;
// 20003C3B: using guessed type char byte_20003C3B;
// 20003C3C: using guessed type char byte_20003C3C;
// 20003C3D: using guessed type char byte_20003C3D;
// 20003C3E: using guessed type char byte_20003C3E;
// 20003C3F: using guessed type char byte_20003C3F;
// 20003C40: using guessed type char byte_20003C40;
// 20003C41: using guessed type char byte_20003C41;
// 20003C42: using guessed type char byte_20003C42;
// 20003C43: using guessed type __int16 word_20003C43;
// 20003C45: using guessed type __int16 word_20003C45;
// 20003C47: using guessed type __int16 word_20003C47;
// 20003C49: using guessed type __int16 word_20003C49;
// 20003C59: using guessed type __int16 word_20003C59;
// 20003C5B: using guessed type __int16 word_20003C5B;
// 20003C61: using guessed type __int16 word_20003C61;
// 20003C63: using guessed type int dword_20003C63;
// 20003C6B: using guessed type int dword_20003C6B;
// 20003C6F: using guessed type int dword_20003C6F;
// 20003C73: using guessed type int dword_20003C73;
// 20003C77: using guessed type int dword_20003C77;
// 20003C7B: using guessed type int dword_20003C7B;
// 20003C7F: using guessed type int dword_20003C7F;
// 20003C83: using guessed type int dword_20003C83;
// 20003C87: using guessed type int dword_20003C87;
// 20003C8B: using guessed type int dword_20003C8B;
// 20003C8F: using guessed type int dword_20003C8F;
// 20003D38: using guessed type __int16 word_20003D38;
// 20003D3A: using guessed type __int16 word_20003D3A;
// 20003D44: using guessed type __int16 word_20003D44;
// 20003D7F: using guessed type char byte_20003D7F;
// 20003D80: using guessed type char byte_20003D80;
// 2000409D: using guessed type __int16 word_2000409D;
// 2000409F: using guessed type __int16 word_2000409F;
// 200040A1: using guessed type char byte_200040A1;
// 200040A2: using guessed type char byte_200040A2;
// 200040A3: using guessed type char byte_200040A3;
// 200040A4: using guessed type char byte_200040A4;
// 200040A5: using guessed type char byte_200040A5;
// 200040A6: using guessed type __int16 word_200040A6;
// 200040A8: using guessed type char byte_200040A8;
// 200040A9: using guessed type __int16 word_200040A9;
// 200040AB: using guessed type int dword_200040AB;
// 200040AF: using guessed type int dword_200040AF;
// 200040B3: using guessed type int dword_200040B3;
// 200040B7: using guessed type int dword_200040B7;
// 200040BB: using guessed type int dword_200040BB;
// 200040BF: using guessed type __int16 word_200040BF;
// 200040C1: using guessed type __int16 word_200040C1;
// 200040C3: using guessed type char byte_200040C3;
// 200040C4: using guessed type char byte_200040C4;
// 200040C5: using guessed type char byte_200040C5;
// 200040C6: using guessed type int dword_200040C6;
// 200040CA: using guessed type int dword_200040CA;
// 200040CE: using guessed type __int16 word_200040CE;
// 200040D0: using guessed type __int16 word_200040D0;
// 200040D2: using guessed type int dword_200040D2;
// 200040D6: using guessed type int dword_200040D6;
// 200040DA: using guessed type char byte_200040DA;
// 200040DB: using guessed type char byte_200040DB;
// 200040DC: using guessed type int dword_200040DC;
// 200040E0: using guessed type int dword_200040E0;
// 200040E4: using guessed type char byte_200040E4;
// 200040E5: using guessed type __int16 word_200040E5;
// 200040E7: using guessed type __int16 word_200040E7;
// 200040E9: using guessed type char byte_200040E9;
// 200040EA: using guessed type char byte_200040EA;
// 200040EB: using guessed type char byte_200040EB;
// 200040EC: using guessed type __int16 word_200040EC;
// 200040FB: using guessed type char byte_200040FB;
// 200040FC: using guessed type char byte_200040FC;
// 200040FD: using guessed type char byte_200040FD;
// 200040FE: using guessed type char byte_200040FE;
// 200040FF: using guessed type char byte_200040FF;
// 20004100: using guessed type char byte_20004100;
// 20004101: using guessed type char byte_20004101;

//----- (08007A98) --------------------------------------------------------
unsigned int sub_8007A98()
{
  word_20003F4D = BYTE2(dword_20002E7E);
  dword_20003F4F = dword_20002E74;
  word_20003F53 = word_20002E78;
  dword_20003F55 = dword_20002E7A;
  word_20003F59 = dword_20002E7E;
  dword_20003F5B = dword_20002E82;
  word_20003F5F = word_20002E86;
  byte_20003F61 = dword_20002E90;
  byte_20003F62 = BYTE2(dword_20002E90);
  word_20003F63 = (unsigned __int16)dword_20002E7E * (unsigned __int16)dword_20002E7A / 1000;
  dword_20003F65 = dword_20002E88;
  dword_20003F69 = dword_20002E8C;
  dword_20003F6D = dword_20000474;
  word_20003F71 = *(_WORD *)((char *)&dword_20002E90 + 3);
  word_20003F73 = word_20002E95;
  dword_20003F75 = dword_20002E97;
  dword_20003F79 = dword_20002E9B;
  return qmemcpy((unsigned int)&word_20003F7D, (unsigned int)&dword_20002E9F, 0x20u);
}
// 20000474: using guessed type int dword_20000474;
// 20002E74: using guessed type int dword_20002E74;
// 20002E78: using guessed type __int16 word_20002E78;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002E7E: using guessed type int dword_20002E7E;
// 20002E82: using guessed type int dword_20002E82;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E88: using guessed type int dword_20002E88;
// 20002E8C: using guessed type int dword_20002E8C;
// 20002E90: using guessed type int dword_20002E90;
// 20002E95: using guessed type __int16 word_20002E95;
// 20002E97: using guessed type int dword_20002E97;
// 20002E9B: using guessed type int dword_20002E9B;
// 20002E9F: using guessed type int dword_20002E9F;
// 20003F4D: using guessed type __int16 word_20003F4D;
// 20003F4F: using guessed type int dword_20003F4F;
// 20003F53: using guessed type __int16 word_20003F53;
// 20003F55: using guessed type int dword_20003F55;
// 20003F59: using guessed type __int16 word_20003F59;
// 20003F5B: using guessed type int dword_20003F5B;
// 20003F5F: using guessed type __int16 word_20003F5F;
// 20003F61: using guessed type char byte_20003F61;
// 20003F62: using guessed type char byte_20003F62;
// 20003F63: using guessed type __int16 word_20003F63;
// 20003F65: using guessed type int dword_20003F65;
// 20003F69: using guessed type int dword_20003F69;
// 20003F6D: using guessed type int dword_20003F6D;
// 20003F71: using guessed type __int16 word_20003F71;
// 20003F73: using guessed type __int16 word_20003F73;
// 20003F75: using guessed type int dword_20003F75;
// 20003F79: using guessed type int dword_20003F79;
// 20003F7D: using guessed type __int16 word_20003F7D;

//----- (08007B1C) --------------------------------------------------------
BOOL sub_8007B1C()
{
  return sub_800E108(3, 0, 0);
}

//----- (08007B28) --------------------------------------------------------
int sub_8007B28()
{
  int result; // r0

  sub_800E108(0, (const char *)&dword_8007B50, 0);
  sub_800E108(0, "User Cert", 0);
  sub_800E108(0, "User Key", 0);
  result = 0;
  byte_200037DC = 0;
  return result;
}
// 8007B50: using guessed type int dword_8007B50;
// 200037DC: using guessed type char byte_200037DC;

//----- (08007B70) --------------------------------------------------------
int sub_8007B70()
{
  int result; // r0

  byte_20003C26 = byte_20000512;
  word_20003C27 = (unsigned int)flt_200002F0;
  word_20003C29 = (unsigned int)flt_20002798;
  word_20003C2B = (unsigned int)flt_200027A4;
  word_20003C2D = (unsigned int)flt_20001C2C;
  word_20003C2F = (unsigned int)flt_20001C30;
  word_20003C31 = (unsigned int)flt_20001C34;
  word_20003C33 = word_20002E86;
  word_20003C35 = sub_8010294((__int16 *)&dword_20002E97, 4u);
  result = (unsigned __int8)byte_20002F60;
  word_20003C37 = (unsigned __int8)byte_20002F60;
  return result;
}
// 200002F0: using guessed type float flt_200002F0;
// 20000512: using guessed type char byte_20000512;
// 20001C2C: using guessed type float flt_20001C2C;
// 20001C30: using guessed type float flt_20001C30;
// 20001C34: using guessed type float flt_20001C34;
// 20002798: using guessed type float flt_20002798;
// 200027A4: using guessed type float flt_200027A4;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E97: using guessed type int dword_20002E97;
// 20002F60: using guessed type char byte_20002F60;
// 20003C26: using guessed type char byte_20003C26;
// 20003C27: using guessed type __int16 word_20003C27;
// 20003C29: using guessed type __int16 word_20003C29;
// 20003C2B: using guessed type __int16 word_20003C2B;
// 20003C2D: using guessed type __int16 word_20003C2D;
// 20003C2F: using guessed type __int16 word_20003C2F;
// 20003C31: using guessed type __int16 word_20003C31;
// 20003C33: using guessed type __int16 word_20003C33;
// 20003C35: using guessed type __int16 word_20003C35;
// 20003C37: using guessed type __int16 word_20003C37;

//----- (08007C0C) --------------------------------------------------------
int __fastcall sub_8007C0C(int result)
{
  if ( result == 1 )
    return sub_8005398(0);
  if ( result == 2 )
    return sub_8005398(2);
  return result;
}

//----- (08007C20) --------------------------------------------------------
void __fastcall __noreturn sub_8007C20(int a1)
{
  int v2; // r4
  unsigned __int8 v3[128]; // [sp+0h] [bp-80h] BYREF

  sub_8002364(v3, 128);
  if ( a1 )
  {
    sprintf((int)v3, "AT+QWLANOTA=http://192.168.137.1/FC41D_OTA.rbl");
    v2 = 200;
  }
  else
  {
    sprintf((int)v3, (const char *)dword_8029918);
    v2 = 400;
  }
  if ( sub_80256C8(dword_20000458, 5000) )
  {
    sub_8023DC8((_DWORD *)dword_20000010);
    sub_8023DC8((_DWORD *)dword_20000004);
    sub_8023DC8((_DWORD *)dword_20000008);
    sub_8025188(dword_20000458, 0, 0, 0);
    sub_80052C4("Fc41d OTA GIVE MUTEX.\r\n");
  }
  sub_800DFB4(v3, "OK", 0, 300 * v2);
  sub_8023A34(10000);
  __disable_irq();
  sub_801EA48();
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8029918: using guessed type int dword_8029918[21];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007D00) --------------------------------------------------------
int __fastcall sub_8007D00(int a1)
{
  int v2; // r4
  unsigned __int8 v4[140]; // [sp+4h] [bp-8Ch] BYREF

  sub_8002364(v4, 128);
  if ( a1 )
  {
    sprintf((int)v4, "AT+QWLANOTA=http://192.168.137.1/FC41D_OTA.rbl");
    v2 = 200;
  }
  else
  {
    sprintf((int)v4, (const char *)dword_8029918);
    v2 = 400;
  }
  if ( sub_80256C8(dword_20000458, 5000) )
  {
    sub_8023DC8((_DWORD *)dword_20000010);
    sub_8023DC8((_DWORD *)dword_20000004);
    sub_8023DC8((_DWORD *)dword_20000008);
    sub_8025188(dword_20000458, 0, 0, 0);
    sub_80052C4("Fc41d OTA GIVE MUTEX.\r\n");
  }
  sub_800DFB4(v4, "OK", 0, 300 * v2);
  return sub_8023A34(10000);
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8029918: using guessed type int dword_8029918[21];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007DE0) --------------------------------------------------------
int __fastcall sub_8007DE0(const char *a1, unsigned int a2, int a3)
{
  unsigned __int8 v7[272]; // [sp+0h] [bp-110h] BYREF

  sub_8002364(v7, 256);
  if ( a1 && a2 <= 0xFF )
  {
    if ( a3 )
      sprintf((int)v7, "AT+QWLANOTA=%s,%d", a1, a3);
    else
      sprintf((int)v7, "AT+QWLANOTA=%s", a1);
    if ( sub_80256C8(dword_20000458, 5000) )
    {
      sub_8023DC8((_DWORD *)dword_20000010);
      sub_8023DC8((_DWORD *)dword_20000004);
      sub_8023DC8((_DWORD *)dword_20000008);
      sub_8025188(dword_20000458, 0, 0, 0);
      sub_80052C4("Fc41d OTA GIVE MUTEX.\r\n");
    }
    if ( sub_800DFB4(v7, (unsigned __int8 *)&dword_8007EC4, 0, 180000) )
    {
      sub_80052C4("Fc41d OTA OK!.\r\n");
      __disable_irq();
      sub_801EA48();
    }
    __disable_irq();
    sub_801EA48();
  }
  return sub_80052C4((const char *)dword_8029834, a1, a2, a3);
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8007EC4: using guessed type int dword_8007EC4;
// 8029834: using guessed type int dword_8029834[18];
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 20000010: using guessed type int dword_20000010;
// 20000458: using guessed type int dword_20000458;

//----- (08007EEC) --------------------------------------------------------
int sub_8007EEC()
{
  sub_8002364(byte_200038E3, 26);
  sprintf((int)byte_200038E3, "%x%x%x", MEMORY[0x1FFF7598], MEMORY[0x1FFF7594], MEMORY[0x1FFF7590]);
  return sub_80052C4("*** Fc41d_info.uid = %s ***\r\n", byte_200038E3);
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);

//----- (08007F58) --------------------------------------------------------
int sub_8007F58()
{
  int result; // r0
  unsigned __int16 v1; // r0

  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    sprintf((int)byte_20004974, "dev_net_info:%s,ct_connect_ip:%s", byte_200112A8, (const char *)&qword_20011298);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v1,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];
// 20011298: using guessed type __int64 qword_20011298;

//----- (08008028) --------------------------------------------------------
int sub_8008028()
{
  unsigned int v0; // r4
  unsigned __int8 *v1; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( v0 >= 3 )
      return 0;
    if ( sub_800DFB4("AT+QVERSION", 0, (unsigned __int8 *)&dword_8008080, 300) )
      break;
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  v1 = strstr((unsigned __int8 *)byte_20003A24, "bin_");
  if ( v1 )
  {
    dword_200038FD = *((_DWORD *)v1 + 1);
    dword_20003901 = *((_DWORD *)v1 + 2);
    dword_20003905 = *((_DWORD *)v1 + 3);
    byte_20003909 = 0;
    sub_80052C4("Blue version: %s\r\n", (const char *)&dword_200038FD);
  }
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8008080: using guessed type int dword_8008080;
// 200038FD: using guessed type int dword_200038FD;
// 20003901: using guessed type int dword_20003901;
// 20003905: using guessed type int dword_20003905;
// 20003909: using guessed type char byte_20003909;

//----- (080080B4) --------------------------------------------------------
int __fastcall sub_80080B4(int a1)
{
  int result; // r0
  int v3; // r1

  sub_80052C4("Hardware reset, type:%d, reset_time:%d min.\r\n", a1, (unsigned __int16)word_200037DD);
  result = (unsigned __int8)byte_200015B4;
  if ( !byte_200015B4 )
  {
    if ( a1 == 1 )
    {
      if ( !sub_801B040(&word_200008FE, (unsigned __int16)(60 * word_200037DD)) )
      {
        result = (unsigned __int16)word_200037DD;
        if ( word_200037DD != 15 )
          return result;
      }
      if ( (unsigned __int16)word_200037DD < 0xF0u )
        word_200037DD *= 2;
      else
        word_200037DD = 15;
    }
    else if ( a1 == 2 )
    {
      result = sub_801B040(&word_200008FE, 0x708u);
      if ( !result )
        return result;
    }
    sub_8018F5C(4, 401);
    v3 = dword_20000904++;
    sub_8018434(1, v3, 1, 2);
    if ( sub_80256C8(dword_20000458, 1500) )
    {
      sub_801292E(1207962624, 2048, 1);
      sub_8023A34(2000);
      sub_801292E(1207962624, 2048, 0);
      sub_8023A34(1000);
      sub_8025188(dword_20000458, 0, 0, 0);
    }
    else
    {
      sub_801292E(1207962624, 2048, 1);
      sub_8023A34(2000);
      sub_801292E(1207962624, 2048, 0);
      sub_8023A34(1000);
    }
    result = 0;
    if ( byte_2000050A == 1 )
      byte_200037D4[0] = 2;
    else
      byte_200037D4[0] = 0;
    byte_20000931 = 0;
    byte_2000436E = 0;
    byte_20004360 = 0;
    byte_20000995 = 1;
    byte_200037D6 = 0;
    byte_20004370 = 0;
    byte_20000996 = 0;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20000458: using guessed type int dword_20000458;
// 2000050A: using guessed type char byte_2000050A;
// 200008FE: using guessed type _WORD word_200008FE;
// 20000904: using guessed type int dword_20000904;
// 20000931: using guessed type char byte_20000931;
// 20000995: using guessed type char byte_20000995;
// 20000996: using guessed type char byte_20000996;
// 200015B4: using guessed type char byte_200015B4;
// 200037D6: using guessed type char byte_200037D6;
// 200037DD: using guessed type __int16 word_200037DD;
// 20004360: using guessed type char byte_20004360;
// 2000436E: using guessed type char byte_2000436E;
// 20004370: using guessed type char byte_20004370;

//----- (0800823C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_800823C(unsigned __int8 *result, int a2)
{
  unsigned __int8 *v2; // r4
  int v4; // t1

  v2 = result;
  if ( result )
  {
    while ( a2 )
    {
      v4 = *v2++;
      sub_8004A2C(v4);
      a2 = (unsigned __int16)(a2 - 1);
    }
    return 0;
  }
  return result;
}

//----- (0800825C) --------------------------------------------------------
#error "80082F2: call analysis failed (funcsize=69)"

//----- (08008344) --------------------------------------------------------
int __fastcall sub_8008344(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v7; // r4

  v7 = 0;
  if ( !a1 )
    return 0;
  if ( sub_80256C8(dword_20000458, 500) )
  {
    sub_8002364(byte_200009A4, 2048);
    word_2000099A = 0;
    sub_800F1D8(a1);
    byte_200037D9 = 3;
    sub_80052C4((const char *)sub_8008438, a1);
    if ( sub_80233A4(0, 0, 400) == 1 )
    {
      sub_8023A34(a4);
      byte_200009A4[(unsigned __int16)word_2000099A] = 0;
      sub_80052C4(asc_800845C, byte_200009A4);
      if ( (unsigned int)a2 | (unsigned int)a3 )
      {
        if ( a2 && a3 && strstr(byte_200009A4, a2) && strstr(byte_200009A4, a3) )
        {
          v7 = 1;
        }
        else if ( a2 && strstr(byte_200009A4, a2) )
        {
          v7 = 1;
        }
        else if ( strstr(byte_200009A4, a3) )
        {
          v7 = 1;
        }
      }
      else
      {
        sub_80052C4("Set expected reply content error!\r\n");
      }
    }
    byte_200037D9 = 0;
    sub_8025188(dword_20000458, 0, 0, 0);
  }
  return v7;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8008438: using guessed type int sub_8008438();
// 20000458: using guessed type int dword_20000458;
// 2000099A: using guessed type __int16 word_2000099A;
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];
// 200037D9: using guessed type char byte_200037D9;

//----- (080084A4) --------------------------------------------------------
int sub_80084A4()
{
  unsigned int v0; // r4
  unsigned __int8 *v1; // r0
  unsigned int v2; // r6
  unsigned __int8 *v4; // r0
  int v5; // r9
  unsigned __int8 *v6; // r0
  int v7; // r8
  unsigned __int8 *v8; // r0
  char *i; // r5
  int v10; // r10
  __int16 v11; // r0
  unsigned int v12; // r1
  int v13; // r1
  unsigned int j; // r0
  unsigned int k; // r5
  unsigned int m; // r0
  unsigned __int16 *v17; // r1
  unsigned int v18; // r2
  unsigned int n; // r4
  _WORD v20[96]; // [sp+8h] [bp-120h] BYREF
  __int16 v21; // [sp+C8h] [bp-60h]
  __int16 v22; // [sp+CAh] [bp-5Eh]

  v0 = 0;
  sub_8002364(v20, 256);
  v1 = strstr(byte_200009A4, (unsigned __int8 *)&dword_80086A0);
  if ( v1 )
  {
    v2 = (unsigned __int16)sub_8002644((char *)v1 + 2);
    if ( v2 > 0xE10 || !v2 )
      v2 = 3600;
    v4 = strstr(byte_200009A4, "c=");
    if ( v4 )
    {
      v5 = (unsigned __int16)sub_8002644((char *)v4 + 2);
      v6 = strstr(byte_200009A4, "l=");
      if ( v6 )
      {
        v7 = (unsigned __int16)sub_8002644((char *)v6 + 2);
        v8 = strstr(byte_200009A4, "d=");
        if ( v8 )
        {
          for ( i = (char *)(v8 + 2); *i; i = (char *)(v10 + 1) )
          {
            if ( v0 >= 0x80 )
              break;
            v10 = sub_80023CE((int)i, 0x2Cu);
            v11 = sub_8002644(i);
            v12 = v0++;
            v20[v12] = v11;
            if ( !v10 )
              break;
          }
          if ( v0 < 0x80 )
          {
            v13 = 0;
            for ( j = 0; j < v0; ++j )
              v13 ^= (unsigned __int16)v20[j];
            if ( v13 == v5 && v7 == v0 )
            {
              if ( byte_200037D5 == 1 )
              {
                sub_80052C4((const char *)&off_802932C, v2, v13, v5, v7, v0);
                for ( k = 0; k < v0; ++k )
                  sub_80052C4("%u, ", (unsigned __int16)v20[k]);
                sub_80052C4("\r\n");
              }
              for ( m = 0; m < 0x18; m = (unsigned __int8)(m + 1) )
              {
                v18 = 4 * m + 3;
                if ( v18 >= v0 )
                  break;
                word_200051A4[3 * m] = v20[4 * m];
                v17 = &word_200051A4[3 * m];
                v17[1] = v20[4 * m + 1];
                *((_BYTE *)v17 + 4) = v20[4 * m + 2];
                *((_BYTE *)v17 + 5) = v20[v18];
              }
              if ( v0 >= 0x60 )
              {
                byte_20005234 = v21;
                byte_20005235 = v22;
              }
              dword_200015A8 = dword_2000002C + v2 + 10;
              if ( byte_200037D5 == 1 )
              {
                sub_80052C4("[HTTP] Get economy data :\r\n");
                for ( n = 0; n < 0x18; n = (unsigned __int8)(n + 1) )
                  sub_80052C4(
                    "not Found\r\n",
                    n,
                    word_200051A4[3 * n],
                    (__int16)word_200051A4[3 * n + 1],
                    LOBYTE(word_200051A4[3 * n + 2]),
                    HIBYTE(word_200051A4[3 * n + 2]));
                sub_80052C4(
                  "\r\ntotal_time = %d, info_idx = %d.\r\n",
                  (unsigned __int8)byte_20005234,
                  (unsigned __int8)byte_20005235);
              }
              return 1;
            }
            else
            {
              sub_80052C4("var\r\n");
              return 0;
            }
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else if ( strstr(byte_200009A4, "ERROR") )
  {
    sub_80052C4("[HTTP] Get economy data error.\r\n");
    if ( (unsigned __int8)byte_2000094B <= 3u )
    {
      ++byte_2000094B;
      return 0;
    }
    else
    {
      sub_80052C4("[HTTP] Wait next time.\r\n");
      byte_2000094B = 0;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 80086A0: using guessed type int dword_80086A0;
// 802932C: using guessed type _UNKNOWN *off_802932C;
// 2000002C: using guessed type int dword_2000002C;
// 2000094B: using guessed type char byte_2000094B;
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];
// 200015A8: using guessed type int dword_200015A8;
// 200037D5: using guessed type char byte_200037D5;
// 200051A4: using guessed type unsigned __int16 word_200051A4[72];
// 20005234: using guessed type char byte_20005234;
// 20005235: using guessed type char byte_20005235;

//----- (08008760) --------------------------------------------------------
int __fastcall sub_8008760(int a1)
{
  unsigned int v1; // r4

  v1 = 0;
  sprintf((int)byte_200011A4, "AT+QHTTPGET=%d", a1);
  while ( v1 < 2 )
  {
    if ( sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_80087B0, 0, 300) )
      return 1;
    v1 = (unsigned __int8)(v1 + 1);
    sub_8023A34(100);
  }
  return 0;
}
// 80087B0: using guessed type int dword_80087B0;
// 200011A4: using guessed type unsigned __int8 byte_200011A4[1024];

//----- (080087B4) --------------------------------------------------------
_BYTE *sub_80087B4()
{
  int i; // r4
  char *v1; // r0
  _BYTE *result; // r0

  for ( i = 0; i < 143; ++i )
  {
    v1 = (char *)&unk_20005260 + 340 * i;
    *(_DWORD *)v1 = -1;
    result = sub_8002364(v1 + 12, 328);
  }
  return result;
}

//----- (080087E8) --------------------------------------------------------
int sub_80087E8()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_8008344((unsigned __int8 *)sub_8008828, "OK", "+QHTTPREAD: 0", 900) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  while ( v0 < 2 );
  return 0;
}

//----- (08008828) --------------------------------------------------------
int __fastcall sub_8008828(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r4
  int v5; // r5
  int v6; // r6
  int v7; // r8
  int *v8; // r1
  int v9; // r5
  int *v10; // r6
  char *v12; // r0
  int i; // r4

  *(_BYTE *)(a1 + a2) = a2;
  *(_DWORD *)(v5 + v4) = a4;
  *(_BYTE *)(2 * a2) = a1;
  *(_DWORD *)(a3 + a2) = v4;
  v8 = (int *)(a2 + v7);
  v9 = v6 + 61;
  v10 = v8;
  if ( !v8 || !a3 )
    return 0;
  if ( dword_2000099C == v9 )
    return 0;
  if ( (unsigned __int16)word_20000997 >= 0x8Fu )
  {
    for ( i = 1; i < 143; ++i )
      qmemcpy((unsigned int)&dword_20005260[85 * i - 85], (unsigned int)&dword_20005260[85 * i], 0x154u);
    dword_20010EF8 = v9;
    dword_20010EFC = *v10;
    dword_20010F00 = v10[1];
    qmemcpy((unsigned int)&unk_20010F04, a3, 0x148u);
  }
  else
  {
    dword_20005260[85 * (unsigned __int16)word_20000997] = v9;
    v12 = (char *)&dword_20005260[85 * (unsigned __int16)word_20000997];
    *((_DWORD *)v12 + 1) = *v8;
    *((_DWORD *)v12 + 2) = v8[1];
    qmemcpy((unsigned int)&dword_20005260[85 * (unsigned __int16)word_20000997++ + 3], a3, 0x148u);
  }
  dword_2000099C = v9;
  return 1;
}
// 800882A: variable 'v5' is possibly undefined
// 800882A: variable 'v4' is possibly undefined
// 8008832: variable 'v7' is possibly undefined
// 800883C: variable 'v6' is possibly undefined
// 20000997: using guessed type __int16 word_20000997;
// 2000099C: using guessed type int dword_2000099C;
// 20005260: using guessed type _DWORD dword_20005260[11264];
// 20010EF8: using guessed type int dword_20010EF8;
// 20010EFC: using guessed type int dword_20010EFC;
// 20010F00: using guessed type int dword_20010F00;

//----- (08008910) --------------------------------------------------------
int sub_8008910()
{
  unsigned __int8 *v0; // r0
  int v1; // r4

  v0 = strstr(byte_200009A4, "\"de\":");
  if ( !v0 )
    return 0;
  v1 = (unsigned __int8)sub_8002644((char *)v0 + 5);
  sub_80052C4("[HTTP] Upload decrypt result = %d.\r\n", v1);
  return v1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];

//----- (080089C8) --------------------------------------------------------
int sub_80089C8()
{
  int result; // r0
  bool v1; // zf
  bool v2; // zf
  unsigned int i; // r0
  unsigned __int8 v4; // r8
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // [sp+1Ch] [bp-5Ch]
  int v11; // [sp+20h] [bp-58h] BYREF
  int v12; // [sp+24h] [bp-54h]
  int v13; // [sp+28h] [bp-50h]
  int v14; // [sp+2Ch] [bp-4Ch]
  char *v15; // [sp+48h] [bp-30h]
  unsigned __int8 *v16; // [sp+4Ch] [bp-2Ch]
  unsigned __int8 *v17; // [sp+50h] [bp-28h]

  if ( byte_20000995 == 1 )
  {
    byte_20000995 = 0;
    byte_20000938 = 0;
  }
  sub_8010328((int)&unk_20000962);
  dword_200009A0 = sub_80104B0((int)&unk_20000962);
  if ( dword_200009A0 != dword_2000099C && sub_801B040(word_2000094C, 0x14u) )
  {
    sub_800F8E4();
    ((void (__fastcall *)(_DWORD, void *, char *))loc_8008838)(
      (unsigned __int16)dword_200009A0,
      &unk_20000962,
      &byte_20003C39);
    sub_80052C4("", (unsigned __int16)word_20000997, dword_2000099C, dword_200009A0);
    sub_8003202();
    byte_20000947 = 1;
    byte_20000946 = 3;
  }
  result = (unsigned __int8)byte_20000930;
  v1 = byte_20000930 == 0;
LABEL_7:
  if ( !v1 )
  {
    result = (unsigned __int8)byte_200015B4;
    v2 = byte_200015B4 == 0;
    while ( v2 )
    {
      result = (unsigned __int8)byte_200037DC;
      v2 = byte_200037DC == 7;
      if ( byte_200037DC == 7 )
      {
        result = (unsigned __int8)byte_200015AF;
        v1 = byte_200015AF == 1;
        if ( byte_200015AF == 1 )
          goto LABEL_7;
        if ( !byte_20000943 && word_20000997 && sub_801B040(&word_2000094C[1], 0x12Cu) )
        {
          byte_20000943 = 1;
          byte_20000946 = 3;
        }
        if ( !byte_20000946 )
        {
          byte_20000943 = 0;
          byte_20000947 = 0;
        }
        if ( byte_20000945 == 1 )
        {
          if ( sub_801B040(&word_2000094C[2], 0x12Cu) )
            byte_20000944 = 1;
        }
        else if ( !byte_20000944 )
        {
          byte_20000944 = sub_801B040(&word_2000094C[2], 0x708u) != 0;
        }
        if ( byte_20002F60 == 5
          && (dword_200015A8 < (unsigned int)dword_2000002C || sub_801B040(&algn_20000954[2], 0xE10u)) )
        {
          byte_200015A6 = 1;
        }
        if ( !byte_200015AC && byte_20002FD1 == 2 )
        {
          if ( byte_20002F60 == 1 && sub_801B040(&word_2000095C, 0x3Cu) )
          {
            byte_200015AC = 1;
          }
          else if ( (!byte_20002F60 || byte_20002F60 == 5) && sub_801B040(&word_2000095C, 0xAu) )
          {
            byte_200015AC = 1;
          }
        }
        if ( byte_20002FD1 == 2 && byte_200015E6 && (unsigned __int8)byte_20000949 > 4u )
        {
          byte_200015E6 = 0;
          byte_20000949 = 0;
          dword_20005238 = 0;
          dword_2000523C = 0;
          dword_20005240 = 0;
          dword_20005244 = 0;
          byte_200015AE = 6;
          sub_80052C4("!!! [HTTP] Warning : P1 METER DISCONNECT!!!\r\n");
        }
        if ( !byte_200015AD && byte_20002FD1 == 7 )
        {
          if ( byte_20002F60 == 1 && sub_801B040(&word_2000095C, 0x3Cu) )
          {
            byte_200015AD = 1;
          }
          else if ( (!byte_20002F60 || byte_20002F60 == 5) && sub_801B040(&word_2000095C, 0xAu) )
          {
            byte_200015AD = 1;
          }
        }
        if ( byte_20002FD1 == 7 && byte_200015E6 && (unsigned __int8)byte_20000949 > 4u )
        {
          byte_200015E6 = 0;
          byte_20000949 = 0;
          dword_20005238 = 0;
          dword_2000523C = 0;
          dword_20005240 = 0;
          dword_20005244 = 0;
          byte_200015AE = 6;
          sub_80052C4("!!! [HTTP] Warning : ECO-TRACKER DISCONNECT!!!\r\n");
        }
        if ( (unsigned __int8)byte_20000939 > 6u || (unsigned __int8)byte_2000093A > 0xAu )
        {
          sub_80052C4("\r");
          byte_20000947 = 0;
          byte_20000939 = 0;
          byte_2000093A = 0;
          byte_2000093B = 0;
          byte_2000093C = 0;
          byte_2000093D = 0;
          byte_200037D6 = 0;
          byte_20000938 = 1;
          sub_8018F5C(4, 407);
          if ( byte_200015E6 != 1 || byte_20004360 == 2 || byte_200037D8 )
          {
            if ( byte_20004360 != 2 && !byte_200037D8 )
              sub_80080B4(0);
          }
          else
          {
            sub_80080B4(1);
          }
        }
        if ( (unsigned __int8)byte_2000093B <= 2u )
        {
          if ( (unsigned __int8)byte_2000093C <= 2u )
          {
            if ( (unsigned __int8)byte_2000093D <= 2u )
            {
              if ( (unsigned __int8)byte_2000093E <= 2u )
              {
                if ( (unsigned __int8)byte_20000948 > 2u )
                {
                  sub_80052C4(
                    "&war1=%llx&wifi_s=%d&inc_a=%d&pri_c=%d&pri_d=%d&set_v=%d&mxc_p=%d&mxd_p=%d&soc=%d&rec_i=%d&red_i=%d&cell_v=%d&cell_i=%d&bat_p=%d&dsoc=%d&pha=%d&ble=%d&mqqt=%d&ct_t=%d&ct_w=%d&ct_p=%s&ct_m=%s",
                    (unsigned __int8)byte_20000949);
                  byte_20000948 = 0;
                  byte_200037D6 = 0;
                  byte_20000938 = 1;
                  byte_200015AC = 0;
                  byte_200015AD = 0;
                }
              }
              else
              {
                sub_80052C4("!!! [HTTP] Warning : GET ACTIVE ERR!!!\r\n");
                byte_2000093E = 0;
                byte_200037D6 = 0;
                byte_20000938 = 18;
                byte_200015A7 = 0;
              }
            }
            else
            {
              sub_80052C4("!!! [HTTP] Warning : GET PRICE ERR!!!\r\n");
              byte_2000093D = 0;
              byte_200037D6 = 0;
              byte_20000938 = 14;
              byte_200015A6 = 0;
              dword_200015A8 = dword_2000002C + 120;
            }
          }
          else
          {
            sub_80052C4("!!! [HTTP] Warning : GET DATA ERR!!!\r\n");
            byte_2000093C = 0;
            byte_200037D6 = 0;
            byte_20000938 = 10;
            byte_20000943 = 0;
            byte_20000947 = 0;
          }
        }
        else
        {
          sub_80052C4("!!! [HTTP] Warning : GET TIME ERR!!!\r\n");
          byte_2000093B = 0;
          byte_200037D6 = 0;
          byte_20000938 = 5;
          byte_20000944 = 0;
        }
        v17 = (unsigned __int8 *)&dword_200038FD;
        result = (int)byte_20003A13;
        v15 = byte_20003A13;
        v16 = byte_200009A4;
        switch ( byte_20000938 )
        {
          case 0:
            result = ((int (__fastcall *)(int))loc_8008968)(3);
            if ( result )
            {
              byte_20000939 = 0;
              byte_20000938 = 1;
            }
            else
            {
              result = (unsigned __int8)byte_20000939++ + 1;
            }
            break;
          case 1:
            result = (unsigned __int8)byte_20000944;
            if ( byte_20000944 == 1 )
            {
              if ( sub_8009F48(2) )
              {
                byte_20000939 = 0;
                result = 2;
                byte_20000938 = 2;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)byte_2000093B++ + 1;
                byte_20000938 = 5;
              }
            }
            else
            {
              byte_20000938 = 5;
            }
            break;
          case 2:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              if ( word_20000958 == 60 && strstr(v17, "2025") )
                word_20000958 = 30;
              if ( sub_8008760((unsigned __int8)word_20000958) )
              {
                result = 3;
                byte_20000938 = 3;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                ++byte_2000093A;
                result = 3;
                byte_20000938 = 3;
              }
              word_20000952 = 0;
            }
            break;
          case 3:
            if ( strstr(v16, "+QHTTPGET: 0") || byte_20000996 == 1 )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_2000093B = 0;
              result = 4;
              byte_20000938 = 4;
              byte_200037D6 = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              result = (unsigned __int8)byte_2000093B++ + 1;
              byte_20000938 = 5;
              byte_200037D6 = 0;
            }
            else
            {
              result = sub_801B040(&word_20000952, (unsigned __int16)(word_20000958 + 10));
              if ( result )
              {
                if ( strstr(v16, "+QHTTPGET: 0") || byte_20000996 == 1 )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_2000093B = 0;
                  result = 4;
                  byte_20000938 = 4;
                }
                else
                {
                  ++byte_20000939;
                  result = (unsigned __int8)byte_2000093B++ + 1;
                  byte_20000938 = 5;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 4:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_2000093F = 0;
                result = sub_8009B0C();
                if ( result )
                {
                  byte_20000945 = 0;
                  byte_20000944 = 0;
                }
                byte_20000938 = 5;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)++byte_2000093F;
                byte_20000938 = 5;
                if ( (unsigned __int8)byte_2000093F > 3u )
                {
                  byte_2000093F = 0;
                  byte_20000944 = 0;
                }
              }
              word_20000952 = 0;
            }
            break;
          case 5:
            result = (unsigned __int8)byte_20000943 | (unsigned __int8)byte_20000947 | (unsigned __int8)byte_20000946;
            if ( result )
            {
              result = (unsigned __int16)word_20000997;
              if ( word_20000997 )
              {
                if ( (unsigned __int16)word_20000997 <= 3u || (result = sub_801B040(algn_20000954, 0x3Cu)) != 0 )
                {
                  sub_80052C4(
                    "l",
                    (unsigned __int16)word_20000997,
                    (unsigned __int8)byte_20000946,
                    (unsigned __int8)byte_20000947,
                    (unsigned __int8)byte_20000943);
                  if ( sub_8009C2C(
                         LOWORD(dword_20005260[85 * (unsigned __int16)word_20000997 - 85]),
                         (unsigned __int16)(word_20000997 - 1)) )
                  {
                    word_200015A4 = word_20000997 - 1;
                    byte_20000943 = 0;
                    byte_20000939 = 0;
                    byte_20000938 = 6;
                    byte_20000947 = 0;
                    result = (unsigned __int8)byte_20000946;
                    if ( byte_20000946 )
                      result = (unsigned __int8)byte_20000946-- - 1;
                  }
                  else
                  {
                    ++byte_20000939;
                    ++byte_2000093C;
                    byte_20000938 = 10;
                    result = (unsigned __int8)byte_20000946;
                    if ( byte_20000946 )
                      result = (unsigned __int8)byte_20000946-- - 1;
                  }
                }
                else
                {
                  byte_20000938 = 10;
                }
              }
              else
              {
                byte_20000943 = 0;
                byte_20000947 = 0;
                byte_20000946 = 0;
                byte_20000938 = 10;
              }
            }
            else
            {
              byte_20000938 = 10;
            }
            break;
          case 6:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              if ( word_2000095A == 60 && strstr(v17, "2025") )
                word_2000095A = 30;
              result = sub_8008760((unsigned __int8)word_2000095A);
              if ( result )
              {
                byte_20000938 = 7;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                result = (unsigned __int8)byte_2000093A++ + 1;
                byte_20000938 = 7;
              }
              word_20000952 = 0;
            }
            break;
          case 7:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_2000093C = 0;
              byte_20000938 = 8;
              byte_200037D6 = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              result = (unsigned __int8)byte_2000093C++ + 1;
              byte_20000938 = 10;
              byte_200037D6 = 0;
            }
            else
            {
              result = sub_801B040(&word_20000952, (unsigned __int16)(word_2000095A + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_2000093C = 0;
                  byte_20000938 = 8;
                }
                else
                {
                  ++byte_20000939;
                  result = (unsigned __int8)byte_2000093C++ + 1;
                  byte_20000938 = 10;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 8:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_20000940 = 0;
                result = sub_8008910();
                if ( result )
                {
                  result = 9;
                  byte_20000938 = 9;
                }
                else
                {
                  byte_20000938 = 10;
                }
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)++byte_20000940;
                byte_20000938 = 10;
                if ( (unsigned __int8)byte_20000940 > 3u )
                {
                  byte_20000940 = 0;
                  byte_20000946 = 0;
                }
              }
              word_20000952 = 0;
            }
            break;
          case 9:
            if ( (unsigned __int16)word_20000997 - (unsigned __int16)word_200015A4 <= 1 )
            {
              qmemcpy(
                (unsigned int)&dword_20005260[85 * (unsigned __int16)word_20000997 - 85],
                (unsigned int)&dword_20005260[85 * (unsigned __int16)word_20000997],
                0x154u);
              result = (unsigned __int16)word_20000997-- - 1;
            }
            else
            {
              sub_80052C4(
                "[HTTP] Delete data, upload_cnt = %d, delate_flag = %d.\r\n",
                (unsigned __int16)word_20000997,
                (unsigned __int16)word_200015A4);
              for ( i = (unsigned __int8)word_200015A4; (unsigned __int16)word_20000997 > i; i = v4 )
              {
                v4 = i + 1;
                qmemcpy((unsigned int)&dword_20005260[85 * i], (unsigned int)&dword_20005260[85 * i + 85], 0x154u);
              }
              result = (unsigned __int16)word_20000997-- - 1;
            }
            byte_20000939 = 0;
            byte_20000938 = 10;
            break;
          case 10:
            if ( byte_200015A6 == 1 )
            {
              if ( byte_20002F60 != 5 )
                byte_20000938 = 14;
              if ( sub_8009F48(4) )
              {
                byte_20000939 = 0;
                result = 11;
                byte_20000938 = 11;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)byte_2000093D++ + 1;
              }
            }
            else
            {
              result = 14;
              byte_20000938 = 14;
            }
            break;
          case 11:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              result = sub_8008760(60);
              if ( result )
              {
                byte_20000938 = 12;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                result = (unsigned __int8)byte_2000093A++ + 1;
                byte_20000938 = 12;
              }
              word_20000952 = 0;
            }
            break;
          case 12:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_2000093D = 0;
              byte_20000938 = 13;
              byte_200037D6 = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              result = (unsigned __int8)byte_2000093D++ + 1;
              byte_20000938 = 10;
              byte_200037D6 = 0;
            }
            else
            {
              result = sub_801B040(&word_20000952, 0x46u);
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_2000093D = 0;
                  byte_20000938 = 13;
                }
                else
                {
                  ++byte_20000939;
                  result = (unsigned __int8)byte_2000093D++ + 1;
                  byte_20000938 = 10;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 13:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_20000941 = 0;
                if ( sub_80084A4() )
                  byte_200015A6 = 0;
                result = 14;
                byte_20000938 = 14;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)++byte_20000941;
                if ( (unsigned __int8)byte_20000941 > 3u )
                {
                  byte_20000941 = 0;
                  byte_20000938 = 14;
                  byte_200015A6 = 0;
                  result = dword_2000002C + 120;
                  dword_200015A8 = dword_2000002C + 120;
                }
              }
              word_20000952 = 0;
            }
            break;
          case 14:
            if ( byte_200015A7 == 1 )
            {
              if ( sub_8009F48(5) )
              {
                byte_20000939 = 0;
                result = 15;
                byte_20000938 = 15;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)byte_2000093E++ + 1;
              }
            }
            else
            {
              result = 18;
              byte_20000938 = 18;
            }
            break;
          case 15:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              result = sub_8008760(60);
              if ( result )
              {
                byte_20000938 = 16;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                result = (unsigned __int8)byte_2000093A++ + 1;
                byte_20000938 = 16;
              }
              word_20000952 = 0;
            }
            break;
          case 16:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_2000093E = 0;
              byte_20000938 = 17;
              byte_200037D6 = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              ++byte_2000093E;
              result = 14;
              byte_20000938 = 14;
              byte_200037D6 = 0;
            }
            else
            {
              result = sub_801B040(&word_20000952, 0x46u);
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_2000093E = 0;
                  byte_20000938 = 17;
                }
                else
                {
                  ++byte_20000939;
                  ++byte_2000093E;
                  result = 14;
                  byte_20000938 = 14;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 17:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_20000942 = 0;
                if ( sub_800825C() )
                  byte_200015A7 = 0;
                result = 18;
                byte_20000938 = 18;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)++byte_20000942;
                if ( (unsigned __int8)byte_20000942 > 3u )
                {
                  byte_20000942 = 0;
                  result = 18;
                  byte_20000938 = 18;
                  byte_200015A7 = 0;
                }
              }
              word_20000952 = 0;
            }
            break;
          case 18:
            if ( byte_200015AC == 1 )
            {
              if ( !sub_80023E2((unsigned __int8 *)v15) )
              {
                sub_80057C4(0x3500u, (int)v15, 16);
                sub_80052C4("[HTTP] Read P1 meter ip: %s.\r\n", v15);
              }
              if ( sub_8009F48(6) )
              {
                byte_20000939 = 0;
                result = 19;
                byte_20000938 = 19;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)byte_20000948++ + 1;
              }
            }
            else
            {
              result = 23;
              byte_20000938 = 23;
            }
            break;
          case 19:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              if ( strstr(v17, "2025") )
                word_2000095E = 30;
              result = sub_8008760((unsigned __int8)word_2000095E);
              if ( result )
              {
                byte_20000938 = 20;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                result = (unsigned __int8)byte_2000093A++ + 1;
                byte_20000938 = 20;
              }
              word_20000952 = 0;
            }
            break;
          case 20:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_20000948 = 0;
              byte_20000949 = 0;
              byte_20000938 = 21;
              byte_200037D6 = 0;
              byte_200015AE = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              ++byte_20000948;
              byte_20000938 = 18;
              byte_200037D6 = 0;
              result = 3;
              byte_200015AE = 3;
            }
            else
            {
              result = sub_801B040(&word_20000952, (unsigned __int16)(word_2000095E + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_20000948 = 0;
                  byte_20000949 = 0;
                  byte_20000938 = 21;
                  byte_200015AE = 0;
                }
                else
                {
                  ++byte_20000939;
                  ++byte_20000948;
                  if ( !byte_2000093A )
                  {
                    ++byte_20000949;
                    byte_200015AE = 4;
                  }
                  if ( (unsigned __int8)byte_20000949 > 6u )
                  {
                    byte_20000949 = 6;
                    byte_200015AE = 5;
                  }
                  result = 18;
                  byte_20000938 = 18;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 21:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                sub_8002364(&v11, 40);
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_20000948 = 0;
                byte_20000938 = 22;
                v10 = sub_8010150(v16, "wifi_strength");
                v5 = sub_8010150(v16, "active_power_w");
                dword_20005238 = v5;
                if ( v5 == 0xFFFF )
                {
                  ++byte_2000094A;
                  v11 = 0;
                  if ( (unsigned __int8)byte_2000094A > 4u )
                  {
                    byte_2000094A = 0;
                    byte_200015AE = 1;
                    if ( byte_20002FD1 == 2 )
                    {
                      if ( byte_200015E6 )
                        byte_200015E6 = 0;
                    }
                  }
                }
                else
                {
                  byte_2000094A = 0;
                  v11 = v5;
                  byte_200015AE = 0;
                  byte_20000949 = 0;
                  byte_200015E4 = 5;
                  if ( byte_20002FD1 == 2 )
                    byte_200015E6 = 1;
                }
                v6 = sub_8010150(v16, "active_power_l1_w");
                dword_2000523C = v6;
                if ( v6 == 0xFFFF )
                  v12 = 0;
                else
                  v12 = v6;
                v7 = sub_8010150(v16, "active_power_l2_w");
                dword_20005240 = v7;
                if ( v7 == 0xFFFF )
                  v13 = 0;
                else
                  v13 = v7;
                v8 = sub_8010150(v16, "active_power_l3_w");
                dword_20005244 = v8;
                if ( v8 == 0xFFFF )
                  v14 = 0;
                else
                  v14 = v8;
                sub_80052C4(
                  (const char *)dword_8028FE4,
                  dword_20005238,
                  dword_2000523C,
                  dword_20005240,
                  v8,
                  v11,
                  v12,
                  v13,
                  v14,
                  v10,
                  (unsigned __int8)byte_20000931);
                result = sub_8025188(dword_20000434, (unsigned int)&v11, 0, 2);
                byte_200015AC = 0;
              }
              else
              {
                ++byte_20000939;
                ++byte_20000948;
                if ( (unsigned __int8)++byte_2000094A > 4u )
                {
                  byte_2000094A = 0;
                  byte_200015AE = 2;
                }
                result = 23;
                byte_20000938 = 23;
              }
              word_20000952 = 0;
            }
            break;
          case 22:
            byte_20000939 = 0;
            byte_20000948 = 0;
            result = 23;
            byte_20000938 = 23;
            break;
          case 23:
            if ( byte_200015AD == 1 )
            {
              if ( !sub_80023E2((unsigned __int8 *)v15) )
              {
                sub_80057C4(0x3500u, (int)v15, 16);
                sub_80052C4("[HTTP] Read Eco-Tracker ip: %s.\r\n", v15);
              }
              if ( sub_8009F48(7) )
              {
                byte_20000939 = 0;
                result = 24;
                byte_20000938 = 24;
              }
              else
              {
                ++byte_20000939;
                result = (unsigned __int8)byte_20000948++ + 1;
              }
            }
            else
            {
              result = 27;
              byte_20000938 = 27;
            }
            break;
          case 24:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              byte_20000996 = 0;
              if ( strstr(v17, "2025") )
                word_20000960 = 30;
              result = sub_8008760((unsigned __int8)word_20000960);
              if ( result )
              {
                byte_20000938 = 25;
                byte_200037D6 = 1;
                byte_2000093A = 0;
              }
              else
              {
                result = (unsigned __int8)byte_2000093A++ + 1;
                byte_20000938 = 25;
              }
              word_20000952 = 0;
            }
            break;
          case 25:
            result = (int)strstr(v16, "+QHTTPGET: 0");
            if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
            {
              byte_20000996 = 0;
              byte_20000939 = 0;
              byte_20000948 = 0;
              byte_20000949 = 0;
              byte_20000938 = 26;
              byte_200037D6 = 0;
              byte_200015AE = 0;
            }
            else if ( byte_20000996 == 4 && byte_2000093A )
            {
              byte_20000996 = 0;
              ++byte_20000939;
              ++byte_20000948;
              byte_20000938 = 23;
              byte_200037D6 = 0;
              result = 3;
              byte_200015AE = 3;
            }
            else
            {
              result = sub_801B040(&word_20000952, (unsigned __int16)(word_20000960 + 10));
              if ( result )
              {
                result = (int)strstr(v16, "+QHTTPGET: 0");
                if ( result || (result = (unsigned __int8)byte_20000996, byte_20000996 == 1) )
                {
                  byte_20000996 = 0;
                  byte_20000939 = 0;
                  byte_20000948 = 0;
                  byte_20000949 = 0;
                  byte_20000938 = 26;
                  byte_200015AE = 0;
                }
                else
                {
                  ++byte_20000939;
                  ++byte_20000948;
                  if ( !byte_2000093A )
                  {
                    ++byte_20000949;
                    byte_200015AE = 4;
                  }
                  if ( (unsigned __int8)byte_20000949 > 6u )
                  {
                    byte_20000949 = 6;
                    byte_200015AE = 5;
                  }
                  result = 23;
                  byte_20000938 = 23;
                }
                byte_200037D6 = 0;
                word_20000952 = 0;
              }
            }
            break;
          case 26:
            result = sub_801B018(&word_20000952, 0x12Cu);
            if ( result )
            {
              if ( sub_80087E8() )
              {
                sub_8002364(&v11, 40);
                byte_20000996 = 0;
                byte_20000939 = 0;
                byte_20000948 = 0;
                byte_20000938 = 27;
                v9 = sub_8010150(v16, "power");
                dword_20005238 = v9;
                if ( v9 == 0xFFFF )
                {
                  ++byte_2000094A;
                  v11 = 0;
                  if ( (unsigned __int8)byte_2000094A > 4u )
                  {
                    byte_2000094A = 0;
                    byte_200015AE = 1;
                    if ( byte_20002FD1 == 7 )
                    {
                      if ( byte_200015E6 )
                        byte_200015E6 = 0;
                    }
                  }
                }
                else
                {
                  byte_2000094A = 0;
                  v11 = v9;
                  byte_200015AE = 0;
                  byte_20000949 = 0;
                  byte_200015E4 = 9;
                  if ( byte_20002FD1 == 7 )
                    byte_200015E6 = 1;
                }
                v12 = 0;
                v13 = 0;
                v14 = 0;
                sub_80052C4(" = %d, bin_crc = %d.\r\n", v9, v11);
                result = sub_8025188(dword_20000434, (unsigned int)&v11, 0, 2);
                byte_200015AD = 0;
              }
              else
              {
                ++byte_20000939;
                ++byte_20000948;
                if ( (unsigned __int8)++byte_2000094A > 4u )
                {
                  byte_2000094A = 0;
                  byte_200015AE = 2;
                }
                result = 27;
                byte_20000938 = 27;
              }
              word_20000952 = 0;
            }
            break;
          case 27:
            byte_20000939 = 0;
            byte_20000948 = 0;
            byte_20000938 = 1;
            break;
          default:
            return result;
        }
        return result;
      }
    }
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800825C: using guessed type int sub_800825C(void);
// 8028FE4: using guessed type int dword_8028FE4[20];
// 2000002C: using guessed type int dword_2000002C;
// 20000434: using guessed type int dword_20000434;
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 20000938: using guessed type char byte_20000938;
// 20000939: using guessed type char byte_20000939;
// 2000093A: using guessed type char byte_2000093A;
// 2000093B: using guessed type char byte_2000093B;
// 2000093C: using guessed type char byte_2000093C;
// 2000093D: using guessed type char byte_2000093D;
// 2000093E: using guessed type char byte_2000093E;
// 2000093F: using guessed type char byte_2000093F;
// 20000940: using guessed type char byte_20000940;
// 20000941: using guessed type char byte_20000941;
// 20000942: using guessed type char byte_20000942;
// 20000943: using guessed type char byte_20000943;
// 20000944: using guessed type char byte_20000944;
// 20000945: using guessed type char byte_20000945;
// 20000946: using guessed type char byte_20000946;
// 20000947: using guessed type char byte_20000947;
// 20000948: using guessed type char byte_20000948;
// 20000949: using guessed type char byte_20000949;
// 2000094A: using guessed type char byte_2000094A;
// 2000094C: using guessed type _WORD[3];
// 20000952: using guessed type __int16 word_20000952;
// 20000954: using guessed type _BYTE[4];
// 20000958: using guessed type __int16 word_20000958;
// 2000095A: using guessed type __int16 word_2000095A;
// 2000095C: using guessed type _WORD;
// 2000095E: using guessed type __int16 word_2000095E;
// 20000960: using guessed type __int16 word_20000960;
// 20000995: using guessed type char byte_20000995;
// 20000996: using guessed type char byte_20000996;
// 20000997: using guessed type __int16 word_20000997;
// 2000099C: using guessed type int dword_2000099C;
// 200009A0: using guessed type int dword_200009A0;
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];
// 200015A4: using guessed type __int16 word_200015A4;
// 200015A6: using guessed type char byte_200015A6;
// 200015A7: using guessed type char byte_200015A7;
// 200015A8: using guessed type int dword_200015A8;
// 200015AC: using guessed type char byte_200015AC;
// 200015AD: using guessed type char byte_200015AD;
// 200015AE: using guessed type char byte_200015AE;
// 200015AF: using guessed type char byte_200015AF;
// 200015B4: using guessed type char byte_200015B4;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD1: using guessed type char byte_20002FD1;
// 200037D6: using guessed type char byte_200037D6;
// 200037D8: using guessed type char byte_200037D8;
// 200037DC: using guessed type char byte_200037DC;
// 200038FD: using guessed type int dword_200038FD;
// 20003C39: using guessed type char byte_20003C39;
// 20004360: using guessed type char byte_20004360;
// 20005238: using guessed type int dword_20005238;
// 2000523C: using guessed type int dword_2000523C;
// 20005240: using guessed type int dword_20005240;
// 20005244: using guessed type int dword_20005244;
// 20005260: using guessed type _DWORD dword_20005260[11264];

//----- (08009B0C) --------------------------------------------------------
int sub_8009B0C()
{
  unsigned __int8 *v0; // r0
  const char *v1; // r0
  const char *v3; // [sp+Ch] [bp-1Ch] BYREF
  unsigned __int8 v4; // [sp+11h] [bp-17h]
  unsigned __int8 v5; // [sp+12h] [bp-16h]
  unsigned __int8 v6; // [sp+13h] [bp-15h]

  v0 = strstr(byte_200009A4, (unsigned __int8 *)&dword_8009C1C);
  if ( !v0 )
    return 0;
  LOWORD(v3) = 100 * (v0[2] - 48) + 10 * (v0[3] - 48) + v0[4] + 1000 * (v0[1] - 48) - 2048;
  BYTE2(v3) = 10 * (v0[6] - 48) - 48 + v0[7];
  HIBYTE(v3) = 10 * (v0[9] - 48) - 48 + v0[10];
  v4 = 10 * (v0[12] - 48) - 48 + v0[13];
  v5 = 10 * (v0[15] - 48) - 48 + v0[16];
  v1 = (const char *)(unsigned __int8)(10 * (v0[18] - 48) - 48 + v0[19]);
  v6 = (unsigned __int8)v1;
  sub_80052C4(
    "=%d&ble=%d&mqqt=%d&ct_t=%d&ct_w=%d&ct_p=%s&ct_m=%s",
    (unsigned __int16)v3,
    BYTE2(v3),
    HIBYTE(v3),
    v4,
    v5,
    v1,
    v3);
  if ( !sub_8004DB8((unsigned __int8 *)&v3) )
    return 0;
  sub_802085C((unsigned __int8)v3, BYTE2(v3), HIBYTE(v3));
  sub_8020888(v4, v5, v6);
  if ( !byte_20003A0A )
  {
    byte_20003A0A = 1;
    sub_8018F5C(2, 203);
  }
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8009C1C: using guessed type int dword_8009C1C;
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];
// 20003A0A: using guessed type char byte_20003A0A;

//----- (08009C2C) --------------------------------------------------------
BOOL __fastcall sub_8009C2C(int a1, int a2)
{
  int v4; // r6
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r1
  int v7; // r0
  char *v8; // r5
  int i; // r4
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // [sp+78h] [bp-A0h]
  int v13; // [sp+A4h] [bp-74h]
  int v14; // [sp+BCh] [bp-5Ch]
  int v15; // [sp+C0h] [bp-58h]
  int v16; // [sp+C4h] [bp-54h]
  int v17; // [sp+C8h] [bp-50h]
  int v18; // [sp+CCh] [bp-4Ch]
  int v19; // [sp+D0h] [bp-48h]
  int v20; // [sp+D4h] [bp-44h]
  int v21; // [sp+D8h] [bp-40h]
  int v22; // [sp+DCh] [bp-3Ch]
  int v23; // [sp+E0h] [bp-38h]
  int v24; // [sp+E4h] [bp-34h]
  int v25; // [sp+E8h] [bp-30h]
  int v26; // [sp+100h] [bp-18h] BYREF

  sub_80057C4(0x441u, (int)&byte_2000303B, 1);
  if ( byte_2000303B && byte_2000303B != 1 && byte_2000303B != 2 )
    byte_2000303B = 0;
  if ( byte_2000303B == 1 )
    v4 = 2;
  else
    v4 = (unsigned __int8)byte_2000303B;
  sub_80052C4("http://www.hamedata.com/app/download/neng/HM_HIE_FC41D_remote_ota.rbl", v4);
  v22 = HIBYTE(dword_20005260[85 * a2 + 70]);
  v23 = LOBYTE(dword_20005260[85 * a2 + 71]);
  v24 = BYTE1(dword_20005260[85 * a2 + 71]);
  v25 = BYTE2(dword_20005260[85 * a2 + 71]);
  v18 = *(unsigned __int16 *)((char *)&dword_20005260[85 * a2 + 68] + 1);
  v19 = *(unsigned __int16 *)((char *)&dword_20005260[85 * a2 + 68] + 3);
  v20 = *(__int16 *)((char *)&dword_20005260[85 * a2 + 69] + 1);
  v21 = *(__int16 *)((char *)&dword_20005260[85 * a2 + 70] + 1);
  v14 = *(unsigned __int16 *)((char *)&dword_20005260[85 * a2 + 66] + 3);
  v15 = *(unsigned __int16 *)((char *)&dword_20005260[85 * a2 + 67] + 1);
  v16 = HIBYTE(dword_20005260[85 * a2 + 3]);
  v17 = *(unsigned __int16 *)((char *)&dword_20005260[85 * a2 + 67] + 3);
  v13 = *(_DWORD *)((char *)&dword_20005260[85 * a2 + 63] + 3);
  v5 = (unsigned __int8 *)&dword_20005260[85 * a2];
  v12 = v5 + 230;
  v6 = v5 + 102;
  v5 += 14;
  sprintf(
    (int)byte_200011A4,
    (const char *)&dword_80295B4,
    &unk_200038E3,
    &unk_20004152,
    *((_DWORD *)v5 + 17),
    *((_DWORD *)v5 + 18),
    *((_DWORD *)v5 + 10),
    *((_DWORD *)v5 + 11),
    *((_DWORD *)v5 + 12),
    *((_DWORD *)v5 + 13),
    *((_DWORD *)v5 + 14),
    *((_DWORD *)v5 + 15),
    v5[2],
    v5[4],
    *((unsigned __int16 *)v5 + 5),
    *((__int16 *)v5 + 6),
    *(v5 - 2),
    *((unsigned __int16 *)v5 + 8),
    *((unsigned __int16 *)v5 + 9),
    *(v5 - 1),
    *v5,
    *((unsigned __int16 *)v5 + 7),
    *((unsigned __int16 *)v5 + 15),
    *((unsigned __int16 *)v5 + 16),
    *((unsigned __int16 *)v5 + 17),
    *((unsigned __int16 *)v5 + 18),
    151,
    *((unsigned __int16 *)v5 + 19),
    *((__int16 *)v5 + 10),
    *((__int16 *)v5 + 11),
    *((__int16 *)v5 + 12),
    *((__int16 *)v5 + 13),
    *((__int16 *)v5 + 14),
    v6,
    v12,
    LOWORD(dword_20005260[85 * a2 + 1]),
    BYTE2(dword_20005260[85 * a2 + 1]),
    HIBYTE(dword_20005260[85 * a2 + 1]),
    (unsigned __int8)byte_20000967,
    (unsigned __int8)byte_20000968,
    (unsigned __int8)byte_20000969,
    a1,
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 60] + 3),
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 61] + 3),
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 62] + 3),
    v13,
    HIBYTE(dword_20005260[85 * a2 + 4]),
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 19] + 2),
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 64] + 3),
    *(_DWORD *)((char *)&dword_20005260[85 * a2 + 65] + 3),
    BYTE1(dword_20005260[85 * a2 + 5]),
    v14,
    v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25);
  v26 = (unsigned __int16)sub_80023E2(byte_200011A4);
  sub_80052C4("[HTTP] Upload data_len : %d, data: %s.\r\n\r\n", v26, (const char *)byte_200011A4);
  v7 = sub_8003AE8(0, (int)byte_200011A4, &v26, (int)&dword_2000096C[6], 16);
  v8 = (char *)v7;
  if ( !v7 )
    return 0;
  if ( byte_200037D5 == 1 )
  {
    sub_80052C4("\r\n<<< Output info: \r\n    [Encrypted data (%d byte)]: ", (unsigned __int16)v26);
    for ( i = 0; i < (unsigned __int16)v26; ++i )
      sub_80052C4("%02x ", (unsigned __int8)v8[i]);
    sub_80052C4("\r\n");
  }
  sub_80040A0(v8, (unsigned __int16)v26, (int)byte_20004D94, 0x400u);
  v11 = sub_80023E2((unsigned __int8 *)byte_20004D94);
  sub_80052C4("\r\n    [URL Base64 data (%d byte)]: %s.\r\n\r\n", v11, byte_20004D94);
  sub_8002364(byte_200011A4, 1024);
  sprintf((int)byte_200011A4, (const char *)dword_8029564, dword_2000096C[v4], byte_20004D94);
  return sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_8009F44, 0, 300) != 0;
}
// 8009DC2: too many varargs, some ignored
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 8009F44: using guessed type int dword_8009F44;
// 8029564: using guessed type int dword_8029564[3];
// 80295B4: using guessed type int dword_80295B4;
// 20000967: using guessed type char byte_20000967;
// 20000968: using guessed type char byte_20000968;
// 20000969: using guessed type char byte_20000969;
// 2000096C: using guessed type _DWORD dword_2000096C[10];
// 20000997: using guessed type __int16 word_20000997;
// 200011A4: using guessed type unsigned __int8 byte_200011A4[1024];
// 2000303B: using guessed type char byte_2000303B;
// 200037D5: using guessed type char byte_200037D5;
// 20005260: using guessed type _DWORD dword_20005260[11264];

//----- (08009F48) --------------------------------------------------------
int __fastcall sub_8009F48(int a1)
{
  int result; // r0

  sub_80057C4(0x441u, (int)&byte_2000303B, 1);
  if ( byte_2000303B && byte_2000303B != 1 && byte_2000303B != 2 )
    byte_2000303B = 0;
  sub_80052C4("[HTTP] URL server type: %d\r\n", (unsigned __int8)byte_2000303B);
  switch ( a1 )
  {
    case 1:
      sprintf((int)byte_200011A4, (const char *)dword_8029468, dword_2000096C[(unsigned __int8)byte_2000303B]);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 2:
      sub_800FD78();
      sprintf(
        (int)byte_200011A4,
        (const char *)&dword_8029390,
        dword_2000096C[(unsigned __int8)byte_2000303B],
        dword_2000096C[(unsigned __int8)byte_2000303B + 3],
        &unk_200038E3,
        &dword_200038FD,
        &dword_20003A0B,
        151,
        BYTE2(dword_20002E7E));
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 3:
      if ( !word_20002FC5 || (unsigned __int16)word_20002FC5 == 0xFFFF )
        word_20002FC5 = 1;
      sprintf((int)byte_200011A4, (const char *)&off_8029400, (unsigned __int16)word_20002FC5);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 4:
      sprintf(
        (int)byte_200011A4,
        (const char *)dword_80294B0,
        dword_2000096C[(unsigned __int8)byte_2000303B],
        &unk_200038E3);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 5:
      sprintf(
        (int)byte_200011A4,
        (const char *)dword_8029514,
        dword_2000096C[(unsigned __int8)byte_2000303B],
        &unk_200038E3);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 6:
      sprintf((int)byte_200011A4, "AT+QHTTPCFG=\"url\",\"http://%s/api/v1/data\"", byte_20003A13);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    case 7:
      sprintf((int)byte_200011A4, "AT+QHTTPCFG=\"url\",\"http://%s/v1/json\"", byte_20003A13);
      if ( !sub_8008344(byte_200011A4, (unsigned __int8 *)&dword_800A0FC, 0, 300) )
        goto LABEL_24;
      result = 1;
      break;
    default:
LABEL_24:
      result = 0;
      break;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800A0FC: using guessed type int dword_800A0FC;
// 8029390: using guessed type int dword_8029390;
// 8029400: using guessed type _UNKNOWN *off_8029400;
// 8029468: using guessed type int dword_8029468[6];
// 80294B0: using guessed type int dword_80294B0[9];
// 8029514: using guessed type int dword_8029514[12];
// 2000096C: using guessed type _DWORD dword_2000096C[10];
// 200011A4: using guessed type unsigned __int8 byte_200011A4[1024];
// 20002E7E: using guessed type int dword_20002E7E;
// 20002FC5: using guessed type __int16 word_20002FC5;
// 2000303B: using guessed type char byte_2000303B;
// 200038FD: using guessed type int dword_200038FD;
// 20003A0B: using guessed type int dword_20003A0B;

//----- (0800A170) --------------------------------------------------------
int __fastcall sub_800A170(__int64 a1)
{
  sub_800FFA4(a1);
  sub_8018F5C(2, 200);
  sub_800E6C8();
  sub_8007EEC();
  sub_800E9EC(1);
  sub_8008028();
  sub_800FF64();
  sub_800E860();
  word_200037DD = 15;
  return sub_800FD78();
}
// 200037DD: using guessed type __int16 word_200037DD;

//----- (0800A1AC) --------------------------------------------------------
int sub_800A1AC()
{
  switch ( byte_200037D4[0] )
  {
    case 0:
      if ( sub_8007038() )
        byte_200037D4[0] = 1;
      break;
    case 1:
      if ( sub_800E2E4() )
        byte_200037D4[0] = 4;
      break;
    case 2:
      if ( sub_800F208() )
        byte_200037D4[0] = 4;
      break;
    case 3:
      if ( sub_800A494() )
        byte_200037D4[0] = 4;
      break;
    case 4:
      if ( byte_20000930 )
      {
        if ( byte_20004360 )
        {
          if ( !byte_2000436E || byte_2000436F == 1 )
            byte_200037D4[0] = 3;
        }
        else
        {
          byte_200037D4[0] = 0;
        }
      }
      else
      {
        byte_200037D4[0] = 2;
      }
      break;
    default:
      byte_200037D4[0] = 4;
      break;
  }
  sub_8007844();
  sub_800F740();
  sub_800CAE8();
  return sub_8005C20();
}
// 20000930: using guessed type char byte_20000930;
// 20004360: using guessed type char byte_20004360;
// 2000436E: using guessed type char byte_2000436E;
// 2000436F: using guessed type char byte_2000436F;

//----- (0800A240) --------------------------------------------------------
int sub_800A240()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_8007A98();
  sub_800FD78();
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    sprintf(
      (int)byte_20004974,
      "force_mark = %d, chrg_soc_top = %d.\r\n",
      (unsigned __int16)word_20003F4D,
      (unsigned __int16)dword_20003F4F);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v1,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003F4D: using guessed type __int16 word_20003F4D;
// 20003F4F: using guessed type int dword_20003F4F;
// 20003F53: using guessed type __int16 word_20003F53;
// 20003F55: using guessed type int dword_20003F55;
// 20003F59: using guessed type __int16 word_20003F59;
// 20003F5B: using guessed type int dword_20003F5B;
// 20003F5F: using guessed type __int16 word_20003F5F;
// 20003F61: using guessed type char byte_20003F61;
// 20003F62: using guessed type char byte_20003F62;
// 20003F63: using guessed type __int16 word_20003F63;
// 20003F65: using guessed type int dword_20003F65;
// 20003F69: using guessed type int dword_20003F69;
// 20003F6D: using guessed type int dword_20003F6D;
// 20003F71: using guessed type __int16 word_20003F71;
// 20003F73: using guessed type __int16 word_20003F73;
// 20003F75: using guessed type int dword_20003F75;
// 20003F79: using guessed type int dword_20003F79;
// 20003F7D: using guessed type __int16 word_20003F7D;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800A3A8) --------------------------------------------------------
BOOL __fastcall sub_800A3A8(int a1)
{
  unsigned __int8 v3[72]; // [sp+0h] [bp-48h] BYREF

  sub_8002364(v3, 64);
  sprintf((int)v3, "AT+QMTCLOSE=%d", a1);
  return sub_800DFB4(v3, "OK", 0, 300) && sub_800CB6C(9, 0x3A98u, 300);
}

//----- (0800A400) --------------------------------------------------------
BOOL __fastcall sub_800A400(int a1, const char *a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[148]; // [sp+4h] [bp-94h] BYREF

  sub_8002364(v8, 128);
  v6 = 0;
  if ( !a2 )
    return 0;
  sprintf((int)v8, "AT+QMTOPEN=%d,\"%s\",%d", a1, a2, a3);
  while ( v6 < 3 )
  {
    if ( sub_800DFB4(v8, "OK", 0, 300) )
      return strstr((unsigned __int8 *)byte_20003A24, "+QMTOPEN: 0, 2") == 0;
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (0800A494) --------------------------------------------------------
int sub_800A494()
{
  int result; // r0

  if ( byte_20000930 )
  {
    if ( byte_200015B4 )
    {
      return 0;
    }
    else if ( byte_2000436E && !byte_2000436F )
    {
      return 1;
    }
    else
    {
      switch ( byte_20004370 )
      {
        case 10:
          sub_800A3A8(0);
          byte_20000914 = 0;
          byte_20004370 = 0;
          break;
        case 4:
          sub_800A3A8(0);
          byte_20000914 = 8;
          byte_20004370 = 0;
          break;
        case 3:
          byte_20000914 = 10;
          byte_20004370 = 0;
          break;
      }
      switch ( byte_20000914 )
      {
        case 0:
          if ( sub_801B040(&word_20000920, 0xAu) )
            byte_20000914 = 1;
          goto LABEL_66;
        case 1:
          if ( sub_800AD8C() )
            byte_20000914 = 2;
          goto LABEL_66;
        case 2:
          if ( sub_800A400(
                 0,
                 "B/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n",
                 8883) )
          {
            byte_20000914 = 3;
            byte_200037D6 = 1;
            byte_200015AF = 1;
            sub_80052C4("Wait for MQTT chatlink......\r\n");
          }
          else
          {
            byte_20000914 = 8;
          }
          goto LABEL_66;
        case 3:
          if ( byte_20004370 == 6 || sub_801B040(&word_2000091E, 0x1Eu) )
          {
            byte_20000914 = 4;
            word_2000091E = 0;
            byte_200037D6 = 0;
            byte_20004370 = 0;
            byte_200015AF = 0;
          }
          goto LABEL_66;
        case 4:
          if ( sub_800AF6C() )
          {
            byte_20000914 = 5;
            word_20000924 = 0;
            sub_80052C4("MQTT chatlink ok!\r\n");
          }
          else
          {
            sub_80052C4("MQTT chatlink err!\r\n");
            if ( (unsigned __int16)++word_20000924 > 2u )
            {
              word_20000924 = 0;
              byte_20000914 = 8;
            }
          }
          goto LABEL_66;
        case 5:
          sub_80052C4("Mqtt link......\r\n");
          if ( sub_800AFB0(0, 0, byte_200038E3, 0, 0) )
            byte_20000914 = 6;
          else
            byte_20000914 = 8;
          goto LABEL_66;
        case 6:
          sub_80052C4("Mqtt subscribe......\r\n");
          if ( sub_800CA3C(0, 1, byte_200038E3, 0) )
            byte_20000914 = 7;
          else
            byte_20000914 = 8;
          goto LABEL_66;
        case 7:
          if ( sub_800C738(
                 0,
                 0,
                 0,
                 0,
                 byte_200038E3,
                 5,
                 "Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAXhlULXxvVfM/fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n") )
          {
            sub_80052C4("Mqtt publish ok!\r\n");
            byte_2000436E = 1;
            byte_2000436F = 0;
            byte_20000914 = 0;
            result = 1;
          }
          else
          {
            byte_20000914 = 8;
LABEL_66:
            result = 0;
          }
          break;
        case 8:
          sub_80052C4("Mqtt chatlink close......\r\n");
          if ( sub_800A3A8(0) )
          {
            sub_80052C4("Mqtt chatlink off!\r\n");
            byte_20000914 = 2;
          }
          else
          {
            byte_20000914 = 9;
          }
          goto LABEL_66;
        case 9:
          if ( sub_801B018(&word_20000920, 0x12Cu) )
          {
            sub_80052C4("Mqtt chatlink close again......\r\n");
            sub_800A3A8(0);
            word_20000920 = 0;
            ++byte_20000915;
            byte_20000914 = 0;
            if ( (unsigned __int8)byte_20000915 > 0xAu )
            {
              byte_20000915 = 0;
              byte_20000914 = 10;
            }
          }
          goto LABEL_66;
        case 10:
          sub_80052C4("MQTT ERROR!\r\n");
          sub_800A3A8(0);
          if ( (byte_20002FD1 == 2 || byte_20002FD1 == 7) && byte_200015E6 == 1 && !byte_20002F60 || byte_20002F60 == 5 )
          {
            if ( (unsigned __int8)++byte_20000915 <= 1u )
            {
              byte_20000914 = 0;
            }
            else
            {
              byte_20000915 = 0;
              byte_20000914 = 11;
            }
            sub_80052C4("CT connected, mqtt_err_cnt: %d. Wait for init MQTT......\r\n", (unsigned __int8)byte_20000915);
          }
          else
          {
            byte_20000914 = 0;
          }
          sub_8018F5C(4, 410);
          if ( byte_200015E6 == 1 && byte_20004360 != 2 && sub_801B040(algn_20000922, 0x78u) )
          {
            sub_80080B4(1);
          }
          else if ( byte_20004360 != 2 && sub_801B040(algn_20000922, 0x78u) )
          {
            sub_80080B4(0);
          }
          goto LABEL_66;
        case 11:
          if ( sub_801B040(algn_20000926, 0x78u) )
            byte_20000914 = 0;
          goto LABEL_66;
        default:
          goto LABEL_66;
      }
    }
  }
  else
  {
    byte_200037D4[0] = 2;
    return 0;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20000914: using guessed type char byte_20000914;
// 20000915: using guessed type char byte_20000915;
// 2000091E: using guessed type __int16 word_2000091E;
// 20000920: using guessed type __int16 word_20000920;
// 20000922: using guessed type _BYTE[2];
// 20000924: using guessed type __int16 word_20000924;
// 20000926: using guessed type _BYTE[2];
// 20000930: using guessed type char byte_20000930;
// 200015AF: using guessed type char byte_200015AF;
// 200015B4: using guessed type char byte_200015B4;
// 200015E6: using guessed type char byte_200015E6;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD1: using guessed type char byte_20002FD1;
// 200037D6: using guessed type char byte_200037D6;
// 20004360: using guessed type char byte_20004360;
// 2000436E: using guessed type char byte_2000436E;
// 2000436F: using guessed type char byte_2000436F;
// 20004370: using guessed type char byte_20004370;

//----- (0800A88C) --------------------------------------------------------
int sub_800A88C()
{
  unsigned int v0; // r4
  int result; // r0

  LOBYTE(v0) = 0;
  while ( 1 )
  {
    if ( byte_200037D6 == 1 )
    {
      sub_80052C4("[MQTT] Wait for urc, don't check mqtt state!\r\n");
      return 1;
    }
    if ( sub_800DFB4("AT+QMTCONN?", (unsigned __int8 *)&dword_800A8F8, 0, 900)
      && (strstr((unsigned __int8 *)byte_20003A24, "+QMTCONN: 0,3") || byte_20004370 == 1) )
    {
      break;
    }
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(200);
    if ( v0 >= 9 )
    {
      sub_80052C4("[MQTT] State disconnected!\r\n");
      byte_2000436E = 0;
      return 0;
    }
  }
  result = 1;
  byte_2000436E = 1;
  byte_20004370 = 0;
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800A8F8: using guessed type int dword_800A8F8;
// 200037D6: using guessed type char byte_200037D6;
// 2000436E: using guessed type char byte_2000436E;
// 20004370: using guessed type char byte_20004370;

//----- (0800A96C) --------------------------------------------------------
int __fastcall sub_800A96C(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"datatype\",%d,%d", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"datatype\",%d", a2);
      if ( sub_800DFB4(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800AA24) --------------------------------------------------------
int sub_800AA24()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_8007B70();
  sub_800FD78();
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    sprintf(
      (int)byte_20004974,
      "//%s.hamedata.com/app/neng/getDateInfo%s.php?uid=%s&fcv=%s&aid=%s&sv=%d&sbv=%d&mv=101\"",
      (const char *)(unsigned __int8)byte_20003C26,
      (const char *)(unsigned __int16)word_20003C27,
      (const char *)(unsigned __int16)word_20003C29,
      (const char *)(unsigned __int16)word_20003C2B,
      (const char *)(unsigned __int16)word_20003C2D,
      (unsigned __int16)word_20003C2F,
      (unsigned __int16)word_20003C31);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v1,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003C26: using guessed type char byte_20003C26;
// 20003C27: using guessed type __int16 word_20003C27;
// 20003C29: using guessed type __int16 word_20003C29;
// 20003C2B: using guessed type __int16 word_20003C2B;
// 20003C2D: using guessed type __int16 word_20003C2D;
// 20003C2F: using guessed type __int16 word_20003C2F;
// 20003C31: using guessed type __int16 word_20003C31;
// 20003C33: using guessed type __int16 word_20003C33;
// 20003C35: using guessed type __int16 word_20003C35;
// 20003C37: using guessed type __int16 word_20003C37;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800AB00) --------------------------------------------------------
int sub_800AB00()
{
  int v0; // r5
  int result; // r0
  unsigned int i; // r4
  unsigned __int16 *v3; // r3
  unsigned __int16 v4; // r11
  int v5; // r4
  unsigned __int8 v6[88]; // [sp+18h] [bp-58h] BYREF

  v0 = 0;
  sub_8002364(v6, 52);
  sub_800FD78();
  sub_8002364(byte_20004974, 1024);
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v3 = (unsigned __int16 *)&dword_20003D81 + 7 * i;
      sprintf(
        (int)v6,
        "err%d=%d|%d|%d|%d|%d|%lld.",
        i,
        *v3,
        *((unsigned __int8 *)v3 + 2),
        *((unsigned __int8 *)v3 + 3),
        *((unsigned __int8 *)v3 + 4),
        *((unsigned __int8 *)v3 + 5),
        *(_QWORD *)(v3 + 3));
      v4 = (unsigned __int16)sub_80023E2(v6);
      qmemcpy((unsigned int)&byte_2000436E[v0 + 1542], (unsigned int)v6, v4);
      v0 = (unsigned __int16)(v0 + v4);
      sub_8002364(v6, 52);
    }
    v5 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sub_8002364(byte_20004574, 1024);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v5,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003D81: using guessed type int dword_20003D81;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800AC44) --------------------------------------------------------
int sub_800AC44()
{
  int v0; // r5
  int result; // r0
  unsigned int i; // r4
  unsigned __int16 *v3; // r3
  unsigned __int16 v4; // r11
  int v5; // r4
  unsigned __int8 v6[88]; // [sp+18h] [bp-58h] BYREF

  v0 = 0;
  sub_8002364(v6, 52);
  sub_800FD78();
  sub_8002364(byte_20004974, 1024);
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v3 = (unsigned __int16 *)&byte_20003E99[9 * i];
      sprintf(
        (int)v6,
        "event%d=%d|%d|%d|%d|%d|%d|%d.",
        i,
        *v3,
        *((unsigned __int8 *)v3 + 2),
        *((unsigned __int8 *)v3 + 3),
        *((unsigned __int8 *)v3 + 4),
        *((unsigned __int8 *)v3 + 5),
        *((unsigned __int8 *)v3 + 6),
        *(unsigned __int16 *)((char *)v3 + 7));
      v4 = (unsigned __int16)sub_80023E2(v6);
      qmemcpy((unsigned int)&byte_2000436E[v0 + 1542], (unsigned int)v6, v4);
      v0 = (unsigned __int16)(v0 + v4);
      sub_8002364(v6, 52);
    }
    v5 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sub_8002364(byte_20004574, 1024);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v5,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003E99: using guessed type _BYTE byte_20003E99[180];
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800AD8C) --------------------------------------------------------
int sub_800AD8C()
{
  int result; // r0

  if ( (unsigned __int8)byte_20000917 <= 0xCu )
  {
    switch ( byte_20000916 )
    {
      case 0:
        if ( sub_800E570(1, 0, 2) )
        {
          byte_20000916 = 1;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 1:
        if ( sub_800E230(1, 0, "0xffff") )
        {
          byte_20000916 = 2;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 2:
        if ( sub_800E61C(1, 0, 4) )
        {
          byte_20000916 = 3;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 3:
        if ( sub_800C984(1, 0, 1, 0) )
        {
          byte_20000916 = 4;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 4:
        if ( sub_800CC74(1, 0, 3) )
        {
          byte_20000916 = 5;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 5:
        if ( sub_800A96C(1, 0, 0) )
        {
          byte_20000916 = 6;
          byte_20000917 = 0;
        }
        else
        {
          ++byte_20000917;
        }
        goto LABEL_24;
      case 6:
        if ( !sub_800AEB0(1, 0, 120) )
          goto LABEL_24;
        byte_20000916 = 0;
        byte_20000917 = 0;
        result = 1;
        break;
      default:
LABEL_24:
        result = 0;
        break;
    }
  }
  else
  {
    sub_80052C4((const char *)dword_800AE8C);
    sub_800A3A8(0);
    sub_8023A34(300);
    byte_20000917 = 0;
    return 0;
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800AE8C: using guessed type int dword_800AE8C[7];
// 20000916: using guessed type char byte_20000916;
// 20000917: using guessed type char byte_20000917;

//----- (0800AEB0) --------------------------------------------------------
int __fastcall sub_800AEB0(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"keepalive\",%d,%d", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"keepalive\",%d", a2);
      if ( sub_800DFB4(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800AF6C) --------------------------------------------------------
int sub_800AF6C()
{
  unsigned int v0; // r4

  LOBYTE(v0) = 0;
  do
  {
    if ( sub_800DFB4("AT+QMTOPEN?", "+QMTOPEN: 0", 0, 600) )
      return 1;
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  while ( v0 < 3 );
  return 0;
}

//----- (0800AFB0) --------------------------------------------------------
int __fastcall sub_800AFB0(int a1, int a2, const char *a3, const char *a4, const char *a5)
{
  unsigned int v9; // r4
  unsigned __int8 v11[100]; // [sp+Ch] [bp-64h] BYREF

  sub_8002364(v11, 64);
  v9 = 0;
  if ( !a3 )
    return 0;
  while ( v9 < 3 )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        if ( !a4 || !a5 )
          return 0;
        sprintf((int)v11, "AT+QMTCONN=%d,\"%s\",\"%s\",\"%s\"", a2, a3, a4, a5);
        if ( sub_800DFB4(v11, "OK", 0, 300) && sub_800CB6C(5, 0x3A98u, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v11, "AT+QMTCONN=%d,\"hm_%s\"", a2, a3);
      if ( sub_800DFB4(v11, "OK", 0, 300) && sub_800CB6C(5, 0x3A98u, 300) )
        return 1;
    }
    v9 = (unsigned __int8)(v9 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (0800B098) --------------------------------------------------------
int __fastcall sub_800B098(int a1)
{
  unsigned __int8 v1; // r0

  sub_800FD78();
  if ( !sub_80256C8(dword_20000458, 500) )
    return a1;
  sprintf(
    (int)byte_20004974,
    "CFG=\"url\",\"https://eu.hamedata.com/external-services/api/v1/electrics/prices/current?zone=%d\"",
    (unsigned __int8)byte_20002FD1);
  v1 = (unsigned __int8)sub_80023E2((unsigned __int8 *)byte_20004974);
  sprintf(
    (int)byte_20004574,
    "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
    (const char *)&dword_20003A0B,
    byte_200038E3,
    v1,
    byte_20004974);
  sub_800E77E(byte_20004574);
  return sub_8025188(dword_20000458, 0, 0, 0);
}
// 20000458: using guessed type int dword_20000458;
// 200015AE: using guessed type char byte_200015AE;
// 20002FD1: using guessed type char byte_20002FD1;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];
// 20005238: using guessed type int dword_20005238;
// 2000523C: using guessed type int dword_2000523C;
// 20005244: using guessed type int dword_20005244;

//----- (0800B168) --------------------------------------------------------
int __fastcall sub_800B168(int result, unsigned int a2)
{
  unsigned int v2; // r1
  bool v3; // zf
  int v4; // r2
  char *v5; // r4
  int v6; // r0
  unsigned __int16 v7; // r0
  int v8; // r4
  unsigned int v9; // r6
  int v10; // r5
  int v11; // r7
  unsigned __int8 v12; // r0
  char *v13; // r4
  int v14; // r5
  int v15; // r7
  unsigned __int8 v16; // r0
  int v17; // r5
  int v18; // r5
  unsigned __int16 v19; // r0
  int v20; // r5
  unsigned __int16 v21; // r0
  int v22; // r0
  int v23; // r4
  unsigned __int16 v24; // r0
  bool v25; // zf
  bool v26; // zf
  int v27; // r4
  int v28; // r0
  int v29; // r4
  int v30; // r0
  int v31; // r0
  int v32; // r0
  int v33; // r0
  bool v34; // zf
  int v35; // r0
  int v36; // r4
  int v37; // r0
  int v38; // r0
  int v39; // r0
  int v40; // r4
  int v41; // r0
  int v42; // r1
  int v43; // r2
  int v44; // r0
  unsigned int v45; // r4
  int v46; // r1
  int v47; // r2
  int v48; // r0
  unsigned int v49; // r4
  int v50; // r1
  int v51; // r2
  int v52; // r1
  int v53; // r2
  int v54; // r6
  bool v55; // zf
  int v56; // r4
  int v57; // r6
  int v58; // r0
  int v59; // r5
  int v60; // r1
  int v61; // r1
  int v62; // r0
  unsigned __int16 v63; // r0
  int v64; // r5
  unsigned __int16 v65; // r0
  unsigned __int16 v66; // r0
  unsigned __int16 v67; // r0
  unsigned __int16 v68; // r0
  int v69; // r6
  unsigned int v70; // r4
  int v71; // r6
  unsigned __int16 v72; // r0
  int v73; // r7
  unsigned __int16 v74; // r0
  unsigned __int16 v75; // r0
  int v76; // r0
  char v77[20]; // [sp+8h] [bp-50h] BYREF
  int v78; // [sp+1Ch] [bp-3Ch] BYREF
  int v79; // [sp+20h] [bp-38h]
  int v80; // [sp+24h] [bp-34h] BYREF
  int v81; // [sp+28h] [bp-30h]

  if ( result && a2 >= 3 )
  {
    v2 = a2 + result;
    v3 = *(_BYTE *)(v2 - 1) == 10;
    while ( 1 )
    {
      if ( !v3 )
        return result;
      v4 = *(unsigned __int8 *)(v2 - 2);
      v3 = v4 == 13;
      if ( v4 == 13 )
      {
        v2 = *(unsigned __int8 *)(v2 - 3);
        v3 = v2 == 34;
        if ( v2 == 34 )
          break;
      }
    }
    result = strstr(result + 15, &loc_800B590);
    if ( result )
    {
      v81 = result + 3;
      result = (unsigned __int8)sub_8002644(result + 3);
      v5 = byte_20002F5F;
      switch ( (char)result )
      {
        case 1:
          v6 = sub_80052C4("[MQTT] Get work data...\r\n");
          return sub_800CD2C(v6);
        case 2:
          sub_8002364(v77, 32);
          if ( strstr(v81, "md=0") )
          {
            byte_20002F60 = 0;
            sub_800591C(769, &byte_20002F60, 1);
          }
          else if ( strstr(v81, "md=1") )
          {
            byte_20002F60 = 1;
            sub_800591C(769, &byte_20002F60, 1);
          }
          else if ( strstr(v81, "md=5") )
          {
            byte_20002F60 = 5;
            sub_800591C(769, &byte_20002F60, 1);
          }
          sub_80052C4("[MQTT] Set work mode : %d.\r\n", (unsigned __int8)byte_20002F60);
          sprintf(v77, "cd=%d,md=%d", 2, (unsigned __int8)byte_20002F60);
          v7 = sub_80023E2(v77);
          return sub_800C8E4(v77, v7);
        case 3:
          sub_8002364(v77, 32);
          sub_80052C4("[MQTT] Set manual mode or economy mode info...\r\n");
          if ( strstr(v81, "md=1") )
          {
            byte_20002F60 = 1;
            sub_800591C(769, &byte_20002F60, 1);
            sub_80052C4("[MQTT] user_work_mode = %d\r\n", (unsigned __int8)byte_20002F60);
            result = strstr(v81, "nm");
            v8 = result;
            if ( result )
            {
              v9 = (unsigned __int8)sub_8002644(result + 3);
              result = sub_80052C4("[MQTT] time_num = %d\r\n", v9);
              if ( v9 < 0xA )
              {
                result = strstr(v8, "bt");
                v10 = result;
                if ( result )
                {
                  v11 = (unsigned __int8)sub_8002644(result + 3);
                  v12 = sub_8002644(v10 + 6);
                  v13 = &byte_20002F5F[10 * v9];
                  *((_WORD *)v13 + 3) = v12 | (unsigned __int16)((_WORD)v11 << 8);
                  sub_80052C4("[MQTT] start_time = %d:%d\r\n", v11, v12);
                  result = strstr(v10, "et");
                  v14 = result;
                  if ( result )
                  {
                    v15 = (unsigned __int8)sub_8002644(result + 3);
                    v16 = sub_8002644(v14 + 6);
                    *((_WORD *)v13 + 4) = v16 | (unsigned __int16)((_WORD)v15 << 8);
                    sub_80052C4("[MQTT] end_time = %d:%d\r\n", v15, v16);
                    result = strstr(v14, "wk");
                    v17 = result;
                    if ( result )
                    {
                      v13[2] = sub_8002644(result + 3);
                      result = strstr(v17, "vv");
                      v18 = result;
                      if ( result )
                      {
                        *((_WORD *)v13 + 2) = sub_8002644(result + 3);
                        result = strstr(v18, "as");
                        if ( result )
                        {
                          v13[3] = sub_8002644(result + 3);
                          sub_80058E0(v9);
                          sub_80052C4(
                            "[MQTT] grid_power = %d, grid_state = %d\r\n",
                            *((__int16 *)v13 + 2),
                            (unsigned __int8)v13[3]);
                          sprintf(v77, "cd=%d,md=%d", 3, (unsigned __int8)byte_20002F60);
                          v19 = sub_80023E2(v77);
                          return sub_800C8E4(v77, v19);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            result = strstr(v81, "md=5");
            if ( result )
            {
              byte_20002F60 = 5;
              sub_800591C(769, &byte_20002F60, 1);
              byte_200015A6 = 1;
              sub_80052C4("[MQTT] user_work_mode = %d\r\n", (unsigned __int8)byte_20002F60);
              result = strstr(v81, "nl");
              if ( result )
              {
                v20 = (unsigned __int8)sub_8002644(result + 3);
                sub_80052C4("[MQTT] cur_protect_en = %d\r\n", v20);
                sprintf(v77, "cd=%d,md=%d,nl=%d", 3, (unsigned __int8)byte_20002F60, v20);
                v21 = sub_80023E2(v77);
                return sub_800C8E4(v77, v21);
              }
            }
          }
          return result;
        case 4:
          sub_80052C4("[MQTT] Set local time...\r\n");
          v22 = strstr(v81, "yy");
          v23 = v22;
          if ( !v22 )
            goto LABEL_43;
          v24 = sub_8002644(v22 + 3);
          LOWORD(v79) = v24 - 2000;
          sub_80052C4("[MQTT] Set local time : year = %d\r\n", v24);
          result = strstr(v23, "mm");
          v5 = (char *)result;
          v25 = result == 0;
          goto LABEL_37;
        case 5:
          sub_80052C4("[MQTT] Set reset...\r\n");
          if ( strstr(v81, "rs=1") )
            return sub_8007C0C(1);
          result = strstr(v81, "rs=2");
          v25 = result == 0;
          if ( result )
            return sub_8007C0C(2);
LABEL_37:
          if ( !v25 )
          {
            BYTE2(v79) = sub_8002644(v5 + 3);
            sub_80052C4("[MQTT] Set local time : month = %d.\r\n", BYTE2(v79));
            result = strstr(v5, "rr");
            v5 = (char *)result;
            v26 = result == 0;
LABEL_39:
            if ( !v26 )
            {
              HIBYTE(v79) = sub_8002644(v5 + 3);
              sub_80052C4("[MQTT] Set local time : day = %d.\r\n", HIBYTE(v79));
              result = strstr(v5, "hh");
              v27 = result;
              if ( result )
              {
                BYTE1(v80) = sub_8002644(result + 3);
                sub_80052C4("[MQTT] Set local time : hour = %d.\r\n", BYTE1(v80));
                result = strstr(v27, "mn");
                if ( result )
                {
                  BYTE2(v80) = sub_8002644(result + 3);
                  sub_80052C4("[MQTT] Set local time : min = %d.\r\n", BYTE2(v80));
LABEL_43:
                  sub_802085C((unsigned __int8)v79, BYTE2(v79), HIBYTE(v79));
                  sub_8020888(BYTE1(v80), BYTE2(v80), HIBYTE(v80));
                  return sub_800C800(1);
                }
              }
            }
          }
          return result;
        case 6:
          v28 = sub_80052C4("[MQTT] Get developer mode data...\r\n");
          return sub_800AA24(v28);
        case 7:
          sub_80052C4("[MQTT] Set developer mode data...\r\n");
          result = strstr(v81, "dm");
          v26 = result == 0;
          if ( !result )
            goto LABEL_39;
          v29 = (unsigned __int8)sub_8002644(result + 3);
          result = sub_80052C4("[MQTT] Set develop mode = %d.\r\n", v29);
          switch ( v29 )
          {
            case 0:
              return sub_80080B4(0);
            case 1:
              v32 = sub_80031E4(1);
              v33 = sub_801F610(v32);
              sub_801EA24(v33);
            case 2:
              sub_8007B28(result);
              v30 = sub_80031E4(1);
              v31 = sub_801F610(v30);
              sub_801EA24(v31);
          }
          return result;
        case 8:
          sub_80052C4("[MQTT] Set mode auto change...\r\n");
          if ( strstr(v81, "dt=1") )
          {
            if ( byte_200015E6 == 1 )
            {
              byte_20002F60 = 0;
            }
            else if ( !byte_200015E6 || byte_200015E6 == 2 )
            {
              byte_20002F60 = 1;
            }
            byte_20002FCF = 1;
            sub_800591C(880, &byte_20002FCF, 1);
            sub_800C800(1);
            return sub_80052C4(", http_timer_flag = %d.\r\n", (unsigned __int8)byte_20002F60);
          }
          else
          {
            if ( !strstr(v81, "dt=0") )
              return sub_800C800(0);
            byte_20002FCF = 0;
            sub_800591C(880, &byte_20002FCF, 1);
            sub_800C800(1);
            return sub_80052C4(
                     "[MQTT] Set mode auto change close, g_work_mode_change = %d.\r\n",
                     (unsigned __int8)byte_20002FCF);
          }
        case 9:
          if ( strstr(v81, "ot=0") )
          {
            sub_80052C4("[MQTT] Set fc41d ota, ot = 0.\r\n");
            sub_8007C20(0);
          }
          result = strstr(v81, "ot=1");
          v34 = result == 0;
          goto LABEL_70;
        case 10:
          v35 = sub_80052C4("[MQTT] Get fc41d version...\r\n");
          return sub_800CBBC(v35);
        case 11:
          if ( strstr(v81, "bc=1") )
          {
            sub_80052C4("[MQTT] Set eps enable.\r\n");
            sub_80031EE(1);
            if ( byte_20002F5F[0] == 1 )
              return sub_800C800(1);
            return sub_800C800(0);
          }
          result = strstr(v81, "bc=0");
          v34 = result == 0;
          if ( result )
          {
            sub_80052C4("[MQTT] Set eps disable.\r\n");
            sub_80031EE(0);
            if ( !byte_20002F5F[0] )
              return sub_800C800(1);
            return sub_800C800(0);
          }
LABEL_70:
          if ( !v34 )
          {
            sub_80052C4("[MQTT] Set fc41d ota, ot = 1.\r\n");
            sub_8007C20(1);
          }
          return result;
        case 12:
          v36 = 0;
          v80 = 0;
          if ( !strstr(v81, "ht=0") )
          {
            if ( strstr(v81, "ht=1") )
            {
              v36 = 1;
            }
            else if ( strstr(v81, "ht=2") )
            {
              v36 = 2;
            }
          }
          sub_80057C4(1089, &v80, 1);
          if ( (unsigned __int8)v80 != v36 || (unsigned __int8)v80 == 255 )
          {
            byte_2000303B = v36;
            sub_800591C(1089, &byte_2000303B, 1);
          }
          return sub_80052C4("[MQTT] Set http server type : %d.\r\n", (unsigned __int8)byte_2000303B);
        case 13:
          v37 = sub_80052C4("[MQTT] Get err code info...\r\n");
          return sub_800AB00(v37);
        case 14:
          v38 = sub_80052C4("[MQTT] Get bms data info...\r\n");
          return sub_800A240(v38);
        case 15:
          sub_80052C4("[MQTT] Set version num...\r\n");
          v39 = strstr(v81, "vs");
          if ( v39 )
          {
            v40 = (unsigned __int16)sub_8002644(v39 + 3);
            if ( byte_2000050B == 2 )
            {
              sub_800C800(1);
            }
            else if ( v40 == 800 )
            {
              byte_2000050B = 1;
              word_2000051A = 800;
              sub_800591C(516, &word_2000051A, 2);
              sub_800591C(144, &byte_2000050B, 1);
              v41 = sub_800C800(1);
              sub_800E860(v41);
            }
            else if ( v40 == 2500 )
            {
              byte_2000050B = 0;
              word_2000051A = 2500;
              sub_800591C(516, &word_2000051A, 2);
              sub_800591C(144, &byte_2000050B, 1);
              sub_800C800(1);
            }
            else
            {
              sub_800C800(0);
              sub_80052C4("[MQTT] Set version value err.\r\n");
            }
            return sub_80052C4("[MQTT] Set version = %d, real version = %d.\r\n", v40, (unsigned __int8)byte_2000050B);
          }
          else
          {
            sub_800C800(0);
            return sub_80052C4("[MQTT] Set version err.\r\n", v42, v43);
          }
        case 16:
          v44 = strstr(v81, "cp");
          if ( v44 )
          {
            v45 = (unsigned __int16)sub_8002644(v44 + 3);
            if ( v45 > 0x9C4 )
            {
              sub_800C800(0);
              sub_80052C4("[MQTT] Set max charge power value err.\r\n");
            }
            else
            {
              word_20000518 = v45;
              sub_800591C(514, &word_20000518, 2);
              sub_800C800(1);
            }
            return sub_80052C4(
                     "[MQTT] Set max charge power = %d, real max charge power = %d.\r\n",
                     v45,
                     (unsigned __int16)word_20000518);
          }
          else
          {
            sub_800C800(0);
            return sub_80052C4("[MQTT] Set max charge power err.\r\n", v46, v47);
          }
        case 17:
          v48 = strstr(v81, "dp");
          if ( v48 )
          {
            v49 = (unsigned __int16)sub_8002644(v48 + 3);
            if ( v49 > 0x9C4 )
            {
              sub_800C800(0);
              sub_80052C4("[MQTT] Set max discharge power value err.\r\n");
            }
            else
            {
              if ( byte_2000050B == 1 && v49 > 0x320 )
              {
                sub_800C800(0);
                return sub_80052C4("[MQTT] Set max discharge power value err, over 800W.\r\n", v50, v51);
              }
              word_2000051A = v49;
              sub_800591C(516, &word_2000051A, 2);
              sub_800C800(1);
            }
            return sub_80052C4("%d, current_time_no = %d.\r\n", v49, (unsigned __int16)word_2000051A);
          }
          else
          {
            sub_800C800(0);
            return sub_80052C4("[MQTT] Set max discharge power err.\r\n", v52, v53);
          }
        case 18:
          return sub_800DC20(v81);
        case 19:
          sub_800DB08();
          result = strstr(v81, "meter_data");
          if ( result )
            return sub_800B098();
          return result;
        case 20:
          sub_80052C4("[MQTT] Set FC41D URL OTA...\r\n");
          result = strstr(v81, "len");
          v54 = result;
          v55 = result == 0;
          while ( !v55 )
          {
            v56 = (unsigned __int8)sub_8002644(v54 + 4);
            if ( v56 == 255 )
            {
              sub_800C800(0);
              return sub_80052C4("[MQTT] Set FC41D URL OTA length err.\r\n");
            }
            result = strstr(v54, "url=");
            v55 = result == 0;
            if ( result )
            {
              v57 = result + 4;
              sub_800C800(1);
              sub_8002364(byte_2000390A, 256);
              sub_80023B6(byte_2000390A, v57, v56);
              byte_200037D4[v56 + 310] = 0;
              v58 = strstr(v57, "port=");
              if ( v58 )
              {
                v59 = (unsigned __int16)sub_8002644(v58 + 5);
                sub_80052C4("[MQTT] Receive ota url: %s, url_len = %d, url_port = %d.\r\n", byte_2000390A, v56, v59);
                v60 = (unsigned __int16)sub_80023E2(byte_2000390A);
                return sub_8007DE0(byte_2000390A, v60, v59);
              }
              else
              {
                sub_80052C4("[MQTT] Receive ota url: %s, url_len = %d.\r\n", byte_2000390A, v56);
                v61 = (unsigned __int16)sub_80023E2(byte_2000390A);
                return sub_8007DE0(byte_2000390A, v61, 0);
              }
            }
          }
          return result;
        case 21:
          v62 = sub_80052C4("[MQTT] Get event log info...\r\n");
          return sub_800AC44(v62);
        case 22:
          sub_8002364(v77, 32);
          sub_80052C4("[MQTT] Info active upgrade...\r\n");
          byte_200015A7 = 1;
          sprintf(v77, "cd=%d,ret=%d", 22, 1);
          v63 = sub_80023E2(v77);
          return sub_800C8E4(v77, v63);
        case 23:
          sub_8002364(v77, 32);
          result = strstr(v81, "pm");
          if ( !result )
            return result;
          v64 = (unsigned __int8)sub_8002644(result + 3);
          sub_80052C4("[MQTT] Set parallel machine enable = %d.\r\n", v64);
          switch ( v64 )
          {
            case 2:
              if ( byte_20002FD3 != 1 )
              {
                sub_80052C4("[MQTT] !!! Parallel machine Not ready.\r\n");
                sprintf(v77, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002FD3);
                v65 = sub_80023E2(v77);
                return sub_800C8E4(v77, v65);
              }
              sub_80052C4("[MQTT] Parallel machine ON.\r\n");
              sub_80031F8(2);
              break;
            case 1:
              sub_80052C4("[MQTT] Parallel machine Ready.\r\n");
              sub_80031F8(1);
              break;
            case 0:
              if ( byte_20002FD3 != 1 )
              {
                sub_80052C4("[MQTT] !!! Parallel machine not ready.\r\n");
                sprintf(v77, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002FD3);
                v66 = sub_80023E2(v77);
                return sub_800C8E4(v77, v66);
              }
              sub_80052C4("[MQTT] Parallel machine OFF.\r\n");
              sub_80031F8(0);
              break;
          }
          sprintf(v77, "cd=%d,ret=%d", 23, (unsigned __int8)byte_20002FD3);
          v67 = sub_80023E2(v77);
          return sub_800C8E4(v77, v67);
        case 24:
          sub_8002364(v77, 32);
          if ( strstr(v81, "ip?") )
          {
            sub_80052C4("[MQTT] Get meter ip info...\r\n");
            sub_80057C4(13568, byte_20003A13, 16);
            sprintf(v77, "cd=%d,ip=%s", 24, byte_20003A13);
            v68 = sub_80023E2(v77);
            return sub_800C8E4(v77, v68);
          }
          else
          {
            sub_80052C4("[MQTT] Set P1 IP...\r\n");
            result = strstr(v81, "len");
            v69 = result;
            if ( result )
            {
              v70 = (unsigned __int8)sub_8002644(result + 4);
              if ( v70 <= 0x10 )
              {
                result = strstr(v69, "ip=");
                if ( result )
                {
                  v71 = result + 3;
                  sub_8002364(byte_20003A13, 16);
                  sub_80023B6(byte_20003A13, v71, v70);
                  byte_200037D4[v70 + 575] = 0;
                  sub_80057C4(13568, v77, 16);
                  if ( sub_80023F0(byte_20003A13, v77) )
                  {
                    sub_80052C4("[MQTT] *** Receive ip: %s, read ip: %s.\r\n", byte_20003A13, v77);
                    sub_800591C(13568, byte_20003A13, 16);
                  }
                  sub_80052C4("[MQTT] Receive ip_len = %d, ip: %s, read ip: %s.\r\n", v70, byte_20003A13, v77);
                  sub_8002364(v77, 32);
                  sprintf(v77, "cd=%d,ip=%s", 24, byte_20003A13);
                  v72 = sub_80023E2(v77);
                  return sub_800C8E4(v77, v72);
                }
              }
              else
              {
                sub_800C800(0);
                return sub_80052C4("[MQTT] Set P1 IP len err.\r\n");
              }
            }
          }
          return result;
        case 25:
          sub_8002364(v77, 32);
          result = strstr(v81, "gen");
          if ( result )
          {
            v73 = (unsigned __int8)sub_8002644(result + 4);
            sub_80052C4("[MQTT] Set generator enable = %d.\r\n", v73);
            if ( v73 == 1 )
            {
              sub_80052C4("[MQTT] Generator enable.\r\n");
              byte_20002FD5 = 1;
            }
            else if ( !v73 )
            {
              sub_80052C4("[MQTT] Generator disable.\r\n");
              byte_20002FD5 = 0;
            }
            sprintf(v77, "cd=%d,ret=%d", 25, (unsigned __int8)byte_20002FD5);
            v74 = sub_80023E2(v77);
            return sub_800C8E4(v77, v74);
          }
          return result;
        case 26:
          return sub_8007F58();
        case 27:
          v78 = 0;
          v79 = 0;
          v80 = 0;
          if ( strstr(v81, "jp=0") )
          {
            byte_2000050C = 0;
            byte_20002F60 = 1;
            sub_800591C(146, &byte_2000050C, 1);
          }
          else if ( strstr(v81, "jp=1") )
          {
            byte_2000050C = 1;
            sub_800591C(146, &byte_2000050C, 1);
          }
          sprintf(&v78, "jp=%d", (unsigned __int8)byte_2000050C);
          v75 = sub_80023E2(&v78);
          return sub_800C8E4(&v78, v75);
        case 28:
          v78 = 0;
          v79 = 0;
          v80 = 0;
          sprintf(&v78, "cd=%d", 28);
          sub_800C8E4(&v78, 0);
          v76 = sub_8023A34(1000);
          sub_802325C(v76);
        default:
          return result;
      }
    }
  }
  return result;
}
// 800BB92: variable 'v42' is possibly undefined
// 800BB92: variable 'v43' is possibly undefined
// 800BBF6: variable 'v46' is possibly undefined
// 800BBF6: variable 'v47' is possibly undefined
// 800BC30: variable 'v50' is possibly undefined
// 800BC30: variable 'v51' is possibly undefined
// 800BC7E: variable 'v52' is possibly undefined
// 800BC7E: variable 'v53' is possibly undefined
// 8002364: using guessed type int __fastcall sub_8002364(_DWORD, _DWORD);
// 8002392: using guessed type int __fastcall strstr(_DWORD, _DWORD);
// 80023B6: using guessed type int __fastcall sub_80023B6(_DWORD, _DWORD, _DWORD);
// 80023E2: using guessed type int __fastcall sub_80023E2(_DWORD);
// 80023F0: using guessed type int __fastcall sub_80023F0(_DWORD, _DWORD);
// 8002644: using guessed type int __fastcall sub_8002644(_DWORD);
// 80031E4: using guessed type int __fastcall sub_80031E4(_DWORD);
// 80031EE: using guessed type int __fastcall sub_80031EE(_DWORD);
// 80031F8: using guessed type int __fastcall sub_80031F8(_DWORD);
// 80052C4: using guessed type int sub_80052C4(const char *, ...);
// 80057C4: using guessed type int __fastcall sub_80057C4(_DWORD, _DWORD, _DWORD);
// 80058E0: using guessed type int __fastcall sub_80058E0(_DWORD);
// 800591C: using guessed type int __fastcall sub_800591C(_DWORD, _DWORD, _DWORD);
// 8007B28: using guessed type int __fastcall sub_8007B28(_DWORD);
// 8007C0C: using guessed type int __fastcall sub_8007C0C(_DWORD);
// 8007C20: using guessed type void __fastcall __noreturn sub_8007C20(_DWORD);
// 8007DE0: using guessed type int __fastcall sub_8007DE0(_DWORD, _DWORD, _DWORD);
// 8007F58: using guessed type int sub_8007F58(void);
// 80080B4: using guessed type int __fastcall sub_80080B4(_DWORD);
// 800A240: using guessed type int __fastcall sub_800A240(_DWORD);
// 800AA24: using guessed type int __fastcall sub_800AA24(_DWORD);
// 800AB00: using guessed type int __fastcall sub_800AB00(_DWORD);
// 800AC44: using guessed type int __fastcall sub_800AC44(_DWORD);
// 800B098: using guessed type int sub_800B098(void);
// 800C800: using guessed type int __fastcall sub_800C800(_DWORD);
// 800C8E4: using guessed type int __fastcall sub_800C8E4(_DWORD, _DWORD);
// 800CBBC: using guessed type int __fastcall sub_800CBBC(_DWORD);
// 800CD2C: using guessed type int __fastcall sub_800CD2C(_DWORD);
// 800DB08: using guessed type int sub_800DB08(void);
// 800DC20: using guessed type int __fastcall sub_800DC20(_DWORD);
// 800E860: using guessed type int __fastcall sub_800E860(_DWORD);
// 801EA24: using guessed type void __fastcall __noreturn sub_801EA24(_DWORD);
// 801F610: using guessed type int __fastcall sub_801F610(_DWORD);
// 802085C: using guessed type int __fastcall sub_802085C(_DWORD, _DWORD, _DWORD);
// 8020888: using guessed type int __fastcall sub_8020888(_DWORD, _DWORD, _DWORD);
// 802325C: using guessed type void __fastcall __noreturn sub_802325C(_DWORD);
// 8023A34: using guessed type int __fastcall sub_8023A34(_DWORD);
// 2000050B: using guessed type char byte_2000050B;
// 2000050C: using guessed type char byte_2000050C;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 200015A6: using guessed type char byte_200015A6;
// 200015A7: using guessed type char byte_200015A7;
// 200015E6: using guessed type char byte_200015E6;
// 20002F60: using guessed type char byte_20002F60;
// 20002FCF: using guessed type char byte_20002FCF;
// 20002FD3: using guessed type char byte_20002FD3;
// 20002FD5: using guessed type char byte_20002FD5;
// 2000303B: using guessed type char byte_2000303B;

//----- (0800C738) --------------------------------------------------------
int __fastcall sub_800C738(int a1, int a2, int a3, int a4, const char *a5, int a6, const char *a7)
{
  unsigned int v11; // r4
  unsigned __int8 v13[164]; // [sp+1Ch] [bp-A4h] BYREF

  sub_8002364(v13, 128);
  v11 = 0;
  if ( !a5 || !a7 )
    return 0;
  sub_800FD78();
  sprintf(
    (int)v13,
    "AT+QMTPUB=%d,%d,%d,%d,\"hame_energy/%s/App/%s/ctrl\",%d,\"%s\"",
    a1,
    a2,
    a3,
    a4,
    (const char *)&dword_20003A0B,
    a5,
    a6,
    a7);
  while ( v11 < 3 )
  {
    if ( sub_800DFB4(v13, "OK", 0, 300) && sub_800CB6C(8, 0x3A98u, 300) )
      return 1;
    v11 = (unsigned __int8)(v11 + 1);
    sub_8023A34(100);
  }
  return 0;
}
// 20003A0B: using guessed type int dword_20003A0B;

//----- (0800C800) --------------------------------------------------------
int __fastcall sub_800C800(int a1)
{
  int result; // r0

  sub_800FD78();
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    if ( a1 == 1 )
    {
      sprintf(
        (int)byte_20004574,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",5,\"ret=1\"\r\n",
        (const char *)&dword_20003A0B,
        byte_200038E3);
    }
    else if ( !a1 )
    {
      sprintf(
        (int)byte_20004574,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",5,\"ret=0\"\r\n",
        (const char *)&dword_20003A0B,
        byte_200038E3);
    }
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800C8E4) --------------------------------------------------------
int __fastcall sub_800C8E4(int result, unsigned int a2)
{
  const char *v2; // r5

  v2 = (const char *)result;
  if ( result && a2 && a2 <= 0x39C )
  {
    sub_800FD78();
    result = sub_80256C8(dword_20000458, 500);
    if ( result )
    {
      sprintf(
        (int)byte_20004574,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
        (const char *)&dword_20003A0B,
        byte_200038E3,
        a2,
        v2);
      sub_800E77E(byte_20004574);
      return sub_8025188(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800C984) --------------------------------------------------------
int __fastcall sub_800C984(int a1, int a2, int a3, int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[92]; // [sp+4h] [bp-5Ch] BYREF

  sub_8002364(v10, 64);
  LOBYTE(v8) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v10, "AT+QMTCFG=\"ssl\",%d,%d,%d", a2, a3, a4);
        if ( sub_800DFB4(v10, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v10, "AT+QMTCFG=\"ssl\",%d", a2);
      if ( sub_800DFB4(v10, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v8 = (unsigned __int8)(v8 + 1);
    sub_8023A34(100);
  }
  while ( v8 < 3 );
  return 0;
}

//----- (0800CA3C) --------------------------------------------------------
int __fastcall sub_800CA3C(int a1, int a2, const char *a3, int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[152]; // [sp+10h] [bp-98h] BYREF

  sub_8002364(v10, 128);
  v8 = 0;
  if ( !a3 )
    return 0;
  sub_800FD78();
  sprintf((int)v10, "AT+QMTSUB=%d,%d,\"hame_energy/%s/App/%s/ctrl\",%d", a1, a2, (const char *)&dword_20003A0B, a3, a4);
  while ( v8 < 3 )
  {
    if ( sub_800DFB4(v10, "OK", 0, 300) && sub_800CB6C(7, 0x3A98u, 300) )
      return 1;
    v8 = (unsigned __int8)(v8 + 1);
    sub_8023A34(100);
  }
  return 0;
}
// 20003A0B: using guessed type int dword_20003A0B;

//----- (0800CAE8) --------------------------------------------------------
int sub_800CAE8()
{
  int result; // r0

  result = (unsigned __int8)byte_200015B4;
  if ( !byte_200015B4 )
  {
    if ( byte_2000436E && !byte_200037D6 )
    {
      if ( sub_801B040(word_20000918, 0x3Cu) )
        sub_800A88C();
      if ( sub_801B040(&word_20000918[1], 0x258u) )
        sub_800CD2C();
    }
    if ( word_200037DD != 15 && byte_2000436E && sub_801B040(&word_2000091C, 0x708u) )
    {
      result = 15;
      word_200037DD = 15;
    }
    else
    {
      result = (unsigned __int8)byte_2000436E;
      if ( !byte_2000436E )
      {
        result = (unsigned __int8)byte_20000930;
        if ( byte_20000930 )
        {
          result = 0;
          word_2000091C = 0;
        }
      }
    }
  }
  return result;
}
// 20000918: using guessed type _WORD word_20000918[2];
// 2000091C: using guessed type __int16 word_2000091C;
// 20000930: using guessed type char byte_20000930;
// 200015B4: using guessed type char byte_200015B4;
// 200037D6: using guessed type char byte_200037D6;
// 200037DD: using guessed type __int16 word_200037DD;
// 2000436E: using guessed type char byte_2000436E;

//----- (0800CB6C) --------------------------------------------------------
int __fastcall sub_800CB6C(int a1, unsigned int a2, int a3)
{
  int v6; // r6
  unsigned int v7; // r0
  unsigned int v8; // r4

  v6 = sub_8025B30();
  v7 = 0;
  if ( !a2 || !a3 )
    return 0;
  v8 = 1000 * a3;
  while ( v7 < a2 )
  {
    if ( (unsigned __int8)byte_20004370 == a1 )
    {
      byte_20004370 = 0;
      return 1;
    }
    sub_8023A34(v8 / 0x3E8);
    v7 = sub_8025B30() - v6;
  }
  return 0;
}
// 20004370: using guessed type char byte_20004370;

//----- (0800CBBC) --------------------------------------------------------
int sub_800CBBC()
{
  int result; // r0
  unsigned __int8 v1; // r0

  sub_8008028();
  sub_800FD78();
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    sprintf((int)byte_20004974, "wifi_v=%s", (const char *)&dword_200038FD);
    v1 = (unsigned __int8)sub_80023E2((unsigned __int8 *)byte_20004974);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v1,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 200038FD: using guessed type int dword_200038FD;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800CC74) --------------------------------------------------------
int __fastcall sub_800CC74(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QMTCFG=\"version\",%d,%d", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QMTCFG=\"version\",%d", a2);
      if ( sub_800DFB4(v8, "+QMTCFG:", "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800CD2C) --------------------------------------------------------
int sub_800CD2C()
{
  int result; // r0
  unsigned __int16 v1; // r0

  sub_800F8E4();
  sub_800FD78();
  result = sub_80256C8(dword_20000458, 500);
  if ( result )
  {
    sub_8005494();
    sub_800FBCC();
    sprintf(
      (int)byte_20004974,
      "\"",
      dword_20003C7F,
      dword_20003C83,
      dword_20003C63,
      dword_20003C67,
      dword_20003C6B,
      dword_20003C6F,
      dword_20003C73,
      dword_20003C77,
      (unsigned __int16)word_20003C45,
      word_20003C47,
      (unsigned __int8)byte_20003C39,
      (unsigned __int8)byte_20003C3A,
      (unsigned __int8)byte_20003C3B,
      (unsigned __int16)word_20003C49,
      (unsigned __int8)byte_20003C3C,
      (unsigned __int16)word_20003C59,
      (unsigned __int16)word_20003C5B,
      (unsigned __int16)word_20003C43,
      (unsigned __int8)byte_20003C3F,
      (unsigned __int8)byte_20003C3D,
      HIBYTE(word_20002F65),
      (unsigned __int8)word_20002F65,
      HIBYTE(word_20002F67),
      (unsigned __int8)word_20002F67,
      (unsigned __int8)byte_20002F61,
      word_20002F63,
      (unsigned __int8)byte_20002F62,
      HIBYTE(word_20002F6F),
      (unsigned __int8)word_20002F6F,
      HIBYTE(word_20002F71),
      (unsigned __int8)word_20002F71,
      (unsigned __int8)byte_20002F6B,
      word_20002F6D,
      (unsigned __int8)byte_20002F6C,
      HIBYTE(word_20002F79),
      (unsigned __int8)word_20002F79,
      HIBYTE(word_20002F7B),
      (unsigned __int8)word_20002F7B,
      (unsigned __int8)byte_20002F75,
      word_20002F77,
      (unsigned __int8)byte_20002F76,
      HIBYTE(word_20002F83),
      (unsigned __int8)word_20002F83,
      HIBYTE(word_20002F85),
      (unsigned __int8)word_20002F85,
      (unsigned __int8)byte_20002F7F,
      word_20002F81,
      (unsigned __int8)byte_20002F80,
      HIBYTE(word_20002F8D),
      (unsigned __int8)word_20002F8D,
      HIBYTE(word_20002F8F),
      (unsigned __int8)word_20002F8F,
      (unsigned __int8)byte_20002F89,
      word_20002F8B,
      (unsigned __int8)byte_20002F8A,
      HIBYTE(word_20002F97),
      (unsigned __int8)word_20002F97,
      HIBYTE(word_20002F99),
      (unsigned __int8)word_20002F99,
      (unsigned __int8)byte_20002F93,
      word_20002F95);
    v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
    sprintf(
      (int)byte_20004574,
      "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
      (const char *)&dword_20003A0B,
      byte_200038E3,
      v1,
      byte_20004974);
    sub_800E77E(byte_20004574);
    return sub_8025188(dword_20000458, 0, 0, 0);
  }
  return result;
}
// 800CFA4: too many varargs, some ignored
// 20000458: using guessed type int dword_20000458;
// 200004AC: using guessed type char byte_200004AC;
// 200004BB: using guessed type char byte_200004BB;
// 200015AE: using guessed type char byte_200015AE;
// 200015E4: using guessed type char byte_200015E4;
// 20002F61: using guessed type char byte_20002F61;
// 20002F62: using guessed type char byte_20002F62;
// 20002F63: using guessed type __int16 word_20002F63;
// 20002F65: using guessed type __int16 word_20002F65;
// 20002F67: using guessed type __int16 word_20002F67;
// 20002F6B: using guessed type char byte_20002F6B;
// 20002F6C: using guessed type char byte_20002F6C;
// 20002F6D: using guessed type __int16 word_20002F6D;
// 20002F6F: using guessed type __int16 word_20002F6F;
// 20002F71: using guessed type __int16 word_20002F71;
// 20002F75: using guessed type char byte_20002F75;
// 20002F76: using guessed type char byte_20002F76;
// 20002F77: using guessed type __int16 word_20002F77;
// 20002F79: using guessed type __int16 word_20002F79;
// 20002F7B: using guessed type __int16 word_20002F7B;
// 20002F7F: using guessed type char byte_20002F7F;
// 20002F80: using guessed type char byte_20002F80;
// 20002F81: using guessed type __int16 word_20002F81;
// 20002F83: using guessed type __int16 word_20002F83;
// 20002F85: using guessed type __int16 word_20002F85;
// 20002F89: using guessed type char byte_20002F89;
// 20002F8A: using guessed type char byte_20002F8A;
// 20002F8B: using guessed type __int16 word_20002F8B;
// 20002F8D: using guessed type __int16 word_20002F8D;
// 20002F8F: using guessed type __int16 word_20002F8F;
// 20002F93: using guessed type char byte_20002F93;
// 20002F95: using guessed type __int16 word_20002F95;
// 20002F97: using guessed type __int16 word_20002F97;
// 20002F99: using guessed type __int16 word_20002F99;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FD3: using guessed type char byte_20002FD3;
// 20002FD5: using guessed type char byte_20002FD5;
// 20002FD9: using guessed type char byte_20002FD9;
// 2000303B: using guessed type char byte_2000303B;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003C39: using guessed type char byte_20003C39;
// 20003C3A: using guessed type char byte_20003C3A;
// 20003C3B: using guessed type char byte_20003C3B;
// 20003C3C: using guessed type char byte_20003C3C;
// 20003C3D: using guessed type char byte_20003C3D;
// 20003C3E: using guessed type char byte_20003C3E;
// 20003C3F: using guessed type char byte_20003C3F;
// 20003C40: using guessed type char byte_20003C40;
// 20003C42: using guessed type char byte_20003C42;
// 20003C43: using guessed type __int16 word_20003C43;
// 20003C45: using guessed type __int16 word_20003C45;
// 20003C47: using guessed type __int16 word_20003C47;
// 20003C49: using guessed type __int16 word_20003C49;
// 20003C59: using guessed type __int16 word_20003C59;
// 20003C5B: using guessed type __int16 word_20003C5B;
// 20003C61: using guessed type __int16 word_20003C61;
// 20003C63: using guessed type int dword_20003C63;
// 20003C67: using guessed type int dword_20003C67;
// 20003C6B: using guessed type int dword_20003C6B;
// 20003C6F: using guessed type int dword_20003C6F;
// 20003C73: using guessed type int dword_20003C73;
// 20003C77: using guessed type int dword_20003C77;
// 20003C7B: using guessed type int dword_20003C7B;
// 20003C7F: using guessed type int dword_20003C7F;
// 20003C83: using guessed type int dword_20003C83;
// 20003C87: using guessed type int dword_20003C87;
// 20003C8B: using guessed type int dword_20003C8B;
// 20003C8F: using guessed type int dword_20003C8F;
// 20003D38: using guessed type __int16 word_20003D38;
// 20003D3A: using guessed type __int16 word_20003D3A;
// 20003D44: using guessed type __int16 word_20003D44;
// 20004360: using guessed type char byte_20004360;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800D058) --------------------------------------------------------
unsigned int __fastcall sub_800D058(unsigned int result, int a2)
{
  unsigned int i; // r2

  if ( a2 )
  {
    for ( i = 0; i < result; ++i )
      dword_200015C4 += *(unsigned __int8 *)(a2 + i);
    result = (unsigned __int8)byte_200015B2;
    if ( byte_200015B2 == 1 )
    {
      sub_80052C4((const char *)sub_800D08C);
      dword_200015C8 = dword_200015C4;
      result = ~dword_200015C4;
      dword_200015C4 = ~dword_200015C4;
    }
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800D08C: using guessed type int sub_800D08C();
// 200015B2: using guessed type char byte_200015B2;
// 200015C4: using guessed type int dword_200015C4;
// 200015C8: using guessed type int dword_200015C8;

//----- (0800D0B0) --------------------------------------------------------
int __fastcall sub_800D0B0(int a1)
{
  int result; // r0
  int v3; // r1
  unsigned int v5; // r1
  int v6; // r0

  if ( byte_200015B0 != 1 )
    sub_8018674((char *)a1);
  result = (unsigned __int8)byte_200015B0;
  if ( byte_200015B0 != 2 )
  {
    if ( a1 )
    {
      result = (unsigned __int16)word_200015B8;
      if ( (unsigned __int16)word_200015B8 >= 2u )
      {
        result = (unsigned __int16)word_200015B8;
        if ( word_200015B8 == word_200015B6 )
        {
          v3 = *(unsigned __int8 *)(a1 + 2);
          _R7 = 1;
          switch ( v3 )
          {
            case ':':
              result = *(unsigned __int8 *)(a1 + 1);
              if ( result == 5 )
              {
                result = *(unsigned __int8 *)(a1 + 3);
                if ( result == 3 )
                {
                  result = *(unsigned __int8 *)(a1 + 4);
                  if ( result == 2 )
                  {
                    byte_200037D7 = 1;
                    word_200037DF = 0;
                    dword_200015D0 = 0;
                    dword_200015D4 = 0;
                    byte_200015BA = 1;
                    sub_80052C4((const char *)sub_800D398);
                    sub_800D450((_BYTE *)0x3A, (unsigned int)&byte_200015BA, 2);
                    byte_200015B4 = 1;
                    byte_200015B0 = 1;
                    return sub_801FF60();
                  }
                }
              }
              break;
            case 'P':
              result = (unsigned __int8)byte_200015B4;
              if ( byte_200015B4 == 1 )
              {
                byte_200037D7 = 1;
                word_200037DF = 0;
                byte_200015B4 = 2;
                dword_200015D0 |= *(unsigned __int8 *)(a1 + 3)
                                | (*(unsigned __int8 *)(a1 + 4) << 8)
                                | (*(unsigned __int8 *)(a1 + 5) << 16)
                                | (*(unsigned __int8 *)(a1 + 6) << 24);
                dword_200015D4 |= *(unsigned __int8 *)(a1 + 7)
                                | (*(unsigned __int8 *)(a1 + 8) << 8)
                                | (*(unsigned __int8 *)(a1 + 9) << 16)
                                | (*(unsigned __int8 *)(a1 + 10) << 24);
                dword_200015CC = 0;
                dword_200015C4 = 0;
                byte_200015B2 = 0;
                sub_80052C4((const char *)dword_802987C);
                if ( MEMORY[0x1FFF75E0] == 0xFFFF )
                  v5 = 0x80000;
                else
                  v5 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
                sub_800F808(0x8040000u, (v5 >> 1) + 134479872);
                return (int)sub_800D450((_BYTE *)0x50, 0x8028202u, 2);
              }
              break;
            case 'Q':
              result = (unsigned __int8)byte_200015B4;
              if ( byte_200015B4 == 2 || byte_200015B4 == 3 )
              {
                byte_200037D7 = 1;
                word_200037DF = 0;
                byte_200015B4 = 3;
                sub_80052C4(
                  (const char *)dword_80298C0,
                  *(unsigned __int8 *)(a1 + 2),
                  *(unsigned __int8 *)(a1 + 3),
                  *(unsigned __int8 *)(a1 + 4),
                  *(unsigned __int8 *)(a1 + 5),
                  *(unsigned __int8 *)(a1 + 6));
                dword_200015CC = *(unsigned __int8 *)(a1 + 3)
                               | (*(unsigned __int8 *)(a1 + 4) << 8)
                               | (*(unsigned __int8 *)(a1 + 5) << 16)
                               | (*(unsigned __int8 *)(a1 + 6) << 24);
                sub_80052C4((const char *)sub_800D3D8);
                sub_800F86C((_DWORD *)(dword_200015CC + 134490112), a1 + 7, 0x10u);
                if ( dword_200015CC + 128 == dword_200015D0 )
                {
                  sub_80052C4((const char *)sub_800D410);
                  byte_200015B2 = 1;
                }
                sub_80052C4((const char *)dword_80297E4, dword_200015CC + 128, dword_200015D0);
                sub_800D058(0x80u, a1 + 7);
                return (int)sub_800D450((_BYTE *)0x51, a1 + 3, 4);
              }
              break;
            case 'R':
              sub_80052C4(
                "*** case 0x52: buf[2] = %#x, g_bin_crc = %#x, bin_crc = %#x.\r\n",
                82,
                dword_200015C4,
                dword_200015D4);
              result = (unsigned __int8)byte_200015B4;
              if ( byte_200015B4 == 3 )
              {
                byte_200037D7 = 1;
                word_200037DF = 0;
                byte_200015B4 = 4;
                if ( dword_200015C4 == dword_200015D4 )
                {
                  if ( MEMORY[0x8050004] == *(_DWORD *)((char *)&loc_8010002 + 2) )
                  {
                    sub_80052C4((const char *)dword_800D374);
                    byte_200015BA = 1;
                    sub_800D450((_BYTE *)0x52, (unsigned int)&byte_200015BA, 2);
                    sub_80052C4((const char *)dword_800D380);
                    dword_200110C0 = 134479872;
                    dword_200110C8 = 1;
                    dword_200110C4 = dword_200015D0;
                    dword_200110CC = (unsigned __int16)dword_200015C8;
                    sub_800F86C((_DWORD *)0x8040000, (int)&dword_200110C0, 2u);
                  }
                  else
                  {
                    sub_80052C4((const char *)sub_800D42C);
                    byte_200015BA = 0;
                    sub_800D450((_BYTE *)0x52, (unsigned int)&byte_200015BA, 2);
                  }
                }
                else
                {
                  sub_80052C4((const char *)dword_800D438);
                  byte_200015BA = 0;
                  sub_800D450((_BYTE *)0x52, (unsigned int)&byte_200015BA, 2);
                }
                sub_800D450((_BYTE *)0x52, (unsigned int)&byte_200015BA, 2);
                byte_200015B4 = 0;
                sub_80031E4();
                sub_801F610(v6);
                __asm { MSR.W           FAULTMASK, R7 }
                sub_80139D4();
              }
              break;
          }
        }
      }
    }
  }
  return result;
}
// 800D30C: variable 'v6' is possibly undefined
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800D374: using guessed type int dword_800D374[3];
// 800D380: using guessed type int dword_800D380[5];
// 800D398: using guessed type int sub_800D398();
// 800D3D8: using guessed type int sub_800D3D8();
// 800D410: using guessed type int sub_800D410();
// 800D42C: using guessed type int sub_800D42C();
// 800D438: using guessed type int dword_800D438[5];
// 801F610: using guessed type __int64 __fastcall sub_801F610(_DWORD);
// 80297E4: using guessed type int dword_80297E4[7];
// 802987C: using guessed type int[17];
// 80298C0: using guessed type int dword_80298C0[22];
// 200015B0: using guessed type char byte_200015B0;
// 200015B2: using guessed type char byte_200015B2;
// 200015B4: using guessed type char byte_200015B4;
// 200015B6: using guessed type __int16 word_200015B6;
// 200015B8: using guessed type __int16 word_200015B8;
// 200015BA: using guessed type char byte_200015BA;
// 200015C4: using guessed type int dword_200015C4;
// 200015C8: using guessed type int dword_200015C8;
// 200015CC: using guessed type int dword_200015CC;
// 200015D0: using guessed type int dword_200015D0;
// 200015D4: using guessed type int dword_200015D4;
// 200037D7: using guessed type char byte_200037D7;
// 200037DF: using guessed type __int16 word_200037DF;
// 200110C0: using guessed type int dword_200110C0;
// 200110C4: using guessed type int dword_200110C4;
// 200110C8: using guessed type int dword_200110C8;
// 200110CC: using guessed type int dword_200110CC;

//----- (0800D450) --------------------------------------------------------
_BYTE *__fastcall sub_800D450(_BYTE *result, unsigned int a2, signed int a3)
{
  char v3; // r7
  int v6; // r5
  unsigned int i; // r4
  int v8; // r2
  int v9; // r2

  v3 = (char)result;
  if ( a2 )
  {
    v6 = a3 + 6;
    sub_8002364(byte_20003A24, 512);
    byte_20003A24[0] = 115;
    byte_20003A25 = (unsigned __int16)(a3 + 6) >> 8;
    byte_20003A26 = a3 + 6;
    byte_20003A27 = v3;
    byte_20003A28 = 0;
    if ( a3 > 0 )
      qmemcpy((unsigned int)&unk_20003A29, a2, a3);
    byte_200015B5 = 0;
    for ( i = 0; i < v6 - 1; ++i )
    {
      v8 = (unsigned __int8)byte_20003A24[i];
      byte_200015B5 ^= v8;
      sub_80052C4("### OTA send data buf[%d] = %#x\r\n", i, v8);
    }
    v9 = (unsigned __int8)byte_200015B5;
    byte_20003A24[v6 - 1] = byte_200015B5;
    sub_80052C4("### OTA send data buf[%d] = %#x\r\n", v6 - 1, v9);
    return sub_8007788((unsigned __int8 *)byte_20003A24, v6);
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200015B5: using guessed type char byte_200015B5;
// 20003A25: using guessed type char byte_20003A25;
// 20003A26: using guessed type char byte_20003A26;
// 20003A27: using guessed type char byte_20003A27;
// 20003A28: using guessed type char byte_20003A28;

//----- (0800D500) --------------------------------------------------------
unsigned __int8 *sub_800D500()
{
  unsigned __int8 v0; // r0
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r4
  int v6; // [sp+0h] [bp-28h]
  int v7; // [sp+4h] [bp-24h]
  int v8; // [sp+8h] [bp-20h]
  int v9; // [sp+Ch] [bp-1Ch]
  int v10; // [sp+10h] [bp-18h]
  int v11; // [sp+14h] [bp-14h]
  int v12; // [sp+18h] [bp-10h]
  int v13; // [sp+1Ch] [bp-Ch]
  int v14; // [sp+20h] [bp-8h]

  v0 = sub_80233A4(0, 0, 300);
  v4 = v0;
  if ( v0 )
  {
    if ( v0 == 1 && (unsigned __int8)byte_200037DA > 2u )
    {
      sub_8006000((int)byte_20003863, v1, v2, v3, v6, v7, v8, v9, v10, v11, v12, v13, v14);
      byte_200037DA = 0;
      byte_200037DB = 0;
      sub_8002364(byte_20003863, 128);
    }
    if ( v4 == 2 && (unsigned __int8)byte_20004371 > 1u && !byte_200015B4 )
    {
      sub_80052C4("\r\n### Mqtt recv: %s\r\n", byte_20004374);
      word_200037E1 = 0;
      byte_200037D8 = 1;
      sub_800B168((int)byte_20004374, (unsigned __int16)word_20004372);
      word_20004372 = 0;
      byte_20004371 = 0;
      sub_8002364(byte_20004374, 512);
    }
    if ( v4 == 3 && (unsigned __int16)word_200015B6 >= 2u )
    {
      sub_800D0B0((int)&byte_200110D0);
      word_200015B6 = 0;
      word_200015B8 = 0;
      sub_8002364(&byte_200110D0, 256);
    }
  }
  else
  {
    if ( byte_200037DA )
    {
      byte_200037DA = 0;
      byte_200037DB = 0;
      sub_8002364(byte_20003863, 128);
    }
    if ( byte_20004371 )
    {
      word_20004372 = 0;
      byte_20004371 = 0;
      sub_8002364(byte_20004374, 512);
    }
    if ( word_200015B6 )
    {
      word_200015B6 = 0;
      word_200015B8 = 0;
      sub_8002364(&byte_200110D0, 256);
    }
    if ( sub_801B040(&word_200037E1, 0x3Cu) )
      byte_200037D8 = 0;
  }
  if ( byte_200037D7 && sub_801B040(&word_200037DF, 0x3Cu) )
    byte_200037D7 = 0;
  if ( byte_200015B4 )
    return (unsigned __int8 *)sub_80190A8();
  else
    return sub_800EA48();
}
// 800D538: variable 'v1' is possibly undefined
// 800D538: variable 'v2' is possibly undefined
// 800D538: variable 'v3' is possibly undefined
// 800D538: variable 'v6' is possibly undefined
// 800D538: variable 'v7' is possibly undefined
// 800D538: variable 'v8' is possibly undefined
// 800D538: variable 'v9' is possibly undefined
// 800D538: variable 'v10' is possibly undefined
// 800D538: variable 'v11' is possibly undefined
// 800D538: variable 'v12' is possibly undefined
// 800D538: variable 'v13' is possibly undefined
// 800D538: variable 'v14' is possibly undefined
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200015B4: using guessed type char byte_200015B4;
// 200015B6: using guessed type __int16 word_200015B6;
// 200015B8: using guessed type __int16 word_200015B8;
// 200037D7: using guessed type char byte_200037D7;
// 200037D8: using guessed type char byte_200037D8;
// 200037DA: using guessed type char byte_200037DA;
// 200037DB: using guessed type char byte_200037DB;
// 200037DF: using guessed type __int16 word_200037DF;
// 200037E1: using guessed type __int16 word_200037E1;
// 20003863: using guessed type _BYTE[128];
// 20004371: using guessed type char byte_20004371;
// 20004372: using guessed type __int16 word_20004372;
// 200110D0: using guessed type char byte_200110D0;

//----- (0800D64C) --------------------------------------------------------
int __fastcall sub_800D64C(int a1)
{
  int v1; // r0
  int v2; // r2
  unsigned int v3; // r1
  int v4; // r1
  int v5; // r3
  int v6; // r1
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int result; // r0
  int v13; // [sp+Ch] [bp-2Ch] BYREF
  int v14; // [sp+10h] [bp-28h] BYREF

  v14 = a1;
  v13 = 0;
  if ( !byte_200015B4 )
  {
    v1 = (unsigned __int8)v14;
    switch ( byte_200037D9 )
    {
      case 1:
        if ( (word_20003C24 & 0x7FFFu) <= 0x1FE )
        {
          byte_20003A24[word_20003C24 & 0x7FFF] = v14;
          word_20003C24 = word_20003C24 & 0x8000 | (word_20003C24 + 1) & 0x7FFF;
          if ( (word_20003C24 & 0x7FFFu) > 3 && v1 == 10 && byte_20003A24[(word_20003C24 & 0x7FFF) - 2] == 13 )
            sub_802596C((_DWORD *)dword_20000008, 0, 1, 3, 0, &v13);
        }
        else
        {
          word_20003C24 &= 0x8000u;
          sub_8002364(byte_20003A24, 512);
        }
        break;
      case 2:
        if ( byte_20002FD1 )
        {
          if ( !sub_8025520(dword_20000440) )
            sub_802532C(dword_20000440, (unsigned int)&v14, &v13, 0);
        }
        else
        {
          v2 = (unsigned __int16)word_200008FC++;
          v3 = (unsigned __int16)word_200008FC;
          byte_20003F9D[v2] = v14;
          if ( v3 < 0x7F )
          {
            if ( v3 > 3 && v1 == 10 && byte_20003F9D[v3 - 2] == 13 )
            {
              sub_802532C(dword_20000430, (unsigned int)byte_20003F9D, &v13, 0);
              sub_8002364(byte_20003F9D, 128);
              word_200008FC = 0;
            }
          }
          else
          {
            sub_8002364(byte_20003F9D, 128);
            word_200008FC = 0;
          }
        }
        break;
      case 3:
        if ( (unsigned __int16)word_2000099A < 0x7FFu )
        {
          v4 = (unsigned __int16)word_2000099A++;
          byte_20000995[v4 + 15] = v14;
          if ( (unsigned __int16)word_2000099A > 3u
            && v1 == 10
            && *((_BYTE *)&dword_200009A0 + (unsigned __int16)word_2000099A + 2) == 13 )
          {
            sub_802596C((_DWORD *)dword_20000010, 0, 1, 3, 0, &v13);
          }
        }
        else
        {
          word_2000099A = 0;
          sub_8002364(byte_200009A4, 2048);
        }
        break;
    }
  }
  v5 = (unsigned __int16)word_200015B6;
  if ( (unsigned __int16)word_200015B6 > 0xFFu )
  {
    word_200015B6 = 0;
    word_200015B8 = 0;
    sub_8002364(byte_200110D0, 256);
  }
  else if ( word_200015B6 )
  {
    if ( word_200015B6 == 1 )
    {
      if ( (_BYTE)v14 )
      {
        word_200015B8 = (unsigned __int8)v14;
        word_200015B6 = 2;
        byte_200110D1 = v14;
      }
      else
      {
        word_200015B6 = 2;
        byte_200110D1 = 0;
      }
    }
    else if ( word_200015B6 == 2 )
    {
      if ( !byte_200110D1 )
        word_200015B8 = (unsigned __int8)v14;
      word_200015B6 = 3;
      byte_200110D2 = v14;
    }
    else
    {
      v6 = (unsigned __int16)word_200015B8;
      if ( (unsigned __int16)word_200015B6 < (unsigned int)(unsigned __int16)word_200015B8 )
      {
        ++word_200015B6;
        byte_200110D0[v5] = v14;
      }
      if ( v6 == (unsigned __int16)word_200015B6 )
        sub_802596C((_DWORD *)dword_2000000C, 0, 3, 3, 0, &v13);
    }
  }
  else if ( (unsigned __int8)v14 == 115 )
  {
    word_200015B6 = 1;
    byte_200110D0[0] = 115;
  }
  if ( (unsigned __int8)byte_200037DB >= 0x80u || byte_200015B4 )
  {
LABEL_48:
    byte_200037DB = 0;
    byte_200037DA = 0;
    sub_8002364(byte_20003863, 128);
    goto LABEL_49;
  }
  switch ( byte_200037DB )
  {
    case 0:
      if ( (unsigned __int8)v14 == 115 )
      {
        v8 = (unsigned __int8)byte_200037DB++;
        byte_200037D4[v8 + 143] = 115;
        byte_200037DA = 0x80;
        goto LABEL_49;
      }
      goto LABEL_48;
    case 1:
      if ( (unsigned __int8)v14 < 0x80u )
      {
        byte_200037DA = v14;
        v9 = (unsigned __int8)byte_200037DB++;
        byte_200037D4[v9 + 143] = v14;
        goto LABEL_49;
      }
      goto LABEL_48;
    case 2:
      if ( (unsigned __int8)v14 == 35 )
      {
        v10 = (unsigned __int8)byte_200037DB++;
        byte_200037D4[v10 + 143] = 35;
        goto LABEL_49;
      }
      goto LABEL_48;
  }
  if ( (unsigned __int8)byte_200037DB < (unsigned int)(unsigned __int8)byte_200037DA
    && (unsigned __int8)byte_200037DB < 0x80u )
  {
    v7 = (unsigned __int8)byte_200037DB++;
    byte_200037D4[v7 + 143] = v14;
  }
  if ( byte_200037DB == byte_200037DA )
    sub_802596C((_DWORD *)dword_2000000C, 0, 1, 3, 0, &v13);
LABEL_49:
  if ( byte_2000436E[0] && !byte_200015B4 )
  {
    if ( (unsigned __int8)byte_20004371 < 2u && (unsigned __int16)word_20004372 < 0x200u )
    {
      v11 = (unsigned __int16)word_20004372++;
      byte_2000436E[v11 + 6] = v14;
    }
    if ( (unsigned __int16)word_20004372 > 0x1FEu )
    {
      word_20004372 = 0;
      sub_8002364(byte_20004374, 512);
    }
    if ( byte_20004371 )
    {
      if ( byte_20004371 == 1 )
      {
        if ( (unsigned __int8)v14 == 10 && *((_BYTE *)&word_20004372 + (unsigned __int16)word_20004372) == 13 )
        {
          sub_802596C((_DWORD *)dword_2000000C, 0, 2, 3, 0, &v13);
          byte_20004371 = 2;
        }
      }
      else if ( byte_20004371 != 2 )
      {
        byte_20004371 = 0;
      }
    }
    else if ( word_20004372
           && (unsigned __int16)word_20004372 <= 9u
           && aBeginCertifica_0[(unsigned __int16)word_20004372 + 782] == *((_BYTE *)&word_20004372
                                                                          + (unsigned __int16)word_20004372
                                                                          + 1) )
    {
      byte_20004371 = word_20004372 == 9;
    }
    else
    {
      word_20004372 = 0;
      sub_8002364(byte_20004374, 512);
    }
  }
  if ( (byte_20004360 || byte_20000930) && !byte_200015B4 && sub_800E94C((unsigned __int8)v14) )
  {
    sub_802532C(dword_20000450, (unsigned int)&byte_200037E3, 0, 0);
    sub_8002364(&byte_200037E3, 256);
  }
  result = (unsigned __int8)byte_200015E5;
  if ( byte_200015E5 == 1 )
  {
    result = (unsigned __int8)byte_200015B4;
    if ( !byte_200015B4 )
    {
      result = sub_80044EC((unsigned __int8)v14);
      if ( result )
      {
        byte_200015E5 = result;
        return sub_8025438(dword_2000042C, 0);
      }
    }
  }
  return result;
}
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 20000010: using guessed type int dword_20000010;
// 2000042C: using guessed type int dword_2000042C;
// 20000430: using guessed type int dword_20000430;
// 20000440: using guessed type int dword_20000440;
// 20000450: using guessed type int dword_20000450;
// 200008FC: using guessed type __int16 word_200008FC;
// 20000930: using guessed type char byte_20000930;
// 2000099A: using guessed type __int16 word_2000099A;
// 200009A0: using guessed type int dword_200009A0;
// 200009A4: using guessed type unsigned __int8 byte_200009A4[2048];
// 200015B4: using guessed type char byte_200015B4;
// 200015B6: using guessed type __int16 word_200015B6;
// 200015B8: using guessed type __int16 word_200015B8;
// 200015E5: using guessed type char byte_200015E5;
// 20002FD1: using guessed type char byte_20002FD1;
// 200037D9: using guessed type char byte_200037D9;
// 200037DA: using guessed type char byte_200037DA;
// 200037DB: using guessed type char byte_200037DB;
// 200037E3: using guessed type char byte_200037E3;
// 20003863: using guessed type _BYTE byte_20003863[128];
// 20003C24: using guessed type __int16 word_20003C24;
// 20003F9D: using guessed type _BYTE byte_20003F9D[128];
// 20004360: using guessed type char byte_20004360;
// 20004371: using guessed type char byte_20004371;
// 20004372: using guessed type __int16 word_20004372;
// 200110D1: using guessed type char byte_200110D1;
// 200110D2: using guessed type char byte_200110D2;

//----- (0800DB08) --------------------------------------------------------
int sub_800DB08()
{
  int result; // r0
  int v1; // r4

  if ( !word_20000928 || (result = sub_801B040(&word_20000928, 5u)) != 0 )
  {
    sub_801B040(&word_20000928, 5u);
    sub_800FD78();
    result = sub_80256C8(dword_20000458, 500);
    if ( result )
    {
      sub_8002364(byte_20004974, 1024);
      sprintf(
        (int)byte_20004974,
        "get_power=%d|%d|%d|%d|%d",
        dword_20002EC4,
        dword_20002EC8,
        dword_20002ECC,
        dword_20002ED0,
        (int)flt_200027A4);
      v1 = (unsigned __int16)sub_80023E2((unsigned __int8 *)byte_20004974);
      sub_8002364(byte_20004574, 1024);
      sprintf(
        (int)byte_20004574,
        "AT+QMTPUB=0,0,0,0,\"hame_energy/%s/device/%s/ctrl\",%d,\"%s\"\r\n",
        (const char *)&dword_20003A0B,
        byte_200038E3,
        v1,
        byte_20004974);
      sub_800E77E(byte_20004574);
      return sub_8025188(dword_20000458, 0, 0, 0);
    }
  }
  return result;
}
// 20000458: using guessed type int dword_20000458;
// 20000928: using guessed type __int16 word_20000928;
// 200027A4: using guessed type float flt_200027A4;
// 20002EC4: using guessed type int dword_20002EC4;
// 20002EC8: using guessed type int dword_20002EC8;
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;
// 20003A0B: using guessed type int dword_20003A0B;
// 20004574: using guessed type unsigned __int8 byte_20004574[1024];

//----- (0800DC20) --------------------------------------------------------
int __fastcall sub_800DC20(int result)
{
  unsigned __int8 *v1; // r6
  unsigned __int8 *v2; // r0
  bool v3; // zf
  unsigned int v4; // r5
  int v5; // r0
  unsigned int v6; // r2
  unsigned __int8 *v7; // r0
  unsigned int v8; // r5
  unsigned __int8 *v9; // r0
  int *v10; // r4
  unsigned __int8 *v11; // r0
  unsigned int v12; // r0
  unsigned __int8 *v13; // r0
  unsigned __int8 v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 v16; // r0
  unsigned __int8 *v17; // r0
  __int16 v18; // r0
  unsigned __int8 *v19; // r0
  unsigned __int8 v20; // r0
  unsigned __int16 v21; // r0
  unsigned __int16 v22; // r0
  char v23[32]; // [sp+0h] [bp-88h] BYREF
  unsigned __int8 v24[64]; // [sp+20h] [bp-68h] BYREF
  int v25; // [sp+60h] [bp-28h] BYREF
  int v26; // [sp+64h] [bp-24h]
  int v27; // [sp+68h] [bp-20h]
  int v28; // [sp+6Ch] [bp-1Ch]

  v1 = (unsigned __int8 *)result;
  if ( result )
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    sub_8002364(v24, 64);
    sub_8002364(v23, 32);
    v2 = (unsigned __int8 *)sub_80023CE((int)v1, 0x2Cu);
    v3 = v2 == 0;
    do
    {
      if ( v3 )
        goto LABEL_20;
      v4 = (unsigned int)(v2 + 1);
      v5 = sub_80023CE((int)v1, 0x3Du);
      if ( v5 )
        goto LABEL_7;
      v2 = strstr(v1, "seq_check");
      v3 = v2 == 0;
    }
    while ( !v2 );
    LOBYTE(v5) = sub_80023CE((int)v1, 0x6Bu) + 1;
LABEL_7:
    v6 = (unsigned __int8)(v5 - v4);
    if ( v6 > 0x20 )
    {
LABEL_20:
      sprintf((int)v24, "cd=%d,err_cmd", 18);
      v22 = (unsigned __int16)sub_80023E2(v24);
      return sub_800C8E4((int)v24, v22);
    }
    qmemcpy((unsigned int)v23, v4, v6);
    if ( strstr(v1, "meter=") )
    {
      v7 = strstr(v1, "meter=");
      v8 = (unsigned __int8)sub_8002644((char *)v7 + 6);
      sub_80052C4("[MQTT] Set meter type = %d.\r\n", v8);
      if ( (unsigned __int8)byte_20002FD1 != v8 && v8 < 8 )
      {
        sub_80191AC();
        byte_20002FD1 = v8;
        byte_200015DE = 1;
      }
      if ( byte_20002FD1 == 2 )
      {
        byte_200015AC = 1;
        byte_200015AD = 0;
      }
      else if ( byte_20002FD1 == 7 )
      {
        byte_200015AD = 1;
        byte_200015AC = 0;
      }
      else
      {
        byte_200015AC = 0;
        byte_200015AD = 0;
      }
      byte_200015AE = 0;
      if ( strstr(v1, "mac=") )
      {
        v9 = strstr(v1, "mac=");
        v10 = (int *)(v9 + 4);
        v25 = *((_DWORD *)v9 + 1);
        v26 = *((_DWORD *)v9 + 2);
        v27 = *((_DWORD *)v9 + 3);
        if ( sub_80023F0((int)&v25, (int)&dword_20004361) )
        {
          dword_20004361 = *v10;
          dword_20004365 = v10[1];
          dword_20004369 = v10[2];
          sub_80191AC();
        }
      }
    }
    else if ( strstr(v1, "dchrg=") )
    {
      v11 = strstr(v1, "dchrg=");
      v12 = (unsigned __int8)sub_8002644((char *)v11 + 6);
      if ( (unsigned __int8)byte_20002FD0 != (unsigned __int8)v12 && (unsigned __int8)v12 <= 1u )
        sub_8005BB0(v12);
    }
    else if ( strstr(v1, "seq_check") )
    {
      sub_80191AC();
    }
    else if ( strstr(v1, "rechrg_seq") )
    {
      v13 = strstr(v1, "rechrg_seq=");
      v14 = sub_8002644((char *)v13 + 11);
      sub_8005AA4(v14);
    }
    else if ( strstr(v1, "ctrl_rate=") )
    {
      v15 = strstr(v1, "ctrl_rate=");
      v16 = sub_8002644((char *)v15 + 10);
      sub_8005A54(v16);
    }
    else if ( strstr(v1, "shelly_port=") )
    {
      v17 = strstr(v1, "shelly_port=");
      v18 = sub_8002644((char *)v17 + 12);
      sub_8005BCC(v18);
    }
    else if ( strstr(v1, "ctrl_ratio=") )
    {
      v19 = strstr(v1, "ctrl_ratio=");
      v20 = sub_8002644((char *)v19 + 11);
      sub_8005A84(v20);
    }
    sprintf((int)v24, "cd=%d,%s", 18, v23);
    v21 = (unsigned __int16)sub_80023E2(v24);
    return sub_800C8E4((int)v24, v21);
  }
  return result;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 200015AC: using guessed type char byte_200015AC;
// 200015AD: using guessed type char byte_200015AD;
// 200015AE: using guessed type char byte_200015AE;
// 200015DE: using guessed type char byte_200015DE;
// 20002FD0: using guessed type char byte_20002FD0;
// 20002FD1: using guessed type char byte_20002FD1;
// 20004361: using guessed type int dword_20004361;
// 20004365: using guessed type int dword_20004365;
// 20004369: using guessed type int dword_20004369;

//----- (0800DEE0) --------------------------------------------------------
int sub_800DEE0()
{
  unsigned int v0; // r4
  unsigned __int8 *v2; // r7
  unsigned __int8 *v3; // r0

  v0 = 0;
  sub_8018F5C(4, 411);
  while ( 1 )
  {
    if ( v0 >= 3 )
      return 0;
    if ( byte_2000435F )
      return 0;
    v2 = sub_80023E2((unsigned __int8 *)byte_20002FFB);
    v3 = sub_80023E2((unsigned __int8 *)byte_20002FDB);
    if ( sub_800F450(byte_20002FDB, byte_20002FFB, (int)v3, (unsigned int)v2) )
      break;
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  if ( !sub_800F554(2) )
    return 0;
  sub_80052C4("Set wifi success! ### wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002FDB, byte_20002FFB);
  sub_800591C(0x400u, byte_20002FDB, 0x20u);
  sub_800591C(0x420u, byte_20002FFB, 0x40u);
  byte_2000436E = 0;
  sub_800A3A8(0);
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 2000435F: using guessed type char byte_2000435F;
// 2000436E: using guessed type char byte_2000436E;

//----- (0800DFB4) --------------------------------------------------------
int __fastcall sub_800DFB4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v8; // r4

  v8 = 0;
  if ( !a1 )
    return 0;
  if ( sub_80256C8(dword_20000458, 500) )
  {
    sub_8002364(byte_20003A24, 512);
    word_20003C24 &= 0x8000u;
    sub_800F1D8(a1);
    byte_200037D9 = 1;
    sub_80052C4((const char *)dword_800E0A4, a1);
    if ( sub_80233A4(0, 0, a4) == 1 )
    {
      sub_8023A34(a4);
      byte_20003A24[word_20003C24 & 0x7FFF] = 0;
      sub_80052C4((const char *)sub_800E0C4, byte_20003A24);
      if ( (unsigned int)a2 | (unsigned int)a3 )
      {
        if ( a2 && a3 && strstr((unsigned __int8 *)byte_20003A24, a2) && strstr((unsigned __int8 *)byte_20003A24, a3) )
        {
          v8 = 1;
        }
        else if ( a2 && strstr((unsigned __int8 *)byte_20003A24, a2) )
        {
          v8 = 1;
        }
        else if ( strstr((unsigned __int8 *)byte_20003A24, a3) )
        {
          v8 = 1;
        }
      }
      else
      {
        sub_80052C4("Set expected reply content error!\r\n");
      }
    }
    byte_200037D9 = 0;
    sub_8025188(dword_20000458, 0, 0, 0);
  }
  return v8;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800E0A4: using guessed type int dword_800E0A4[8];
// 800E0C4: using guessed type int sub_800E0C4();
// 20000458: using guessed type int dword_20000458;
// 200037D9: using guessed type char byte_200037D9;
// 20003C24: using guessed type __int16 word_20003C24;

//----- (0800E108) --------------------------------------------------------
BOOL __fastcall sub_800E108(int a1, const char *a2, int a3)
{
  unsigned int v6; // r5
  BOOL result; // r0
  unsigned __int8 v8[88]; // [sp+8h] [bp-58h] BYREF

  v6 = 0;
  sub_8002364(v8, 64);
  while ( v6 < 3 )
  {
    if ( a1 )
    {
      switch ( a1 )
      {
        case 1:
          sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d", a2, 1);
          result = sub_800DFB4(v8, 0, "OK", 300) != 0;
          break;
        case 2:
          sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d,%d", a2, 2, a3);
          if ( sub_800DFB4(v8, "CONNECT", 0, 300) )
          {
            sub_80052C4("UPLOAD CONNECT...\r\n");
            result = 1;
          }
          else
          {
            result = 0;
          }
          break;
        case 3:
          result = sub_800DFB4("AT+QSSLCERT?", 0, "OK", 300) != 0;
          break;
        default:
          result = 0;
          break;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCERT=\"%s\",%d", a2, 0);
      result = sub_800DFB4(v8, "OK", 0, 300) != 0;
    }
    if ( result )
      return result;
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  return 0;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);

//----- (0800E230) --------------------------------------------------------
int __fastcall sub_800E230(int a1, int a2, const char *a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"ciphersuite\",%d,%s", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"ciphersuite\",%d", a2);
      if ( sub_800DFB4(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800E2E4) --------------------------------------------------------
int sub_800E2E4()
{
  switch ( byte_2000092A )
  {
    case 0:
      sub_80052C4("Check certificate...\r\n");
      if ( !sub_800E108(3, 0, 0) )
        goto LABEL_10;
      if ( strstr((unsigned __int8 *)byte_20003A24, "\"CA\",1") )
        byte_200037DC |= 1u;
      if ( strstr((unsigned __int8 *)byte_20003A24, "\"User Cert\",1") )
        byte_200037DC |= 2u;
      if ( strstr((unsigned __int8 *)byte_20003A24, "\"User Key\",1") )
        byte_200037DC |= 4u;
      if ( byte_200037DC != 7 )
      {
LABEL_10:
        byte_2000092A = 1;
        return 0;
      }
      sub_80052C4("Certificates are completed!\r\n");
      return 1;
    case 1:
      if ( (unsigned __int8)byte_200037DC << 31 )
        byte_2000092A = 4;
      else
        byte_2000092A = 2;
      return 0;
    case 2:
      if ( sub_800E108(2, "CA", 1187) )
        byte_2000092A = 3;
      else
        byte_2000092A = 1;
      return 0;
    case 3:
      sub_80052C4("Uploading CA certificate...\r\n");
      sub_800E77E((unsigned __int8 *)"fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n");
      byte_2000092A = 10;
      return 0;
    case 4:
      sub_80052C4("Checking User Cert...\r\n");
      if ( (byte_200037DC & 2) != 0 )
        byte_2000092A = 7;
      else
        byte_2000092A = 5;
      return 0;
    case 5:
      if ( sub_800E108(2, "User Cert", 1224) )
        byte_2000092A = 6;
      else
        byte_2000092A = 4;
      return 0;
    case 6:
      sub_80052C4("Uploading User Cert certificate...\r\n");
      sub_800E77E((unsigned __int8 *)dword_80276A8 + 1);
      byte_2000092A = 10;
      return 0;
    case 7:
      sub_80052C4("Checking User Key...\r\n");
      if ( (byte_200037DC & 4) != 0 )
        byte_2000092A = 10;
      else
        byte_2000092A = 8;
      return 0;
    case 8:
      if ( sub_800E108(2, "User Key", 1679) )
        byte_2000092A = 9;
      else
        byte_2000092A = 7;
      return 0;
    case 9:
      sub_80052C4("Uploading User Key certificate...\r\n");
      sub_800E77E((_BYTE *)&dword_8027B3C[13] + 2);
      byte_2000092A = 10;
      return 0;
    case 10:
      if ( sub_801B018(&word_2000092C, 0x4E20u) )
        byte_2000092A = 0;
      return 0;
    default:
      return 0;
  }
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 80276A8: using guessed type int dword_80276A8[3];
// 8027B3C: using guessed type int[61];
// 2000092A: using guessed type char byte_2000092A;
// 2000092C: using guessed type _WORD;
// 200037DC: using guessed type char byte_200037DC;

//----- (0800E570) --------------------------------------------------------
int __fastcall sub_800E570(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"verify\",%d,%d", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"verify\",%d", a2);
      if ( sub_800DFB4(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800E61C) --------------------------------------------------------
int __fastcall sub_800E61C(int a1, int a2, int a3)
{
  unsigned int v6; // r4
  unsigned __int8 v8[88]; // [sp+0h] [bp-58h] BYREF

  sub_8002364(v8, 64);
  LOBYTE(v6) = 0;
  do
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sprintf((int)v8, "AT+QSSLCFG=\"version\",%d,%d", a2, a3);
        if ( sub_800DFB4(v8, "OK", 0, 300) )
          return 1;
      }
    }
    else
    {
      sprintf((int)v8, "AT+QSSLCFG=\"version\",%d", a2);
      if ( sub_800DFB4(v8, 0, "OK", 300) )
        return 1;
    }
    v6 = (unsigned __int8)(v6 + 1);
    sub_8023A34(100);
  }
  while ( v6 < 3 );
  return 0;
}

//----- (0800E6C8) --------------------------------------------------------
int sub_800E6C8()
{
  unsigned int v0; // r4

  v0 = 0;
  sub_801292E(1207962624, 1024, 1);
  sub_8023A34(1000);
  while ( v0 < 3 )
  {
    if ( sub_800DFB4("AT+QRST", (unsigned __int8 *)&dword_800E734, 0, 300) )
    {
      sub_8023A34(1000);
      if ( sub_800DFB4("AT", (unsigned __int8 *)&dword_800E734, 0, 300) )
      {
        sub_80052C4("Fc41d start!\r\n");
        return 1;
      }
    }
    sub_80080B4(0);
    v0 = (unsigned __int8)(v0 + 1);
    sub_8023A34(100);
  }
  sub_80052C4("Fc41d start err!\r\n");
  return 0;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800E734: using guessed type int dword_800E734;

//----- (0800E768) --------------------------------------------------------
int __fastcall sub_800E768(int a1, int a2)
{
  if ( !a1 )
    return 0;
  sub_801D6C8(a1, a2);
  return a2;
}

//----- (0800E77E) --------------------------------------------------------
int __fastcall sub_800E77E(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !a1 )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  if ( !v2 )
    return 0;
  sub_801D6C8((int)a1, v2);
  return 1;
}

//----- (0800E7A4) --------------------------------------------------------
int __fastcall sub_800E7A4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  int v8; // r4
  unsigned __int16 v9; // r0
  unsigned __int8 v11[156]; // [sp+4h] [bp-9Ch] BYREF

  v8 = 0;
  sub_8002364(v11, 128);
  if ( !a1 )
    return 0;
  if ( sub_80256C8(dword_20000458, 400) )
  {
    v9 = (unsigned __int16)sub_80023E2(a1);
    sub_800E768((int)a1, (unsigned __int16)(v9 - 1));
    byte_200037D9 = 2;
    if ( sub_8025570(dword_20000430, (unsigned int)v11, a4) && (unsigned int)a2 | (unsigned int)a3 )
    {
      if ( a2 && a3 && strstr(v11, a2) && strstr(v11, a3) )
      {
        v8 = 1;
      }
      else if ( a2 && strstr(v11, a2) )
      {
        v8 = 1;
      }
      else if ( strstr(v11, a3) )
      {
        v8 = 1;
      }
    }
    byte_200037D9 = 0;
    sub_8025188(dword_20000458, 0, 0, 0);
  }
  return v8;
}
// 20000430: using guessed type int dword_20000430;
// 20000458: using guessed type int dword_20000458;
// 200037D9: using guessed type char byte_200037D9;

//----- (0800E860) --------------------------------------------------------
int sub_800E860()
{
  int result; // r0
  unsigned int i; // r4

  result = (unsigned __int8)byte_2000050B;
  if ( byte_2000050B == 1 )
  {
    for ( i = 0; i < 0xA; i = (unsigned __int8)(i + 1) )
    {
      result = (int)&byte_20002F5F[10 * i];
      if ( *(__int16 *)(result + 4) > 800 )
      {
        *(_WORD *)(result + 4) = 800;
        result = sub_80058E0(i);
      }
    }
  }
  return result;
}
// 2000050B: using guessed type char byte_2000050B;

//----- (0800E89C) --------------------------------------------------------
int __fastcall sub_800E89C(int result)
{
  if ( result )
  {
    if ( result == 1 )
    {
      if ( sub_800E108(2, "User Cert", 1224) )
        return sub_800E77E((unsigned __int8 *)dword_80276A8 + 1);
    }
    else
    {
      if ( result != 2 )
        return result;
      if ( sub_800E108(2, "User Key", 1679) )
        return sub_800E77E((_BYTE *)&dword_8027B3C[13] + 2);
    }
  }
  else if ( sub_800E108(2, (const char *)&dword_800E920, 1187) )
  {
    return sub_800E77E((unsigned __int8 *)"fyyzcgzGAhEH\nqK1YzBGAPx7C7UP+ZUJB5WEGXe7O2QPO0t0AIn5mA5+IQUC3hYXQpRXigXbqmJ0T\nmw36soOFEUnRNaX/87n/dKvzqtHGBQmQBdG383+PFlB6gaRjDqgqw8I5I5HTIbPz\n0PwAKLGYcup8bAtbOXXelRj9QW9OvVVHQ39nkZ12ft8S9KvyRW3JrifGqpxNQFvq\nUrx6kMaRDZz/nyiJ4pEbYMaM6yAJI2e2GxqUYAS868pzEHAaxjzuvMvFs2iV7fwb\nPiaYMJANabli7EbRBU9EBOZ6sIEfx4Jn4qfgG6AM3v2vehEXXW+iMkWQX6OOgA==\n-----END CERTIFICATE-----\n");
  }
  return sub_80052C4("\r\nUploading err!\r\n");
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800E920: using guessed type int dword_800E920;
// 80276A8: using guessed type int dword_80276A8[3];
// 8027B3C: using guessed type int dword_8027B3C[61];

//----- (0800E94C) --------------------------------------------------------
int __fastcall sub_800E94C(int a1)
{
  char *v2; // r1

  if ( (unsigned __int8)byte_200008F8 >= 0x7Fu )
  {
    sub_8002364(&byte_200037E3, 128);
    byte_200008F8 = 0;
    return 0;
  }
  switch ( byte_200008F8 )
  {
    case 0:
      if ( a1 == 43 )
      {
        byte_200008F8 = 1;
        byte_200037E3 = 43;
      }
      return 0;
    case 1:
      if ( a1 == 81 )
      {
        byte_200008F8 = 2;
        byte_200037E4 = 81;
        return 0;
      }
      goto LABEL_12;
    case 2:
      if ( a1 != 73 && a1 != 87 && a1 != 71 )
      {
        byte_200008F8 = 3;
        byte_200037E5 = a1;
        return 0;
      }
LABEL_12:
      sub_8002364(&byte_200037E3, 128);
      byte_200008F8 = 0;
      return 0;
  }
  if ( a1 != 10 )
  {
    v2 = &byte_200037D4[(unsigned __int8)byte_200008F8++];
    v2[15] = a1;
    return 0;
  }
  byte_200037D4[(unsigned __int8)byte_200008F8 + 15] = 10;
  byte_200008F8 = 0;
  return 1;
}
// 200008F8: using guessed type char byte_200008F8;
// 200037E3: using guessed type char byte_200037E3;
// 200037E4: using guessed type char byte_200037E4;
// 200037E5: using guessed type char byte_200037E5;

//----- (0800E9EC) --------------------------------------------------------
int __fastcall sub_800E9EC(int a1)
{
  unsigned int v2; // r4
  unsigned __int8 v4[76]; // [sp+4h] [bp-4Ch] BYREF

  sub_8002364(v4, 64);
  v2 = 0;
  sprintf((int)v4, "AT+QURCCFG=%d", a1);
  while ( v2 < 3 )
  {
    if ( sub_800DFB4(v4, "OK", 0, 300) )
      return 1;
    v2 = (unsigned __int8)(v2 + 1);
    sub_8023A34(100);
  }
  return 0;
}

//----- (0800EA48) --------------------------------------------------------
unsigned __int8 *sub_800EA48()
{
  unsigned __int8 *result; // r0
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // [sp+0h] [bp-128h]
  int v12; // [sp+4h] [bp-124h] BYREF
  int v13; // [sp+8h] [bp-120h]
  const char *v14; // [sp+Ch] [bp-11Ch]
  const char *v15; // [sp+10h] [bp-118h]
  int v16; // [sp+14h] [bp-114h]
  int v17; // [sp+18h] [bp-110h]
  int v18; // [sp+1Ch] [bp-10Ch]
  int v19; // [sp+20h] [bp-108h]
  int v20; // [sp+24h] [bp-104h]
  int v21; // [sp+28h] [bp-100h]
  const char *v22; // [sp+2Ch] [bp-FCh]
  const char *v23; // [sp+30h] [bp-F8h]
  int v24; // [sp+34h] [bp-F4h]
  int v25; // [sp+38h] [bp-F0h]
  int v26; // [sp+3Ch] [bp-ECh]
  int v27; // [sp+40h] [bp-E8h]
  int v28; // [sp+44h] [bp-E4h]
  int v29; // [sp+48h] [bp-E0h]
  int v30; // [sp+4Ch] [bp-DCh]

  sub_8002364(&v12, 256);
  sub_8002364(&v12, 256);
  result = (unsigned __int8 *)sub_8025570(dword_20000450, (unsigned int)&v12, 0);
  if ( result == (unsigned __int8 *)1 )
  {
    sub_80052C4((const char *)&loc_800ECA4, &v12);
    if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: ") )
    {
      if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 0") )
      {
        byte_20000996 = 1;
        sub_80052C4((const char *)&loc_800ECE4);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 4") )
      {
        sub_80052C4((const char *)&loc_800ED24);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QHTTPGET: 9") )
      {
        byte_20000996 = 4;
        sub_80052C4(",ctrl_r=%d,par=%d,gen=%d,ble=%d,shelly_p=%d,c_ratio=%d", v1, v2, v3, v11, v12, v13);
      }
      return sub_8002364(&v12, 256);
    }
    if ( strstr((unsigned __int8 *)&v12, "+QMT") )
    {
      if ( strstr((unsigned __int8 *)&v12, "+QMTCONN: 0,3") )
      {
        sub_80052C4((const char *)&loc_800ED9C);
        byte_2000436E[0] = 1;
        byte_20004370 = 1;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTCONN: 0,0,0") )
      {
        sub_80052C4((const char *)&loc_800EDE0);
        byte_20004370 = 5;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTSUB: 0,1,0,0") )
      {
        sub_80052C4((const char *)&loc_800EE2C);
        byte_20004370 = 7;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTPUB: 0,0,0") )
      {
        sub_80052C4((const char *)&loc_800EE70);
        byte_20004370 = 8;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTCLOSE: 0,0") )
      {
        sub_80052C4((const char *)&loc_800EE70);
        byte_20004370 = 9;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,0") )
      {
        sub_80052C4((const char *)&loc_800EEC4);
        byte_20004370 = 6;
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,2") )
      {
        sub_80052C4(
          ",mcp_w=%d,mdp_w=%d,ct_t=%d,phase_t=%d,dchrg_t=%d,bms_v=%d,fc_v=%s,wifi_n=%s,seq_s=%d,ctrl_r=%d,par=%d,gen=%d,ble=%d,shelly_p=%d,c_ratio=%d",
          v4,
          v5,
          v6,
          v11,
          v12,
          v13,
          v14,
          v15,
          v16,
          v17,
          v18,
          v19,
          v20,
          v21,
          v22);
        byte_2000436E[0] = 0;
        byte_20004370 = 4;
        sub_8018F5C(4, 408);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTOPEN: 0,-1") )
      {
        sub_80052C4("ng : GET METER ERR!!! meter_disconnect_cnt = %d!\r\n", v7);
        byte_2000436E[0] = 0;
        byte_20004370 = 3;
        sub_8018F5C(4, 409);
      }
      else if ( strstr((unsigned __int8 *)&v12, "+QMTSTAT:") )
      {
        sub_80052C4((const char *)&loc_800EF28);
        sub_8018F5C(4, 410);
        if ( byte_20000930 )
          byte_2000436E[0] = 0;
        else
          byte_200037D4[0] = 2;
      }
      return sub_8002364(&v12, 256);
    }
    else
    {
      if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:") )
      {
        if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:WLAN_CONNECTED")
          || strstr((unsigned __int8 *)&v12, "+QSTASTAT:GOT_IP") )
        {
          sub_80052C4((const char *)&loc_800EFA4);
          byte_20000930 = 1;
          byte_2000436E[0] = 0;
          byte_2000436F = 1;
          byte_20004370 = 10;
          sub_8018F5C(4, 404);
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QSTASTAT:WLAN DISCONNECTED")
               || strstr((unsigned __int8 *)&v12, "+QSTASTAT:SCAN_NO_AP") )
        {
          sub_80052C4(
            "_i=%d,tra_o=%d,htt_p=%d,prc_c=%d,prc_d=%d,wif_s=%d,inc_a=%d,set_v=%d,mcp_w=%d,mdp_w=%d,ct_t=%d,phase_t=%d,dchrg_t=%d,bms_v=%d,fc_v=%s,wifi_n=%s,seq_s=%d,ctrl_r=%d,par=%d,gen=%d,ble=%d,shelly_p=%d,c_ratio=%d",
            v8,
            v9,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19,
            v20,
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30);
          byte_20000930 = 0;
          byte_200037D4[0] = 2;
          sub_8018F5C(4, 405);
        }
        return sub_8002364(&v12, 256);
      }
      result = strstr((unsigned __int8 *)&v12, "+QBLESTAT:");
      if ( result )
      {
        if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:ADVERTISING") )
        {
          sub_80052C4((const char *)&loc_800F038);
          byte_20004360 = 1;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:CONNECTED") )
        {
          sub_80052C4((const char *)sub_800F0E8);
          byte_20004360 = 2;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:DISCONNECTED") )
        {
          sub_80052C4((const char *)sub_800F130);
          byte_20004360 = 3;
        }
        else if ( strstr((unsigned __int8 *)&v12, "+QBLESTAT:NOINIT")
               || strstr((unsigned __int8 *)&v12, "+QBLESTAT:INIT") )
        {
          sub_80052C4((const char *)&dword_800F194);
          byte_20004360 = 0;
          sub_8018F5C(4, 406);
          if ( byte_2000050A == 1 )
            byte_200037D4[0] = 2;
          else
            byte_200037D4[0] = 0;
        }
        return sub_8002364(&v12, 256);
      }
    }
  }
  return result;
}
// 800EAC4: variable 'v1' is possibly undefined
// 800EAC4: variable 'v2' is possibly undefined
// 800EAC4: variable 'v3' is possibly undefined
// 800EAC4: variable 'v11' is possibly undefined
// 800EB86: variable 'v4' is possibly undefined
// 800EB86: variable 'v5' is possibly undefined
// 800EB86: variable 'v6' is possibly undefined
// 800EBA8: variable 'v7' is possibly undefined
// 800EC4A: variable 'v8' is possibly undefined
// 800EC4A: variable 'v9' is possibly undefined
// 800EC4A: variable 'v10' is possibly undefined
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800F130: using guessed type int sub_800F130();
// 800F194: using guessed type int dword_800F194;
// 20000450: using guessed type int dword_20000450;
// 2000050A: using guessed type char byte_2000050A;
// 20000930: using guessed type char byte_20000930;
// 20000996: using guessed type char byte_20000996;
// 20004360: using guessed type char byte_20004360;
// 2000436F: using guessed type char byte_2000436F;
// 20004370: using guessed type char byte_20004370;

//----- (0800F0E8) --------------------------------------------------------
void __fastcall sub_800F0E8(int a1, int a2, int a3, int a4)
{
  *(_WORD *)(a4 + a2) = a4;
  JUMPOUT(0x800F5DE);
}
// 800F0EA: control flows out of bounds to 800F5DE

//----- (0800F1D8) --------------------------------------------------------
int __fastcall sub_800F1D8(unsigned __int8 *a1)
{
  unsigned __int16 v2; // r0

  if ( !a1 )
    return 0;
  v2 = (unsigned __int16)sub_80023E2(a1);
  if ( !v2 )
    return 0;
  sub_801D6C8((int)a1, v2);
  sub_801D6C8((int)&dword_800F204, 2);
  return 1;
}
// 800F204: using guessed type int dword_800F204;

//----- (0800F208) --------------------------------------------------------
int sub_800F208()
{
  unsigned __int8 *v1; // r6
  unsigned __int8 *v2; // r0

  if ( byte_200015B4 )
    return 0;
  if ( (unsigned __int8)byte_2000092F > 0xAu )
  {
    byte_2000092F = 0;
    byte_2000092E = 2;
    if ( byte_20004360 != 2 && !byte_200037D8 )
      sub_80080B4(1);
  }
  if ( byte_20000930 )
  {
    byte_2000092F = 0;
    byte_2000092E = 0;
    return 1;
  }
  if ( byte_2000092E )
  {
    switch ( byte_2000092E )
    {
      case 1:
        if ( sub_801B040(&word_20000936, 0x14u) )
        {
          word_20000936 = 0;
          ++byte_2000092F;
          byte_2000092E = 2;
        }
        break;
      case 2:
        if ( sub_801B018(&word_20000936, 0x12Cu) )
        {
          word_20000936 = 0;
          sub_8002364(byte_20002FDB, 32);
          sub_8002364(byte_20002FFB, 64);
          sub_80057C4(0x400u, (int)byte_20002FDB, 32);
          sub_80057C4(0x420u, (int)byte_20002FFB, 64);
          sub_80052C4("### Auto set wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002FDB, byte_20002FFB);
          if ( (unsigned __int8)byte_20002FDB[0] == 255 || (unsigned __int8)byte_20002FFB[0] == 255 )
          {
            sub_800240C(byte_20002FDB, "SM471");
            sub_800240C(byte_20002FFB, "Hame147258");
            sub_80052C4("**** wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002FDB, byte_20002FFB);
          }
          byte_2000092E = 3;
        }
        break;
      case 3:
        v1 = sub_80023E2((unsigned __int8 *)byte_20002FFB);
        v2 = sub_80023E2((unsigned __int8 *)byte_20002FDB);
        sub_800F450(byte_20002FDB, byte_20002FFB, (int)v2, (unsigned int)v1);
        byte_2000092E = 0;
        byte_200037D6 = 0;
        break;
      default:
        byte_2000092E = 2;
        break;
    }
    return 0;
  }
  if ( !sub_800F554(1) && !byte_20000930 )
  {
    byte_2000092E = 1;
    sub_80052C4("Wait for wifi link, check cnt = %d.\r\n", (unsigned __int8)byte_2000092F);
    return 0;
  }
  sub_80052C4("Wifi connected! ### wifi_ssid:%s,wifi_key:%s.\r\n", byte_20002FDB, byte_20002FFB);
  sub_800591C(0x400u, byte_20002FDB, 0x20u);
  sub_800591C(0x420u, byte_20002FFB, 0x40u);
  byte_2000092F = 0;
  byte_2000436E = 0;
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 2000092E: using guessed type char byte_2000092E;
// 2000092F: using guessed type char byte_2000092F;
// 20000930: using guessed type char byte_20000930;
// 20000936: using guessed type __int16 word_20000936;
// 200015B4: using guessed type char byte_200015B4;
// 200037D6: using guessed type char byte_200037D6;
// 200037D8: using guessed type char byte_200037D8;
// 20004360: using guessed type char byte_20004360;
// 2000436E: using guessed type char byte_2000436E;

//----- (0800F450) --------------------------------------------------------
int __fastcall sub_800F450(const char *a1, const char *a2, int a3, unsigned int a4)
{
  unsigned int v8; // r4
  unsigned __int8 v10[152]; // [sp+8h] [bp-98h] BYREF

  sub_8002364(v10, 128);
  v8 = 0;
  if ( !a1 || !a2 )
    return 0;
  sub_80052C4("Set Wifi ssid:%s, key:%s, ssid_len:%d, key_len:%d.\r\n", a1, a2, a3, a4);
  if ( (unsigned int)(a3 - 1) < 0x20 && a4 >= 8 && a4 <= 0x40 )
  {
    sprintf((int)v10, "AT+QSTAAPINFODEF=%s,%s", a1, a2);
    while ( v8 < 3 )
    {
      if ( sub_800DFB4(v10, "OK", 0, 600) )
      {
        byte_20000930 = 0;
        return 1;
      }
      sub_8023A34(200);
      v8 = (unsigned __int8)(v8 + 1);
    }
    return 0;
  }
  else
  {
    sub_80052C4("Warning : WiFi set oversize!\r\n");
    return 0;
  }
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20000930: using guessed type char byte_20000930;

//----- (0800F554) --------------------------------------------------------
int __fastcall sub_800F554(int a1)
{
  int v1; // r5
  unsigned int v2; // r4
  unsigned int v4; // r4
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r4
  unsigned __int8 *v7; // r0
  int i; // r1
  unsigned __int8 *v9; // r0

  v1 = a1;
  v2 = 0;
  if ( a1 == 2 )
  {
    while ( !byte_20000930 && v2 <= 6 )
    {
      if ( byte_2000435F )
        return 0;
      v2 = (unsigned __int8)(v2 + 1);
      sub_8023A34(300);
    }
  }
  v4 = 0;
  if ( !byte_20000930 && v1 == 3 )
  {
    v1 = 1;
    v4 = 2;
  }
  while ( 1 )
  {
    if ( 3 * v1 <= v4 )
    {
      byte_20000930 = 0;
      sub_80052C4("[WIFI] State disconnected!\r\n");
      return 0;
    }
    if ( byte_200037D6 == 1 && v1 == 3 )
    {
      sub_80052C4("[WIFI] Wait for urc, don't check wifi state!\r\n");
      return 1;
    }
    if ( sub_800DFB4("AT+QGETWIFISTATE", 0, (unsigned __int8 *)&dword_800F664, 600) )
      break;
    sub_8023A34(200);
    v4 = (unsigned __int8)(v4 + 1);
  }
  sub_80052C4("WiFi link ok!\r\n");
  byte_20000930 = 1;
  v5 = strstr((unsigned __int8 *)byte_20003A24, "ssid=");
  v6 = v5;
  if ( v5 )
  {
    v7 = strstr(v5, (unsigned __int8 *)&dword_800F698);
    for ( i = 5; v7 - v6 != i; i = (unsigned __int8)(i + 1) )
      byte_20004D74[i - 5] = v6[i];
    byte_20004D74[i - 5] = 0;
    sub_80052C4("WiFi connected ssid:%s, wifi name:%s.\r\n", byte_20004D74, &byte_20002FDB);
  }
  v9 = strstr((unsigned __int8 *)byte_20003A24, "rssi=");
  if ( v9 )
  {
    byte_20000931 = sub_8002644((char *)v9 + 6);
    sub_80052C4("WiFi signal strength:%d.\r\n", (unsigned __int8)byte_20000931);
  }
  return 1;
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 800F664: using guessed type int dword_800F664;
// 800F698: using guessed type int dword_800F698;
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 20002FDB: using guessed type char byte_20002FDB;
// 200037D6: using guessed type char byte_200037D6;
// 2000435F: using guessed type char byte_2000435F;

//----- (0800F740) --------------------------------------------------------
int sub_800F740()
{
  int result; // r0

  result = (unsigned __int8)byte_200015B4;
  if ( !byte_200015B4 )
  {
    if ( byte_2000435F )
    {
      byte_2000435F = 0;
      sub_800DEE0();
    }
    result = (int)&byte_2000092E;
    if ( byte_200037D8 )
      word_20000934 = 10;
    else
      word_20000934 = 60;
    if ( byte_200037DC == 7 && !byte_200037D6 )
    {
      result = sub_801B040(algn_20000932, (unsigned __int16)word_20000934);
      if ( result )
        return sub_800F554(3);
    }
  }
  return result;
}
// 2000092E: using guessed type char byte_2000092E;
// 20000932: using guessed type _BYTE[2];
// 20000934: using guessed type __int16 word_20000934;
// 200015B4: using guessed type char byte_200015B4;
// 200037D6: using guessed type char byte_200037D6;
// 200037D8: using guessed type char byte_200037D8;
// 200037DC: using guessed type char byte_200037DC;
// 2000435F: using guessed type char byte_2000435F;

//----- (0800F7A4) --------------------------------------------------------
unsigned int sub_800F7A4()
{
  unsigned int v0; // r4
  unsigned int result; // r0
  int i; // r0

  v0 = 0;
  result = sub_8012948() - dword_2000005C;
  if ( result <= 0x46 )
  {
    for ( i = 0; i < 4; ++i )
      v0 += dword_20001A04[i];
    return 2 * (v0 >> 2);
  }
  return result;
}
// 2000005C: using guessed type int dword_2000005C;
// 20001A04: using guessed type _DWORD dword_20001A04[4];

//----- (0800F808) --------------------------------------------------------
BOOL __fastcall sub_800F808(unsigned int a1, int a2)
{
  int v4; // r4
  int v6; // [sp+4h] [bp-24h] BYREF
  int v7; // [sp+8h] [bp-20h]
  unsigned int v8; // [sp+Ch] [bp-1Ch]
  unsigned int v9; // [sp+10h] [bp-18h]
  unsigned int v10; // [sp+14h] [bp-14h] BYREF

  v10 = 0;
  sub_80126C4();
  MEMORY[0x40022010] = 178;
  if ( a1 < 0x8040000 )
  {
    v7 = 1;
    v8 = (a1 - 0x8000000) >> 11;
  }
  else
  {
    v7 = 2;
    v8 = (a1 - 134479872) >> 11;
  }
  v6 = 0;
  v9 = (a2 - a1) >> 11;
  v4 = sub_8012530(&v6, &v10);
  sub_8012628();
  return v4 != 0;
}

//----- (0800F86C) --------------------------------------------------------
int __fastcall sub_800F86C(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v6; // r4
  unsigned int v8; // r0

  v6 = 0;
  sub_80126C4();
  MEMORY[0x40022010] = 186;
  while ( v6 < a3 )
  {
    v8 = MEMORY[0x1FFF75E0] == 0xFFFF ? 0x80000 : (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
    if ( (v8 >> 1) + 134479864 < (unsigned int)a1 )
      break;
    if ( sub_8012644(0, a1, *(int **)(a2 + 8 * v6), *(_DWORD *)(a2 + 8 * v6 + 4)) )
      return 3;
    a1 += 2;
    ++v6;
  }
  sub_8012628();
  return 0;
}

//----- (0800F8E4) --------------------------------------------------------
int sub_800F8E4()
{
  int result; // r0

  dword_20003C7F = dword_20003040 / 0xAu;
  dword_20003C83 = dword_20003044 / 0xAu;
  dword_20003C63 = dword_20003058 / 0xAu;
  dword_20003C67 = dword_2000304C / 0xAu;
  dword_20003C6B = dword_2000305C / 0xAu;
  dword_20003C6F = dword_20003050 / 0xAu;
  dword_20003C73 = dword_20003060 / 100000;
  dword_20003C77 = dword_20003054 / 100000;
  dword_20003C7B = dword_20003048 / 100000;
  byte_20003C40 = byte_20000931;
  word_20003C45 = (unsigned int)flt_2000277C;
  if ( !byte_200002AB && byte_20002F5F[0] == 1 )
    word_20003C47 = (int)flt_2000277C;
  else
    word_20003C47 = (int)flt_200027A4;
  byte_20003C39 = byte_200004AD;
  byte_20003C3A = byte_200015E6;
  byte_20003C3B = sub_801D334();
  word_20003C49 = (unsigned __int16)dword_20002E7E * (unsigned __int16)dword_20002E7A / 1000;
  byte_20003C3C = dword_20002E7A;
  word_20003C59 = 0;
  word_20003C5B = 0;
  word_20003C5D = dword_20002E88;
  word_20003C5F = dword_20002E8C;
  word_20003C43 = word_20002F5A;
  byte_20003C3F = 0;
  byte_20003C3D = byte_20002F60;
  byte_20003C3E = byte_20002FCF;
  word_20003C61 = (unsigned __int8)byte_20002F5F[0];
  dword_20003C87 = (unsigned __int16)word_20002FC5;
  dword_20003C8B = dword_20002FC7;
  dword_20003C8F = dword_20002FCB;
  dword_20003D30 = (unsigned __int8)byte_200015AE;
  dword_20003D34 = (unsigned __int8)byte_20002FD1;
  word_20003C4B = (unsigned int)flt_200002F0;
  word_20003C4D = (unsigned int)flt_20002798;
  word_20003C4F = (int)flt_20001C2C;
  word_20003C51 = (int)flt_20001C30;
  word_20003C53 = (int)flt_20001C34;
  word_20003C55 = word_20002E86;
  word_20003C57 = sub_8010294((__int16 *)&dword_20002E97, 4u);
  byte_20003C41 = byte_2000303B;
  byte_20003C42 = byte_2000050B;
  word_20003D38 = word_20000518;
  word_20003D3A = word_2000051A;
  word_20003D3C = HIWORD(dword_20002E74);
  word_20003D3E = word_20002E78;
  word_20003D40 = (unsigned int)(float)(flt_20001C14 * 10.0);
  word_20003D42 = (int)(float)(flt_20001C18 * 10.0);
  word_20003D44 = BYTE2(dword_20002E7E);
  word_20003D46 = (int)(float)(flt_20001C04 * 10.0);
  byte_20003D48 = byte_20000517;
  byte_20003D49 = byte_200004AC;
  byte_20003D4A = byte_20004360;
  byte_20003D4B = byte_2000436E;
  byte_20003D4C = byte_200015E4;
  byte_20003D4D = byte_2001126C;
  if ( sub_80023E2(&byte_20011220[8]) )
    qmemcpy((unsigned int)byte_20003D4E, (unsigned int)&byte_20011220[8], sizeof(byte_20003D4E));
  else
    strcpy(byte_20003D4E, "000000000000");
  *(_QWORD *)&off_20003D20 = *(_QWORD *)&dword_200028C0;
  dword_20003D28 = dword_200028C8;
  dword_20003D2C = dword_200028CC;
  sub_801D35C();
  byte_20003D7F = byte_20002FD3;
  result = (unsigned __int8)byte_20002FD5;
  byte_20003D80 = byte_20002FD5;
  return result;
}
// 200002AB: using guessed type char byte_200002AB;
// 200002F0: using guessed type float flt_200002F0;
// 200004AC: using guessed type char byte_200004AC;
// 200004AD: using guessed type char byte_200004AD;
// 2000050B: using guessed type char byte_2000050B;
// 20000517: using guessed type char byte_20000517;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 20000931: using guessed type char byte_20000931;
// 200015AE: using guessed type char byte_200015AE;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 20001C04: using guessed type float flt_20001C04;
// 20001C14: using guessed type float flt_20001C14;
// 20001C18: using guessed type float flt_20001C18;
// 20001C2C: using guessed type float flt_20001C2C;
// 20001C30: using guessed type float flt_20001C30;
// 20001C34: using guessed type float flt_20001C34;
// 2000277C: using guessed type float flt_2000277C;
// 20002798: using guessed type float flt_20002798;
// 200027A4: using guessed type float flt_200027A4;
// 200028C0: using guessed type int dword_200028C0;
// 200028C8: using guessed type int dword_200028C8;
// 200028CC: using guessed type int dword_200028CC;
// 20002E74: using guessed type int dword_20002E74;
// 20002E78: using guessed type __int16 word_20002E78;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002E7E: using guessed type int dword_20002E7E;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E88: using guessed type int dword_20002E88;
// 20002E8C: using guessed type int dword_20002E8C;
// 20002E97: using guessed type int dword_20002E97;
// 20002F5A: using guessed type __int16 word_20002F5A;
// 20002F60: using guessed type char byte_20002F60;
// 20002FC5: using guessed type __int16 word_20002FC5;
// 20002FC7: using guessed type int dword_20002FC7;
// 20002FCB: using guessed type int dword_20002FCB;
// 20002FCF: using guessed type char byte_20002FCF;
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FD3: using guessed type char byte_20002FD3;
// 20002FD5: using guessed type char byte_20002FD5;
// 2000303B: using guessed type char byte_2000303B;
// 20003040: using guessed type int dword_20003040;
// 20003044: using guessed type int dword_20003044;
// 20003048: using guessed type int dword_20003048;
// 2000304C: using guessed type int dword_2000304C;
// 20003050: using guessed type int dword_20003050;
// 20003054: using guessed type int dword_20003054;
// 20003058: using guessed type int dword_20003058;
// 2000305C: using guessed type int dword_2000305C;
// 20003060: using guessed type int dword_20003060;
// 20003C39: using guessed type char byte_20003C39;
// 20003C3A: using guessed type char byte_20003C3A;
// 20003C3B: using guessed type char byte_20003C3B;
// 20003C3C: using guessed type char byte_20003C3C;
// 20003C3D: using guessed type char byte_20003C3D;
// 20003C3E: using guessed type char byte_20003C3E;
// 20003C3F: using guessed type char byte_20003C3F;
// 20003C40: using guessed type char byte_20003C40;
// 20003C41: using guessed type char byte_20003C41;
// 20003C42: using guessed type char byte_20003C42;
// 20003C43: using guessed type __int16 word_20003C43;
// 20003C45: using guessed type __int16 word_20003C45;
// 20003C47: using guessed type __int16 word_20003C47;
// 20003C49: using guessed type __int16 word_20003C49;
// 20003C4B: using guessed type __int16 word_20003C4B;
// 20003C4D: using guessed type __int16 word_20003C4D;
// 20003C4F: using guessed type __int16 word_20003C4F;
// 20003C51: using guessed type __int16 word_20003C51;
// 20003C53: using guessed type __int16 word_20003C53;
// 20003C55: using guessed type __int16 word_20003C55;
// 20003C57: using guessed type __int16 word_20003C57;
// 20003C59: using guessed type __int16 word_20003C59;
// 20003C5B: using guessed type __int16 word_20003C5B;
// 20003C5D: using guessed type __int16 word_20003C5D;
// 20003C5F: using guessed type __int16 word_20003C5F;
// 20003C61: using guessed type __int16 word_20003C61;
// 20003C63: using guessed type int dword_20003C63;
// 20003C67: using guessed type int dword_20003C67;
// 20003C6B: using guessed type int dword_20003C6B;
// 20003C6F: using guessed type int dword_20003C6F;
// 20003C73: using guessed type int dword_20003C73;
// 20003C77: using guessed type int dword_20003C77;
// 20003C7B: using guessed type int dword_20003C7B;
// 20003C7F: using guessed type int dword_20003C7F;
// 20003C83: using guessed type int dword_20003C83;
// 20003C87: using guessed type int dword_20003C87;
// 20003C8B: using guessed type int dword_20003C8B;
// 20003C8F: using guessed type int dword_20003C8F;
// 20003D20: using guessed type _UNKNOWN *off_20003D20;
// 20003D28: using guessed type int dword_20003D28;
// 20003D2C: using guessed type int dword_20003D2C;
// 20003D30: using guessed type int dword_20003D30;
// 20003D34: using guessed type int dword_20003D34;
// 20003D38: using guessed type __int16 word_20003D38;
// 20003D3A: using guessed type __int16 word_20003D3A;
// 20003D3C: using guessed type __int16 word_20003D3C;
// 20003D3E: using guessed type __int16 word_20003D3E;
// 20003D40: using guessed type __int16 word_20003D40;
// 20003D42: using guessed type __int16 word_20003D42;
// 20003D44: using guessed type __int16 word_20003D44;
// 20003D46: using guessed type __int16 word_20003D46;
// 20003D48: using guessed type char byte_20003D48;
// 20003D49: using guessed type char byte_20003D49;
// 20003D4A: using guessed type char byte_20003D4A;
// 20003D4B: using guessed type char byte_20003D4B;
// 20003D4C: using guessed type char byte_20003D4C;
// 20003D4D: using guessed type char byte_20003D4D;
// 20003D7F: using guessed type char byte_20003D7F;
// 20003D80: using guessed type char byte_20003D80;
// 20004360: using guessed type char byte_20004360;
// 2000436E: using guessed type char byte_2000436E;
// 20011220: using guessed type unsigned __int8 byte_20011220[44];
// 2001126C: using guessed type char byte_2001126C;

//----- (0800FBB0) --------------------------------------------------------
int __fastcall sub_800FBB0(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int i; // r2

  result = 0;
  if ( a1 )
  {
    for ( i = 0; i < a2; ++i )
      result = (unsigned __int16)(result + *(unsigned __int8 *)(a1 + i));
  }
  return result;
}

//----- (0800FBCC) --------------------------------------------------------
int sub_800FBCC()
{
  int result; // r0

  LOBYTE(result) = 1;
  if ( (unsigned __int8)byte_20002FDA >= 3u )
  {
    if ( byte_20002FD1 == 4 )
      LOBYTE(result) = 2;
  }
  else
  {
    LOBYTE(result) = byte_20002FDA;
  }
  return (unsigned __int8)result;
}
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FDA: using guessed type char byte_20002FDA;

//----- (0800FBF0) --------------------------------------------------------
int sub_800FBF0()
{
  int result; // r0

  result = 5;
  if ( (unsigned __int8)byte_20002FDA < 3u )
    return *(unsigned __int16 *)&aBeginCertifica_0[4 * (unsigned __int8)byte_20002FDA + 131];
  if ( byte_20002FD1 == 4 )
    return 10;
  return result;
}
// 20002FD1: using guessed type char byte_20002FD1;
// 20002FDA: using guessed type char byte_20002FDA;

//----- (0800FC1C) --------------------------------------------------------
__int64 sub_800FC1C()
{
  unsigned __int8 *v0; // r0
  unsigned int v1; // r4
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r0
  unsigned int v4; // r6
  unsigned int v5; // r4
  int v6; // r0
  signed int v7; // r2
  _BYTE *v8; // r0
  __int64 v10; // [sp+0h] [bp-20h] BYREF
  int v11; // [sp+8h] [bp-18h]
  int v12; // [sp+Ch] [bp-14h]

  v10 = 0;
  v11 = 0;
  v12 = 0;
  sub_8004BA0();
  if ( !byte_200112A8[0] )
  {
    if ( sub_8018B94("AT+QGETIP=station\r\n", "QGETIP", 300) )
    {
      v0 = strstr(byte_20011328, "ip:");
      v1 = (unsigned int)v0;
      if ( v0 )
      {
        if ( v0[3] != 48 )
        {
          v2 = strstr(byte_20011328, "dns:");
          if ( v2 )
          {
            if ( v2[4] != 48 )
            {
              v3 = strstr(byte_20011328, "\r\n");
              if ( v3 )
              {
                v4 = (unsigned int)&v3[-v1];
                if ( (unsigned int)&v3[-v1] < 0x80 )
                {
                  sub_8002364(byte_200112A8, 128);
                  qmemcpy((unsigned int)byte_200112A8, v1, v4);
                  v5 = v1 + 3;
                  v6 = sub_80023CE(v5, 0x2Cu);
                  if ( v6 )
                  {
                    v7 = v6 - v5;
                    if ( (int)(v6 - v5) <= 16 && v7 > 4 )
                    {
                      qmemcpy((unsigned int)&v10, v5, v7);
                      v8 = sub_8002480(&v10, 46);
                      if ( v8 && (unsigned int)(v8 - (_BYTE *)&v10) < 0x10 )
                      {
                        dword_20011298 = 0;
                        dword_2001129C = 0;
                        dword_200112A0 = 0;
                        dword_200112A4 = 0;
                        qmemcpy((unsigned int)&dword_20011298, (unsigned int)&v10, v8 - (_BYTE *)&v10);
                        sub_800237A((int)&dword_20011298, ".255");
                      }
                      sub_801ADD8((int)"%s %d g_dev_net_info:%s\r\n", " discharge power = %d.\r\n", 997, byte_200112A8);
                      sub_801ADD8(
                        (int)"%s %d g_szMonitorIP:%s\r\n",
                        " discharge power = %d.\r\n",
                        998,
                        (const char *)&dword_20011298);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}
// 20011298: using guessed type int dword_20011298;
// 2001129C: using guessed type int dword_2001129C;
// 200112A0: using guessed type int dword_200112A0;
// 200112A4: using guessed type int dword_200112A4;
// 20011328: using guessed type _BYTE byte_20011328[936];

//----- (0800FD78) --------------------------------------------------------
int sub_800FD78()
{
  sub_80057C4(0x3000u, (int)&dword_20003A0B, 8);
  if ( !sub_80023F0((int)&dword_20003A0B, (int)"HMG-50") && (unsigned __int16)dword_20002E7E > 0xBB8u
    || !sub_80023F0((int)&dword_20003A0B, (int)"HMG-25")
    && (_WORD)dword_20002E7E
    && (unsigned __int16)dword_20002E7E <= 0xBB8u )
  {
    return sub_80052C4(
             "*** Device type [AC Couple]: %s, BMS capacity: %d.\r\n",
             &dword_20003A0B,
             (unsigned __int16)dword_20002E7E);
  }
  if ( (unsigned int)(unsigned __int16)dword_20002E7E - 3001 >= 0xBB7 )
  {
    if ( (unsigned int)(unsigned __int16)dword_20002E7E - 1 >= 0xBB7 )
    {
      strcpy((char *)&dword_20003A0B, "HMG-1");
      return sub_80052C4("Device type [AC Couple]: %s, size: %d, BMS capacity: %d.\r\n", &dword_20003A0B, 6);
    }
    else
    {
      dword_20003A0B = *(_DWORD *)"HMG-25";
      dword_20003A0F = *(unsigned __int16 *)"25";
      BYTE2(dword_20003A0F) = 0;
      sub_800591C(0x3000u, &dword_20003A0B, 8u);
      return sub_80052C4("Device type [AC Couple 2.5]: %s, size: %d, BMS capacity: %d.\r\n", &dword_20003A0B, 7);
    }
  }
  else
  {
    dword_20003A0B = *(_DWORD *)"HMG-50";
    dword_20003A0F = *(unsigned __int16 *)"50";
    BYTE2(dword_20003A0F) = 0;
    sub_800591C(0x3000u, &dword_20003A0B, 8u);
    return sub_80052C4("Device type [AC Couple 5.0]: %s, size: %d, BMS capacity: %d.\r\n", &dword_20003A0B, 7);
  }
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 20002E7E: using guessed type int dword_20002E7E;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003A0F: using guessed type int dword_20003A0F;

//----- (0800FF64) --------------------------------------------------------
_BYTE *sub_800FF64()
{
  unsigned int i; // r4
  _BYTE *result; // r0

  sub_80057C4(0x1100u, (int)&dword_20003D81, 280);
  for ( i = 0; i < 0x14; ++i )
  {
    result = (char *)&dword_20003D81 + 14 * i;
    if ( (unsigned int)*(unsigned __int16 *)result - 2000 >= 0xC9 || (unsigned __int8)result[2] > 0xCu || !result[2] )
      result = sub_8002364(result, 14);
  }
  return result;
}
// 20003D81: using guessed type int dword_20003D81;

//----- (0800FFA4) --------------------------------------------------------
__int64 __fastcall sub_800FFA4(__int64 a1)
{
  unsigned int i; // r0
  unsigned __int16 *v2; // r2
  unsigned int j; // r7
  unsigned int k; // r4
  char *v5; // r6
  char *v6; // r5
  unsigned int m; // r4
  int v10; // [sp+8h] [bp-28h]
  char v11; // [sp+Ch] [bp-24h]

  sub_80057C4(0x2000u, (int)byte_20003E99, 180);
  for ( i = 0; i < 0x14; ++i )
  {
    v2 = (unsigned __int16 *)&byte_20003E99[9 * i];
    if ( (unsigned int)*v2 - 2000 >= 0xC9 || *((unsigned __int8 *)v2 + 2) > 0xCu || !*((_BYTE *)v2 + 2) )
    {
      *(_DWORD *)v2 = 0;
      *((_DWORD *)v2 + 1) = 0;
      *((_BYTE *)v2 + 8) = 0;
    }
  }
  for ( j = 0; j < 0x13; ++j )
  {
    for ( k = 0; 19 - j > k; ++k )
    {
      v5 = &byte_20003E99[9 * k + 9];
      v6 = &byte_20003E99[9 * k];
      LODWORD(a1) = *(_DWORD *)v6;
      WORD2(a1) = *((_WORD *)v6 + 2);
      if ( sub_8004F52(*(_DWORD *)v6, SWORD2(a1), *(_DWORD *)v5, *((_WORD *)v5 + 2)) > 0 )
      {
        HIDWORD(a1) = *(_DWORD *)v6;
        v10 = *((_DWORD *)v6 + 1);
        v11 = v6[8];
        *(_DWORD *)v6 = *(_DWORD *)v5;
        *((_DWORD *)v6 + 1) = *((_DWORD *)v5 + 1);
        v6[8] = v5[8];
        *(_DWORD *)v5 = HIDWORD(a1);
        *((_DWORD *)v5 + 1) = v10;
        v5[8] = v11;
      }
    }
  }
  for ( m = 0; m < 0x14; ++m )
    sub_800591C(9 * m + 0x2000, &byte_20003E99[9 * m], 9u);
  return a1;
}
// 20003E99: using guessed type _BYTE byte_20003E99[180];

//----- (08010070) --------------------------------------------------------
__int64 __fastcall sub_8010070(__int64 a1, int a2, int a3)
{
  unsigned __int8 *v3; // r0
  int v4; // r4
  int v5; // r0
  signed int v6; // r2
  unsigned int i; // r4
  int v8; // r0
  __int64 v10; // [sp+0h] [bp-20h] BYREF
  int v11; // [sp+8h] [bp-18h]
  int v12; // [sp+Ch] [bp-14h]

  v10 = a1;
  v11 = a2;
  v12 = a3;
  if ( (_DWORD)a1 )
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v3 = strstr((unsigned __int8 *)a1, "QIRD:");
    if ( v3 )
    {
      v4 = sub_80023CE((int)v3, 0x2Cu) + 2;
      v5 = sub_80023CE(v4, 0x22u);
      if ( v5 )
      {
        v6 = v5 - v4;
        if ( v5 - v4 <= 16 && v6 > 4 )
          qmemcpy((unsigned int)&v10, v4, v6);
      }
    }
    if ( sub_80023F0((int)&v10, (int)&qword_20011298) )
    {
      sub_801ADD8(
        (int)"%s %d tmp_ip:%s\r\n",
        "b_ver=%d,b_chv=%d,b_rci=%d,b_rdi=%d,b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cp"
        "c=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d"
        ",b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
        1141,
        (const char *)&v10);
      sub_801ADD8(
        (int)"%s %d g_szMonitorIP:%s\r\n",
        "b_ver=%d,b_chv=%d,b_rci=%d,b_rdi=%d,b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cp"
        "c=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d"
        ",b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
        1142,
        (const char *)&qword_20011298);
      for ( i = 0; (unsigned int)sub_80023E2((unsigned __int8 *)&v10) > i; ++i )
      {
        v8 = *((unsigned __int8 *)&v10 + i);
        if ( (unsigned int)(v8 - 48) >= 0xA && v8 != 46 )
          return v10;
      }
      qword_20011298 = v10;
      dword_200112A0 = v11;
      dword_200112A4 = v12;
    }
    sub_801ADD8(
      (int)"%s %d g_szMonitorIP:%s\r\n",
      "b_ver=%d,b_chv=%d,b_rci=%d,b_rdi=%d,b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cpc="
      "%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d,b_v"
      "o4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
      1151,
      (const char *)&qword_20011298);
  }
  return v10;
}
// 20011298: using guessed type __int64 qword_20011298;
// 200112A0: using guessed type int dword_200112A0;
// 200112A4: using guessed type int dword_200112A4;

//----- (08010150) --------------------------------------------------------
int __fastcall sub_8010150(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r5
  _BYTE *v5; // r0
  unsigned int v6; // r4
  char v8[84]; // [sp+4h] [bp-54h] BYREF

  if ( a1 && a2 )
  {
    v3 = strstr(a1, a2);
    if ( v3 )
    {
      v4 = &v3[(_DWORD)sub_80023E2(a2) + 2];
      v5 = sub_80024A0(v4, &dword_80101D4);
      if ( v5 )
      {
        v6 = v5 - v4;
        sub_8002364(v8, 64);
        if ( v6 >= 0x40 )
          v6 = 63;
        sub_80023B6(v8, v4, v6);
        v8[v6] = 0;
        sub_80052C4("Get meter data info, \"%s\" = %s.\r\n", (const char *)a2, v8);
        return sub_8002644(v8);
      }
      else
      {
        sub_80052C4("Get meter data info failed, end position not found.\r\n");
        return 0xFFFF;
      }
    }
    else
    {
      sub_80052C4("Get meter data info failed, key not found.\r\n");
      return 0xFFFF;
    }
  }
  else
  {
    sub_80052C4("Get meter data info failed, input is null.\r\n");
    return 0xFFFF;
  }
}
// 80052C4: using guessed type int sub_80052C4(const char *a1, ...);
// 80101D4: using guessed type int dword_80101D4;

//----- (08010294) --------------------------------------------------------
int __fastcall sub_8010294(__int16 *a1, unsigned int a2)
{
  int v2; // r3
  unsigned int i; // r2

  if ( !a1 || !a2 )
    return 0;
  v2 = *a1;
  for ( i = 1; i < a2; i = (unsigned __int8)(i + 1) )
  {
    if ( a1[i] < v2 )
      v2 = a1[i];
  }
  return (__int16)v2;
}

//----- (080102C0) --------------------------------------------------------
int sub_80102C0()
{
  unsigned int v0; // r4
  int i; // r0
  char *v2; // r1
  BOOL v3; // r2

  v0 = (unsigned __int8)byte_20002F1D | ((unsigned __int8)byte_20002F1C << 8);
  for ( i = 0; i < 10; ++i )
  {
    v2 = &byte_20002F5F[10 * i];
    if ( v2[3] && v2[2] )
    {
      v3 = 0;
      if ( *((unsigned __int16 *)v2 + 3) <= v0 )
        v3 = *((unsigned __int16 *)v2 + 4) > v0;
      if ( ((1 << (byte_20000500 - 1)) & (unsigned int)(unsigned __int8)v2[2]) >> (byte_20000500 - 1) && v3 )
        return *(__int16 *)&byte_20002F5F[10 * i + 4];
    }
  }
  return 0;
}
// 20000500: using guessed type char byte_20000500;
// 20002F1C: using guessed type char byte_20002F1C;
// 20002F1D: using guessed type char byte_20002F1D;

//----- (08010328) --------------------------------------------------------
int __fastcall sub_8010328(int result)
{
  int v1; // r4
  _BYTE v2[2]; // [sp+0h] [bp-20h] BYREF
  unsigned __int8 v3; // [sp+2h] [bp-1Eh]
  _BYTE v4[12]; // [sp+14h] [bp-Ch] BYREF

  v1 = result;
  if ( result )
  {
    sub_80194C8(v4, (int)v2);
    *(_WORD *)v1 = v4[3] + 2000;
    *(_BYTE *)(v1 + 2) = v4[1];
    *(_BYTE *)(v1 + 3) = v4[2];
    *(_BYTE *)(v1 + 4) = v4[0];
    *(_BYTE *)(v1 + 5) = v2[0];
    *(_BYTE *)(v1 + 6) = v2[1];
    result = v3;
    *(_BYTE *)(v1 + 7) = v3;
  }
  return result;
}

//----- (0801036C) --------------------------------------------------------
int __fastcall sub_801036C(int a1, __int16 a2)
{
  float v2; // s0
  int result; // r0
  int v4; // r3
  float v5; // s0
  __int16 v6; // [sp+Ah] [bp-Ah]
  unsigned __int8 v7; // [sp+Dh] [bp-7h]

  v6 = HIWORD(a1);
  v7 = HIBYTE(a2);
  result = (int)v2;
  v4 = (unsigned __int8)a2;
  if ( (_BYTE)a2 )
  {
    LOBYTE(a2) = HIBYTE(a2);
    if ( HIBYTE(a2) <= (unsigned int)(unsigned __int8)byte_20000517 )
      LOBYTE(a2) = byte_20000517;
    v7 = a2;
  }
  if ( v4 )
  {
    v5 = 0.1;
    if ( v6 <= 0 )
    {
      if ( v6 < 0 )
      {
        if ( v7 < (unsigned int)(unsigned __int16)dword_20002E7A )
        {
          if ( v7 >= (unsigned __int16)dword_20002E7A - 5 )
          {
            if ( result < 0 )
              return (int)(float)result;
            return (int)v5;
          }
        }
        else if ( v6 <= result )
        {
          return v6;
        }
      }
      else
      {
        return 0;
      }
    }
    else if ( v7 > (unsigned int)(unsigned __int16)dword_20002E7A )
    {
      if ( v7 <= (unsigned int)(unsigned __int16)dword_20002E7A + 5 )
      {
        if ( result >= 0 )
          return (int)(float)result;
        return (int)v5;
      }
    }
    else if ( v6 > result )
    {
      return v6;
    }
  }
  else if ( v6 <= 0 )
  {
    if ( v6 < 0 && v7 >= (unsigned int)(unsigned __int16)dword_20002E7A && v6 > result )
      return v6;
  }
  else if ( v7 <= (unsigned int)(unsigned __int16)dword_20002E7A && v6 <= result )
  {
    return v6;
  }
  return result;
}
// 8010376: variable 'v2' is possibly undefined
// 20000517: using guessed type char byte_20000517;
// 20002E7A: using guessed type int dword_20002E7A;

//----- (0801043C) --------------------------------------------------------
int sub_801043C()
{
  int v0; // r4
  int result; // r0
  int v2; // r1
  unsigned int v3; // r2
  int v4; // [sp+0h] [bp-20h] BYREF
  int v5; // [sp+4h] [bp-1Ch] BYREF

  v5 = 0;
  v4 = 0;
  v0 = 1;
  byte_200037D9 = 0;
  result = sub_8025188(dword_20000458, 0, 0, 0);
  while ( v0 )
  {
    result = sub_801B018(&v4, 0xAu);
    if ( result )
      break;
    result = sub_8025570(dword_20000440, (unsigned int)&v5, 0);
    v0 = result;
    if ( result )
    {
      v2 = (unsigned __int16)word_200015F6;
      result = (unsigned __int8)v5;
      v3 = (unsigned __int16)++word_200015F6;
      byte_20011328[v2] = v5;
      if ( v3 >= 0x3FF )
        break;
    }
  }
  return result;
}
// 20000440: using guessed type int dword_20000440;
// 20000458: using guessed type int dword_20000458;
// 200015F6: using guessed type __int16 word_200015F6;
// 200037D9: using guessed type char byte_200037D9;
// 20011328: using guessed type _BYTE byte_20011328[936];

//----- (080104B0) --------------------------------------------------------
unsigned int __fastcall sub_80104B0(int a1)
{
  if ( a1 )
    return (*(unsigned __int8 *)(a1 + 6) + 60 * (unsigned int)*(unsigned __int8 *)(a1 + 5)) / 0xA;
  else
    return 0;
}

//----- (080104CC) --------------------------------------------------------
int __fastcall sub_80104CC(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int i; // r2

  result = 0;
  if ( !a1 )
    return 0;
  for ( i = 0; i < a2; ++i )
    result ^= *(unsigned __int8 *)(a1 + i);
  return result;
}

//----- (080104EC) --------------------------------------------------------
int sub_80104EC()
{
  MEMORY[0x4002104C] |= 1u;
  MEMORY[0x4002104C] |= 2u;
  MEMORY[0x4002104C] |= 4u;
  MEMORY[0x4002104C] |= 8u;
  MEMORY[0x4002104C] |= 0x10u;
  MEMORY[0x4002104C] |= 0x20u;
  sub_8004188((int *)0x48001000, 4096, 2);
  sub_8004188((int *)0x48001400, 4, 2);
  sub_8004188((int *)0x48000C00, 4, 2);
  sub_80041AE((int *)0x48001000, 128, 2);
  sub_80041AE((int *)0x48001000, 256, 2);
  sub_80041AE((int *)0x48001000, 1024, 2);
  sub_80041AE((int *)0x48001000, 2048, 2);
  sub_80041D6((int *)0x48001000, 64);
  sub_80041D6((int *)0x48000800, 2048);
  sub_80041D6((int *)0x48000000, 16);
  sub_80041D6((int *)0x48001000, 4);
  sub_80041D6((int *)0x48001000, 8);
  sub_80041D6((int *)0x48001000, 16);
  sub_80041D6((int *)0x48001000, 32);
  sub_80041D6((int *)0x48000000, 32);
  sub_80041D6((int *)0x48000800, 16);
  sub_80041D6((int *)0x48000800, 32);
  sub_80041D6((int *)0x48000400, 4);
  sub_80041D6((int *)0x48000400, 0x8000);
  sub_80041D6((int *)0x48000C00, 2);
  sub_80041D6((int *)0x48000C00, 1);
  sub_80041D6((int *)0x48001000, 1);
  sub_80041D6((int *)0x48001000, 2);
  sub_80041D6((int *)0x48000C00, 2048);
  sub_80041D6((int *)0x48000C00, 1024);
  sub_80041D6((int *)0x48000800, 4096);
  sub_80041D6((int *)0x48000C00, 8);
  sub_80041D6((int *)0x48000C00, 128);
  sub_80041D6((int *)0x48000400, 8);
  sub_80041D6((int *)0x48000000, 4096);
  sub_80041D6((int *)0x48000800, 1024);
  sub_801292E(1207961600, 4096, 1);
  sub_8013970(23, 8u, 0);
  sub_8013970(40, 8u, 0);
  sub_8013954(23);
  return sub_8013954(40);
}

//----- (080106B8) --------------------------------------------------------
unsigned int __fastcall sub_80106B8(unsigned int result)
{
  if ( byte_20000002 )
    return sub_801AFD0(result);
  else
    return sub_801AFB8(result);
}
// 20000002: using guessed type char byte_20000002;

//----- (080106CC) --------------------------------------------------------
int __fastcall sub_80106CC(int a1, int a2)
{
  int result; // r0
  int v4; // r2
  int v5; // r1

  result = 1207963648;
  if ( byte_20000002 )
  {
    switch ( a1 )
    {
      case 0:
        goto LABEL_10;
      case 1:
        goto LABEL_9;
      case 2:
        goto LABEL_8;
      case 3:
        return sub_801292E(1207959552, 16, a2);
      case 4:
        return sub_801292E(1207961600, 2048, a2);
      case 5:
        goto LABEL_4;
      case 7:
        goto LABEL_12;
      case 8:
        goto LABEL_11;
      case 9:
        if ( a2 )
          result = sub_801AFB8(0x2710u);
        else
          result = sub_801AFB8(0);
        break;
      default:
        return result;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
LABEL_4:
        v4 = a2;
        v5 = 64;
        goto LABEL_5;
      case 1:
        return sub_801292E(1207961600, 2048, a2);
      case 2:
        return sub_801292E(1207959552, 16, a2);
      case 3:
LABEL_8:
        v4 = a2;
        v5 = 4;
        goto LABEL_5;
      case 4:
LABEL_9:
        v4 = a2;
        v5 = 8;
        goto LABEL_5;
      case 5:
LABEL_10:
        v4 = a2;
        v5 = 16;
        goto LABEL_5;
      case 7:
LABEL_11:
        v4 = a2;
        v5 = 32;
LABEL_5:
        result = sub_801292E(1207963648, v5, v4);
        break;
      case 8:
LABEL_12:
        result = sub_801292E(1207959552, 32, a2);
        break;
      case 9:
        if ( a2 )
          result = sub_801AFD0(0x2710u);
        else
          result = sub_801AFD0(0);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 20000002: using guessed type char byte_20000002;

//----- (080107EC) --------------------------------------------------------
int __fastcall sub_80107EC(int a1, int a2)
{
  int v4; // r3
  int v6; // [sp+0h] [bp-18h]

  v6 = 0;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  v4 = sub_8003358((int *)a1);
  if ( v4 )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFEEFD | 2;
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x3FFFFFC0 | a2 & 0x40000000 | 0x80000000;
    while ( *(int *)(*(_DWORD *)a1 + 8) < 0 )
    {
      if ( (unsigned int)++v6 >= 0x4DE02 )
      {
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFED | 0x10;
        *(_BYTE *)(a1 + 88) = 0;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFFC | 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  return v4;
}

//----- (08010888) --------------------------------------------------------
int __fastcall sub_8010888(int a1, int a2)
{
  int v4; // r6
  __int16 v6; // r0
  int v7; // r10
  int v8; // r2
  int v9; // r0
  int v10; // r1
  int v11; // r0
  int v12; // r1
  int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r0
  int v16; // r0
  unsigned int v17; // r1
  unsigned int v18; // r0
  int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // r0
  int v22; // r0
  unsigned int v23; // r1
  unsigned int v24; // r0
  int v25; // r0
  int v26; // r0
  unsigned int v27; // r1
  unsigned int v28; // r0
  int v29; // r1
  int v30; // r1
  int v31; // r8
  int v32; // r1
  int v33; // r1
  unsigned int v34; // r1
  int v35; // r1
  int v36; // r8
  int v37; // r1
  int v38; // r1
  unsigned int v39; // r2
  int v40; // r0
  int v41; // r3
  int v42; // r1
  int v43; // r1
  unsigned int i; // [sp+0h] [bp-28h]

  v4 = 0;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  if ( sub_8017338(*(_DWORD *)a1) )
  {
    *(_DWORD *)(a1 + 92) |= 0x20u;
    v4 = 1;
  }
  else
  {
    v6 = *(_WORD *)(a2 + 4);
    *(_DWORD *)(*(_DWORD *)a1 + ((unsigned __int16)(v6 & 0x300) >> 6) + 48) = *(_DWORD *)(*(_DWORD *)a1
                                                                                        + ((unsigned __int16)(v6 & 0x300) >> 6)
                                                                                        + 48)
                                                                            & ~(31 << (v6 & 0x1F))
                                                                            | (((*(_DWORD *)a2 >> 26) & 0x1F) << (v6 & 0x1F));
    v7 = sub_8017338(*(_DWORD *)a1);
    if ( !(v7 | sub_8017328(*(_DWORD *)a1)) )
    {
      v8 = *(_DWORD *)(a2 + 8);
      if ( v8 == 0x80000000 )
      {
        sub_8017350(*(_DWORD *)a1, *(_DWORD *)a2, 0);
        *(_DWORD *)(*(_DWORD *)a1 + 20) |= 0x80000000;
      }
      else
      {
        sub_8017350(*(_DWORD *)a1, *(_DWORD *)a2, v8);
        *(_DWORD *)(*(_DWORD *)a1 + 20) &= ~0x80000000;
      }
      v9 = *(_DWORD *)a1;
      v10 = *(_DWORD *)(a2 + 16);
      if ( v10 == 4 )
      {
        if ( sub_801731C(v9, 0) << 13 )
          v14 = __clz(__rbit32(sub_801731C(*(_DWORD *)a1, 0)));
        else
          v14 = ((unsigned int)sub_801731C(*(_DWORD *)a1, 0) >> 26) & 0x1F;
        v15 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v16 = __clz(__rbit32(v15));
        else
          v16 = (v15 >> 26) & 0x1F;
        if ( v14 == v16 )
          sub_801736E(*(_DWORD *)a1, 0, 0);
        if ( sub_801731C(*(_DWORD *)a1, 1) << 13 )
          v17 = __clz(__rbit32(sub_801731C(*(_DWORD *)a1, 1)));
        else
          v17 = ((unsigned int)sub_801731C(*(_DWORD *)a1, 1) >> 26) & 0x1F;
        v18 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v19 = __clz(__rbit32(v18));
        else
          v19 = (v18 >> 26) & 0x1F;
        if ( v17 == v19 )
          sub_801736E(*(_DWORD *)a1, 1, 0);
        if ( sub_801731C(*(_DWORD *)a1, 2) << 13 )
          v20 = __clz(__rbit32(sub_801731C(*(_DWORD *)a1, 2)));
        else
          v20 = ((unsigned int)sub_801731C(*(_DWORD *)a1, 2) >> 26) & 0x1F;
        v21 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v22 = __clz(__rbit32(v21));
        else
          v22 = (v21 >> 26) & 0x1F;
        if ( v20 == v22 )
          sub_801736E(*(_DWORD *)a1, 2, 0);
        if ( sub_801731C(*(_DWORD *)a1, 3) << 13 )
          v23 = __clz(__rbit32(sub_801731C(*(_DWORD *)a1, 3)));
        else
          v23 = ((unsigned int)sub_801731C(*(_DWORD *)a1, 3) >> 26) & 0x1F;
        v24 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          v25 = __clz(__rbit32(v24));
        else
          v25 = (v24 >> 26) & 0x1F;
        if ( v23 == v25 )
          sub_801736E(*(_DWORD *)a1, 3, 0);
      }
      else
      {
        *(_DWORD *)(v9 + 4 * v10 + 96) = *(_DWORD *)(v9 + 4 * v10 + 96) & 0x3FFF000
                                       | *(_DWORD *)a2 & 0x7C000000
                                       | (*(_DWORD *)(a2 + 20) << (2 * ((*(_DWORD *)(*(_DWORD *)a1 + 12) >> 3) & 3)))
                                       | 0x80000000;
        v11 = *(_DWORD *)a1 + 4 * *(_DWORD *)(a2 + 16);
        *(_DWORD *)(v11 + 96) = *(_DWORD *)(v11 + 96) & 0xFEFFFFFF | *(_DWORD *)(a2 + 24);
        if ( *(_BYTE *)(a2 + 28) == 1 )
          v12 = 0x2000000;
        else
          v12 = 0;
        v13 = *(_DWORD *)a1 + 4 * *(_DWORD *)(a2 + 16);
        *(_DWORD *)(v13 + 96) = *(_DWORD *)(v13 + 96) & 0xFDFFFFFF | v12;
      }
    }
    if ( !sub_8017330(*(_DWORD *)a1) )
    {
      v26 = *(_DWORD *)a1;
      v27 = *(_DWORD *)a2;
      if ( *(_DWORD *)(a2 + 12) == 1082064896 )
        *(_DWORD *)(v26 + 176) |= v27 & 0x7FFFF;
      else
        *(_DWORD *)(v26 + 176) &= ~(v27 & 0x7FFFF);
      if ( *(_DWORD *)(a2 + 12) == 1082064896 )
      {
        v28 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 << 13 )
          LOBYTE(v29) = __clz(__rbit32(v28));
        else
          v29 = (v28 >> 26) & 0x1F;
        if ( (((_BYTE)v29 + 1) & 0x1Fu) > 9 )
        {
          if ( v28 << 13 )
            LOBYTE(v35) = __clz(__rbit32(v28));
          else
            v35 = (v28 >> 26) & 0x1F;
          v36 = 1 << ((v35 + 1) & 0x1F);
          if ( v28 << 13 )
            LOBYTE(v37) = __clz(__rbit32(v28));
          else
            v37 = (v28 >> 26) & 0x1F;
          v38 = v36 | ((((_BYTE)v37 + 1) & 0x1F) << 26);
          if ( v28 << 13 )
            LOBYTE(v28) = __clz(__rbit32(v28));
          else
            v28 = (v28 >> 26) & 0x1F;
          v34 = v38 | (3145728 * ((((_BYTE)v28 + 1) & 0x1F) - 10)) | 0x2000000;
        }
        else
        {
          if ( v28 << 13 )
            LOBYTE(v30) = __clz(__rbit32(v28));
          else
            v30 = (v28 >> 26) & 0x1F;
          v31 = 1 << ((v30 + 1) & 0x1F);
          if ( v28 << 13 )
            LOBYTE(v32) = __clz(__rbit32(v28));
          else
            v32 = (v28 >> 26) & 0x1F;
          v33 = v31 | ((((_BYTE)v32 + 1) & 0x1F) << 26);
          if ( v28 << 13 )
            LOBYTE(v28) = __clz(__rbit32(v28));
          else
            v28 = (v28 >> 26) & 0x1F;
          v34 = v33 | (3145728 * (((_BYTE)v28 + 1) & 0x1F));
        }
        sub_8017350(*(_DWORD *)a1, v34, *(_DWORD *)(a2 + 8));
      }
    }
    v39 = *(_DWORD *)a2;
    if ( (*(_DWORD *)a2 & 0x80080000) != 0 )
    {
      v40 = *(_DWORD *)a1;
      v41 = 1342178048;
      if ( *(_DWORD *)a1 == 1342177280 || v40 == 1342177536 )
        v42 = 1342178048;
      else
        v42 = 1342179072;
      v43 = *(_DWORD *)(v42 + 8) & 0x1C00000;
      if ( (v39 == -1021247488 || v39 == -1866465264) && (v43 & 0x800000) == 0 )
      {
        if ( v40 == 1342177280 || v40 == 1342178816 )
        {
          if ( v40 != 1342177280 )
            v41 = 1342179072;
          *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x800000;
          for ( i = 12 * (dword_20000290 / 0x30D40u + 1); i; --i )
            ;
        }
      }
      else if ( v39 != -950927360 || (v43 & 0x1000000) != 0 )
      {
        if ( v39 == -880541696 && (v43 & 0x400000) == 0 && v40 != 1342177536 )
        {
          if ( v40 != 1342177280 )
            v41 = 1342179072;
          *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x400000;
        }
      }
      else
      {
        if ( v40 != 1342177280 && v40 != 1342177536 )
          v41 = 1342179072;
        *(_DWORD *)(v41 + 8) = *(_DWORD *)(v41 + 8) & 0xFE3FFFFF | v43 | 0x1000000;
      }
    }
  }
  *(_BYTE *)(a1 + 88) = 0;
  return v4;
}
// 8010C40: conditional instruction was optimized away because r0.4==50000600
// 8010C8C: conditional instruction was optimized away because r0.4==50000100
// 20000290: using guessed type int dword_20000290;

//----- (08010D08) --------------------------------------------------------
int __fastcall sub_8010D08(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1342177280 )
  {
    sub_801292E(1207963648, 1, 1);
    sub_800320C();
    return sub_801292E(1207963648, 1, 0);
  }
  return result;
}

//----- (08010D38) --------------------------------------------------------
int __fastcall sub_8010D38(int a1)
{
  int v2; // r5
  int v4; // r0
  int v5; // r0
  int v6; // r1
  int v7; // r0
  int v8; // r1
  int v9; // r0
  int v10; // r6
  unsigned int i; // [sp+0h] [bp-18h]

  v2 = 0;
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 92) )
  {
    sub_8010F88((int *)a1);
    *(_DWORD *)(a1 + 96) = 0;
    *(_BYTE *)(a1 + 88) = 0;
  }
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 29) & 1) != 0 )
    *(_DWORD *)(*(_DWORD *)a1 + 8) &= 0x5FFFFFC0u;
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 28) & 1) == 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x6FFFFFC0 | 0x10000000;
    for ( i = 2 * (dword_20000290 / 0x30D40u + 1); i; --i )
      ;
  }
  v4 = *(_DWORD *)a1;
  if ( ((*(_DWORD *)(*(_DWORD *)a1 + 8) >> 28) & 1) == 0 )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
    *(_DWORD *)(a1 + 96) |= 1u;
    v2 = 1;
  }
  if ( *(_DWORD *)(a1 + 92) & 0x10 | sub_8017338(v4) )
  {
    *(_DWORD *)(a1 + 92) |= 0x10u;
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFEFD | 2;
    if ( !sub_8017330(*(_DWORD *)a1) )
    {
      v5 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 == 1342177280 || v5 == 1342177536 )
        v6 = MEMORY[0x50000008] & 1 | MEMORY[0x50000108] & 1;
      else
        v6 = MEMORY[0x50000408] & 1 | MEMORY[0x50000508] & 1 | MEMORY[0x50000608] & 1;
      if ( !v6 )
      {
        if ( v5 == 1342177280 || v5 == 1342177536 )
          v7 = 1342178048;
        else
          v7 = 1342179072;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 8) & 0xFFC0FFFF | *(_DWORD *)(a1 + 4);
      }
    }
    v8 = *(unsigned __int8 *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 60)
       | *(_DWORD *)(a1 + 12)
       | *(_DWORD *)(a1 + 8)
       | (*(unsigned __int8 *)(a1 + 29) << 13)
       | (v8 << 16);
    if ( v8 == 1 )
      v9 |= (*(unsigned __int16 *)(a1 + 40) - 1) << 17;
    if ( *(_DWORD *)(a1 + 44) )
      v9 |= *(_DWORD *)(a1 + 48) | *(_DWORD *)(a1 + 44) & 0x3E0;
    *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(*(_DWORD *)a1 + 12) & 0xFFF04007 | v9;
    *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(*(_DWORD *)a1 + 16) & 0xF3FFFFFF | *(_DWORD *)(a1 + 52);
    v10 = sub_8017338(*(_DWORD *)a1);
    if ( !(v10 | sub_8017328(*(_DWORD *)a1)) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(*(_DWORD *)a1 + 12) & 0xFFFFBFFD
                                      | (*(unsigned __int8 *)(a1 + 28) << 14)
                                      | (2 * *(unsigned __int8 *)(a1 + 56));
      if ( *(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 16) |= 0x10000u;
        *(_DWORD *)(*(_DWORD *)a1 + 192) = *(_DWORD *)(*(_DWORD *)a1 + 192) & 0xFFFFC000 | *(_DWORD *)(a1 + 16);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~0x10000u;
        *(_DWORD *)(*(_DWORD *)a1 + 192) &= 0xFFFFC000;
      }
      if ( *(_BYTE *)(a1 + 64) == 1 )
        *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 68)
                                        | *(_DWORD *)(a1 + 72)
                                        | *(_DWORD *)(a1 + 76)
                                        | *(_DWORD *)(a1 + 80)
                                        | *(_DWORD *)(*(_DWORD *)a1 + 16) & 0xFFFFF803
                                        | 1;
      else
        *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~1u;
    }
    if ( *(_DWORD *)(a1 + 20) == 1 )
      *(_DWORD *)(*(_DWORD *)a1 + 48) = *(_DWORD *)(*(_DWORD *)a1 + 48) & 0xFFFFFFF0 | (*(_DWORD *)(a1 + 32) - 1);
    else
      *(_DWORD *)(*(_DWORD *)a1 + 48) &= 0xFFFFFFF0;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFFC | 1;
  }
  return v2;
}
// 20000290: using guessed type int dword_20000290;

//----- (08010F88) --------------------------------------------------------
int *__fastcall sub_8010F88(int *a1)
{
  int v2; // r1
  int *result; // r0
  _DWORD v4[17]; // [sp+4h] [bp-84h] BYREF
  int v5; // [sp+48h] [bp-40h]
  unsigned int v6; // [sp+4Ch] [bp-3Ch]
  int v7; // [sp+58h] [bp-30h] BYREF
  int v8; // [sp+5Ch] [bp-2Ch]
  int v9; // [sp+60h] [bp-28h]

  sub_8002364(v4, 84);
  v2 = *a1;
  if ( *a1 == 1342177280 )
  {
    v4[0] = 0x8000;
    v5 = 0x20000000;
    sub_8013AD4(v4);
    if ( ++dword_2000006C == 1 )
      MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 1u;
    v7 = 12;
    v8 = 3;
    v9 = 0;
    sub_8012760((int *)0x48000800, (int)&v7);
    v7 = 4;
    v8 = 3;
    v9 = 0;
    return sub_8012760((int *)0x48000000, (int)&v7);
  }
  else if ( v2 == 1342177536 )
  {
    v4[0] = 0x8000;
    v5 = 0x20000000;
    if ( sub_8013AD4(v4) )
      sub_8005C1C();
    if ( ++dword_2000006C == 1 )
      MEMORY[0x4002104C] |= 0x2000u;
    MEMORY[0x4002104C] |= 1u;
    v7 = 129;
    v8 = 3;
    v9 = 0;
    return sub_8012760((int *)0x48000000, (int)&v7);
  }
  else
  {
    result = (int *)0x10000;
    switch ( v2 )
    {
      case 1342178304:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013AD4(v4) )
          sub_8005C1C();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 2u;
        MEMORY[0x4002104C] |= 0x10u;
        v7 = 2;
        v8 = 3;
        v9 = 0;
        sub_8012760((int *)0x48000400, (int)&v7);
        v7 = 8704;
        v8 = 3;
        v9 = 0;
        return sub_8012760((int *)0x48001000, (int)&v7);
      case 1342178560:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013AD4(v4) )
          sub_8005C1C();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 0x10u;
        MEMORY[0x4002104C] |= 2u;
        v7 = 49152;
        v8 = 3;
        v9 = 0;
        sub_8012760((int *)0x48001000, (int)&v7);
        v7 = 0x4000;
        v8 = 3;
        v9 = 0;
        return sub_8012760((int *)0x48000400, (int)&v7);
      case 1342178816:
        v4[0] = 0x10000;
        v6 = 0x80000000;
        if ( sub_8013AD4(v4) )
          sub_8005C1C();
        if ( ++dword_20000070 == 1 )
          MEMORY[0x4002104C] |= 0x4000u;
        MEMORY[0x4002104C] |= 8u;
        v7 = 8960;
        v8 = 3;
        v9 = 0;
        return sub_8012760((int *)0x48000C00, (int)&v7);
    }
  }
  return result;
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 2000006C: using guessed type int dword_2000006C;
// 20000070: using guessed type int dword_20000070;

//----- (080111F8) --------------------------------------------------------
int __fastcall sub_80111F8(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r8
  int v8; // r1
  int v9; // r5
  int result; // r0
  int v11; // r0

  v6 = *(_DWORD *)a1;
  v7 = 1342177280;
  if ( v6 == 1342177280 || v6 == 1342177536 )
    v8 = 1342178048;
  else
    v8 = 1342179072;
  v9 = *(_DWORD *)(v8 + 8) & 0x1F;
  if ( sub_8017338(v6) )
    return 2;
  if ( *(_BYTE *)(a1 + 88) == 1 )
    return 2;
  *(_BYTE *)(a1 + 88) = 1;
  if ( (*(_DWORD *)a1 == 1342178816 ? 0 : v9) == 0 || v9 == 5 || v9 == 9 )
  {
    result = sub_80033DC((int *)a1);
    if ( result )
    {
      *(_BYTE *)(a1 + 88) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF0FE | 0x100;
      v11 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 != 1342177536 )
      {
        if ( v11 == 1342178560 )
          v7 = 1342178304;
        else
          v7 = *(_DWORD *)a1;
      }
      if ( v7 == v11 || !v9 )
        *(_DWORD *)(a1 + 92) &= ~0x100000u;
      if ( (*(_DWORD *)(a1 + 92) & 0x1000) != 0 )
        *(_DWORD *)(a1 + 96) &= 0xFFFFFFF9;
      else
        *(_DWORD *)(a1 + 96) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 44) = 134232759;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 48) = 134232911;
      *(_DWORD *)(*(_DWORD *)(a1 + 84) + 52) = 134232885;
      **(_DWORD **)a1 = 28;
      *(_BYTE *)(a1 + 88) = 0;
      *(_DWORD *)(*(_DWORD *)a1 + 4) |= 0x10u;
      *(_DWORD *)(*(_DWORD *)a1 + 12) |= 1u;
      result = sub_8011CC8(*(_DWORD *)(a1 + 84), *(_DWORD *)a1 + 64, a2, a3);
      *(_DWORD *)(*(_DWORD *)a1 + 8) = (*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x7FFFFFC0) + 4;
    }
  }
  else
  {
    result = 1;
    *(_BYTE *)(a1 + 88) = 0;
  }
  return result;
}

//----- (08011328) --------------------------------------------------------
int __fastcall sub_8011328(int a1)
{
  int v2; // r5
  int v3; // r2
  int *v4; // r1
  int v5; // r0
  int v6; // r6
  unsigned int i; // [sp+0h] [bp-28h]

  v2 = 0;
  if ( !a1 )
    return 1;
  if ( **(int **)a1 < 0 )
    return 1;
  if ( !*(_BYTE *)(a1 + 29) )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    sub_80115A8((int **)a1);
  }
  v3 = **(_DWORD **)a1 & 0x800000;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFF007E0F
                  | *(_DWORD *)(a1 + 8)
                  | *(_DWORD *)(a1 + 4)
                  | *(_DWORD *)(a1 + 20)
                  | *(_DWORD *)(a1 + 12)
                  | *(_DWORD *)(a1 + 16);
  v4 = *(int **)a1;
  if ( (**(_DWORD **)a1 & 0x800000) != 0 && !v3 )
  {
    for ( i = 20 * (dword_20000290 / 0x30D40u + 1); i; --i )
      ;
  }
  if ( v4 == (int *)1073807872 )
  {
    v5 = 0x200000;
  }
  else if ( v4 == (int *)1073807876 )
  {
    v5 = 0x400000;
  }
  else if ( v4 == (int *)1073807880 )
  {
    v5 = 0x20000000;
  }
  else if ( v4 == (int *)1073807884 )
  {
    v5 = 0x40000000;
  }
  else if ( v4 == (int *)1073807888 )
  {
    v5 = 0x80000000;
  }
  else if ( v4 == (int *)1073807892 )
  {
    v5 = 1;
  }
  else
  {
    v5 = 2;
  }
  v6 = *(_DWORD *)(a1 + 24);
  if ( v6 << 30 )
  {
    if ( (v6 & 0x10) != 0 )
    {
      if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
        MEMORY[0x40010428] |= v5;
      else
        MEMORY[0x40010408] |= v5;
    }
    else if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
    {
      MEMORY[0x40010428] &= ~v5;
    }
    else
    {
      MEMORY[0x40010408] &= ~v5;
    }
    if ( (*(_BYTE *)(a1 + 24) & 0x20) != 0 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x4001042C] |= v5;
      else
        MEMORY[0x4001040C] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x4001042C] &= ~v5;
    }
    else
    {
      MEMORY[0x4001040C] &= ~v5;
    }
    if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
      MEMORY[0x40010434] = v5;
    else
      MEMORY[0x40010414] = v5;
    if ( (*(_BYTE *)(a1 + 24) & 2) != 0 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x40010424] |= v5;
      else
        MEMORY[0x40010404] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x40010424] &= ~v5;
    }
    else
    {
      MEMORY[0x40010404] &= ~v5;
    }
    if ( *(unsigned __int8 *)(a1 + 24) << 31 )
    {
      if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
        MEMORY[0x40010420] |= v5;
      else
        MEMORY[0x40010400] |= v5;
    }
    else if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
    {
      MEMORY[0x40010420] &= ~v5;
    }
    else
    {
      MEMORY[0x40010400] &= ~v5;
    }
  }
  else
  {
    if ( v4 == (int *)1073807892 || v4 == (int *)1073807896 )
      MEMORY[0x40010424] &= ~v5;
    else
      MEMORY[0x40010404] &= ~v5;
    if ( *(_DWORD *)a1 == 1073807892 || *(_DWORD *)a1 == 1073807896 )
      MEMORY[0x40010420] &= ~v5;
    else
      MEMORY[0x40010400] &= ~v5;
  }
  if ( !*(_BYTE *)(a1 + 29) )
    *(_BYTE *)(a1 + 29) = 1;
  return v2;
}
// 20000290: using guessed type int dword_20000290;

//----- (080115A8) --------------------------------------------------------
int *__fastcall sub_80115A8(int **a1)
{
  int *result; // r0
  int v3; // [sp+4h] [bp-1Ch] BYREF
  int v4; // [sp+8h] [bp-18h]
  int v5; // [sp+Ch] [bp-14h]

  sub_8002364(&v3, 20);
  result = *a1;
  if ( *a1 == (int *)1073807872 )
  {
    MEMORY[0x4002104C] |= 1u;
    v3 = 2;
    v4 = 3;
    v5 = 0;
    return sub_8012760((int *)0x48000000, (int)&v3);
  }
  else if ( result == (int *)1073807884 )
  {
    MEMORY[0x4002104C] |= 2u;
    v3 = 1;
    v4 = 3;
    v5 = 0;
    return sub_8012760((int *)0x48000400, (int)&v3);
  }
  else if ( result == (int *)1073807880 )
  {
    MEMORY[0x4002104C] |= 4u;
    v3 = 3;
    v4 = 3;
    v5 = 0;
    return sub_8012760((int *)0x48000800, (int)&v3);
  }
  return result;
}

//----- (0801164C) --------------------------------------------------------
int __fastcall sub_801164C(int a1)
{
  int result; // r0
  unsigned int i; // [sp+0h] [bp-8h]

  result = 0;
  if ( !a1 )
    return 1;
  if ( **(int **)a1 < 0 )
    return 1;
  if ( *(_BYTE *)(a1 + 29) != 1 )
    return 1;
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 29) = 2;
  for ( i = 5 * (dword_20000290 / 0x1E8480u); i; --i )
    ;
  return result;
}
// 20000290: using guessed type int dword_20000290;

//----- (080116A8) --------------------------------------------------------
int __fastcall sub_80116A8(int a1, _DWORD *a2)
{
  int v2; // r2

  v2 = 0;
  if ( *(_BYTE *)(a1 + 33) == 1 )
  {
    **(_DWORD **)a1 = *a2 | a2[6] | a2[1] | a2[4] | a2[5] | a2[2] | a2[3] | **(_DWORD **)a1 & 0xFF87F800;
  }
  else
  {
    *(_DWORD *)(a1 + 36) |= 2u;
    return 1;
  }
  return v2;
}

//----- (080116F0) --------------------------------------------------------
int __fastcall sub_80116F0(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 33) )
  {
    *(_BYTE *)(a1 + 32) = 0;
    sub_8003216();
  }
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)(a1 + 33) = 1;
  return 0;
}

//----- (08011728) --------------------------------------------------------
int __fastcall sub_8011728(int a1, int a2, int a3)
{
  char v6; // r6
  int result; // r0
  int v8; // r7
  int v9; // r0
  BOOL v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r0
  int v14; // r9
  int v15; // r9
  unsigned int v16; // r7
  unsigned int v17; // r0

  if ( *(_BYTE *)(a1 + 5) == 1 )
    return 2;
  *(_BYTE *)(a1 + 5) = 1;
  *(_BYTE *)(a1 + 4) = 2;
  v6 = a3 & 0x10;
  if ( *(_DWORD *)(a2 + 8) == 4 )
  {
    v8 = sub_8012948();
    if ( a3 )
    {
      while ( *(int *)(*(_DWORD *)a1 + 52) < 0 )
      {
        if ( (unsigned int)(sub_8012948() - v8) > 1 )
        {
          *(_DWORD *)(a1 + 16) |= 8u;
          *(_BYTE *)(a1 + 4) = 3;
          return 3;
        }
      }
      sub_8011D58(1u);
      *(_DWORD *)(*(_DWORD *)a1 + 68) = *(_DWORD *)(a2 + 36);
    }
    else
    {
      while ( (*(_DWORD *)(*(_DWORD *)a1 + 52) & 0x8000) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v8) > 1 )
        {
          *(_DWORD *)(a1 + 16) |= 8u;
          *(_BYTE *)(a1 + 4) = 3;
          return 3;
        }
      }
      sub_8011D58(1u);
      *(_DWORD *)(*(_DWORD *)a1 + 64) = *(_DWORD *)(a2 + 36);
    }
    *(_DWORD *)(*(_DWORD *)a1 + 72) = *(_DWORD *)(*(_DWORD *)a1 + 72) & ~(1023 << v6) | (*(_DWORD *)(a2 + 40) << v6);
    *(_DWORD *)(*(_DWORD *)a1 + 76) = *(_DWORD *)(*(_DWORD *)a1 + 76) & ~(255 << v6) | (*(_DWORD *)(a2 + 44) << v6);
  }
  if ( *(_DWORD *)(a2 + 28) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 56) = (*(_DWORD *)(a2 + 32) << v6) | *(_DWORD *)(*(_DWORD *)a1 + 56) & ~(31 << v6);
  v9 = *(_DWORD *)(a2 + 24);
  if ( v9 == 1 )
    v10 = 0;
  else
    v10 = v9 == 2 || *(_DWORD *)(a2 + 20) == 0;
  v11 = *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 20) | v10;
  v12 = 256;
  if ( *(_BYTE *)(a2 + 4) != 1 )
    v12 = 0;
  v13 = v12 | v11;
  v14 = 512;
  if ( *(_BYTE *)(a2 + 5) != 1 )
    v14 = 0;
  v15 = v14 | v13;
  v16 = *(_DWORD *)(*(_DWORD *)a1 + 60) & ~(7 << v6) & ~(256 << v6) & ~(512 << v6) & 0xFFFF3FFF;
  if ( *(_DWORD *)a2 == 2 )
  {
    v17 = sub_8013FAC();
    if ( v17 <= 0x9896800 )
    {
      if ( v17 > 0x4C4B400 )
        v16 |= 0x4000u;
    }
    else
    {
      v16 |= 0x8000u;
    }
  }
  else
  {
    v16 |= *(_DWORD *)a2;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 60) = (v15 << v6) | v16;
  **(_DWORD **)a1 &= ~(0x4000 << v6);
  **(_DWORD **)a1 = (*(_DWORD *)(a2 + 12) << v6) | **(_DWORD **)a1 & ~(4094 << v6);
  **(_DWORD **)a1 &= ~(192 << v6);
  *(_DWORD *)(*(_DWORD *)a1 + 96) = *(_DWORD *)(*(_DWORD *)a1 + 96) & ~(3855 << v6)
                                  | (((*(unsigned __int8 *)(a2 + 12) >> 2) & 0xF | ((*(_BYTE *)(a2 + 16) & 0x3C) << 6)) << v6);
  *(_BYTE *)(a1 + 4) = 1;
  result = 0;
  *(_BYTE *)(a1 + 5) = 0;
  return result;
}

//----- (080118FC) --------------------------------------------------------
int __fastcall sub_80118FC(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 4) )
  {
    *(_BYTE *)(a1 + 5) = 0;
    sub_8011928((int *)a1);
  }
  *(_BYTE *)(a1 + 4) = 2;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 4) = 1;
  return 0;
}

//----- (08011928) --------------------------------------------------------
int __fastcall sub_8011928(int *a1)
{
  int v2; // r1
  int result; // r0
  _DWORD v4[7]; // [sp+4h] [bp-1Ch] BYREF

  sub_8002364(v4, 20);
  v2 = *a1;
  result = 1073876992;
  if ( *a1 == 1342179328 )
  {
    MEMORY[0x4002104C] |= 0x10000u;
    return MEMORY[0x4002104C] & 0x10000;
  }
  else if ( v2 == 1342180352 )
  {
    MEMORY[0x4002104C] |= 0x20000u;
    MEMORY[0x4002104C] |= 1u;
    v4[0] = 64;
    v4[1] = 3;
    v4[2] = 2;
    return (int)sub_8012760((int *)0x48000000, (int)v4);
  }
  else if ( v2 == 1342181376 )
  {
    MEMORY[0x4002104C] |= 0x40000u;
    return MEMORY[0x4002104C] & 0x40000;
  }
  return result;
}

//----- (080119BC) --------------------------------------------------------
int __fastcall sub_80119BC(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // r0
  _DWORD *v6; // [sp+0h] [bp-18h]

  v4 = *a1 + a3;
  if ( a2 )
    v6 = (_DWORD *)(v4 + 20);
  else
    v6 = (_DWORD *)(v4 + 8);
  *v6 = a4;
  return 0;
}

//----- (080119EE) --------------------------------------------------------
int __fastcall sub_80119EE(_BYTE *a1, int a2)
{
  char v4; // r5
  int result; // r0

  if ( a1[5] == 1 )
    return 2;
  a1[5] = 1;
  a1[4] = 2;
  v4 = a2 & 0x10;
  **(_DWORD **)a1 |= 1 << (a2 & 0x10);
  sub_8011D58(1u);
  if ( a2 )
  {
    if ( (**(_DWORD **)a1 & 0x3E0000) == 2 << v4 )
      *(_DWORD *)(*(_DWORD *)a1 + 4) |= 2u;
  }
  else if ( ((**(_DWORD **)a1 >> 1) & 0x1F) == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 4) |= 1u;
  }
  a1[4] = 1;
  result = 0;
  a1[5] = 0;
  return result;
}

//----- (08011A5C) --------------------------------------------------------
int __fastcall sub_8011A5C(int a1)
{
  int v1; // r1
  _DWORD *v2; // r2
  _BYTE *v3; // r0

  v1 = 0;
  if ( *(_BYTE *)(a1 + 37) == 2 )
  {
    **(_DWORD **)a1 &= 0xFFFFFFF1;
    **(_DWORD **)(a1 + 72) &= ~0x100u;
    **(_DWORD **)a1 &= ~1u;
    *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4) = 1 << (*(_BYTE *)(a1 + 68) & 0x1F);
    *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
    v2 = *(_DWORD **)(a1 + 84);
    if ( v2 )
    {
      *v2 &= ~0x100u;
      *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 60) = 4;
    v1 = 1;
  }
  v3 = (_BYTE *)(a1 + 36);
  v3[1] = 1;
  *v3 = 0;
  return v1;
}

//----- (08011AC4) --------------------------------------------------------
int __fastcall sub_8011AC4(int a1)
{
  int v1; // r4
  int v2; // r0
  _DWORD *v3; // r1
  void (*v4)(void); // r1

  v1 = 0;
  if ( *(_BYTE *)(a1 + 37) == 2 )
  {
    **(_DWORD **)a1 &= 0xFFFFFFF1;
    **(_DWORD **)a1 &= ~1u;
    **(_DWORD **)(a1 + 72) &= ~0x100u;
    *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4) = 1 << (*(_BYTE *)(a1 + 68) & 0x1F);
    *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
    v3 = *(_DWORD **)(a1 + 84);
    if ( v3 )
    {
      *v3 &= ~0x100u;
      *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
    }
    *(_BYTE *)(a1 + 37) = 1;
    *(_BYTE *)(a1 + 36) = 0;
    v4 = *(void (**)(void))(a1 + 56);
    if ( v4 )
      v4();
  }
  else
  {
    v2 = a1 + 36;
    *(_DWORD *)(v2 + 24) = 4;
    *(_BYTE *)(v2 + 1) = 1;
    *(_BYTE *)v2 = 0;
    return 1;
  }
  return v1;
}

//----- (08011C08) --------------------------------------------------------
int __fastcall sub_8011C08(int a1)
{
  unsigned int *v2; // r0
  int v4; // r4

  if ( !a1 )
    return 1;
  v2 = *(unsigned int **)a1;
  if ( *(_DWORD *)a1 >= 0x40020408u )
  {
    *(_DWORD *)(a1 + 68) = 4 * ((unsigned int)(v2 - 268468482) / 0x14);
    *(_DWORD *)(a1 + 64) = 1073873920;
  }
  else
  {
    *(_DWORD *)(a1 + 68) = 4 * ((unsigned int)(v2 - 268468226) / 0x14);
    *(_DWORD *)(a1 + 64) = 1073872896;
  }
  *(_BYTE *)(a1 + 37) = 2;
  *v2 = *(_DWORD *)(a1 + 8)
      | *(_DWORD *)(a1 + 12)
      | *(_DWORD *)(a1 + 16)
      | *(_DWORD *)(a1 + 20)
      | *(_DWORD *)(a1 + 24)
      | *(_DWORD *)(a1 + 28)
      | *(_DWORD *)(a1 + 32)
      | *v2 & 0xFFFF800F;
  sub_8005090((int *)a1);
  if ( *(_DWORD *)(a1 + 8) == 0x4000 )
    *(_DWORD *)(a1 + 4) = 0;
  **(_DWORD **)(a1 + 72) = *(unsigned __int8 *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4) = *(_DWORD *)(a1 + 80);
  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) > 3 )
  {
    *(_DWORD *)(a1 + 84) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 92) = 0;
  }
  else
  {
    sub_80050D0(a1);
    **(_DWORD **)(a1 + 84) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4) = *(_DWORD *)(a1 + 92);
  }
  v4 = a1 + 36;
  *(_DWORD *)(v4 + 24) = 0;
  *(_BYTE *)(v4 + 1) = 1;
  *(_BYTE *)v4 = 0;
  return 0;
}

//----- (08011CC8) --------------------------------------------------------
int __fastcall sub_8011CC8(int a1, int a2, int a3, int a4)
{
  int v5; // r5
  int v7; // r1
  _DWORD *v8; // r0
  _DWORD *v9; // r0

  v5 = 0;
  if ( *(_BYTE *)(a1 + 36) == 1 )
    return 2;
  *(_BYTE *)(a1 + 36) = 1;
  if ( *(_BYTE *)(a1 + 37) == 1 )
  {
    *(_BYTE *)(a1 + 37) = 2;
    *(_DWORD *)(a1 + 60) = 0;
    **(_DWORD **)a1 &= ~1u;
    sub_80050F4((int *)a1, a2, a3, a4);
    if ( *(_DWORD *)(a1 + 48) )
    {
      v7 = **(_DWORD **)a1 | 0xE;
    }
    else
    {
      **(_DWORD **)a1 &= ~4u;
      v7 = **(_DWORD **)a1 | 0xA;
    }
    **(_DWORD **)a1 = v7;
    v8 = *(_DWORD **)(a1 + 72);
    if ( (*v8 & 0x10000) != 0 )
      *v8 |= 0x100u;
    v9 = *(_DWORD **)(a1 + 84);
    if ( v9 )
      *v9 |= 0x100u;
    **(_DWORD **)a1 |= 1u;
  }
  else
  {
    *(_BYTE *)(a1 + 36) = 0;
    return 2;
  }
  return v5;
}

//----- (08011D58) --------------------------------------------------------
unsigned int __fastcall sub_8011D58(unsigned int a1)
{
  int v2; // r5
  unsigned int result; // r0

  v2 = sub_8012948();
  if ( a1 != -1 )
    a1 += dword_20000268;
  do
    result = sub_8012948() - v2;
  while ( result < a1 );
  return result;
}
// 20000268: using guessed type int dword_20000268;

//----- (08011D7C) --------------------------------------------------------
int __fastcall sub_8011D7C(unsigned __int8 *a1, int a2, int a3)
{
  int v3; // r3
  int v5; // r3

  v3 = a1[92];
  if ( v3 == 1 || v3 == 2 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 88);
    if ( a2 << 29 && !(v5 << 31)
      || (a2 & 0x38) != 0 && (v5 & 2) == 0
      || (a2 & 0x1C0) != 0 && (v5 & 4) == 0
      || (a2 & 0x1E00) != 0 && (v5 & 8) == 0
      || (a2 & 0xE000) != 0 && (v5 & 0x10) == 0
      || (a2 & 0x30000) != 0 && (v5 & 0x20) == 0
      || (a2 & 0xFC0000) != 0 && (v5 & 0x40) == 0 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 92) |= 1u;
    }
    if ( a2 << 29 && v5 << 31
      || (a2 & 0x38) != 0 && (v5 & 2) != 0
      || (a2 & 0x1C0) != 0 && (v5 & 4) != 0
      || (a2 & 0x1E00) != 0 && (v5 & 8) != 0
      || (a2 & 0xE000) != 0 && (v5 & 0x10) != 0
      || (a2 & 0x30000) != 0 && (v5 & 0x20) != 0
      || (a2 & 0xFC0000) != 0 && (v5 & 0x40) != 0 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 92) |= 2u;
    }
    if ( (a2 & 0x80) != 0 )
      *(_DWORD *)(*(_DWORD *)a1 + 220) |= a3;
    if ( (a2 & 0x100) != 0 )
      *(_DWORD *)(*(_DWORD *)a1 + 224) |= a3;
    *(_DWORD *)(*(_DWORD *)a1 + 84) |= a2;
    return 0;
  }
  else
  {
    *((_DWORD *)a1 + 24) |= 2u;
    return 1;
  }
}

//----- (08011E5C) --------------------------------------------------------
int __fastcall sub_8011E5C(_DWORD *a1, int *a2, int a3)
{
  int v5; // r0
  int v6; // r5

  if ( *((_BYTE *)a1 + 92) == 2 )
  {
    v5 = *a1;
    if ( (*(_DWORD *)(*a1 + 196) & 0x200000) != 0 )
    {
      a1[24] |= 0x200u;
      return 1;
    }
    else
    {
      v6 = HIWORD(*(_DWORD *)(v5 + 196)) & 3;
      sub_8005D18((int)a1, a2, a3, v6);
      *(_DWORD *)(*a1 + 204) = 1 << v6;
      a1[22] = 1 << v6;
      return 0;
    }
  }
  else
  {
    a1[24] |= 8u;
    return 1;
  }
}

//----- (08011EAA) --------------------------------------------------------
int __fastcall sub_8011EAA(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int *v5; // r0

  v2 = *(unsigned __int8 *)(a1 + 92);
  if ( v2 == 1 || v2 == 2 )
  {
    if ( *(_DWORD *)a2 )
    {
      v4 = *(_DWORD *)(a2 + 20) | (*(unsigned __int8 *)(a2 + 8) << 30);
      v5 = (int *)(*(_DWORD *)(a1 + 68) + 8 * *(_DWORD *)(a2 + 4));
      *v5 = *(_DWORD *)(a2 + 16) | (*(unsigned __int8 *)(a2 + 12) << 29);
      v5[1] = v4;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4 * *(_DWORD *)(a2 + 4)) = *(_DWORD *)(a2 + 20)
                                                                  | (*(unsigned __int8 *)(a2 + 8) << 30)
                                                                  | (*(unsigned __int8 *)(a2 + 12) << 27)
                                                                  | (*(unsigned __int16 *)(a2 + 16) << 16);
    }
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 2u;
    return 1;
  }
}

//----- (08011F08) --------------------------------------------------------
int __fastcall sub_8011F08(int a1, int a2, int a3, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 92) == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 128) = (16 * a2)
                                     | (4 * a3)
                                     | (2 * a4)
                                     | a5
                                     | *(_DWORD *)(*(_DWORD *)a1 + 128) & 0xFFFFFFC0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    return 1;
  }
}

//----- (08011F3E) --------------------------------------------------------
int __fastcall sub_8011F3E(int a1)
{
  int result; // r0

  if ( !a1 )
    return 1;
  sub_80124A0((int *)a1);
  *(_DWORD *)(*(_DWORD *)a1 + 92) &= 0xFFFFFFFC;
  nullsub_2(a1);
  result = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 92) = 0;
  return result;
}
// 800F7FA: using guessed type int __fastcall nullsub_2(_DWORD);

//----- (08011F6C) --------------------------------------------------------
int __fastcall sub_8011F6C(int a1, int a2, int *a3, int a4)
{
  int v5; // r6
  int v6; // r5
  int v7; // r4
  unsigned int v8; // r4
  int v9; // r5
  unsigned int i; // r4

  if ( *(_BYTE *)(a1 + 92) != 2 )
  {
    *(_DWORD *)(a1 + 96) |= 8u;
    return 1;
  }
  if ( a2 == 64 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 144) << 28 )
    {
      v5 = (*(_DWORD *)(*(_DWORD *)a1 + 144) >> 8) & 3;
      v6 = *(_DWORD *)(a1 + 72) + 72 * v5;
      goto LABEL_6;
    }
LABEL_12:
    *(_DWORD *)(a1 + 96) |= 0x100u;
    return 1;
  }
  if ( !(*(_DWORD *)(*(_DWORD *)a1 + 152) << 28) )
    goto LABEL_12;
  v5 = (*(_DWORD *)(*(_DWORD *)a1 + 152) >> 8) & 3;
  v6 = *(_DWORD *)(a1 + 76) + 72 * v5;
LABEL_6:
  v7 = *(_DWORD *)v6 & 0x40000000;
  a3[1] = v7;
  if ( v7 )
    *a3 = *(_DWORD *)v6 & 0x1FFFFFFF;
  else
    *a3 = (*(_DWORD *)v6 >> 18) & 0x7FF;
  a3[2] = *(_DWORD *)v6 & 0x20000000;
  a3[4] = *(_DWORD *)v6 & 0x80000000;
  a3[7] = *(unsigned __int16 *)(v6 + 4);
  a3[3] = *(_DWORD *)(v6 + 4) & 0xF0000;
  a3[5] = *(_DWORD *)(v6 + 4) & 0x100000;
  a3[6] = *(_DWORD *)(v6 + 4) & 0x200000;
  a3[8] = HIBYTE(*(_DWORD *)(v6 + 4)) & 0x7F;
  v8 = *(_DWORD *)(v6 + 4);
  v9 = v6 + 8;
  a3[9] = v8 >> 31;
  for ( i = 0; *((unsigned __int8 *)dword_80268B4 + HIWORD(a3[3])) > i; ++i )
    *(_BYTE *)(a4 + i) = *(_BYTE *)(v9 + i);
  if ( a2 == 64 )
    *(_DWORD *)(*(_DWORD *)a1 + 148) = v5;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 156) = v5;
  return 0;
}
// 80268B4: using guessed type int dword_80268B4[4];

//----- (080121D8) --------------------------------------------------------
int __fastcall sub_80121D8(int a1)
{
  int v3; // r5
  int v4; // r5
  int v5; // r0

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 92) )
  {
    *(_BYTE *)(a1 + 93) = 0;
    sub_80123B4((int *)a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x10u;
  v3 = sub_8012948();
  while ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 8) != 0 )
  {
    if ( (unsigned int)(sub_8012948() - v3) > 0xA )
    {
      *(_DWORD *)(a1 + 96) |= 1u;
      *(_BYTE *)(a1 + 92) = 3;
      return 1;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) |= 1u;
  v4 = sub_8012948();
  while ( !(*(_DWORD *)(*(_DWORD *)a1 + 24) << 31) )
  {
    if ( (unsigned int)(sub_8012948() - v4) > 0xA )
    {
      *(_DWORD *)(a1 + 96) |= 1u;
      *(_BYTE *)(a1 + 92) = 3;
      return 1;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 24) |= 2u;
  if ( *(_DWORD *)a1 == 1073767424 )
    MEMORY[0x40006500] = *(_DWORD *)(a1 + 4);
  if ( *(_BYTE *)(a1 + 16) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x40u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x40u;
  if ( *(_BYTE *)(a1 + 17) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x4000u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x4000u;
  if ( *(_BYTE *)(a1 + 18) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x1000u;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x1000u;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(*(_DWORD *)a1 + 24) & 0xFFFFFCFF | *(_DWORD *)(a1 + 8);
  *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFFF5B;
  *(_DWORD *)(*(_DWORD *)a1 + 16) &= ~0x10u;
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 == 1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 4u;
  }
  else if ( v5 )
  {
    if ( v5 == 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x80u;
      *(_DWORD *)(*(_DWORD *)a1 + 16) |= 0x10u;
      if ( *(_DWORD *)(a1 + 12) == 3 )
        *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
    }
  }
  *(_DWORD *)(*(_DWORD *)a1 + 28) = ((*(unsigned __int8 *)(a1 + 24) - 1) << 25)
                                  | ((*(_DWORD *)(a1 + 28) - 1) << 8)
                                  | (*(_DWORD *)(a1 + 32) - 1)
                                  | ((*(unsigned __int16 *)(a1 + 20) - 1) << 16);
  if ( *(_DWORD *)(a1 + 8) == 768 )
    *(_DWORD *)(*(_DWORD *)a1 + 12) = (*(_DWORD *)(a1 + 40) - 1)
                                    | ((*(_DWORD *)(a1 + 44) - 1) << 8)
                                    | (16 * (*(_DWORD *)(a1 + 48) - 1))
                                    | ((*(unsigned __int16 *)(a1 + 36) - 1) << 16);
  *(_DWORD *)(*(_DWORD *)a1 + 192) |= *(_DWORD *)(a1 + 60);
  sub_8005CA4((int *)a1);
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 92) = 1;
  return 0;
}

//----- (080123B4) --------------------------------------------------------
int __fastcall sub_80123B4(int *a1)
{
  int result; // r0
  _DWORD v3[21]; // [sp+8h] [bp-70h] BYREF
  _DWORD v4[7]; // [sp+5Ch] [bp-1Ch] BYREF

  sub_8002364(v4, 20);
  sub_8002364(v3, 84);
  result = *a1;
  if ( *a1 == 1073768448 )
  {
    v3[0] = 4096;
    v3[14] = 0x2000000;
    sub_8013AD4(v3);
    MEMORY[0x4002104C] |= 2u;
    MEMORY[0x40021058] |= 0x2000000u;
    v4[0] = 96;
    v4[1] = 2;
    v4[2] = 1;
    v4[3] = 2;
    v4[4] = 9;
    sub_8012760((int *)0x48000400, (int)v4);
    sub_8013970(86, 0xDu, 0);
    return sub_8013954(86);
  }
  return result;
}

//----- (0801243C) --------------------------------------------------------
int __fastcall sub_801243C(unsigned __int8 *a1, int a2)
{
  int result; // r0

  result = a2 << 31;
  if ( a2 << 31 )
  {
    sub_8011F6C((int)a1, 64, &dword_200020E4, (int)&unk_2000025A);
    sub_8004848(dword_200020E4, (int *)&unk_2000025A);
    return sub_8011D7C(a1, 1, 0);
  }
  return result;
}
// 200020E4: using guessed type int dword_200020E4;

//----- (08012474) --------------------------------------------------------
int __fastcall sub_8012474(int a1)
{
  if ( *(_BYTE *)(a1 + 92) == 1 )
  {
    *(_BYTE *)(a1 + 92) = 2;
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~1u;
    *(_DWORD *)(a1 + 96) = 0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    return 1;
  }
}

//----- (080124A0) --------------------------------------------------------
int __fastcall sub_80124A0(int *a1)
{
  unsigned int v1; // r1
  int v3; // r2
  unsigned int v4; // r1
  int v5; // r2

  v1 = 0;
  if ( *((_BYTE *)a1 + 92) == 2 )
  {
    *(_DWORD *)(*a1 + 24) |= 1u;
    v3 = *a1;
    while ( !(*(_DWORD *)(v3 + 24) << 31) )
    {
      if ( v1 > 0xA )
      {
        a1[24] |= 1u;
        *((_BYTE *)a1 + 92) = 3;
        return 1;
      }
      ++v1;
    }
    v4 = 0;
    *(_DWORD *)(v3 + 24) &= ~0x10u;
    v5 = *a1;
    while ( (*(_DWORD *)(v5 + 24) & 8) != 0 )
    {
      if ( v4 > 0xA )
      {
        a1[24] |= 1u;
        *((_BYTE *)a1 + 92) = 3;
        return 1;
      }
      ++v4;
    }
    *(_DWORD *)(v5 + 24) |= 2u;
    a1[22] = 0;
    *((_BYTE *)a1 + 92) = 1;
    return 0;
  }
  else
  {
    a1[24] |= 8u;
    return 1;
  }
}

//----- (08012530) --------------------------------------------------------
int __fastcall sub_8012530(_DWORD *a1, unsigned int *a2)
{
  int v4; // r6
  unsigned int i; // r5

  if ( byte_20000270 == 1 )
    return 2;
  byte_20000270 = 1;
  v4 = sub_8005EB8(0x3E8u);
  if ( !v4 )
  {
    dword_20000274 = 0;
    if ( (MEMORY[0x40022000] & 0x200) != 0 )
    {
      if ( (MEMORY[0x40022000] & 0x400) != 0 )
      {
        MEMORY[0x40022000] &= ~0x400u;
        byte_2000028C = 3;
      }
      else
      {
        byte_2000028C = 1;
      }
    }
    else if ( (MEMORY[0x40022000] & 0x400) != 0 )
    {
      MEMORY[0x40022000] &= ~0x400u;
      byte_2000028C = 2;
    }
    else
    {
      byte_2000028C = 0;
    }
    if ( *a1 == 1 )
    {
      sub_8005DE8(a1[1]);
      v4 = sub_8005EB8(0x3E8u);
      MEMORY[0x40022014] &= 0xFFFF7FFB;
    }
    else
    {
      *a2 = -1;
      for ( i = a1[2]; a1[2] + a1[3] > i; ++i )
      {
        sub_8005E24(i, a1[1]);
        v4 = sub_8005EB8(0x3E8u);
        MEMORY[0x40022014] &= 0xFFFFFC05;
        if ( v4 )
        {
          *a2 = i;
          break;
        }
      }
    }
    sub_8005D8C();
  }
  byte_20000270 = 0;
  return v4;
}
// 20000270: using guessed type char byte_20000270;
// 20000274: using guessed type int dword_20000274;
// 2000028C: using guessed type char byte_2000028C;

//----- (08012628) --------------------------------------------------------
BOOL sub_8012628()
{
  MEMORY[0x40022014] |= 0x80000000;
  return MEMORY[0x40022014] >= 0;
}

//----- (08012644) --------------------------------------------------------
int __fastcall sub_8012644(int a1, _DWORD *a2, int *a3, int a4)
{
  int v8; // r6
  int result; // r0
  int v10; // r1

  v8 = 0;
  if ( byte_20000270 == 1 )
    return 2;
  byte_20000270 = 1;
  result = sub_8005EB8(0x3E8u);
  if ( !result )
  {
    dword_20000274 = 0;
    if ( a1 )
    {
      if ( a1 == 1 || a1 == 2 )
      {
        sub_8005E8C(a2, a3);
        if ( a1 == 2 )
          v8 = 0x40000;
      }
    }
    else
    {
      sub_8005E70(a2, v10, (int)a3, a4);
      v8 = 1;
    }
    result = sub_8005EB8(0x3E8u);
    if ( v8 )
      MEMORY[0x40022014] &= ~v8;
  }
  byte_20000270 = 0;
  return result;
}
// 8012690: variable 'v10' is possibly undefined
// 20000270: using guessed type char byte_20000270;
// 20000274: using guessed type int dword_20000274;

//----- (080126C4) --------------------------------------------------------
int sub_80126C4()
{
  int result; // r0

  result = 0;
  if ( MEMORY[0x40022014] < 0 )
  {
    MEMORY[0x40022008] = -839939669;
    return 1;
  }
  return result;
}

//----- (080126EC) --------------------------------------------------------
int __fastcall sub_80126EC(int result)
{
  unsigned int v1; // r0
  int v2; // r1

  if ( result == 128 || result == 256 )
  {
    sub_8003220();
    v1 = 23;
    goto LABEL_10;
  }
  if ( result == 1024 || result == 2048 )
  {
    sub_8003220();
    v1 = 40;
LABEL_10:
    v2 = 1 << (v1 & 0x1F);
    result = 4 * (v1 >> 5) - 536813568;
    *(_DWORD *)(result + 384) = v2;
    __dsb(0xFu);
    __isb(0xFu);
  }
  return result;
}
// 801E9BE: conditional instruction was optimized away because r0.4 is in (==17|==28)

//----- (08012748) --------------------------------------------------------
int __fastcall sub_8012748(int result)
{
  if ( (MEMORY[0x40010414] & result) != 0 )
  {
    MEMORY[0x40010414] = result;
    return sub_80126EC(result);
  }
  return result;
}

//----- (08012760) --------------------------------------------------------
int *__fastcall sub_8012760(int *result, int a2)
{
  unsigned int i; // r2
  int v3; // r3
  int v4; // r4
  int v5; // r4
  int v6; // r4
  int v7; // r4
  int v8; // r4
  int v9; // r4

  for ( i = 0; *(_DWORD *)a2 >> i; ++i )
  {
    v3 = *(_DWORD *)a2 & (1 << i);
    if ( v3 )
    {
      v4 = *(_BYTE *)(a2 + 4) & 3;
      if ( v4 == 1 || v4 == 2 )
      {
        result[2] = (*(_DWORD *)(a2 + 12) << (2 * i)) | result[2] & ~(3 << (2 * i));
        result[1] = (((*(unsigned __int8 *)(a2 + 4) >> 4) & 1) << i) | result[1] & ~(1 << i);
      }
      if ( ~*(unsigned __int8 *)(a2 + 4) << 30 )
        result[3] = (*(_DWORD *)(a2 + 8) << (2 * i)) | result[3] & ~(3 << (2 * i));
      if ( (*(_BYTE *)(a2 + 4) & 3) == 2 )
        result[(i >> 3) + 8] = (*(_DWORD *)(a2 + 16) << ((4 * i) & 0x1F))
                             | result[(i >> 3) + 8] & ~(15 << ((4 * i) & 0x1F));
      *result = ((*(_BYTE *)(a2 + 4) & 3) << (2 * i)) | *result & ~(3 << (2 * i));
      if ( (*(_DWORD *)(a2 + 4) & 0x30000) != 0 )
      {
        MEMORY[0x40021060] |= 1u;
        if ( result == (int *)1207959552 )
        {
          v5 = 0;
        }
        else if ( result == (int *)1207960576 )
        {
          v5 = 1;
        }
        else if ( result == (int *)1207961600 )
        {
          v5 = 2;
        }
        else if ( result == (int *)1207962624 )
        {
          v5 = 3;
        }
        else if ( result == (int *)1207963648 )
        {
          v5 = 4;
        }
        else if ( result == (int *)1207964672 )
        {
          v5 = 5;
        }
        else
        {
          v5 = 6;
        }
        *(_DWORD *)((i & 0xFFFFFFFC) + 1073807368) = (v5 << ((4 * i) & 0xF))
                                                   | *(_DWORD *)((i & 0xFFFFFFFC) + 1073807368)
                                                   & ~(15 << ((4 * i) & 0xF));
        v6 = MEMORY[0x40010408] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x100000) != 0 )
          v6 |= v3;
        MEMORY[0x40010408] = v6;
        v7 = MEMORY[0x4001040C] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x200000) != 0 )
          v7 |= v3;
        MEMORY[0x4001040C] = v7;
        v8 = MEMORY[0x40010404] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x20000) != 0 )
          v8 |= v3;
        MEMORY[0x40010404] = v8;
        v9 = MEMORY[0x40010400] & ~v3;
        if ( (*(_DWORD *)(a2 + 4) & 0x10000) != 0 )
          v9 |= v3;
        MEMORY[0x40010400] = v9;
      }
    }
  }
  return result;
}

//----- (08012910) --------------------------------------------------------
BOOL __fastcall sub_8012910(int a1, int a2)
{
  return (*(_DWORD *)(a1 + 16) & a2) != 0;
}

//----- (0801291E) --------------------------------------------------------
int __fastcall sub_801291E(int result, int a2)
{
  *(_DWORD *)(result + 24) = a2 & ~*(_DWORD *)(result + 20) | ((*(_DWORD *)(result + 20) & a2) << 16);
  return result;
}

//----- (0801292E) --------------------------------------------------------
int __fastcall sub_801292E(int result, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)(result + 24) = a2;
  else
    *(_DWORD *)(result + 40) = a2;
  return result;
}

//----- (0801293C) --------------------------------------------------------
unsigned int sub_801293C()
{
  return HIWORD(dword_E0042000);
}
// E0042000: using guessed type int dword_E0042000;

//----- (08012948) --------------------------------------------------------
int sub_8012948()
{
  return dword_2000026C;
}
// 2000026C: using guessed type int dword_2000026C;

//----- (08012954) --------------------------------------------------------
int __fastcall sub_8012954(_BYTE *a1, int a2, char a3)
{
  _BYTE *v4; // r0

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == 32 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFFFFE0 | a3 & 0x1F;
  }
  else if ( a2 > 32 )
  {
    switch ( a2 )
    {
      case 64:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFFF83F | ((a3 & 0x1F) << 6);
        break;
      case 128:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFFFE0FFF | ((a3 & 0x1F) << 12);
        break;
      case 256:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xFF83FFFF | ((a3 & 0x1F) << 18);
        break;
      case 512:
        *(_DWORD *)(*(_DWORD *)a1 + 1028) = *(_DWORD *)(*(_DWORD *)a1 + 1028) & 0xE0FFFFFF | ((a3 & 0x1F) << 24);
        break;
      default:
LABEL_19:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
  }
  else if ( a2 == 4 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFE0FFF | ((a3 & 0x1F) << 12);
  }
  else if ( a2 > 4 )
  {
    if ( a2 != 8 )
    {
      if ( a2 == 16 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xE0FFFFFF | ((a3 & 0x1F) << 24);
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFF83FFFF | ((a3 & 0x1F) << 18);
  }
  else
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFFF83F | ((a3 & 0x1F) << 6);
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 1024) = *(_DWORD *)(*(_DWORD *)a1 + 1024) & 0xFFFFFFE0 | a3 & 0x1F;
  }
LABEL_20:
  if ( a1[221] == 7 )
    return 1;
  v4 = a1 + 220;
  v4[1] = 1;
  *v4 = 0;
  return 0;
}

//----- (08012A70) --------------------------------------------------------
int __fastcall sub_8012A70(_BYTE *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r3
  unsigned int v4; // r5
  unsigned int v5; // r4
  _BYTE *v7; // r0

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  v3 = *(_DWORD **)a1;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 896);
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 1020);
  if ( a2 == 32 )
  {
    v5 = (*a3 >> 12) & 0x70 | v5 & 0xFFFFFF8F;
    v3[254] &= 0xFFFFFC1F;
    *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (32 * a3[1]) & 0x3E0;
  }
  else if ( a2 > 32 )
  {
    switch ( a2 )
    {
      case 64:
        v5 = (*a3 >> 8) & 0x700 | v5 & 0xFFFFF8FF;
        v3[254] &= 0xFFFF83FF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (a3[1] << 10) & 0x7C00;
        break;
      case 128:
        v5 = (*a3 >> 4) & 0x7000 | v5 & 0xFFFF8FFF;
        v3[254] &= 0xFFE0FFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int16 *)a3 + 2) << 16) & 0x1F0000;
        break;
      case 256:
        v5 = *a3 & 0x70000 | v5 & 0xFFF8FFFF;
        v3[254] &= 0xFC1FFFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int16 *)a3 + 2) << 21) & 0x3E00000;
        break;
      case 512:
        v5 = (16 * *a3) & 0x700000 | v5 & 0xFF8FFFFF;
        v3[254] &= 0x83FFFFFF;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= (*((unsigned __int8 *)a3 + 4) << 26) & 0x7C000000;
        break;
      default:
LABEL_19:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
  }
  else if ( a2 == 4 )
  {
    v4 = (*a3 << 6) & 0x1C00000 | v4 & 0xFE3FFFFF;
    v3[241] = a3[1];
  }
  else if ( a2 > 4 )
  {
    if ( a2 != 8 )
    {
      if ( a2 == 16 )
      {
        v5 = HIWORD(*a3) & 7 | v5 & 0xFFFFFFF8;
        v3[254] &= 0xFFFFFFE0;
        *(_DWORD *)(*(_DWORD *)a1 + 1016) |= a3[1] & 0x1F;
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    v4 = (*a3 << 9) & 0xE000000 | v4 & 0xF1FFFFFF;
    v3[242] = a3[1];
  }
  else
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
      {
        v4 = (8 * *a3) & 0x380000 | v4 & 0xFFC7FFFF;
        v3[240] = a3[1];
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    v4 = *a3 & 0x70000 | v4 & 0xFFF8FFFF;
    v3[239] = a3[1];
  }
LABEL_20:
  if ( a1[221] == 7 )
    return 1;
  if ( (unsigned int)a2 >= 0x10 )
    *(_DWORD *)(*(_DWORD *)a1 + 1020) = v5;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 896) = v4;
  v7 = a1 + 220;
  v7[1] = 1;
  *v7 = 0;
  return 0;
}

//----- (08012CC2) --------------------------------------------------------
int __fastcall sub_8012CC2(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 928) = *(_DWORD *)(*((_DWORD *)v2 - 55) + 928) & 0xFFFFFFFE | a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08012D02) --------------------------------------------------------
int __fastcall sub_8012D02(_BYTE *a1, int a2)
{
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == -1 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 972) &= ~2u;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 972) |= 2u;
    *(_DWORD *)(*(_DWORD *)a1 + 972) = *(_DWORD *)(*(_DWORD *)a1 + 972) & 0xFFFFFFF3 | a2;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 972) |= 1u;
  a1[221] = 1;
  return 0;
}

//----- (08012D74) --------------------------------------------------------
int __fastcall sub_8012D74(int a1, int a2, int a3)
{
  _BYTE *v3; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v3 = (_BYTE *)(a1 + 220);
  v3[1] = 2;
  *(_DWORD *)(*((_DWORD *)v3 - 55) + (a2 << 7) + 184) = *(_DWORD *)(*((_DWORD *)v3 - 55) + (a2 << 7) + 184) & 0x3C002000
                                                      | *(_DWORD *)(a3 + 28) & 0x80000000
                                                      | *(_DWORD *)(a3 + 32) & 0x40000000
                                                      | *(_DWORD *)(a3 + 24) & 0x2000000
                                                      | (*(unsigned __int16 *)(a3 + 20) << 16) & 0x1FFFFFF
                                                      | *(_WORD *)(a3 + 12) & 0x8000
                                                      | *(_WORD *)(a3 + 16) & 0x4000
                                                      | *(_WORD *)(a3 + 8) & 0x200
                                                      | *(_WORD *)(a3 + 4) & 0x1FF
                                                      | *(_WORD *)a3 & 0x1C00;
  v3[1] = 1;
  *v3 = 0;
  return 0;
}

//----- (08012E04) --------------------------------------------------------
int __fastcall sub_8012E04(int a1, int a2, _BYTE *a3)
{
  _BYTE *v4; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_801621C((_DWORD *)a1, a2, a3);
  v4 = (_BYTE *)(a1 + 220);
  v4[1] = 1;
  result = 0;
  *v4 = 0;
  return result;
}

//----- (08012E3C) --------------------------------------------------------
int __fastcall sub_8012E3C(int a1)
{
  unsigned int i; // r1
  _DWORD *v3; // r0

  if ( !a1 )
    return 1;
  *(_BYTE *)(a1 + 221) = 2;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 236) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  if ( *(unsigned __int8 *)(a1 + 8) << 31 )
  {
    if ( *(_DWORD *)a1 == 1073833984 )
      MEMORY[0x40021060] |= 0x4000000u;
    **(_DWORD **)a1 = *(_WORD *)(a1 + 20) & 0x3000 | *(_WORD *)(a1 + 16) & 0xC000 | **(_DWORD **)a1 & 0xFFFF0FFF;
  }
  sub_8012EF4((int *)a1);
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    **(_DWORD **)a1 = *(_WORD *)(a1 + 12) & 0x300 | **(_DWORD **)a1 & 0xFFFFFCFF;
  *(_BYTE *)(a1 + 221) = 1;
  *(_BYTE *)(a1 + 220) = 0;
  for ( i = 0; i <= 6; i = (unsigned __int8)(i + 1) )
  {
    v3 = (_DWORD *)(a1 + 28 * i);
    v3[6] = 0;
    v3[7] = 0;
    v3[8] = 0;
    v3[9] = 0;
    v3[10] = 0;
    v3[12] = 0;
  }
  return 0;
}

//----- (08012EF4) --------------------------------------------------------
int __fastcall sub_8012EF4(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073833984 )
  {
    MEMORY[0x40021060] |= 0x4000000u;
    return MEMORY[0x40021060] & 0x4000000;
  }
  return result;
}

//----- (08012F1C) --------------------------------------------------------
int *__fastcall sub_8012F1C(int **a1)
{
  int *result; // r0
  int v3; // [sp+4h] [bp-2Ch] BYREF
  int v4; // [sp+8h] [bp-28h]
  int v5; // [sp+Ch] [bp-24h]
  int v6; // [sp+10h] [bp-20h]
  int v7; // [sp+14h] [bp-1Ch]

  sub_8002364(&v3, 20);
  result = *a1;
  if ( *a1 == (int *)1073833984 )
  {
    MEMORY[0x4002104C] |= 2u;
    MEMORY[0x4002104C] |= 4u;
    MEMORY[0x4002104C] |= 1u;
    v3 = 12288;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    sub_8012760((int *)0x48000400, (int)&v3);
    v3 = 192;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    sub_8012760((int *)0x48000800, (int)&v3);
    v3 = 768;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 3;
    sub_8012760((int *)0x48000800, (int)&v3);
    v3 = 3840;
    v4 = 2;
    v5 = 0;
    v6 = 3;
    v7 = 13;
    return sub_8012760((int *)0x48000000, (int)&v3);
  }
  return result;
}

//----- (08012FE0) --------------------------------------------------------
int __fastcall sub_8012FE0(_BYTE *a1, unsigned int a2)
{
  int v4; // r6
  _BYTE *v5; // r5
  int result; // r0

  v4 = sub_8012948();
  do
  {
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 904) & 0x10000) == 0 )
    {
      v5 = a1 + 220;
      v5[1] = 1;
      result = 0;
      *v5 = 0;
      return result;
    }
  }
  while ( a2 == -1 || sub_8012948() - v4 <= a2 && a2 );
  a1[221] = 7;
  return 3;
}

//----- (08013020) --------------------------------------------------------
int __fastcall sub_8013020(int a1, int a2, _DWORD *a3)
{
  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  *(_BYTE *)(a1 + 221) = 2;
  if ( a2 == 6 )
    sub_8016530((int *)a1, a3);
  else
    sub_80166C8((int *)a1, a2, a3);
  *(_BYTE *)(a1 + 221) = 1;
  return 0;
}

//----- (08013054) --------------------------------------------------------
int __fastcall sub_8013054(_BYTE *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r5
  int v5; // r6
  int v6; // r4
  int v8; // r1
  int v9; // r1

  if ( a1[221] == 2 )
    return 2;
  if ( a1[220] == 1 )
    return 2;
  a1[220] = 1;
  a1[221] = 2;
  if ( a2 == 6 )
  {
    switch ( a3 )
    {
      case 1:
        *(_DWORD *)(*(_DWORD *)a1 + 28) = *a4;
        break;
      case 2:
        *(_DWORD *)(*(_DWORD *)a1 + 36) = *a4;
        break;
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 40) = *a4;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 44) = *a4;
        break;
      default:
        a1[221] = 7;
        a1[220] = 0;
        break;
    }
    if ( a1[221] != 7 )
    {
LABEL_19:
      a1[221] = 1;
      a1[220] = 0;
      return 0;
    }
    return 1;
  }
  else
  {
    v4 = (a2 << 7) + 156;
    if ( a3 == 1 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + v4) = *a4;
    }
    else
    {
      v5 = (a2 << 7) + 168;
      v6 = (a2 << 7) + 128;
      switch ( a3 )
      {
        case 2:
          *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 164) = *a4;
          if ( a4[1] )
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFFCFFF;
            *(_DWORD *)(*(_DWORD *)a1 + v6) |= a4[1];
            v8 = a4[1];
            if ( v8 == 0x2000 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v4) = a4[2];
            }
            else if ( v8 == 12288 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v5) = a4[2];
            }
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFFCFFF;
          }
          break;
        case 4:
          *(_DWORD *)(*(_DWORD *)a1 + v5) = *a4;
          break;
        case 8:
          *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 172) = *a4;
          if ( a4[1] )
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFF3FFF;
            *(_DWORD *)(*(_DWORD *)a1 + v6) |= 4 * a4[1];
            v9 = a4[1];
            if ( v9 == 0x2000 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v4) = a4[2];
            }
            else if ( v9 == 12288 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + v5) = a4[2];
            }
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)a1 + v6) &= 0xFFFF3FFF;
          }
          break;
        default:
          a1[221] = 7;
          a1[220] = 0;
          break;
      }
    }
    if ( a1[221] != 7 )
      goto LABEL_19;
    return 1;
  }
}

//----- (080131D6) --------------------------------------------------------
int __fastcall sub_80131D6(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  **((_DWORD **)v2 - 55) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (08013202) --------------------------------------------------------
int __fastcall sub_8013202(int a1, int a2, int a3, _DWORD *a4)
{
  _BYTE *v5; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_80165EA((int *)a1, a2, a3, a4);
  v5 = (_BYTE *)(a1 + 220);
  v5[1] = 1;
  result = 0;
  *v5 = 0;
  return result;
}

//----- (0801323A) --------------------------------------------------------
int __fastcall sub_801323A(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 916) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (0801326A) --------------------------------------------------------
int __fastcall sub_801326A(int a1, int a2)
{
  _BYTE *v2; // r0

  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  v2 = (_BYTE *)(a1 + 220);
  v2[1] = 2;
  *(_DWORD *)(*((_DWORD *)v2 - 55) + 920) |= a2;
  v2[1] = 1;
  *v2 = 0;
  return 0;
}

//----- (0801329A) --------------------------------------------------------
int __fastcall sub_801329A(int a1, int a2, _DWORD *a3)
{
  _DWORD *v6; // r0
  int result; // r0
  _BYTE *v8; // r4

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  if ( a2 == 6 )
    sub_8016556((int *)a1, a3);
  else
    ((void (__fastcall *)(int, int, _DWORD *))loc_8016700)(a1, a2, a3);
  v6 = (_DWORD *)(a1 + 28 * a2);
  v6[8] = *a3;
  v6[9] = a3[1];
  v6[10] = a3[2];
  v6[11] = a3[3];
  v6[12] = a3[4];
  sub_80164B0((_DWORD *)a1, a2);
  if ( a2 != 6 && !a3[11] )
    *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 128) = *(_DWORD *)(*(_DWORD *)a1 + (a2 << 7) + 128) & 0xFFFFFDFF
                                                 | (a3[23] << 9);
  v8 = (_BYTE *)(a1 + 220);
  v8[1] = 1;
  result = 0;
  *v8 = 0;
  return result;
}

//----- (08013330) --------------------------------------------------------
int __fastcall sub_8013330(int a1, int a2, _DWORD *a3)
{
  _BYTE *v5; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 221) == 2 )
    return 2;
  if ( *(_BYTE *)(a1 + 220) == 1 )
    return 2;
  *(_BYTE *)(a1 + 220) = 1;
  *(_BYTE *)(a1 + 221) = 2;
  sub_80168BC((int *)a1, a2, a3);
  sub_80164B0((_DWORD *)a1, a2);
  v5 = (_BYTE *)(a1 + 220);
  v5[1] = 1;
  result = 0;
  *v5 = 0;
  return result;
}

//----- (08013374) --------------------------------------------------------
int __fastcall sub_8013374(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  **(_DWORD **)a1 &= ~0x1000u;
  **(_DWORD **)a1 |= a2;
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (080133CE) --------------------------------------------------------
int __fastcall sub_80133CE(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFFFFF0FF | (a2 << 8);
  **(_DWORD **)a1 |= 1u;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (08013424) --------------------------------------------------------
int __fastcall sub_8013424(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 65) )
  {
    *(_BYTE *)(a1 + 64) = 0;
    sub_801377C((int *)a1);
  }
  *(_BYTE *)(a1 + 65) = 36;
  **(_DWORD **)a1 &= ~1u;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 4) & 0xF0FFFFFF;
  *(_DWORD *)(*(_DWORD *)a1 + 8) &= ~0x8000u;
  if ( *(_DWORD *)(a1 + 12) == 1 )
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(a1 + 8) | 0x8000;
  else
    *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(a1 + 8) | 0x8400;
  if ( *(_DWORD *)(a1 + 12) == 2 )
    *(_DWORD *)(*(_DWORD *)a1 + 4) = 2048;
  *(_DWORD *)(*(_DWORD *)a1 + 4) |= 0x2008000u;
  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x8000u;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = *(_DWORD *)(a1 + 16) | *(_DWORD *)(a1 + 20) | (*(_DWORD *)(a1 + 24) << 8);
  **(_DWORD **)a1 = *(_DWORD *)(a1 + 28) | *(_DWORD *)(a1 + 32);
  **(_DWORD **)a1 |= 1u;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 65) = 32;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 66) = 0;
  return 0;
}

//----- (080134E4) --------------------------------------------------------
int __fastcall sub_80134E4(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5)
{
  int v10; // r6
  int v11; // r0

  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  v10 = sub_8012948();
  if ( ((int (__fastcall *)(int, int, int, int))loc_80170D4)(a1, 0x8000, 1, 25) )
    return 1;
  *(_BYTE *)(a1 + 65) = 34;
  *(_BYTE *)(a1 + 66) = 16;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 36) = a3;
  *(_WORD *)(a1 + 42) = a4;
  *(_DWORD *)(a1 + 52) = 0;
  if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
    sub_80170A4((int *)a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0x80002400);
  }
  else
  {
    *(_WORD *)(a1 + 40) = 255;
    sub_80170A4((int *)a1, a2, 255, 0x1000000, 0x80002400);
  }
  while ( *(_WORD *)(a1 + 42) )
  {
    if ( sub_801712C(a1, a5, v10) )
      return 1;
    *(_BYTE *)(*(_DWORD *)(a1 + 36))++ = *(_DWORD *)(*(_DWORD *)a1 + 36);
    v11 = (unsigned __int16)(*(_WORD *)(a1 + 40) - 1);
    *(_WORD *)(a1 + 40) = v11;
    if ( --*(_WORD *)(a1 + 42) && !v11 )
    {
      if ( ((int (__fastcall *)(int, int, _DWORD, unsigned int))loc_80170D4)(a1, 128, 0, a5) )
        return 1;
      if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
      {
        *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
        sub_80170A4((int *)a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0);
      }
      else
      {
        *(_WORD *)(a1 + 40) = 255;
        sub_80170A4((int *)a1, a2, 255, 0x1000000, 0);
      }
    }
  }
  if ( sub_80171D4((int *)a1, a5, v10) )
    return 1;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (08013630) --------------------------------------------------------
int __fastcall sub_8013630(int a1, __int16 a2, int a3, __int16 a4, unsigned int a5)
{
  int v10; // r6
  __int16 v11; // r0

  if ( *(_BYTE *)(a1 + 65) != 32 )
    return 2;
  if ( *(_BYTE *)(a1 + 64) == 1 )
    return 2;
  *(_BYTE *)(a1 + 64) = 1;
  v10 = sub_8012948();
  if ( ((int (__fastcall *)(int, int, int, int))loc_80170D4)(a1, 0x8000, 1, 25) )
    return 1;
  *(_BYTE *)(a1 + 65) = 33;
  *(_BYTE *)(a1 + 66) = 16;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 36) = a3;
  *(_WORD *)(a1 + 42) = a4;
  *(_DWORD *)(a1 + 52) = 0;
  if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
    sub_80170A4((int *)a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0x80002000);
  }
  else
  {
    *(_WORD *)(a1 + 40) = 255;
    sub_80170A4((int *)a1, a2, 255, 0x1000000, 0x80002000);
  }
  while ( *(_WORD *)(a1 + 42) )
  {
    if ( sub_8017220((int *)a1, a5, v10) )
      return 1;
    *(_DWORD *)(*(_DWORD *)a1 + 40) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 36))++;
    --*(_WORD *)(a1 + 42);
    v11 = *(_WORD *)(a1 + 40) - 1;
    *(_WORD *)(a1 + 40) = v11;
    if ( *(_WORD *)(a1 + 42) && !v11 )
    {
      if ( ((int (__fastcall *)(int, int, _DWORD, unsigned int))loc_80170D4)(a1, 128, 0, a5) )
        return 1;
      if ( *(unsigned __int16 *)(a1 + 42) <= 0xFFu )
      {
        *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 42);
        sub_80170A4((int *)a1, a2, *(unsigned __int8 *)(a1 + 40), 0x2000000, 0);
      }
      else
      {
        *(_WORD *)(a1 + 40) = 255;
        sub_80170A4((int *)a1, a2, 255, 0x1000000, 0);
      }
    }
  }
  if ( sub_80171D4((int *)a1, a5, v10) )
    return 1;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 0;
}

//----- (0801377C) --------------------------------------------------------
int __fastcall sub_801377C(int *a1)
{
  int result; // r0
  _DWORD v3[21]; // [sp+8h] [bp-80h] BYREF
  int v4; // [sp+5Ch] [bp-2Ch] BYREF
  int v5; // [sp+60h] [bp-28h]
  int v6; // [sp+64h] [bp-24h]
  int v7; // [sp+68h] [bp-20h]
  int v8; // [sp+6Ch] [bp-1Ch]

  sub_8002364(&v4, 20);
  sub_8002364(v3, 84);
  result = *a1;
  if ( *a1 == 1073763328 )
  {
    v3[0] = 64;
    v3[7] = 0;
    if ( sub_8013AD4(v3) )
      sub_8005C1C();
    MEMORY[0x4002104C] |= 1u;
    MEMORY[0x4002104C] |= 2u;
    v4 = 0x8000;
    v5 = 18;
    v6 = 0;
    v7 = 2;
    v8 = 4;
    sub_8012760((int *)0x48000000, (int)&v4);
    v4 = 512;
    v5 = 18;
    v6 = 0;
    v7 = 2;
    v8 = 4;
    sub_8012760((int *)0x48000400, (int)&v4);
    MEMORY[0x40021058] |= 0x200000u;
    return MEMORY[0x40021058] & 0x200000;
  }
  return result;
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);

//----- (0801382C) --------------------------------------------------------
int __fastcall sub_801382C(_DWORD *a1)
{
  int v2; // r5
  _DWORD *v4; // r0
  int v5; // r1

  if ( !a1 )
    return 1;
  *(_DWORD *)*a1 = 52428;
  *(_DWORD *)*a1 = 21845;
  *(_DWORD *)(*a1 + 4) = a1[1];
  *(_DWORD *)(*a1 + 8) = a1[2];
  v2 = sub_8012948();
  while ( *(_DWORD *)(*a1 + 12) << 29 )
  {
    if ( (unsigned int)(sub_8012948() - v2) > 0x31 && *(_DWORD *)(*a1 + 12) << 29 )
      return 3;
  }
  v4 = (_DWORD *)*a1;
  v5 = a1[3];
  if ( *(_DWORD *)(*a1 + 16) == v5 )
    *v4 = 43690;
  else
    v4[4] = v5;
  return 0;
}

//----- (080138A0) --------------------------------------------------------
int *sub_80138A0()
{
  int *result; // r0

  result = &dword_20000264;
  dword_2000026C += dword_20000268;
  return result;
}
// 20000264: using guessed type int dword_20000264;
// 20000268: using guessed type int dword_20000268;
// 2000026C: using guessed type int dword_2000026C;

//----- (080138B0) --------------------------------------------------------
int sub_80138B0()
{
  int v0; // r4

  v0 = 0;
  sub_80139B0(3);
  if ( sub_80138D0(0) )
    return 1;
  sub_801391C();
  return v0;
}

//----- (080138D0) --------------------------------------------------------
int __fastcall sub_80138D0(unsigned int a1)
{
  int v2; // r4

  v2 = 0;
  if ( !dword_20000268 )
    return 1;
  if ( HAL_SYSTICK_Config(dword_20000290 / (0x3E8u / dword_20000268)) )
    return 1;
  if ( a1 >= 0x10 )
    return 1;
  sub_8013970(-1, a1, 0);
  dword_20000264 = a1;
  return v2;
}
// 20000264: using guessed type int dword_20000264;
// 20000268: using guessed type int dword_20000268;
// 20000290: using guessed type int dword_20000290;

//----- (0801391C) --------------------------------------------------------
int sub_801391C()
{
  int result; // r0

  MEMORY[0x40021060] |= 1u;
  MEMORY[0x40021058] |= 0x10000000u;
  sub_8014884();
  result = 2;
  MEMORY[0x40010030] = MEMORY[0x40010030] & 0xFFFFFFFD | 2;
  return result;
}

//----- (08013954) --------------------------------------------------------
int __fastcall sub_8013954(int result)
{
  int v1; // r1

  if ( result >= 0 )
  {
    v1 = 1 << (result & 0x1F);
    result = 4 * ((unsigned int)result >> 5) - 536813568;
    *(_DWORD *)(result + 256) = v1;
  }
  return result;
}

//----- (08013970) --------------------------------------------------------
int __fastcall sub_8013970(int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // r3
  char v4; // r4
  char v5; // r3

  v3 = ((unsigned int)AIRCR >> 8) & 7;
  v4 = 7 - v3;
  if ( 7 - v3 > 4 )
    v4 = 4;
  if ( v3 + 4 >= 7 )
    v5 = v3 - 3;
  else
    v5 = 0;
  return _NVIC_SetPriority(a1, (((unsigned __int8)((1 << v4) - 1) & a2) << v5) | ((1 << v5) - 1) & a3);
}
// E000ED0C: using guessed type int AIRCR;

//----- (080139B0) --------------------------------------------------------
int __fastcall sub_80139B0(char a1)
{
  int result; // r0

  result = AIRCR & 0xF8FF | ((a1 & 7) << 8) | 0x5FA0000;
  AIRCR = result;
  return result;
}
// E000ED0C: using guessed type int AIRCR;

//----- (080139D4) --------------------------------------------------------
void __noreturn sub_80139D4()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (080139F8) --------------------------------------------------------
int __fastcall sub_80139F8(int a1)
{
  unsigned int v1; // r2
  unsigned int j; // r0
  unsigned int i; // r0

  v1 = 50 * dword_20000290;
  if ( a1 )
  {
    if ( a1 != 512 )
    {
      MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x400;
      return 0;
    }
    if ( ((MEMORY[0x40007000] >> 9) & 3) != 2 )
    {
      MEMORY[0x40007080] |= 0x100u;
      return 0;
    }
    MEMORY[0x40007080] |= 0x100u;
    MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x200;
    for ( i = v1 / 0xF4240 + 1; (MEMORY[0x40007014] & 0x400) != 0 && i; --i )
      ;
    if ( (MEMORY[0x40007014] & 0x400) == 0 )
      return 0;
    return 3;
  }
  else
  {
    if ( ((MEMORY[0x40007000] >> 9) & 3) != 2 )
    {
      MEMORY[0x40007080] &= ~0x100u;
      return 0;
    }
    MEMORY[0x40007080] &= ~0x100u;
    MEMORY[0x40007000] = MEMORY[0x40007000] & 0xFFFFF9FF | 0x200;
    for ( j = v1 / 0xF4240 + 1; (MEMORY[0x40007014] & 0x400) != 0 && j; --j )
      ;
    if ( (MEMORY[0x40007014] & 0x400) == 0 )
      return 0;
    return 3;
  }
}
// 20000290: using guessed type int dword_20000290;

//----- (08013AC4) --------------------------------------------------------
int sub_8013AC4()
{
  int result; // r0

  result = 1073770496;
  MEMORY[0x40007000] |= 0x100u;
  return result;
}

//----- (08013AD4) --------------------------------------------------------
int __fastcall sub_8013AD4(_DWORD *a1)
{
  int v2; // r6
  int v3; // r7
  int v4; // r8
  int v5; // r9
  unsigned int v6; // r0
  int v7; // r9

  v2 = 0;
  v3 = 0;
  if ( (*a1 & 0x80000) != 0 )
  {
    v4 = 0;
    if ( (MEMORY[0x40021058] & 0x10000000) == 0 )
    {
      MEMORY[0x40021058] |= 0x10000000u;
      v4 = 1;
    }
    MEMORY[0x40007000] |= 0x100u;
    v5 = sub_8012948();
    while ( (MEMORY[0x40007000] & 0x100) == 0 )
    {
      if ( (unsigned int)(sub_8012948() - v5) > 2 )
      {
        v2 = 3;
        break;
      }
    }
    if ( v2 )
    {
      v3 = v2;
    }
    else
    {
      v6 = MEMORY[0x40021090] & 0x300;
      if ( (MEMORY[0x40021090] & 0x300) != 0 && a1[20] != v6 )
      {
        v6 = MEMORY[0x40021090] & 0xFFFFFCFF;
        MEMORY[0x40021090] &= 0xFFFFFCFF;
      }
      if ( v6 << 31 )
      {
        v7 = sub_8012948();
        while ( (MEMORY[0x40021090] & 2) == 0 )
        {
          if ( (unsigned int)(sub_8012948() - v7) > 0x1388 )
          {
            v2 = 3;
            break;
          }
        }
      }
      if ( v2 )
        v3 = v2;
      else
        MEMORY[0x40021090] = MEMORY[0x40021090] & 0xFFFFFCFF | a1[20];
    }
    if ( v4 == 1 )
      MEMORY[0x40021058] &= ~0x10000000u;
  }
  if ( *(unsigned __int8 *)a1 << 31 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFFC | a1[1];
  if ( (*(_BYTE *)a1 & 2) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFF3 | a1[2];
  if ( (*(_BYTE *)a1 & 4) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFFCF | a1[3];
  if ( (*(_BYTE *)a1 & 8) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFF3F | a1[4];
  if ( (*(_BYTE *)a1 & 0x10) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFFCFF | a1[5];
  if ( (*(_BYTE *)a1 & 0x20) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFF3FF | a1[6];
  if ( (*(_BYTE *)a1 & 0x40) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFFCFFF | a1[7];
  if ( (*(_BYTE *)a1 & 0x80) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFF3FFF | a1[8];
  if ( (*(_WORD *)a1 & 0x100) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFFCFFFF | a1[9];
  if ( (*a1 & 0x20000) != 0 )
    MEMORY[0x4002109C] = MEMORY[0x4002109C] & 0xFFFFFFFC | a1[10];
  if ( (*(_WORD *)a1 & 0x200) != 0 )
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFF3FFFF | a1[11];
  if ( (*(_WORD *)a1 & 0x400) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFFCFFFFF | a1[12];
    if ( a1[12] == 0x100000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x800) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFF3FFFFF | a1[13];
    if ( a1[13] == 0x400000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x1000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xFCFFFFFF | a1[14];
    if ( a1[14] == 0x1000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x2000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xF3FFFFFF | a1[15];
    if ( a1[15] == 0x8000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x4000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xF3FFFFFF | a1[16];
    if ( a1[16] == 0x8000000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  if ( (*(_WORD *)a1 & 0x8000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0xCFFFFFFF | a1[17];
    if ( a1[17] == 0x10000000 )
      MEMORY[0x4002100C] |= 0x10000u;
  }
  if ( (*a1 & 0x10000) != 0 )
  {
    MEMORY[0x40021088] = MEMORY[0x40021088] & 0x3FFFFFFF | a1[18];
    if ( a1[18] == 0x40000000 )
      MEMORY[0x4002100C] |= 0x10000u;
  }
  if ( (*a1 & 0x40000) != 0 )
  {
    MEMORY[0x4002109C] = MEMORY[0x4002109C] & 0xFFCFFFFF | a1[19];
    if ( a1[19] == 0x200000 )
      MEMORY[0x4002100C] |= 0x100000u;
  }
  return v3;
}

//----- (08013DE4) --------------------------------------------------------
int __fastcall sub_8013DE4(unsigned __int8 *a1, unsigned int a2)
{
  int v4; // r7
  int v6; // r0
  int v7; // r8
  int v8; // r7

  v4 = 0;
  if ( !a1 )
    return 1;
  if ( (MEMORY[0x40022000] & 0xFu) < a2 )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF0 | a2;
    if ( (MEMORY[0x40022000] & 0xF) != a2 )
      return 1;
  }
  if ( *a1 << 31 )
  {
    v6 = *((_DWORD *)a1 + 1);
    if ( v6 == 3 )
    {
      if ( (MEMORY[0x40021000] & 0x2000000) == 0 )
        return 1;
      if ( sub_8018C68() > 0x4C4B400 && ((MEMORY[0x40021008] & 0xF0) == 0 || (*a1 & 2) != 0 && !*((_DWORD *)a1 + 2)) )
      {
        MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | 0x80;
        v4 = 128;
      }
    }
    else
    {
      if ( v6 == 2 )
      {
        if ( (MEMORY[0x40021000] & 0x20000) == 0 )
          return 1;
      }
      else if ( (MEMORY[0x40021000] & 0x400) == 0 )
      {
        return 1;
      }
      if ( sub_8014000() > 0x4C4B400 )
      {
        MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | 0x80;
        v4 = 128;
      }
    }
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFFFC | *((_DWORD *)a1 + 1);
    v7 = sub_8012948();
    while ( (MEMORY[0x40021008] & 0xC) != 4 * *((_DWORD *)a1 + 1) )
    {
      if ( (unsigned int)(sub_8012948() - v7) > 0x1388 )
        return 3;
    }
  }
  if ( (*(_DWORD *)a1 & 2) != 0 )
  {
    if ( (*(_DWORD *)a1 & 4) != 0 )
      MEMORY[0x40021008] |= 0x700u;
    if ( (*a1 & 8) != 0 )
      MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFC0FF | 0x700;
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFFF0F | *((_DWORD *)a1 + 2);
  }
  else if ( v4 == 128 )
  {
    MEMORY[0x40021008] &= 0xFFFFFF0F;
  }
  if ( (MEMORY[0x40022000] & 0xFu) > a2 )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF0 | a2;
    v8 = sub_8012948();
    while ( (MEMORY[0x40022000] & 0xF) != a2 )
    {
      if ( (unsigned int)(sub_8012948() - v8) > 0x1388 )
        return 3;
    }
  }
  if ( (*a1 & 4) != 0 )
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFF8FF | *((_DWORD *)a1 + 3);
  if ( (*a1 & 8) != 0 )
    MEMORY[0x40021008] = MEMORY[0x40021008] & 0xFFFFC7FF | (8 * *((_DWORD *)a1 + 4));
  dword_20000290 = sub_8014000() >> (*((_BYTE *)dword_80268C4 + (MEMORY[0x40021008] >> 4)) & 0x1F);
  return sub_80138D0(dword_20000264);
}
// 80268C4: using guessed type int dword_80268C4[4];
// 20000264: using guessed type int dword_20000264;
// 20000290: using guessed type int dword_20000290;

//----- (08013FAC) --------------------------------------------------------
int sub_8013FAC()
{
  return dword_20000290;
}
// 20000290: using guessed type int dword_20000290;

//----- (08013FB8) --------------------------------------------------------
unsigned int sub_8013FB8()
{
  return (unsigned int)sub_8013FAC() >> (*((_BYTE *)&unk_80268D4 + ((MEMORY[0x40021008] >> 8) & 7)) & 0x1F);
}

//----- (08013FDC) --------------------------------------------------------
unsigned int sub_8013FDC()
{
  return (unsigned int)sub_8013FAC() >> (*((_BYTE *)&unk_80268D4 + ((MEMORY[0x40021008] >> 11) & 7)) & 0x1F);
}

//----- (08014000) --------------------------------------------------------
unsigned int sub_8014000()
{
  unsigned int result; // r0
  unsigned int v1; // r1
  unsigned int v2; // r0

  result = 16000000;
  if ( ((MEMORY[0x40021008] >> 2) & 3) != 1 )
  {
    if ( ((MEMORY[0x40021008] >> 2) & 3) == 2 )
    {
      return 8000000;
    }
    else if ( ((MEMORY[0x40021008] >> 2) & 3) == 3 )
    {
      v1 = (MEMORY[0x4002100C] >> 4) + 1;
      if ( (MEMORY[0x4002100C] & 3) == 3 )
        v2 = 0x7A1200 / v1 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
      else
        v2 = 0xF42400 / v1 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
      return v2 / (2 * (((MEMORY[0x4002100C] >> 25) & 3u) + 1));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (08014074) --------------------------------------------------------
int __fastcall sub_8014074(unsigned __int8 *a1)
{
  int v3; // r0
  int v4; // r6
  int v5; // r6
  int v6; // r6
  int v7; // r6
  int v8; // r6
  int v9; // r6
  int v10; // r8
  int v11; // r7
  int v12; // r0
  int v13; // r7
  int v14; // r7
  int v15; // r6
  int v16; // r6
  int v17; // r0
  int v18; // r4
  int v19; // r6
  unsigned __int8 *v20; // r4
  int v21; // t1
  int v22; // r4

  if ( !a1 )
    return 1;
  if ( *a1 << 31 )
  {
    if ( (MEMORY[0x40021008] & 0xC) == 0xC && (MEMORY[0x4002100C] & 3) == 3 || (MEMORY[0x40021008] & 0xC) == 8 )
    {
      if ( (MEMORY[0x40021000] & 0x20000) != 0 && !*((_DWORD *)a1 + 1) )
        return 1;
    }
    else
    {
      v3 = *((_DWORD *)a1 + 1);
      if ( v3 == 0x10000 )
      {
        MEMORY[0x40021000] |= 0x10000u;
      }
      else if ( v3 == 327680 )
      {
        MEMORY[0x40021000] |= 0x40000u;
        MEMORY[0x40021000] |= 0x10000u;
      }
      else
      {
        MEMORY[0x40021000] &= ~0x10000u;
        MEMORY[0x40021000] &= ~0x40000u;
      }
      if ( *((_DWORD *)a1 + 1) )
      {
        v4 = sub_8012948();
        while ( (MEMORY[0x40021000] & 0x20000) == 0 )
        {
          if ( (unsigned int)(sub_8012948() - v4) > 0x64 )
            return 3;
        }
      }
      else
      {
        v5 = sub_8012948();
        while ( (MEMORY[0x40021000] & 0x20000) != 0 )
        {
          if ( (unsigned int)(sub_8012948() - v5) > 0x64 )
            return 3;
        }
      }
    }
  }
  if ( (*a1 & 2) != 0 )
  {
    if ( (MEMORY[0x40021008] & 0xC) == 0xC && (MEMORY[0x4002100C] & 3) == 2 || (MEMORY[0x40021008] & 0xC) == 4 )
    {
      if ( (MEMORY[0x40021000] & 0x400) != 0 && !*((_DWORD *)a1 + 3) )
        return 1;
      MEMORY[0x40021004] = MEMORY[0x40021004] & 0x80FFFFFF | (a1[16] << 24);
      if ( sub_80138D0(dword_20000264) )
        return 1;
    }
    else if ( *((_DWORD *)a1 + 3) )
    {
      MEMORY[0x40021000] |= 0x100u;
      v6 = sub_8012948();
      while ( (MEMORY[0x40021000] & 0x400) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v6) > 2 )
          return 3;
      }
      MEMORY[0x40021004] = MEMORY[0x40021004] & 0x80FFFFFF | (a1[16] << 24);
    }
    else
    {
      MEMORY[0x40021000] &= ~0x100u;
      v7 = sub_8012948();
      while ( (MEMORY[0x40021000] & 0x400) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v7) > 2 )
          return 3;
      }
    }
  }
  if ( (*a1 & 8) != 0 )
  {
    if ( *((_DWORD *)a1 + 5) )
    {
      MEMORY[0x40021094] |= 1u;
      v8 = sub_8012948();
      while ( (MEMORY[0x40021094] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v8) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021094] &= ~1u;
      v9 = sub_8012948();
      while ( (MEMORY[0x40021094] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v9) > 2 )
          return 3;
      }
    }
  }
  if ( (*a1 & 4) != 0 )
  {
    v10 = 0;
    if ( (MEMORY[0x40021058] & 0x10000000) == 0 )
    {
      MEMORY[0x40021058] |= 0x10000000u;
      v10 = 1;
    }
    if ( (MEMORY[0x40007000] & 0x100) == 0 )
    {
      MEMORY[0x40007000] |= 0x100u;
      v11 = sub_8012948();
      while ( (MEMORY[0x40007000] & 0x100) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v11) > 2 )
          return 3;
      }
    }
    v12 = *((_DWORD *)a1 + 2);
    if ( v12 == 1 )
    {
      MEMORY[0x40021090] |= 1u;
    }
    else if ( v12 == 5 )
    {
      MEMORY[0x40021090] |= 4u;
      MEMORY[0x40021090] |= 1u;
    }
    else
    {
      MEMORY[0x40021090] &= ~1u;
      MEMORY[0x40021090] &= ~4u;
    }
    if ( *((_DWORD *)a1 + 2) )
    {
      v13 = sub_8012948();
      while ( (MEMORY[0x40021090] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v13) > 0x1388 )
          return 3;
      }
    }
    else
    {
      v14 = sub_8012948();
      while ( (MEMORY[0x40021090] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v14) > 0x1388 )
          return 3;
      }
    }
    if ( v10 == 1 )
      MEMORY[0x40021058] &= ~0x10000000u;
  }
  if ( (*a1 & 0x20) != 0 )
  {
    if ( *((_DWORD *)a1 + 6) )
    {
      MEMORY[0x40021098] |= 1u;
      v15 = sub_8012948();
      while ( (MEMORY[0x40021098] & 2) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v15) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021098] &= ~1u;
      v16 = sub_8012948();
      while ( (MEMORY[0x40021098] & 2) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v16) > 2 )
          return 3;
      }
    }
  }
  v17 = *((_DWORD *)a1 + 7);
  if ( v17 )
  {
    if ( ((MEMORY[0x40021008] >> 2) & 3) == 3 )
    {
      if ( v17 == 1 )
        return 1;
      if ( (MEMORY[0x4002100C] & 3) != *((_DWORD *)a1 + 8)
        || (MEMORY[0x4002100C] & 0xF0) != 16 * (*((_DWORD *)a1 + 9) - 1)
        || (MEMORY[0x4002100C] & 0x7F00) != *((_DWORD *)a1 + 10) << 8
        || (MEMORY[0x4002100C] & 0xF8000000) != a1[44] << 27
        || (MEMORY[0x4002100C] & 0x600000) != ((*((unsigned __int16 *)a1 + 24) >> 1) - 1) << 21
        || (MEMORY[0x4002100C] & 0x6000000) != ((a1[52] >> 1) - 1) << 25 )
      {
        return 1;
      }
    }
    else if ( v17 == 2 )
    {
      MEMORY[0x40021000] &= ~0x1000000u;
      v19 = sub_8012948();
      while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v19) > 2 )
          return 3;
      }
      v21 = *((_DWORD *)a1 + 8);
      v20 = a1 + 32;
      MEMORY[0x4002100C] = v21
                         | (16 * (*((_DWORD *)v20 + 1) - 1))
                         | (*((_DWORD *)v20 + 2) << 8)
                         | (((*((unsigned __int16 *)v20 + 8) >> 1) - 1) << 21)
                         | (((v20[20] >> 1) - 1) << 25)
                         | (v20[12] << 27)
                         | MEMORY[0x4002100C] & 0x19F800C;
      MEMORY[0x40021000] |= 0x1000000u;
      MEMORY[0x4002100C] |= 0x1000000u;
      v22 = sub_8012948();
      while ( (MEMORY[0x40021000] & 0x2000000) == 0 )
      {
        if ( (unsigned int)(sub_8012948() - v22) > 2 )
          return 3;
      }
    }
    else
    {
      MEMORY[0x40021000] &= ~0x1000000u;
      MEMORY[0x4002100C] &= 0xFFFFFFFC;
      MEMORY[0x4002100C] &= 0xFEEEFFFF;
      v18 = sub_8012948();
      while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
      {
        if ( (unsigned int)(sub_8012948() - v18) > 2 )
          return 3;
      }
    }
  }
  return 0;
}
// 20000264: using guessed type int dword_20000264;

//----- (080144CC) --------------------------------------------------------
int __fastcall sub_80144CC(int a1, int a2, int a3, int a4)
{
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 132) )
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_8015D5C((int *)a1);
  }
  *(_DWORD *)(a1 + 132) = 36;
  **(_DWORD **)a1 &= ~1u;
  if ( sub_801B7E0((_DWORD *)a1) == 1 )
    return 1;
  if ( *(_DWORD *)(a1 + 40) )
    sub_801B110(a1);
  *(_DWORD *)(*(_DWORD *)a1 + 8) |= 0x4000u;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0xFFFF7FFF | a2;
  **(_DWORD **)a1 = **(_DWORD **)a1 & 0xFC00FFFF | (a3 << 21) | (a4 << 16);
  **(_DWORD **)a1 |= 1u;
  return sub_801B1D8(a1);
}

//----- (08014560) --------------------------------------------------------
int __fastcall sub_8014560(int a1, _BYTE *a2, int a3)
{
  unsigned int v4; // r1
  char v5; // r0
  int v6; // r3
  char v7; // r0
  int v8; // r3
  char v9; // r0
  int v10; // r3

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4) & 0xFFFF3F;
  a2[3] = BYTE2(v4);
  a2[1] = BYTE1(v4) & 0x1F;
  a2[2] = v4 & 0x3F;
  *a2 = (unsigned __int16)v4 >> 13;
  if ( !a3 )
  {
    v5 = sub_8018CB8(HIWORD(v4));
    *(_BYTE *)(v6 + 3) = v5;
    v7 = sub_8018CB8(*(unsigned __int8 *)(v6 + 1));
    *(_BYTE *)(v8 + 1) = v7;
    v9 = sub_8018CB8(*(unsigned __int8 *)(v8 + 2));
    *(_BYTE *)(v10 + 2) = v9;
  }
  return 0;
}
// 801458A: variable 'v6' is possibly undefined
// 8014592: variable 'v8' is possibly undefined
// 801459A: variable 'v10' is possibly undefined

//----- (080145A4) --------------------------------------------------------
int __fastcall sub_80145A4(int a1, int a2, int a3)
{
  unsigned int v4; // r1
  char v5; // r0
  _BYTE *v6; // r3
  char v7; // r0
  int v8; // r3
  char v9; // r0
  int v10; // r3

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 16) & 0x7FFF;
  v4 = **(_DWORD **)a1 & 0x7F7F7F;
  *(_BYTE *)a2 = BYTE2(v4) & 0x3F;
  *(_BYTE *)(a2 + 1) = BYTE1(v4) & 0x7F;
  *(_BYTE *)(a2 + 2) = v4 & 0x7F;
  *(_BYTE *)(a2 + 3) = v4 >> 22;
  if ( !a3 )
  {
    v5 = sub_8018CB8(HIWORD(v4) & 0x3F);
    *v6 = v5;
    v7 = sub_8018CB8((unsigned __int8)v6[1]);
    *(_BYTE *)(v8 + 1) = v7;
    v9 = sub_8018CB8(*(unsigned __int8 *)(v8 + 2));
    *(_BYTE *)(v10 + 2) = v9;
  }
  return 0;
}
// 80145DE: variable 'v6' is possibly undefined
// 80145E6: variable 'v8' is possibly undefined
// 80145EE: variable 'v10' is possibly undefined

//----- (080145F8) --------------------------------------------------------
int __fastcall sub_80145F8(int a1)
{
  int result; // r0

  result = 1;
  if ( a1 )
  {
    if ( !*(_BYTE *)(a1 + 37) )
    {
      *(_BYTE *)(a1 + 36) = 0;
      sub_801468C((int *)a1);
    }
    *(_BYTE *)(a1 + 37) = 2;
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
    result = sub_8018CE0((_BYTE *)a1);
    if ( !result )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFB8FFFBF;
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= *(_DWORD *)(a1 + 4) | *(_DWORD *)(a1 + 16) | *(_DWORD *)(a1 + 24);
      *(_DWORD *)(*(_DWORD *)a1 + 16) = *(_DWORD *)(a1 + 12) | (*(unsigned __int16 *)(a1 + 8) << 16);
      result = sub_8018D28((_BYTE *)a1);
      if ( !result )
        *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32)
                                        | *(_DWORD *)(a1 + 28)
                                        | *(_DWORD *)(a1 + 20)
                                        | *(_DWORD *)(*(_DWORD *)a1 + 24) & 0x1FFFFFFF;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
    if ( !result )
      *(_BYTE *)(a1 + 37) = 1;
  }
  return result;
}

//----- (0801468C) --------------------------------------------------------
int __fastcall sub_801468C(int *a1)
{
  int result; // r0
  int v3; // r0
  _DWORD v4[23]; // [sp+4h] [bp-5Ch] BYREF

  sub_8002364(v4, 84);
  result = *a1;
  if ( *a1 == 1073752064 )
  {
    v4[0] = 0x80000;
    v4[20] = 256;
    v3 = sub_8013AD4(v4);
    if ( v3 )
      sub_8005C1C(v3);
    MEMORY[0x40021090] |= 0x8000u;
    MEMORY[0x40021058] |= 0x400u;
    return MEMORY[0x40021058] & 0x400;
  }
  return result;
}
// 8005C1C: using guessed type void __fastcall __noreturn sub_8005C1C(_DWORD);

//----- (080146E0) --------------------------------------------------------
int __fastcall sub_80146E0(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v5; // r5
  int v6; // r3
  int v7; // r3
  int v8; // r0
  int v9; // r2
  unsigned __int8 *v10; // r3

  if ( a1[36] == 1 )
    return 2;
  a1[36] = 1;
  a1[37] = 2;
  if ( !a3 && (a2[1] & 0x10) != 0 )
    a2[1] = (a2[1] & 0xEF) + 10;
  if ( a3 )
  {
    v5 = a2[2] | (a2[3] << 16) | (a2[1] << 8) | (*a2 << 13);
  }
  else
  {
    sub_8018CCA(a2[3]);
    sub_8018CCA(*(unsigned __int8 *)(v6 + 1));
    v8 = sub_8018CCA(*(unsigned __int8 *)(v7 + 2));
    v5 = v9 | v8 | (*v10 << 13);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
  result = sub_8018CE0(a1);
  if ( !result )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 4) = v5 & 0xFFFF3F;
    result = sub_8018D28(a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
  if ( !result )
    a1[37] = 1;
  a1[36] = 0;
  return result;
}
// 8014744: variable 'v6' is possibly undefined
// 801474E: variable 'v7' is possibly undefined
// 8014754: variable 'v9' is possibly undefined
// 8014756: variable 'v10' is possibly undefined

//----- (08014784) --------------------------------------------------------
int __fastcall sub_8014784(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r2

  if ( a1[36] == 1 )
    return 2;
  a1[36] = 1;
  a1[37] = 2;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 202;
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 83;
  result = sub_8018CE0(a1);
  if ( !result )
  {
    if ( a3 )
    {
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x40) == 0 )
        a2[3] = 0;
      v7 = a2[2] | (*a2 << 16) | (a2[1] << 8) | (a2[3] << 22);
    }
    else
    {
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x40) == 0 )
        a2[3] = 0;
      sub_8018CCA(*a2);
      sub_8018CCA(a2[1]);
      v8 = sub_8018CCA(a2[2]);
      v7 = v9 | v8 | (a2[3] << 22);
    }
    **(_DWORD **)a1 = v7 & 0x7F7F7F;
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= ~0x40000u;
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= *((_DWORD *)a2 + 3) | *((_DWORD *)a2 + 4);
    result = sub_8018D28(a1);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 36) = 255;
  if ( !result )
    a1[37] = 1;
  a1[36] = 0;
  return result;
}
// 8014836: variable 'v9' is possibly undefined

//----- (08014850) --------------------------------------------------------
int __fastcall sub_8014850(int a1)
{
  int v2; // r4

  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x20u;
  v2 = sub_8012948();
  while ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x20) == 0 )
  {
    if ( (unsigned int)(sub_8012948() - v2) > 0x3E8 )
      return 3;
  }
  return 0;
}

//----- (08014884) --------------------------------------------------------
int sub_8014884()
{
  int result; // r0

  result = 1073807360;
  MEMORY[0x40010030] &= ~1u;
  return result;
}

//----- (080148A8) --------------------------------------------------------
int __fastcall HAL_SYSTICK_Config(int a1)
{
  unsigned int v1; // r0

  v1 = a1 - 1;
  if ( v1 >= 0x1000000 )
    return 1;
  SYST_RVR = v1;
  _NVIC_SetPriority(-1, 15);
  SYST_CVR = 0;
  SYST_CSR = 7;
  return 0;
}
// 80148A8: invalid function type 'uint32_t __fastcall HAL_SYSTICK_Config(uint32_t TicksNumb)' has been ignored
// E000E010: using guessed type int SYST_CSR;
// E000E014: using guessed type int SYST_RVR;
// E000E018: using guessed type int SYST_CVR;

//----- (080148DC) --------------------------------------------------------
int __fastcall sub_80148DC(int a1, int a2)
{
  int v3; // r0
  _DWORD *v5; // r0
  int v6; // r1

  if ( a2 )
  {
    if ( a2 == 4 )
    {
      v3 = *(unsigned __int8 *)(a1 + 69);
    }
    else if ( a2 == 8 )
    {
      v3 = *(unsigned __int8 *)(a1 + 70);
    }
    else
    {
      v3 = *(unsigned __int8 *)(a1 + 71);
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(a1 + 68);
  }
  if ( v3 != 1 )
    return 1;
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      *(_BYTE *)(a1 + 69) = 2;
    }
    else if ( a2 == 8 )
    {
      *(_BYTE *)(a1 + 70) = 2;
    }
    else
    {
      *(_BYTE *)(a1 + 71) = 2;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 68) = 2;
  }
  sub_801A90E(*(_DWORD *)a1, a2, 4);
  *(_DWORD *)(*(_DWORD *)a1 + 68) |= 0x8000u;
  v5 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v5 == (_DWORD *)0x40000000
    || v5 == (_DWORD *)1073742848
    || v5 == (_DWORD *)1073743872
    || v5 == (_DWORD *)1073744896
    || v5 == (_DWORD *)1073820672
    || v5 == (_DWORD *)1073823744
    || v5 == (_DWORD *)1073827840 )
  {
    v6 = v5[2] & 0x10007;
    if ( v6 != 6 && v6 != 0x10000 )
      *v5 |= 1u;
  }
  else
  {
    *v5 |= 1u;
  }
  return 0;
}

//----- (080149B8) --------------------------------------------------------
int __fastcall sub_80149B8(_BYTE *a1, int a2, int a3)
{
  int v3; // r3
  int v5; // r1

  v3 = 0;
  if ( a1[60] == 1 )
    return 2;
  a1[60] = 1;
  if ( a3 )
  {
    switch ( a3 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFFFF0FF | a2;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFF0FFFF | a2;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xF0FFFFFF | a2;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(*(_DWORD *)a1 + 92) & 0xFFFFFFF0 | a2;
    v5 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1073824768 || v5 == 1073825792 )
      *(_DWORD *)(v5 + 104) |= 1u;
    else
      *(_DWORD *)(v5 + 104) &= ~1u;
  }
  a1[60] = 0;
  return v3;
}

//----- (08014A4A) --------------------------------------------------------
int __fastcall sub_8014A4A(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_8014A98((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A820(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (08014A98) --------------------------------------------------------
int __fastcall sub_8014A98(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073746944 )
  {
    MEMORY[0x40021058] |= 0x20u;
    sub_8013970(55, 5u, 0);
    return sub_8013954(55);
  }
  return result;
}

//----- (08014AD4) --------------------------------------------------------
int __fastcall sub_8014AD4(_BYTE *a1)
{
  _DWORD *v2; // r0
  int v3; // r1

  if ( a1[61] != 1 )
    return 1;
  a1[61] = 2;
  *(_DWORD *)(*(_DWORD *)a1 + 12) |= 1u;
  v2 = *(_DWORD **)a1;
  if ( v2 == (_DWORD *)1073818624
    || v2 == (_DWORD *)0x40000000
    || v2 == (_DWORD *)1073742848
    || v2 == (_DWORD *)1073743872
    || v2 == (_DWORD *)1073744896
    || v2 == (_DWORD *)1073820672
    || v2 == (_DWORD *)1073823744
    || v2 == (_DWORD *)1073827840 )
  {
    v3 = v2[2] & 0x10007;
    if ( v3 != 6 && v3 != 0x10000 )
      *v2 |= 1u;
  }
  else
  {
    *v2 |= 1u;
  }
  return 0;
}

//----- (08014B68) --------------------------------------------------------
unsigned int __fastcall sub_8014B68(unsigned int *a1)
{
  unsigned int result; // r0
  int v2; // r4
  int v3; // r5
  __int16 v4; // r0

  result = *a1;
  if ( result == 1073827840 )
  {
    v2 = (unsigned __int16)sub_80157A0((int)&dword_20001A14, 0);
    result = v2 - (unsigned __int16)dword_20000060;
    v3 = (unsigned __int16)result;
    if ( (unsigned __int16)result >= 0x7D0u )
    {
      dword_2000005C = sub_8012948();
      v4 = word_20000058;
      dword_20001A04[(unsigned __int16)word_20000058] = v3;
      dword_20000060 = v2;
      result = (unsigned __int16)(v4 + 1);
      word_20000058 = result;
      if ( result >= 4 )
      {
        result = 0;
        word_20000058 = 0;
      }
    }
  }
  return result;
}
// 20000058: using guessed type __int16 word_20000058;
// 2000005C: using guessed type int dword_2000005C;
// 20000060: using guessed type int dword_20000060;
// 20001A04: using guessed type _DWORD dword_20001A04[4];
// 20001A14: using guessed type int dword_20001A14;

//----- (08014BB8) --------------------------------------------------------
int __fastcall sub_8014BB8(int a1, int *a2, int a3)
{
  int v5; // r6

  v5 = 0;
  if ( *(_BYTE *)(a1 + 60) == 1 )
    return 2;
  *(_BYTE *)(a1 + 60) = 1;
  if ( a3 )
  {
    switch ( a3 )
    {
      case 4:
        sub_801AD38(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFF3FF;
        *(_DWORD *)(*(_DWORD *)a1 + 24) |= a2[2] << 8;
        break;
      case 8:
        sub_801AD6E(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 28) &= 0xFFFFFFF3;
        *(_DWORD *)(*(_DWORD *)a1 + 28) |= a2[2];
        break;
      case 12:
        sub_801ADA0(*(_DWORD *)a1, *a2, a2[1], a2[3]);
        *(_DWORD *)(*(_DWORD *)a1 + 28) &= 0xFFFFF3FF;
        *(_DWORD *)(*(_DWORD *)a1 + 28) |= a2[2] << 8;
        break;
      default:
        v5 = 1;
        break;
    }
  }
  else
  {
    sub_801ACB8(*(_DWORD *)a1, *(_QWORD *)a2, a2[1], a2[3]);
    *(_DWORD *)(*(_DWORD *)a1 + 24) &= 0xFFFFFFF3;
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= a2[2];
  }
  *(_BYTE *)(a1 + 60) = 0;
  return v5;
}

//----- (08014C78) --------------------------------------------------------
int __fastcall sub_8014C78(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_8014CC8((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A820(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (08014CC8) --------------------------------------------------------
int __fastcall sub_8014CC8(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073827840 )
  {
    MEMORY[0x40021060] |= 0x100000u;
    sub_8013970(80, 3u, 0);
    return sub_8013954(80);
  }
  return result;
}

//----- (08014D04) --------------------------------------------------------
int __fastcall sub_8014D04(unsigned __int8 *a1, int a2)
{
  int v3; // r5
  int v4; // r0
  int v5; // r2
  _DWORD *v7; // r0
  int v8; // r1

  v3 = 0;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v4 = a1[63];
        break;
      case 8:
        v4 = a1[64];
        break;
      case 12:
        v4 = a1[65];
        break;
      case 16:
        v4 = a1[66];
        break;
      default:
        v4 = a1[67];
        break;
    }
  }
  else
  {
    v4 = a1[62];
  }
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      v5 = a1[69];
    }
    else if ( a2 == 8 )
    {
      v5 = a1[70];
    }
    else
    {
      v5 = a1[71];
    }
  }
  else
  {
    v5 = a1[68];
  }
  if ( v4 != 1 || v5 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        a1[63] = 2;
        break;
      case 8:
        a1[64] = 2;
        break;
      case 12:
        a1[65] = 2;
        break;
      case 16:
        a1[66] = 2;
        break;
      default:
        a1[67] = 2;
        break;
    }
  }
  else
  {
    a1[62] = 2;
  }
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      a1[69] = 2;
    }
    else if ( a2 == 8 )
    {
      a1[70] = 2;
    }
    else
    {
      a1[71] = 2;
    }
  }
  else
  {
    a1[68] = 2;
  }
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 4u;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 8u;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 0x10u;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 12) |= 2u;
  }
  if ( !v3 )
  {
    sub_801A8F4(*(_DWORD *)a1, a2, 1);
    v7 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v7 == (_DWORD *)0x40000000
      || v7 == (_DWORD *)1073742848
      || v7 == (_DWORD *)1073743872
      || v7 == (_DWORD *)1073744896
      || v7 == (_DWORD *)1073820672
      || v7 == (_DWORD *)1073823744
      || v7 == (_DWORD *)1073827840 )
    {
      v8 = v7[2] & 0x10007;
      if ( v8 != 6 && v8 != 0x10000 )
        *v7 |= 1u;
    }
    else
    {
      *v7 |= 1u;
    }
  }
  return v3;
}

//----- (08014E8C) --------------------------------------------------------
int __fastcall sub_8014E8C(int a1)
{
  unsigned int v2; // r0
  unsigned int v3; // r0
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  int result; // r0

  v2 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(v2 + 16) & 2) == 0 && (~*(_DWORD *)(v2 + 12) & 2) == 0 )
  {
    *(_DWORD *)(v2 + 16) = -3;
    *(_BYTE *)(a1 + 28) = 1;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 24) << 30 )
    {
      sub_8014B68((unsigned int *)a1);
    }
    else
    {
      sub_8015100(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v3 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 4) == 0 && (~*(_DWORD *)(v3 + 12) & 4) == 0 )
  {
    *(_DWORD *)(v3 + 16) = -5;
    *(_BYTE *)(a1 + 28) = 2;
    if ( (*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x300) != 0 )
    {
      sub_8014B68((unsigned int *)a1);
    }
    else
    {
      sub_8015100(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v4 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 8) == 0 && (~*(_DWORD *)(v4 + 12) & 8) == 0 )
  {
    *(_DWORD *)(v4 + 16) = -9;
    *(_BYTE *)(a1 + 28) = 4;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 28) << 30 )
    {
      sub_8014B68((unsigned int *)a1);
    }
    else
    {
      sub_8015100(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v5 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x10) == 0 && (~*(_DWORD *)(v5 + 12) & 0x10) == 0 )
  {
    *(_DWORD *)(v5 + 16) = -17;
    *(_BYTE *)(a1 + 28) = 8;
    if ( (*(_DWORD *)(*(_DWORD *)a1 + 28) & 0x300) != 0 )
    {
      sub_8014B68((unsigned int *)a1);
    }
    else
    {
      sub_8015100(a1);
      nullsub_23(a1);
    }
    *(_BYTE *)(a1 + 28) = 0;
  }
  v6 = *(_DWORD *)a1;
  if ( !(~*(_DWORD *)(*(_DWORD *)a1 + 16) << 31) && !(~*(_DWORD *)(v6 + 12) << 31) )
  {
    *(_DWORD *)(v6 + 16) = -2;
    sub_801576C((int *)a1);
  }
  v7 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x80) == 0 && (~*(_DWORD *)(v7 + 12) & 0x80) == 0 )
  {
    *(_DWORD *)(v7 + 16) = -129;
    nullsub_17(a1);
  }
  v8 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x100) == 0 && (~*(_DWORD *)(v8 + 12) & 0x80) == 0 )
  {
    *(_DWORD *)(v8 + 16) = -257;
    nullsub_16(a1);
  }
  v9 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x40) == 0 && (~*(_DWORD *)(v9 + 12) & 0x40) == 0 )
  {
    *(_DWORD *)(v9 + 16) = -65;
    nullsub_24(a1);
  }
  v10 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x20) == 0 && (~*(_DWORD *)(v10 + 12) & 0x20) == 0 )
  {
    *(_DWORD *)(v10 + 16) = -33;
    nullsub_18(a1);
  }
  v11 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x100000) == 0 && (~*(_DWORD *)(v11 + 12) & 0x100000) == 0 )
  {
    *(_DWORD *)(v11 + 16) = -1048577;
    nullsub_20(a1);
  }
  v12 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x200000) == 0 && (~*(_DWORD *)(v12 + 12) & 0x200000) == 0 )
  {
    *(_DWORD *)(v12 + 16) = -2097153;
    nullsub_19(a1);
  }
  v13 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x400000) == 0 && (~*(_DWORD *)(v13 + 12) & 0x400000) == 0 )
  {
    *(_DWORD *)(v13 + 16) = -4194305;
    nullsub_21(a1);
  }
  result = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x800000) == 0 && (~*(_DWORD *)(result + 12) & 0x800000) == 0 )
  {
    *(_DWORD *)(result + 16) = -8388609;
    return nullsub_22(a1);
  }
  return result;
}
// 80148D0: using guessed type int __fastcall nullsub_16(_DWORD);
// 80148D2: using guessed type int __fastcall nullsub_17(_DWORD);
// 80148D4: using guessed type int __fastcall nullsub_18(_DWORD);
// 80148D6: using guessed type int __fastcall nullsub_19(_DWORD);
// 80148D8: using guessed type int __fastcall nullsub_20(_DWORD);
// 80148DA: using guessed type int __fastcall nullsub_21(_DWORD);
// 8014A48: using guessed type int __fastcall nullsub_22(_DWORD);
// 8015584: using guessed type int __fastcall nullsub_23(_DWORD);
// 80157CC: using guessed type int __fastcall nullsub_24(_DWORD);

//----- (08015090) --------------------------------------------------------
int __fastcall sub_8015090(_DWORD **a1, _DWORD *a2, int a3)
{
  int v4; // r5

  v4 = 0;
  if ( *((_BYTE *)a1 + 60) == 1 )
    return 2;
  *((_BYTE *)a1 + 60) = 1;
  if ( a3 == 12 )
  {
    sub_801AB20(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 > 12 )
  {
    if ( a3 == 16 )
    {
      sub_801ABC4(*a1, (int)a2);
      goto LABEL_12;
    }
    if ( a3 == 20 )
    {
      sub_801AC3C(*a1, (int)a2);
      goto LABEL_12;
    }
LABEL_11:
    v4 = 1;
    goto LABEL_12;
  }
  if ( !a3 )
  {
    sub_801A928(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 == 4 )
  {
    sub_801A9D8(*a1, a2);
    goto LABEL_12;
  }
  if ( a3 != 8 )
    goto LABEL_11;
  sub_801AA7C(*a1, a2);
LABEL_12:
  *((_BYTE *)a1 + 60) = 0;
  return v4;
}

//----- (08015100) --------------------------------------------------------
int __fastcall sub_8015100(int result)
{
  int v1; // r1

  if ( *(_DWORD *)result == 1073743872 )
  {
    v1 = *(unsigned __int8 *)(result + 28);
    result = dword_20001AF8;
    if ( v1 == 1 )
    {
      *(_DWORD *)(dword_20001AF8 + 12) &= ~2u;
      return off_20000064();
    }
    else if ( v1 == 2 )
    {
      *(_DWORD *)(dword_20001AF8 + 12) &= ~4u;
      return off_20000068();
    }
  }
  return result;
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AF8: using guessed type int dword_20001AF8;

//----- (08015140) --------------------------------------------------------
int __fastcall sub_8015140(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    nullsub_25(a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A820(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}
// 801518E: using guessed type int __fastcall nullsub_25(_DWORD);

//----- (08015190) --------------------------------------------------------
int __fastcall sub_8015190(unsigned __int8 *a1, int a2)
{
  int v3; // r5
  int v4; // r0
  int v6; // r0
  _DWORD *v7; // r0
  int v8; // r1

  v3 = 0;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v4 = a1[63];
        break;
      case 8:
        v4 = a1[64];
        break;
      case 12:
        v4 = a1[65];
        break;
      case 16:
        v4 = a1[66];
        break;
      default:
        v4 = a1[67];
        break;
    }
  }
  else
  {
    v4 = a1[62];
  }
  if ( v4 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        a1[63] = 2;
        break;
      case 8:
        a1[64] = 2;
        break;
      case 12:
        a1[65] = 2;
        break;
      case 16:
        a1[66] = 2;
        break;
      default:
        a1[67] = 2;
        break;
    }
  }
  else
  {
    a1[62] = 2;
  }
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 4u;
        break;
      case 8:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 8u;
        break;
      case 12:
        *(_DWORD *)(*(_DWORD *)a1 + 12) |= 0x10u;
        break;
      default:
        v3 = 1;
        break;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 12) |= 2u;
  }
  if ( !v3 )
  {
    sub_801A8F4(*(_DWORD *)a1, a2, 1);
    v6 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v6 == 1073820672
      || v6 == 1073823744
      || v6 == 1073824768
      || v6 == 1073825792
      || v6 == 1073827840 )
    {
      *(_DWORD *)(v6 + 68) |= 0x8000u;
    }
    v7 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 == 1073818624
      || v7 == (_DWORD *)0x40000000
      || v7 == (_DWORD *)1073742848
      || v7 == (_DWORD *)1073743872
      || v7 == (_DWORD *)1073744896
      || v7 == (_DWORD *)1073820672
      || v7 == (_DWORD *)1073823744
      || v7 == (_DWORD *)1073827840 )
    {
      v8 = v7[2] & 0x10007;
      if ( v8 != 6 && v8 != 0x10000 )
        *v7 |= 1u;
    }
    else
    {
      *v7 |= 1u;
    }
  }
  return v3;
}

//----- (080152FC) --------------------------------------------------------
int __fastcall sub_80152FC(_DWORD **a1, _DWORD *a2, int a3)
{
  int v5; // r6

  v5 = 0;
  if ( *((_BYTE *)a1 + 60) == 1 )
    return 2;
  *((_BYTE *)a1 + 60) = 1;
  if ( a3 == 12 )
  {
    sub_801AB20(*a1, a2);
    (*a1)[7] |= 0x800u;
    (*a1)[7] &= ~0x400u;
    (*a1)[7] |= a2[4] << 8;
    goto LABEL_12;
  }
  if ( a3 > 12 )
  {
    if ( a3 == 16 )
    {
      sub_801ABC4(*a1, (int)a2);
      (*a1)[20] |= 8u;
      (*a1)[20] &= ~4u;
      (*a1)[20] |= a2[4];
      goto LABEL_12;
    }
    if ( a3 == 20 )
    {
      sub_801AC3C(*a1, (int)a2);
      (*a1)[20] |= 0x800u;
      (*a1)[20] &= ~0x400u;
      (*a1)[20] |= a2[4] << 8;
      goto LABEL_12;
    }
LABEL_11:
    v5 = 1;
    goto LABEL_12;
  }
  if ( !a3 )
  {
    sub_801A928(*a1, a2);
    (*a1)[6] |= 8u;
    (*a1)[6] &= ~4u;
    (*a1)[6] |= a2[4];
    goto LABEL_12;
  }
  if ( a3 == 4 )
  {
    sub_801A9D8(*a1, a2);
    (*a1)[6] |= 0x800u;
    (*a1)[6] &= ~0x400u;
    (*a1)[6] |= a2[4] << 8;
    goto LABEL_12;
  }
  if ( a3 != 8 )
    goto LABEL_11;
  sub_801AA7C(*a1, a2);
  (*a1)[7] |= 8u;
  (*a1)[7] &= ~4u;
  (*a1)[7] |= a2[4];
LABEL_12:
  *((_BYTE *)a1 + 60) = 0;
  return v5;
}

//----- (08015432) --------------------------------------------------------
int __fastcall sub_8015432(int a1)
{
  _BYTE *v3; // r4

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 61) )
  {
    *(_BYTE *)(a1 + 60) = 0;
    sub_8015480((int *)a1);
  }
  *(_BYTE *)(a1 + 61) = 2;
  sub_801A820(*(unsigned int **)a1, (unsigned int *)(a1 + 4));
  v3 = (_BYTE *)(a1 + 61);
  v3[11] = 1;
  v3[1] = 1;
  v3[2] = 1;
  v3[3] = 1;
  v3[4] = 1;
  v3[5] = 1;
  v3[6] = 1;
  v3[7] = 1;
  v3[8] = 1;
  v3[9] = 1;
  v3[10] = 1;
  *v3 = 1;
  return 0;
}

//----- (08015480) --------------------------------------------------------
int *__fastcall sub_8015480(int *a1)
{
  int v2; // r1
  int *result; // r0
  int v4; // [sp+8h] [bp-28h] BYREF
  int v5; // [sp+Ch] [bp-24h]
  int v6; // [sp+10h] [bp-20h]
  int v7; // [sp+14h] [bp-1Ch]
  int v8; // [sp+18h] [bp-18h]

  sub_8002364(&v4, 20);
  v2 = *a1;
  result = (int *)1073876992;
  if ( *a1 == 1073818624 )
  {
    MEMORY[0x40021060] |= 0x800u;
    MEMORY[0x4002104C] |= 4u;
    v4 = 0x2000;
    v5 = 2;
    v6 = 2;
    v7 = 2;
    v8 = 4;
    return sub_8012760((int *)0x48000800, (int)&v4);
  }
  else if ( v2 == 1073742848 )
  {
    MEMORY[0x40021058] |= 2u;
    MEMORY[0x4002104C] |= 2u;
    v4 = 128;
    v5 = 2;
    v6 = 0;
    v7 = 1;
    v8 = 10;
    sub_8012760((int *)0x48000400, (int)&v4);
    v4 = 16;
    v5 = 2;
    v6 = 0;
    v7 = 1;
    v8 = 2;
    return sub_8012760((int *)0x48000400, (int)&v4);
  }
  else if ( v2 == 1073823744 )
  {
    MEMORY[0x40021060] |= 0x10000u;
    MEMORY[0x4002104C] |= 1u;
    v4 = 8;
    v5 = 2;
    v6 = 0;
    v7 = 0;
    v8 = 9;
    return sub_8012760((int *)0x48000000, (int)&v4);
  }
  return result;
}

//----- (08015588) --------------------------------------------------------
int __fastcall sub_8015588(int a1, int a2)
{
  int v3; // r0
  int v5; // r0
  _DWORD *v6; // r0
  int v7; // r1

  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        v3 = *(unsigned __int8 *)(a1 + 63);
        break;
      case 8:
        v3 = *(unsigned __int8 *)(a1 + 64);
        break;
      case 12:
        v3 = *(unsigned __int8 *)(a1 + 65);
        break;
      case 16:
        v3 = *(unsigned __int8 *)(a1 + 66);
        break;
      default:
        v3 = *(unsigned __int8 *)(a1 + 67);
        break;
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(a1 + 62);
  }
  if ( v3 != 1 )
    return 1;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_BYTE *)(a1 + 63) = 2;
        break;
      case 8:
        *(_BYTE *)(a1 + 64) = 2;
        break;
      case 12:
        *(_BYTE *)(a1 + 65) = 2;
        break;
      case 16:
        *(_BYTE *)(a1 + 66) = 2;
        break;
      default:
        *(_BYTE *)(a1 + 67) = 2;
        break;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 62) = 2;
  }
  sub_801A8F4(*(_DWORD *)a1, a2, 1);
  v5 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v5 == 1073820672
    || v5 == 1073823744
    || v5 == 1073824768
    || v5 == 1073825792
    || v5 == 1073827840 )
  {
    *(_DWORD *)(v5 + 68) |= 0x8000u;
  }
  v6 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 1073818624
    || v6 == (_DWORD *)0x40000000
    || v6 == (_DWORD *)1073742848
    || v6 == (_DWORD *)1073743872
    || v6 == (_DWORD *)1073744896
    || v6 == (_DWORD *)1073820672
    || v6 == (_DWORD *)1073823744
    || v6 == (_DWORD *)1073827840 )
  {
    v7 = v6[2] & 0x10007;
    if ( v7 != 6 && v7 != 0x10000 )
      *v6 |= 1u;
  }
  else
  {
    *v6 |= 1u;
  }
  return 0;
}

//----- (080156B4) --------------------------------------------------------
int __fastcall sub_80156B4(int a1, int a2)
{
  int v4; // r2
  _DWORD *v5; // r0

  sub_801A8F4(*(_DWORD *)a1, a2, 0);
  v4 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 == 1073818624
     || v4 == 1073820672
     || v4 == 1073823744
     || v4 == 1073824768
     || v4 == 1073825792
     || v4 == 1073827840)
    && (*(_DWORD *)(v4 + 32) & 0x1111) == 0
    && (*(_DWORD *)(v4 + 32) & 0x4444) == 0 )
  {
    *(_DWORD *)(v4 + 68) &= ~0x8000u;
  }
  v5 = *(_DWORD **)a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 32) & 0x1111) == 0 && (v5[8] & 0x4444) == 0 )
    *v5 &= ~1u;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 4:
        *(_BYTE *)(a1 + 63) = 1;
        break;
      case 8:
        *(_BYTE *)(a1 + 64) = 1;
        break;
      case 12:
        *(_BYTE *)(a1 + 65) = 1;
        break;
      case 16:
        *(_BYTE *)(a1 + 66) = 1;
        break;
      default:
        *(_BYTE *)(a1 + 67) = 1;
        break;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 62) = 1;
  }
  return 0;
}

//----- (0801576C) --------------------------------------------------------
int __fastcall sub_801576C(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073746944 )
  {
    sub_801292E(1207963648, 2, 1);
    sub_800322A();
    return sub_801292E(1207963648, 2, 0);
  }
  return result;
}

//----- (080157A0) --------------------------------------------------------
int __fastcall sub_80157A0(int a1, int a2)
{
  int result; // r0

  result = 0;
  switch ( a2 )
  {
    case 0:
      return *(_DWORD *)(*(_DWORD *)a1 + 52);
    case 4:
      return *(_DWORD *)(*(_DWORD *)a1 + 56);
    case 8:
      return *(_DWORD *)(*(_DWORD *)a1 + 60);
    case 12:
      return *(_DWORD *)(*(_DWORD *)a1 + 64);
  }
  return result;
}

//----- (080157CE) --------------------------------------------------------
int __fastcall sub_80157CE(int a1)
{
  int v1; // r0
  int *v2; // r1
  int v3; // r2

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  v1 = a1 + 100;
  *(_BYTE *)(v1 + 28) = 1;
  *(_DWORD *)(v1 + 32) = 36;
  v2 = *(int **)(v1 - 100);
  v3 = *v2;
  *v2 &= ~1u;
  *(_DWORD *)v1 = 0;
  **(_DWORD **)(v1 - 100) = v3 & 0xDFFFFFFF;
  *(_DWORD *)(v1 + 32) = 32;
  *(_BYTE *)(v1 + 28) = 0;
  return 0;
}

//----- (0801580A) --------------------------------------------------------
int __fastcall sub_801580A(int a1)
{
  int v2; // r1
  int v3; // r4
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v2 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v2 & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 100) = 0x20000000;
  **(_DWORD **)a1 = v2 | 0x20000000;
  sub_801B0C8(a1);
  v3 = a1 + 128;
  *(_DWORD *)(v3 + 4) = 32;
  result = 0;
  *(_BYTE *)v3 = 0;
  return result;
}

//----- (08015856) --------------------------------------------------------
int __fastcall sub_8015856(int a1, int a2)
{
  int v3; // r5
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v3 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v3 & 0xFFFFFFFE;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0xF1FFFFFF | a2;
  sub_801B0C8(a1);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(a1 + 132) = 32;
  result = 0;
  *(_BYTE *)(a1 + 128) = 0;
  return result;
}

//----- (080158A2) --------------------------------------------------------
int __fastcall sub_80158A2(int a1, int a2)
{
  int v3; // r5
  int result; // r0

  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 36;
  v3 = **(_DWORD **)a1;
  **(_DWORD **)a1 = v3 & 0xFFFFFFFE;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x1FFFFFFF | a2;
  sub_801B0C8(a1);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(a1 + 132) = 32;
  result = 0;
  *(_BYTE *)(a1 + 128) = 0;
  return result;
}

//----- (080158F4) --------------------------------------------------------
int __fastcall sub_80158F4(int a1)
{
  unsigned int *v2; // r0
  unsigned int v3; // r1
  unsigned int *v4; // r0
  unsigned int v5; // r1
  unsigned int *v6; // r0
  unsigned int v7; // r1
  unsigned int *v8; // r0
  unsigned int *v9; // r0
  unsigned int v10; // r1
  int v11; // r0

  do
  {
    v2 = *(unsigned int **)a1;
    v3 = __ldrex(*(unsigned int **)a1);
  }
  while ( __strex(v3 & 0xFFFFFEDF, v2) );
  do
  {
    v4 = (unsigned int *)(*(_DWORD *)a1 + 8);
    v5 = __ldrex(v4);
  }
  while ( __strex(v5 & 0xEFFFFFFE, v4) );
  if ( *(_DWORD *)(a1 + 108) == 1 )
  {
    do
    {
      v6 = *(unsigned int **)a1;
      v7 = __ldrex(*(unsigned int **)a1);
    }
    while ( __strex(v7 & 0xFFFFFFEF, v6) );
  }
  v8 = *(unsigned int **)a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x40) != 0 )
  {
    do
    {
      v9 = (unsigned int *)(*(_DWORD *)a1 + 8);
      v10 = __ldrex(v9);
    }
    while ( __strex(v10 & 0xFFFFFFBF, v9) );
    v11 = *(_DWORD *)(a1 + 124);
    if ( v11 )
    {
      *(_DWORD *)(v11 + 56) = 134331037;
      if ( sub_8011AC4(*(_DWORD *)(a1 + 124)) )
        (*(void (**)(void))(*(_DWORD *)(a1 + 124) + 56))();
    }
    else
    {
      *(_WORD *)(a1 + 94) = 0;
      *(_DWORD *)(a1 + 88) = 0;
      *(_DWORD *)(*(_DWORD *)a1 + 32) = 15;
      *(_DWORD *)(*(_DWORD *)a1 + 24) |= 8u;
      *(_DWORD *)(a1 + 136) = 32;
      *(_DWORD *)(a1 + 108) = 0;
      nullsub_30(a1);
    }
  }
  else
  {
    *(_WORD *)(a1 + 94) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    v8[8] = 15;
    *(_DWORD *)(a1 + 136) = 32;
    *(_DWORD *)(a1 + 108) = 0;
    nullsub_30(a1);
  }
  return 0;
}
// 80158F2: using guessed type int __fastcall nullsub_30(_DWORD);

//----- (080159B8) --------------------------------------------------------
int __fastcall sub_80159B8(_DWORD *a1)
{
  _DWORD *v2; // r4

  if ( !a1 )
    return 1;
  a1[33] = 36;
  *(_DWORD *)*a1 &= ~1u;
  *(_DWORD *)*a1 = 0;
  *(_DWORD *)(*a1 + 4) = 0;
  *(_DWORD *)(*a1 + 8) = 0;
  nullsub_31(a1);
  v2 = a1 + 27;
  v2[8] = 0;
  v2[6] = 0;
  v2[7] = 0;
  *v2 = 0;
  *((_BYTE *)v2 + 20) = 0;
  return 0;
}
// 8015D58: using guessed type int __fastcall nullsub_31(_DWORD);

//----- (080159FC) --------------------------------------------------------
int __fastcall sub_80159FC(_DWORD *a1)
{
  int *v2; // r3
  int result; // r0
  int v4; // r1
  int v5; // r2
  int (__fastcall *v6)(_DWORD *); // r1
  void (__fastcall *v7)(_DWORD *); // r1
  unsigned int *v8; // r0
  unsigned int v9; // r1
  int v10; // r0
  int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int *v14; // r0
  unsigned int v15; // r1
  unsigned int *v16; // r0
  unsigned int v17; // r1
  unsigned int *v18; // r0
  unsigned int v19; // r1
  _DWORD *v20; // r4
  __int16 v21; // t1
  int v22; // r1
  unsigned int **v23; // r4
  unsigned int *v24; // r0
  unsigned int v25; // r2
  unsigned int *v26; // r0
  unsigned int v27; // r2
  unsigned int *v28; // r0
  unsigned int v29; // r2

  v2 = (int *)*a1;
  result = *(_DWORD *)(*a1 + 28);
  v4 = *v2;
  v5 = v2[2];
  if ( (result & 0x80F) == 0 && (result & 0x20) != 0 && *v2 & 0x20 | v5 & 0x10000000 )
  {
    v6 = (int (__fastcall *)(_DWORD *))a1[28];
    if ( v6 )
      return v6(a1);
  }
  else if ( (result & 0x80F) != 0 && v4 & 0x4000120 | v5 & 0x10000001 )
  {
    if ( result << 31 && (v4 & 0x100) != 0 )
    {
      v2[8] = 1;
      a1[35] |= 1u;
    }
    if ( (result & 2) != 0 && v5 << 31 )
    {
      *(_DWORD *)(*a1 + 32) = 2;
      a1[35] |= 4u;
    }
    if ( (result & 4) != 0 && v5 << 31 )
    {
      *(_DWORD *)(*a1 + 32) = 4;
      a1[35] |= 2u;
    }
    if ( (result & 8) != 0 && v4 & 0x20 | v5 & 0x10000001 )
    {
      *(_DWORD *)(*a1 + 32) = 8;
      a1[35] |= 8u;
    }
    if ( (result & 0x800) != 0 && (v4 & 0x4000000) != 0 )
    {
      *(_DWORD *)(*a1 + 32) = 2048;
      a1[35] |= 0x20u;
    }
    if ( a1[35] )
    {
      if ( (result & 0x20) != 0 )
      {
        if ( v4 & 0x20 | v5 & 0x10000000 )
        {
          v7 = (void (__fastcall *)(_DWORD *))a1[28];
          if ( v7 )
            v7(a1);
        }
      }
      if ( (*(_DWORD *)(*a1 + 8) & 0x40) != 0 || (a1[35] & 0x28) != 0 )
      {
        sub_801B310((int)a1);
        if ( (*(_DWORD *)(*a1 + 8) & 0x40) == 0 )
          return nullsub_32(a1);
        do
        {
          v8 = (unsigned int *)(*a1 + 8);
          v9 = __ldrex(v8);
        }
        while ( __strex(v9 & 0xFFFFFFBF, v8) );
        v10 = a1[31];
        if ( v10 )
        {
          *(_DWORD *)(v10 + 56) = 134330937;
          result = sub_8011AC4(a1[31]);
          if ( result )
            return (*(int (**)(void))(a1[31] + 56))();
        }
        else
        {
          return nullsub_32(a1);
        }
      }
      else
      {
        result = nullsub_32(a1);
        a1[35] = 0;
      }
    }
  }
  else if ( a1[27] == 1 && (result & 0x10) != 0 && (v4 & 0x10) != 0 )
  {
    v2[8] = 16;
    if ( (*(_DWORD *)(*a1 + 8) & 0x40) != 0 )
    {
      v11 = a1[31];
      result = (unsigned __int16)*(_DWORD *)(*(_DWORD *)v11 + 4);
      if ( (unsigned __int16)*(_DWORD *)(*(_DWORD *)v11 + 4) && *((unsigned __int16 *)a1 + 46) > (unsigned int)result )
      {
        *((_WORD *)a1 + 47) = result;
        if ( (**(_DWORD **)v11 & 0x20) == 0 )
        {
          do
          {
            v12 = (unsigned int *)*a1;
            v13 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v13 & 0xFFFFFEFF, v12) );
          do
          {
            v14 = (unsigned int *)(*a1 + 8);
            v15 = __ldrex(v14);
          }
          while ( __strex(v15 & 0xFFFFFFFE, v14) );
          do
          {
            v16 = (unsigned int *)(*a1 + 8);
            v17 = __ldrex(v16);
          }
          while ( __strex(v17 & 0xFFFFFFBF, v16) );
          a1[34] = 32;
          a1[27] = 0;
          do
          {
            v18 = (unsigned int *)*a1;
            v19 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v19 & 0xFFFFFFEF, v18) );
          sub_8011A5C(a1[31]);
        }
        return nullsub_26(a1, (unsigned __int16)(*((_WORD *)a1 + 46) - *((_WORD *)a1 + 47)));
      }
    }
    else
    {
      v21 = *((_WORD *)a1 + 46);
      v20 = a1 + 23;
      v22 = (unsigned __int16)(v21 - *((_WORD *)v20 + 1));
      result = *((unsigned __int16 *)v20 + 1);
      v23 = (unsigned int **)(v20 - 23);
      if ( result && v22 )
      {
        do
        {
          v24 = *v23;
          v25 = __ldrex(*v23);
        }
        while ( __strex(v25 & 0xFFFFFEDF, v24) );
        do
        {
          v26 = *v23 + 2;
          v27 = __ldrex(v26);
        }
        while ( __strex(v27 & 0xEFFFFFFE, v26) );
        v23[34] = (unsigned int *)32;
        v23[27] = 0;
        v23[28] = 0;
        do
        {
          v28 = *v23;
          v29 = __ldrex(*v23);
        }
        while ( __strex(v29 & 0xFFFFFFEF, v28) );
        return nullsub_26(v23, v22);
      }
    }
  }
  else if ( (result & 0x100000) != 0 && (v5 & 0x400000) != 0 )
  {
    v2[8] = 0x100000;
    return nullsub_29(a1, v4);
  }
  else if ( (result & 0x80) != 0 && *v2 & 0x80 | v5 & 0x800000 )
  {
    v6 = (int (__fastcall *)(_DWORD *))a1[29];
    if ( v6 )
      return v6(a1);
  }
  else if ( (result & 0x40) != 0 && (v4 & 0x40) != 0 )
  {
    return sub_801B364((int)a1);
  }
  else if ( (result & 0x800000) != 0 && (v4 & 0x40000000) != 0 )
  {
    return nullsub_28(a1);
  }
  else
  {
    result <<= 7;
    if ( result < 0 && v4 < 0 )
      return nullsub_27(a1);
  }
  return result;
}
// 8015852: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 8015854: using guessed type int __fastcall nullsub_27(_DWORD);
// 80158EE: using guessed type int __fastcall nullsub_28(_DWORD);
// 80158F0: using guessed type int __fastcall nullsub_29(_DWORD, _DWORD);
// 80159F8: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (08015CE8) --------------------------------------------------------
int __fastcall sub_8015CE8(int a1)
{
  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 132) )
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_8015D5C((int *)a1);
  }
  *(_DWORD *)(a1 + 132) = 36;
  **(_DWORD **)a1 &= ~1u;
  if ( sub_801B7E0((_DWORD *)a1) == 1 )
    return 1;
  if ( *(_DWORD *)(a1 + 40) )
    sub_801B110(a1);
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFFFFB7FF;
  *(_DWORD *)(*(_DWORD *)a1 + 8) &= 0xFFFFFFD5;
  **(_DWORD **)a1 |= 1u;
  return sub_801B1D8(a1);
}

//----- (08015D5C) --------------------------------------------------------
int __fastcall sub_8015D5C(int *a1)
{
  int result; // r0
  int v3; // r0
  int v4; // [sp+4h] [bp-24h] BYREF
  int v5; // [sp+8h] [bp-20h]
  int v6; // [sp+Ch] [bp-1Ch]
  int v7; // [sp+10h] [bp-18h]
  int v8; // [sp+14h] [bp-14h]

  sub_8002364(&v4, 20);
  result = *a1;
  if ( *a1 == 1073759232 )
  {
    MEMORY[0x40021058] |= 0x20000u;
    MEMORY[0x4002104C] |= 8u;
    MEMORY[0x40021048] |= 2u;
    MEMORY[0x40021048] |= 4u;
    v4 = 112;
    v5 = 2;
    v6 = 1;
    v7 = 2;
    v8 = 7;
    sub_8012760((int *)0x48000C00, (int)&v4);
    dword_200016C8 = 1073873948;
    dword_200016CC = 27;
    dword_200016D0 = 16;
    dword_200016D4 = 0;
    dword_200016D8 = 128;
    dword_200016DC = 0;
    dword_200016E0 = 0;
    dword_200016E4 = 0;
    dword_200016E8 = 0;
    v3 = sub_8011C08((int)&dword_200016C8);
    if ( v3 )
      sub_8005C1C(v3);
    a1[30] = (int)&dword_200016C8;
    dword_200016F0 = (int)a1;
    sub_8013970(57, 0xBu, 0);
    sub_8013954(57);
    sub_8013970(38, 0xAu, 0);
    return sub_8013954(38);
  }
  else if ( result == 1073774592 )
  {
    MEMORY[0x4002105C] |= 1u;
    MEMORY[0x4002104C] |= 2u;
    v4 = 3072;
    v5 = 2;
    v6 = 1;
    v7 = 0;
    v8 = 8;
    sub_8012760((int *)0x48000400, (int)&v4);
    sub_8013970(91, 0xBu, 0);
    return sub_8013954(91);
  }
  return result;
}
// 8005C1C: using guessed type void __fastcall __noreturn sub_8005C1C(_DWORD);
// 200016C8: using guessed type int dword_200016C8;
// 200016CC: using guessed type int dword_200016CC;
// 200016D0: using guessed type int dword_200016D0;
// 200016D4: using guessed type int dword_200016D4;
// 200016D8: using guessed type int dword_200016D8;
// 200016DC: using guessed type int dword_200016DC;
// 200016E0: using guessed type int dword_200016E0;
// 200016E4: using guessed type int dword_200016E4;
// 200016E8: using guessed type int dword_200016E8;
// 200016F0: using guessed type int dword_200016F0;

//----- (08015E8C) --------------------------------------------------------
int __fastcall sub_8015E8C(int a1, int a2, unsigned int a3)
{
  unsigned int *v4; // r3
  unsigned int v5; // r4

  if ( *(_DWORD *)(a1 + 136) != 32 )
    return 2;
  if ( !a2 || !a3 )
    return 1;
  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 108) = 0;
  if ( *(_DWORD *)a1 != 1073774592 && (*(_DWORD *)(*(_DWORD *)a1 + 4) & 0x800000) != 0 )
  {
    do
    {
      v4 = *(unsigned int **)a1;
      v5 = __ldrex(*(unsigned int **)a1);
    }
    while ( __strex(v5 | 0x4000000, v4) );
  }
  return sub_801BAF0(a1, a2, a3);
}

//----- (08015EE4) --------------------------------------------------------
int __fastcall sub_8015EE4(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073759232 )
  {
    byte_20000030 = 1;
    sub_802368C();
    if ( byte_20000031 == 3 )
    {
      sub_802532C(dword_20000444, (unsigned int)byte_20003164, 0, 0);
      return sub_8015E8C((int)&dword_20001728, (int)byte_20003164, 1u);
    }
    else if ( byte_20000031 == 1 )
    {
      sub_802532C(dword_2000043C, (unsigned int)byte_20003164, 0, 0);
      return sub_8015E8C((int)&dword_20001728, (int)byte_20003164, 1u);
    }
    else if ( byte_20000508 )
    {
      sub_802532C(dword_20000448, (unsigned int)byte_20003164, 0, 0);
      return sub_8015E8C((int)&dword_20001728, (int)byte_20003164, 1u);
    }
    else
    {
      if ( (unsigned int)++dword_20000034 <= 0xFF )
        sub_8015E8C((int)&dword_20001728, (int)&byte_20003164[dword_20000034], 1u);
      else
        dword_20000034 = 0;
      return sub_801A574(2, 80, (int (*)(void))((char *)&loc_8018E1C + 1));
    }
  }
  else if ( result == 1073774592 )
  {
    sub_800D64C((unsigned __int8)byte_20000032);
    return sub_8015E8C((int)&dword_200017B8, (int)&byte_20000032, 1u);
  }
  return result;
}
// 20000030: using guessed type char byte_20000030;
// 20000031: using guessed type char byte_20000031;
// 20000032: using guessed type char byte_20000032;
// 20000034: using guessed type int dword_20000034;
// 2000043C: using guessed type int dword_2000043C;
// 20000444: using guessed type int dword_20000444;
// 20000448: using guessed type int dword_20000448;
// 20000508: using guessed type char byte_20000508;
// 20001728: using guessed type int dword_20001728;
// 200017B8: using guessed type int dword_200017B8;

//----- (08015FD4) --------------------------------------------------------
int __fastcall sub_8015FD4(int a1, int a2, int a3)
{
  int v4; // r4
  int v5; // r0
  int *v6; // r4
  int *v7; // r4
  unsigned int *v8; // r0
  unsigned int v9; // r1

  if ( *(_DWORD *)(a1 + 132) != 32 )
    return 2;
  if ( !a2 || !a3 )
    return 1;
  if ( *(_BYTE *)(a1 + 128) == 1 )
    return 2;
  v4 = a1 + 80;
  *(_BYTE *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 80) = a2;
  *(_WORD *)(a1 + 84) = a3;
  *(_WORD *)(a1 + 86) = a3;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 132) = 33;
  v5 = *(_DWORD *)(a1 + 120);
  v6 = (int *)(v4 - 80);
  if ( v5
    && (*(_DWORD *)(v5 + 44) = (char *)&dword_801BAC4 + 1,
        *(_DWORD *)(v6[30] + 48) = 134331143,
        *(_DWORD *)(v6[30] + 52) = 134330957,
        *(_DWORD *)(v6[30] + 56) = 0,
        sub_8011CC8(v6[30], v6[20], *v6 + 40, a3)) )
  {
    v7 = v6 + 32;
    v7[3] = 16;
    *(_BYTE *)v7 = 0;
    v7[1] = 32;
    return 1;
  }
  else
  {
    *(_DWORD *)(*v6 + 32) = 64;
    *((_BYTE *)v6 + 128) = 0;
    do
    {
      v8 = (unsigned int *)(*v6 + 8);
      v9 = __ldrex(v8);
    }
    while ( __strex(v9 | 0x80, v8) );
    return 0;
  }
}
// 801BAC4: using guessed type int dword_801BAC4;

//----- (0801607C) --------------------------------------------------------
_DWORD *sub_801607C()
{
  _DWORD *result; // r0
  int v1; // r2
  unsigned int v2; // r1
  int v3; // r5
  unsigned int v4; // r12
  unsigned int v5; // r4

  result = (_DWORD *)dword_20001848;
  if ( *(_DWORD *)(dword_20001848 + 524) << 31 )
  {
    v1 = dword_20000040;
    dword_20000050 = dword_20000040;
    v2 = (unsigned int)dword_20000040 >> 1;
    dword_20000054 = (unsigned int)dword_20000040 >> 1;
    *(_DWORD *)(dword_20001848 + 520) = 1;
    result[133] = v1;
    if ( dword_2000004C )
    {
      --dword_2000004C;
      result += 103;
      *result = 0xFFFF;
      result[2] = 0xFFFF;
      result[3] = 0xFFFF;
      result[4] = 0xFFFF;
      result[64] = 0xFFFF;
      result[66] = 0xFFFF;
      result[67] = 0xFFFF;
      result[68] = 0xFFFF;
      result[96] = 0xFFFF;
      result[98] = 0xFFFF;
      result[99] = 0xFFFF;
      result[100] = 0xFFFF;
    }
    else
    {
      v3 = dword_20000044;
      v4 = ((unsigned int)dword_20000040 >> 1) + dword_20000044;
      v5 = ((unsigned int)dword_20000040 >> 1) + 340;
      switch ( byte_2000003D )
      {
        case 1:
          result[103] = 340;
          result[105] = v5;
          result[106] = v2;
          result[107] = v1;
          break;
        case 2:
          result[103] = 340;
          result[105] = v5;
          result[106] = v3;
          result[107] = v4;
          break;
        case 3:
          result[103] = 340;
          result[105] = v5;
          result[106] = v2 - dword_20000048;
          result[107] = v1 - dword_20000048;
          break;
        default:
          result[103] = 0xFFFF;
          result[105] = 0xFFFF;
          result[106] = 0xFFFF;
          result[107] = 0xFFFF;
          break;
      }
      switch ( byte_2000003C )
      {
        case 1:
          result += 167;
          *result = 340;
          result[2] = v5;
          result[3] = v2;
          result[4] = v1;
          result[32] = 340;
          result[34] = v5;
          result[35] = v2;
          result[36] = v1;
          break;
        case 2:
          result += 167;
          *result = 340;
          result[2] = v5;
          result[3] = v3;
          result[4] = v4;
          result[32] = 340;
          result[34] = v5;
          result[35] = v3;
          result[36] = v4;
          break;
        case 3:
          result += 167;
          *result = dword_20000048 + 340;
          result[2] = dword_20000048 + v2 + 340;
          result[3] = v2;
          result[4] = v1;
          result[32] = dword_20000048 + 340;
          result[34] = dword_20000048 + v2 + 340;
          result[35] = v2;
          result[36] = v1;
          break;
        case 0:
          result += 167;
          *result = 0xFFFF;
          result[2] = 0xFFFF;
          result[3] = 0xFFFF;
          result[4] = 0xFFFF;
          result[32] = 0xFFFF;
          result[34] = 0xFFFF;
          result[35] = 0xFFFF;
          result[36] = 0xFFFF;
          break;
      }
    }
  }
  return result;
}
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 20000048: using guessed type int dword_20000048;
// 2000004C: using guessed type int dword_2000004C;
// 20000050: using guessed type int dword_20000050;
// 20000054: using guessed type int dword_20000054;
// 20001848: using guessed type int dword_20001848;

//----- (0801621C) --------------------------------------------------------
_DWORD *__fastcall sub_801621C(_DWORD *result, int a2, _BYTE *a3)
{
  int v3; // r3
  int v4; // r4
  int v5; // r5
  int v6; // r6
  unsigned int v7; // r1
  unsigned int v8; // r1
  unsigned int v9; // r1
  unsigned int v10; // r1
  unsigned int v11; // r1
  unsigned int v12; // r1
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int v15; // r1
  unsigned int v16; // r1

  v3 = *result;
  v4 = *(_DWORD *)(*result + 944);
  v5 = *(_DWORD *)(*result + 948);
  v6 = *(_DWORD *)(*result + 952);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(v3 + 944) = 0;
      *(_DWORD *)(*result + 948) = 0;
      result = (_DWORD *)*result;
      result[238] = 0;
      break;
    case 1:
      v7 = a3[8] & 0x18 | a3[4] & 4 | *a3 & 3 | v4 & 0xFFFFFFC0;
      *(_DWORD *)(v3 + 944) = v7;
      result = (_DWORD *)*result;
      result[236] = a3[16] & 0x20 | v7;
      break;
    case 2:
      v8 = (*((_DWORD *)a3 + 2) << 6) & 0x600
         | (*((_DWORD *)a3 + 1) << 6) & 0x100
         | v4 & 0xFFFFF03F
         | (unsigned __int8)(*a3 << 6);
      *(_DWORD *)(v3 + 944) = v8;
      result = (_DWORD *)*result;
      result[236] = (*((_DWORD *)a3 + 4) << 6) & 0x800 | v8;
      break;
    case 3:
      v9 = (*((_DWORD *)a3 + 2) << 12) & 0x18000
         | (*((_DWORD *)a3 + 1) << 12) & 0x4000
         | (*(_DWORD *)a3 << 12) & 0x3000
         | v4 & 0xFFFC0FFF;
      *(_DWORD *)(v3 + 944) = v9;
      result = (_DWORD *)*result;
      result[236] = (*((_DWORD *)a3 + 4) << 12) & 0x20000 | v9;
      break;
    case 4:
      v10 = (*((unsigned __int16 *)a3 + 4) << 18) & 0x600000
          | (*((unsigned __int16 *)a3 + 2) << 18) & 0x100000
          | (*(unsigned __int16 *)a3 << 18) & 0xC0000
          | v4 & 0xFF03FFFF;
      *(_DWORD *)(v3 + 944) = v10;
      result = (_DWORD *)*result;
      result[236] = (*((unsigned __int16 *)a3 + 8) << 18) & 0x800000 | v10;
      break;
    case 5:
      v11 = ((unsigned __int8)a3[8] << 24) & 0x18000000
          | ((unsigned __int8)a3[4] << 24) & 0x4000000
          | ((unsigned __int8)*a3 << 24) & 0x3000000
          | v4 & 0xC0FFFFFF;
      *(_DWORD *)(v3 + 944) = v11;
      result = (_DWORD *)*result;
      result[236] = ((unsigned __int8)a3[16] << 24) & 0x20000000 | v11;
      break;
    case 6:
      v12 = a3[12] & 0xF | v6 & 0xFFFFFFF0;
      *(_DWORD *)(v3 + 948) = a3[8] & 0x18 | a3[4] & 4 | *a3 & 3 | v5 & 0xFFFFFFE0;
      result = (_DWORD *)*result;
      result[238] = v12;
      break;
    case 7:
      v13 = (*((_DWORD *)a3 + 3) << 6) & 0x3C0 | v6 & 0xFFFFFC3F;
      *(_DWORD *)(v3 + 948) = (*((_DWORD *)a3 + 2) << 6) & 0x600
                            | (*((_DWORD *)a3 + 1) << 6) & 0x100
                            | v5 & 0xFFFFF83F
                            | (unsigned __int8)(*a3 << 6);
      result = (_DWORD *)*result;
      result[238] = v13;
      break;
    case 8:
      v14 = (unsigned __int16)((unsigned __int16)*((_DWORD *)a3 + 3) << 12) | v6 & 0xFFFF0FFF;
      *(_DWORD *)(v3 + 948) = (*((_DWORD *)a3 + 2) << 12) & 0x18000
                            | (*((_DWORD *)a3 + 1) << 12) & 0x4000
                            | (*(_DWORD *)a3 << 12) & 0x3000
                            | v5 & 0xFFFE0FFF;
      result = (_DWORD *)*result;
      result[238] = v14;
      break;
    case 9:
      v15 = (*((unsigned __int16 *)a3 + 6) << 18) & 0x3C0000 | v6 & 0xFFC3FFFF;
      *(_DWORD *)(v3 + 948) = (*((unsigned __int16 *)a3 + 4) << 18) & 0x600000
                            | (*((unsigned __int16 *)a3 + 2) << 18) & 0x100000
                            | (*(unsigned __int16 *)a3 << 18) & 0xC0000
                            | v5 & 0xFF83FFFF;
      result = (_DWORD *)*result;
      result[238] = v15;
      break;
    case 10:
      v16 = ((unsigned __int8)a3[12] << 24) & 0xF000000 | v6 & 0xF0FFFFFF;
      *(_DWORD *)(v3 + 948) = ((unsigned __int8)a3[8] << 24) & 0x18000000
                            | ((unsigned __int8)a3[4] << 24) & 0x4000000
                            | ((unsigned __int8)*a3 << 24) & 0x3000000
                            | v5 & 0xE0FFFFFF;
      result = (_DWORD *)*result;
      result[238] = v16;
      break;
    default:
      return result;
  }
  return result;
}

//----- (080164B0) --------------------------------------------------------
_DWORD *__fastcall sub_80164B0(_DWORD *result, int a2)
{
  switch ( a2 )
  {
    case 0:
      result = (_DWORD *)*result;
      result[225] |= 2u;
      break;
    case 1:
      result = (_DWORD *)*result;
      result[225] |= 4u;
      break;
    case 2:
      result = (_DWORD *)*result;
      result[225] |= 8u;
      break;
    case 3:
      result = (_DWORD *)*result;
      result[225] |= 0x10u;
      break;
    case 4:
      result = (_DWORD *)*result;
      result[225] |= 0x20u;
      break;
    case 5:
      result = (_DWORD *)*result;
      result[225] |= 0x40u;
      break;
    case 6:
      result = (_DWORD *)*result;
      result[225] |= 1u;
      break;
    default:
      return result;
  }
  return result;
}

//----- (08016530) --------------------------------------------------------
int __fastcall sub_8016530(int *a1, _DWORD *a2)
{
  int result; // r0

  *(_DWORD *)*a1 = a2[3] | a2[2] & 0xFFFFFFE7 | *(_DWORD *)*a1 & 0xFFFFFFE0;
  *(_DWORD *)(*a1 + 20) = *a2;
  result = *a1;
  *(_DWORD *)(result + 24) = a2[1];
  return result;
}

//----- (08016556) --------------------------------------------------------
int __fastcall sub_8016556(int *a1, _DWORD *a2)
{
  int v2; // r6
  int v3; // r4
  unsigned int v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r1
  int result; // r0

  v2 = a2[5];
  if ( v2 == 32 || (v3 = a2[6], v3 == 2) )
  {
    v4 = v2 & 0xFFFFFF1F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x20;
  }
  else if ( v3 == 3 )
  {
    v4 = v2 & 0xFFFFFF3F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x40;
  }
  else if ( v3 == 4 )
  {
    v4 = v2 & 0xFFFFFF3F | *(_DWORD *)*a1 & 0xFFFFFF1F | 0x80;
  }
  else
  {
    v4 = v2 & 0xFFFFFF1F | *(_DWORD *)*a1 & 0xFFFFFF1F;
  }
  v5 = a2[13]
     | a2[10] & 0x1FFFFFFF
     | a2[9] & 0x17FFFFFF
     | a2[8] & 0x11FFFFFF
     | a2[7] & 0x11FFFBFF
     | v4 & 0x11FFF3FF
     | (4 * a2[11]) & 0xDFFFFFFF;
  v6 = a2[12] | *(_DWORD *)(*a1 + 928) & 0xFFFEFFFF;
  *(_DWORD *)*a1 = v5;
  result = *a1;
  *(_DWORD *)(result + 928) = v6;
  return result;
}

//----- (080165EA) --------------------------------------------------------
int __fastcall sub_80165EA(int *a1, int a2, int a3, _DWORD *a4)
{
  char v4; // r4
  int v5; // r5
  int v6; // r7
  int v7; // r12
  int v8; // r6
  int v9; // r2
  int v10; // r1
  int result; // r0

  v4 = 0;
  v5 = *a1;
  v6 = (a2 << 7) + 228;
  v7 = *(_DWORD *)(*a1 + v6);
  v8 = *(_DWORD *)(*a1 + (a2 << 7) + 184);
  if ( a3 == 64 )
    goto LABEL_20;
  if ( a3 > 64 )
  {
    if ( a3 == 512 )
      goto LABEL_21;
    if ( a3 > 512 )
    {
      if ( a3 == 1024 )
        goto LABEL_20;
      if ( a3 != 2048 )
        goto LABEL_22;
    }
    else if ( a3 != 128 )
    {
      if ( a3 == 256 )
        goto LABEL_20;
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if ( a3 == 8 )
    goto LABEL_21;
  if ( a3 > 8 )
  {
    if ( a3 == 16 )
      goto LABEL_20;
    if ( a3 != 32 )
      goto LABEL_22;
LABEL_21:
    *(_DWORD *)(v5 + (a2 << 7) + 196) = a4[1];
    *(_DWORD *)(*a1 + (a2 << 7) + 200) = a4[2];
    v4 = 16;
    goto LABEL_22;
  }
  switch ( a3 )
  {
    case 1:
LABEL_20:
      *(_DWORD *)(v5 + (a2 << 7) + 188) = a4[1];
      *(_DWORD *)(*a1 + (a2 << 7) + 192) = a4[2];
      break;
    case 2:
      goto LABEL_21;
    case 4:
      goto LABEL_20;
  }
LABEL_22:
  v9 = a4[4];
  v10 = (a4[6] << v4) | (a4[5] << v4) | (v9 << v4) | (a4[3] << v4) | (*a4 << v4) | v7 & ~(254 << v4);
  if ( v9 == 8 && (v8 & 0x200) == 0 && (v8 & 0x2000000) == 0 )
    v10 |= a4[7] << v4;
  result = *a1;
  *(_DWORD *)(result + v6) = v10;
  return result;
}

//----- (080166C8) --------------------------------------------------------
int __fastcall sub_80166C8(int *a1, int a2, _DWORD *a3)
{
  int result; // r0

  *(_DWORD *)(*a1 + (a2 << 7) + 128) = a3[3] | a3[2] & 0xFFFFFFE7 | *(_DWORD *)(*a1 + (a2 << 7) + 128) & 0xFFFFFFE0;
  *(_DWORD *)(*a1 + (a2 << 7) + 148) = *a3;
  result = *a1;
  *(_DWORD *)(result + (a2 << 7) + 152) = a3[1];
  return result;
}

//----- (0801687C) --------------------------------------------------------
void __fastcall IRQ_71_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4
  int v14; // r5
  int v15; // r6
  int v16; // r7
  int v17; // r8
  int v18; // r11
  int v19; // r12
  int v20; // lr
  int v21; // r0
  int v22; // r3

  v21 = a1 >> 12;
  v22 = a4 | (32 * *(_DWORD *)(a3 + 48));
  *(_DWORD *)(v14 + v15) = v18;
  *(_DWORD *)(*(_DWORD *)v21 + v16) = v20;
  *(_DWORD *)(*(_DWORD *)v21 + v19) = v13;
  *(_DWORD *)(*(_DWORD *)v21 + (a2 << 7) + 212) = v17;
  *(_DWORD *)(*(_DWORD *)v21 + 928) = v22;
  __asm { POP.W           {R4-R11,PC} }
}
// 80168B2: unbalanced stack, ignored a potential tail call
// 8016890: variable 'v18' is possibly undefined
// 8016890: variable 'v14' is possibly undefined
// 8016890: variable 'v15' is possibly undefined
// 8016896: variable 'v20' is possibly undefined
// 8016896: variable 'v16' is possibly undefined
// 801689C: variable 'v13' is possibly undefined
// 801689C: variable 'v19' is possibly undefined
// 80168A8: variable 'v17' is possibly undefined

//----- (080168BC) --------------------------------------------------------
unsigned int __fastcall sub_80168BC(int *a1, int a2, _DWORD *a3)
{
  int v3; // r3
  int v4; // r1
  unsigned int result; // r0

  v3 = *a1;
  v4 = (a2 << 7) + 236;
  result = a3[2]
         | a3[3] & 0xFFFDFFFF
         | a3[1] & 0xFFFCFFFF
         | *(_DWORD *)(*a1 + v4) & 0xFFECFFEF
         | (16 * *a3) & 0xFFECFFFF;
  if ( a3[6] == 1 )
    result = a3[5] & 0xFFFFFFFE | a3[4] & 0xFFFFFFFC | result & 0xFFFFFFF8 | 1;
  *(_DWORD *)(v3 + v4) = result;
  return result;
}

//----- (08016910) --------------------------------------------------------
int sub_8016910()
{
  int result; // r0

  result = 0;
  dword_2000004C = 0;
  return result;
}
// 2000004C: using guessed type int dword_2000004C;

//----- (0801691C) --------------------------------------------------------
int sub_801691C()
{
  int result; // r0

  result = 2000;
  dword_2000004C = 2000;
  return result;
}
// 2000004C: using guessed type int dword_2000004C;

//----- (0801692C) --------------------------------------------------------
int sub_801692C()
{
  int result; // r0

  result = 200;
  dword_2000004C = 200;
  return result;
}
// 2000004C: using guessed type int dword_2000004C;

//----- (08016938) --------------------------------------------------------
int sub_8016938()
{
  int result; // r0

  result = 1;
  byte_2000003C = 1;
  return result;
}
// 2000003C: using guessed type char byte_2000003C;

//----- (08016944) --------------------------------------------------------
int sub_8016944()
{
  int result; // r0

  result = 1;
  byte_2000003D = 1;
  return result;
}
// 2000003D: using guessed type char byte_2000003D;

//----- (08016950) --------------------------------------------------------
int sub_8016950()
{
  int v1; // [sp+4h] [bp-11Ch] BYREF
  int v2; // [sp+8h] [bp-118h]
  int v3; // [sp+Ch] [bp-114h]
  int v4; // [sp+10h] [bp-110h]
  int v5; // [sp+14h] [bp-10Ch]
  int v6; // [sp+18h] [bp-108h]
  int v7; // [sp+1Ch] [bp-104h]
  int v8; // [sp+20h] [bp-100h]
  _DWORD v9[9]; // [sp+24h] [bp-FCh] BYREF
  _DWORD v10[7]; // [sp+48h] [bp-D8h] BYREF
  _DWORD v11[3]; // [sp+64h] [bp-BCh] BYREF
  int v12; // [sp+70h] [bp-B0h] BYREF
  int v13; // [sp+74h] [bp-ACh]
  int v14; // [sp+78h] [bp-A8h]
  int v15; // [sp+7Ch] [bp-A4h]
  int v16; // [sp+80h] [bp-A0h]
  int v17; // [sp+84h] [bp-9Ch]
  int v18; // [sp+88h] [bp-98h]
  int v19; // [sp+8Ch] [bp-94h]
  int v20; // [sp+90h] [bp-90h]
  int v21; // [sp+94h] [bp-8Ch]
  int v22; // [sp+98h] [bp-88h]
  int v23; // [sp+9Ch] [bp-84h]
  int v24; // [sp+A0h] [bp-80h]
  int v25; // [sp+A4h] [bp-7Ch]
  int v26; // [sp+A8h] [bp-78h]
  int v27; // [sp+ACh] [bp-74h]
  int v28; // [sp+B0h] [bp-70h]
  int v29; // [sp+B4h] [bp-6Ch]
  int v30; // [sp+B8h] [bp-68h]
  int v31; // [sp+C0h] [bp-60h]
  int v32; // [sp+C4h] [bp-5Ch]
  int v33; // [sp+C8h] [bp-58h]
  int v34; // [sp+CCh] [bp-54h]
  int v35; // [sp+D0h] [bp-50h] BYREF
  int v36; // [sp+D4h] [bp-4Ch]
  int v37; // [sp+D8h] [bp-48h]
  int v38; // [sp+DCh] [bp-44h]
  int v39; // [sp+E0h] [bp-40h] BYREF
  int v40; // [sp+E4h] [bp-3Ch]
  int v41; // [sp+E8h] [bp-38h]
  int v42; // [sp+F0h] [bp-30h]
  int v43; // [sp+F4h] [bp-2Ch] BYREF
  int v44; // [sp+F8h] [bp-28h]

  v43 = 0;
  v44 = 0;
  sub_8002364(&v39, 20);
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  sub_8002364(&v12, 96);
  memset(v11, 0, sizeof(v11));
  sub_8002364(v10, 28);
  sub_8002364(v9, 36);
  sub_8002364(&v1, 32);
  dword_20001848 = 1073833984;
  dword_2000184C = 0;
  dword_20001850 = 0;
  sub_8012E3C((int)&dword_20001848);
  sub_8012D02(&dword_20001848, 12);
  sub_8012FE0(&dword_20001848, 0xAu);
  v35 = 45334;
  v36 = 0;
  v37 = 2;
  v38 = 8;
  sub_8013020((int)&dword_20001848, 6, &v35);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 1;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0x8000000;
  v23 = 0;
  v24 = 0;
  v25 = 0x20000000;
  v34 = 0;
  sub_801329A((int)&dword_20001848, 6, &v12);
  v41 = 0;
  v42 = 0;
  v40 = 4;
  v39 = 1;
  sub_8012E04((int)&dword_20001848, 2, &v39);
  v40 = 0;
  v39 = 1;
  sub_8012E04((int)&dword_20001848, 4, &v39);
  v11[0] = 1150;
  sub_8013054(&dword_20001848, 6, 1, v11);
  v11[0] = 50;
  sub_8013054(&dword_20001848, 6, 2, v11);
  v43 = 0;
  v44 = 1;
  if ( sub_8012A70(&dword_20001848, 1, &v43) )
    sub_8005C1C();
  if ( sub_8012954(&dword_20001848, 1, 0) )
    sub_8005C1C();
  v37 = 1;
  v38 = 8;
  sub_8013020((int)&dword_20001848, 0, &v35);
  sub_8013020((int)&dword_20001848, 1, &v35);
  v37 = 3;
  v35 = 6800;
  sub_8013020((int)&dword_20001848, 3, &v35);
  v35 = 60000;
  sub_8013020((int)&dword_20001848, 2, &v35);
  sub_8013020((int)&dword_20001848, 4, &v35);
  sub_8013020((int)&dword_20001848, 5, &v35);
  v10[0] = 1;
  v10[3] = 0;
  v10[6] = 0;
  sub_8013330((int)&dword_20001848, 0, v10);
  sub_8013330((int)&dword_20001848, 1, v10);
  v10[0] = 0;
  sub_8013330((int)&dword_20001848, 3, v10);
  sub_8013330((int)&dword_20001848, 2, v10);
  sub_8013330((int)&dword_20001848, 4, v10);
  sub_8013330((int)&dword_20001848, 5, v10);
  v12 = 0;
  v13 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v22 = 0x8000000;
  v33 = 0x40000;
  v25 = 0x20000000;
  v32 = 64;
  sub_801329A((int)&dword_20001848, 0, &v12);
  v32 = 64;
  sub_801329A((int)&dword_20001848, 1, &v12);
  v12 = 1;
  v32 = 0;
  sub_801329A((int)&dword_20001848, 3, &v12);
  v29 = 0;
  v12 = 0;
  v32 = 0x2000000;
  sub_801329A((int)&dword_20001848, 2, &v12);
  v32 = 0x10000000;
  sub_801329A((int)&dword_20001848, 4, &v12);
  v32 = 0x10000000;
  sub_801329A((int)&dword_20001848, 5, &v12);
  v11[0] = 23007;
  sub_8013054(&dword_20001848, 0, 1, v11);
  v11[0] = 22327;
  sub_8013054(&dword_20001848, 0, 2, v11);
  v11[0] = 23007;
  sub_8013054(&dword_20001848, 1, 1, v11);
  v11[0] = 22327;
  sub_8013054(&dword_20001848, 1, 2, v11);
  v11[0] = 50;
  sub_8013054(&dword_20001848, 3, 1, v11);
  v11[0] = 340;
  sub_8013054(&dword_20001848, 2, 1, v11);
  sub_8013054(&dword_20001848, 4, 1, v11);
  sub_8013054(&dword_20001848, 5, 1, v11);
  v11[0] = (unsigned int)dword_20000040 >> 1;
  sub_8013054(&dword_20001848, 2, 2, v11);
  sub_8013054(&dword_20001848, 4, 2, v11);
  sub_8013054(&dword_20001848, 5, 2, v11);
  v11[0] = 1500;
  sub_8013054(&dword_20001848, 2, 4, v11);
  sub_8013054(&dword_20001848, 4, 4, v11);
  sub_8013054(&dword_20001848, 5, 4, v11);
  v11[0] = 4900;
  sub_8013054(&dword_20001848, 2, 8, v11);
  sub_8013054(&dword_20001848, 4, 8, v11);
  sub_8013054(&dword_20001848, 5, 8, v11);
  v9[0] = 3072;
  v9[1] = 85;
  memset(&v9[2], 0, 12);
  v9[5] = 85;
  memset(&v9[6], 0, 12);
  sub_8012D74((int)&dword_20001848, 0, (int)v9);
  sub_8012D74((int)&dword_20001848, 1, (int)v9);
  v1 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v2 = 8;
  v3 = 20971520;
  sub_8013202((int)&dword_20001848, 0, 1, &v1);
  v2 = 0;
  v3 = 20971536;
  sub_8013202((int)&dword_20001848, 0, 2, &v1);
  v2 = 8;
  v3 = 20971520;
  sub_8013202((int)&dword_20001848, 1, 4, &v1);
  v2 = 0;
  v3 = 20971536;
  sub_8013202((int)&dword_20001848, 1, 8, &v1);
  v4 = 4;
  v2 = 8;
  v3 = 32;
  sub_8013202((int)&dword_20001848, 2, 16, &v1);
  v2 = 16;
  v3 = 64;
  sub_8013202((int)&dword_20001848, 2, 32, &v1);
  v2 = 8;
  v3 = 32;
  sub_8013202((int)&dword_20001848, 4, 256, &v1);
  sub_8013202((int)&dword_20001848, 5, 1024, &v1);
  v2 = 16;
  v3 = 64;
  sub_8013202((int)&dword_20001848, 4, 512, &v1);
  sub_8013202((int)&dword_20001848, 5, 2048, &v1);
  sub_8012F1C((int **)&dword_20001848);
  sub_8012CC2((int)&dword_20001848, 1);
  sub_80131D6((int)&dword_20001848, 8323072);
  *(_DWORD *)(dword_20001848 + 524) |= 1u;
  sub_8013970(71, 1u, 0);
  return sub_8013954(71);
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20000040: using guessed type int dword_20000040;
// 20001848: using guessed type int dword_20001848;
// 2000184C: using guessed type int dword_2000184C;
// 20001850: using guessed type int dword_20001850;

//----- (08016DAC) --------------------------------------------------------
int sub_8016DAC()
{
  byte_2000003D = 0;
  byte_2000003C = 0;
  sub_801323A((int)&dword_20001848, 48);
  sub_801323A((int)&dword_20001848, 768);
  return sub_801323A((int)&dword_20001848, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20001848: using guessed type int dword_20001848;

//----- (08016DE0) --------------------------------------------------------
int sub_8016DE0()
{
  byte_2000003D = 0;
  byte_2000003C = 0;
  sub_801326A((int)&dword_20001848, 48);
  sub_801326A((int)&dword_20001848, 768);
  return sub_801326A((int)&dword_20001848, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20001848: using guessed type int dword_20001848;

//----- (08016EB4) --------------------------------------------------------
int sub_8016EB4()
{
  int result; // r0

  result = 2;
  byte_2000003C = 2;
  return result;
}
// 2000003C: using guessed type char byte_2000003C;

//----- (08016EC0) --------------------------------------------------------
int sub_8016EC0()
{
  int result; // r0

  result = 2;
  byte_2000003D = 2;
  return result;
}
// 2000003D: using guessed type char byte_2000003D;

//----- (08016ECC) --------------------------------------------------------
unsigned int __fastcall sub_8016ECC(unsigned int result)
{
  if ( result <= 0x2BC )
    dword_20000048 = result;
  else
    dword_20000048 = 700;
  return result;
}
// 20000048: using guessed type int dword_20000048;

//----- (08016EE4) --------------------------------------------------------
int sub_8016EE4()
{
  int result; // r0

  result = 3;
  byte_2000003D = 3;
  return result;
}
// 2000003D: using guessed type char byte_2000003D;

//----- (08016EF0) --------------------------------------------------------
int sub_8016EF0()
{
  byte_2000003C = 3;
  sub_801323A((int)&dword_20001848, 768);
  return sub_801323A((int)&dword_20001848, 3072);
}
// 2000003C: using guessed type char byte_2000003C;
// 20001848: using guessed type int dword_20001848;

//----- (08016F18) --------------------------------------------------------
int sub_8016F18()
{
  int result; // r0

  result = 0;
  byte_2000003C = 0;
  return result;
}
// 2000003C: using guessed type char byte_2000003C;

//----- (08016F24) --------------------------------------------------------
int sub_8016F24()
{
  sub_801323A((int)&dword_20001848, 3);
  return sub_801323A((int)&dword_20001848, 12);
}
// 20001848: using guessed type int dword_20001848;

//----- (08016F40) --------------------------------------------------------
int sub_8016F40()
{
  return *(_DWORD *)(dword_20001848 + 916) & 1;
}
// 20001848: using guessed type int dword_20001848;

//----- (08016F54) --------------------------------------------------------
int sub_8016F54()
{
  sub_801326A((int)&dword_20001848, 3);
  return sub_801326A((int)&dword_20001848, 12);
}
// 20001848: using guessed type int dword_20001848;

//----- (08016F70) --------------------------------------------------------
int __fastcall I2C_Flush_TXDR(int *a1)
{
  int result; // r0

  if ( (~*(_DWORD *)(*a1 + 24) & 2) == 0 )
    *(_DWORD *)(*a1 + 40) = 0;
  result = *a1;
  if ( ~*(_DWORD *)(result + 24) << 31 )
    *(_DWORD *)(result + 24) |= 1u;
  return result;
}

//----- (08016F94) --------------------------------------------------------
int __fastcall sub_8016F94(int *a1, unsigned int a2, int a3)
{
  int v6; // r5
  int v7; // r0
  int v8; // r6
  int v9; // r0

  v6 = 0;
  v7 = *a1;
  v8 = 0;
  if ( (*(_DWORD *)(v7 + 24) & 0x10) != 0 )
  {
    *(_DWORD *)(v7 + 28) = 16;
    while ( !((*(_DWORD *)(*a1 + 24) >> 5) & 1 | v6) )
    {
      if ( a2 != -1 && (sub_8012948() - a3 > a2 || !a2) )
      {
        if ( (~*(_DWORD *)(*a1 + 24) & 0x8000) == 0
          && (*(_DWORD *)(*a1 + 4) & 0x4000) != 0x4000
          && *((_BYTE *)a1 + 66) != 32 )
        {
          *(_DWORD *)(*a1 + 4) |= 0x4000u;
          a3 = sub_8012948();
        }
        while ( (~*(_DWORD *)(*a1 + 24) & 0x20) != 0 )
        {
          if ( (unsigned int)(sub_8012948() - a3) > 0x19 )
          {
            a1[17] |= 0x20u;
            *((_BYTE *)a1 + 65) = 32;
            *((_BYTE *)a1 + 66) = 0;
            *((_BYTE *)a1 + 64) = 0;
            v6 = 1;
          }
        }
      }
    }
    if ( !v6 )
      *(_DWORD *)(*a1 + 28) = 32;
    v8 = 4;
    v6 = 1;
  }
  v9 = *(_DWORD *)(*a1 + 24);
  if ( (v9 & 0x100) != 0 )
  {
    v8 |= 1u;
    *(_DWORD *)(*a1 + 28) = 256;
    v6 = 1;
  }
  if ( (v9 & 0x400) != 0 )
  {
    v8 |= 8u;
    *(_DWORD *)(*a1 + 28) = 1024;
    v6 = 1;
  }
  if ( (v9 & 0x200) != 0 )
  {
    v8 |= 2u;
    *(_DWORD *)(*a1 + 28) = 512;
    v6 = 1;
  }
  if ( v6 )
  {
    I2C_Flush_TXDR(a1);
    *(_DWORD *)(*a1 + 4) &= 0xFE00E800;
    a1[17] |= v8;
    *((_BYTE *)a1 + 65) = 32;
    *((_BYTE *)a1 + 66) = 0;
    *((_BYTE *)a1 + 64) = 0;
  }
  return v6;
}

//----- (080170A4) --------------------------------------------------------
int __fastcall sub_80170A4(int *a1, __int16 a2, int a3, int a4, unsigned int a5)
{
  int result; // r0

  result = *a1;
  *(_DWORD *)(result + 4) = *(_DWORD *)(result + 4) & ~((a5 >> 21) & 0x400 | 0x3FF63FF)
                          | a2 & 0x3FF
                          | (a3 << 16) & 0x7FFFFFFF
                          | a4 & 0x7FFFFFFF
                          | a5 & 0x7FFFFFFF;
  return result;
}

//----- (0801710C) --------------------------------------------------------
void __fastcall HardFault_handler(__int16 a1)
{
  int v1; // r4
  int v2; // r6
  int v3; // r4

  *(_WORD *)(v2 + 14) = a1;
  v3 = v1 + 64;
  *(_DWORD *)(v3 + 4) |= 0x20u;
  *(_BYTE *)(v3 + 1) = 32;
  *(_BYTE *)(v3 + 2) = 0;
  *(_BYTE *)v3 = 0;
  JUMPOUT(0x801710A);
}
// 8017124: control flows out of bounds to 801710A
// 801710C: variable 'v2' is possibly undefined
// 801710E: variable 'v1' is possibly undefined

//----- (0801712C) --------------------------------------------------------
int __fastcall sub_801712C(int a1, unsigned int a2, int a3)
{
  int v7; // r0

  while ( 1 )
  {
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 4) == 0 )
      return 0;
    if ( sub_8016F94((int *)a1, a2, a3) )
      return 1;
    if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 0x20) == 0 )
      break;
    if ( sub_8012948() - a3 > a2 || !a2 )
    {
      *(_DWORD *)(a1 + 68) |= 0x20u;
      *(_BYTE *)(a1 + 65) = 32;
      *(_BYTE *)(a1 + 64) = 0;
      return 1;
    }
  }
  v7 = *(_DWORD *)a1;
  if ( (~*(_DWORD *)(*(_DWORD *)a1 + 24) & 4) == 0 && *(_WORD *)(a1 + 40) )
    return 0;
  if ( (~*(_DWORD *)(v7 + 24) & 0x10) != 0 )
  {
    *(_DWORD *)(a1 + 68) = 0;
  }
  else
  {
    *(_DWORD *)(v7 + 28) = 16;
    *(_DWORD *)(a1 + 68) = 4;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 28) = 32;
  *(_DWORD *)(*(_DWORD *)a1 + 4) &= 0xFE00E800;
  *(_BYTE *)(a1 + 65) = 32;
  *(_BYTE *)(a1 + 66) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return 1;
}

//----- (080171D4) --------------------------------------------------------
int __fastcall sub_80171D4(int *a1, unsigned int a2, int a3)
{
  int *v7; // r4

  do
  {
    if ( (~*(_DWORD *)(*a1 + 24) & 0x20) == 0 )
      return 0;
    if ( sub_8016F94(a1, a2, a3) )
      return 1;
  }
  while ( sub_8012948() - a3 <= a2 && a2 );
  v7 = a1 + 16;
  v7[1] |= 0x20u;
  *((_BYTE *)v7 + 1) = 32;
  *((_BYTE *)v7 + 2) = 0;
  *(_BYTE *)v7 = 0;
  return 1;
}

//----- (08017220) --------------------------------------------------------
int __fastcall sub_8017220(int *a1, unsigned int a2, int a3)
{
  int *v7; // r4

  do
  {
    if ( (~*(_DWORD *)(*a1 + 24) & 2) == 0 )
      return 0;
    if ( sub_8016F94(a1, a2, a3) )
      return 1;
  }
  while ( a2 == -1 || sub_8012948() - a3 <= a2 && a2 );
  v7 = a1 + 16;
  v7[1] |= 0x20u;
  *((_BYTE *)v7 + 1) = 32;
  *((_BYTE *)v7 + 2) = 0;
  *(_BYTE *)v7 = 0;
  return 1;
}

//----- (08017270) --------------------------------------------------------
int sub_8017270()
{
  int result; // r0

  dword_20002170 = 1073763328;
  dword_20002174 = 809542655;
  dword_20002178 = 0;
  dword_2000217C = 1;
  dword_20002180 = 0;
  dword_20002184 = 0;
  dword_20002188 = 0;
  dword_2000218C = 0;
  dword_20002190 = 0;
  if ( sub_8013424((int)&dword_20002170) )
    sub_8005C1C();
  if ( sub_8013374((int)&dword_20002170, 0) )
    sub_8005C1C();
  result = sub_80133CE((int)&dword_20002170, 0);
  if ( result )
    sub_8005C1C();
  return result;
}
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20002170: using guessed type int dword_20002170;
// 20002174: using guessed type int dword_20002174;
// 20002178: using guessed type int dword_20002178;
// 2000217C: using guessed type int dword_2000217C;
// 20002180: using guessed type int dword_20002180;
// 20002184: using guessed type int dword_20002184;
// 20002188: using guessed type int dword_20002188;
// 2000218C: using guessed type int dword_2000218C;
// 20002190: using guessed type int dword_20002190;

//----- (080172C8) --------------------------------------------------------
int __fastcall sub_80172C8(int result, unsigned int a2)
{
  unsigned int v2; // r3
  int v3; // r2
  int v4; // r5
  unsigned int v5; // r4
  int v6; // r12

  v2 = 1000000000;
  v3 = 0;
  v4 = 0;
  LOBYTE(v5) = 0;
  do
  {
    v6 = v3++;
    *(_BYTE *)(result + v6) = a2 / v2 + 48;
    a2 %= v2;
    v2 /= 0xAu;
    if ( *(_BYTE *)(result + v3 - 1) == 48 && !v4 )
      v3 = 0;
    else
      ++v4;
    v5 = (unsigned __int8)(v5 + 1);
  }
  while ( v5 < 0xA );
  return result;
}

//----- (08017310) --------------------------------------------------------
int sub_8017310()
{
  *(_DWORD *)dword_20001BDC = 43690;
  return 0;
}
// 20001BDC: using guessed type int dword_20001BDC;

//----- (0801731C) --------------------------------------------------------
int __fastcall sub_801731C(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 96) & 0x7C000000;
}

//----- (08017328) --------------------------------------------------------
int __fastcall sub_8017328(int a1)
{
  return (*(_DWORD *)(a1 + 8) >> 3) & 1;
}

//----- (08017330) --------------------------------------------------------
int __fastcall sub_8017330(int a1)
{
  return *(_DWORD *)(a1 + 8) & 1;
}

//----- (08017338) --------------------------------------------------------
int __fastcall sub_8017338(int a1)
{
  return (*(_DWORD *)(a1 + 8) >> 2) & 1;
}

//----- (08017340) --------------------------------------------------------
BOOL __fastcall sub_8017340(int a1)
{
  return (*(_DWORD *)(a1 + 12) & 0xC00) == 0;
}

//----- (08017350) --------------------------------------------------------
int __fastcall sub_8017350(int a1, unsigned int a2, int a3)
{
  int result; // r0

  result = a1 + ((a2 & 0x2000000) >> 23);
  *(_DWORD *)(result + 20) = *(_DWORD *)(result + 20) & ~(7 << ((a2 >> 20) & 0x1F)) | (a3 << ((a2 >> 20) & 0x1F));
  return result;
}

//----- (0801736E) --------------------------------------------------------
int __fastcall sub_801736E(int a1, int a2, int a3)
{
  int result; // r0

  result = a1 + 4 * a2;
  *(_DWORD *)(result + 96) = *(_DWORD *)(result + 96) & 0x7FFFFFFF | a3;
  return result;
}

//----- (08017380) --------------------------------------------------------
int sub_8017380()
{
  int result; // r0

  result = 1073774592;
  if ( (MEMORY[0x4000801C] & 0x20) != 0 )
    return sub_800D64C(MEMORY[0x40008024]);
  if ( (MEMORY[0x4000801C] & 8) != 0 )
  {
    MEMORY[0x40008020] = 8;
  }
  else if ( (MEMORY[0x4000801C] & 2) != 0 )
  {
    MEMORY[0x40008020] = 2;
  }
  else if ( (MEMORY[0x4000801C] & 4) != 0 )
  {
    MEMORY[0x40008020] = 4;
  }
  else if ( (MEMORY[0x4000801C] & 8) != 0 )
  {
    MEMORY[0x40008020] = 8;
  }
  else if ( (MEMORY[0x4000801C] & 0x800) != 0 )
  {
    MEMORY[0x40008020] = 2048;
  }
  return result;
}

//----- (08017398) --------------------------------------------------------
int __fastcall sub_8017398(char a1)
{
  int result; // r0

  byte_200004D2 = a1;
  byte_200004D3 = byte_20005235;
  result = (unsigned __int8)byte_20005236;
  byte_200004D4 = byte_20005236;
  return result;
}
// 200004D2: using guessed type char byte_200004D2;
// 200004D3: using guessed type char byte_200004D3;
// 200004D4: using guessed type char byte_200004D4;
// 20005235: using guessed type char byte_20005235;
// 20005236: using guessed type char byte_20005236;

//----- (080173B0) --------------------------------------------------------
int sub_80173B0()
{
  int result; // r0
  unsigned __int8 v1[144]; // [sp+0h] [bp-90h] BYREF

  byte_200015DC = 0;
  byte_200015EC = 0;
  byte_200015DD = 0;
  byte_200015E2 = 0;
  byte_200015E3 = 0;
  sub_8002364(v1, 128);
  byte_200015E1 = 0;
  word_200111D2 = 12345;
  word_200015F4 = 1024;
  if ( (unsigned __int8)byte_200015EF != 255 )
  {
    sprintf((int)v1, "AT+QICLOSE=%d\r\n", (unsigned __int8)byte_200015EF);
    sub_800E7A4(v1, "OK", 0, 400);
    byte_200015EF = -1;
  }
  result = (unsigned __int8)byte_200015EE;
  if ( (unsigned __int8)byte_200015EE != 255 )
  {
    sub_8023A34(3000);
    sub_8002364(v1, 128);
    sprintf((int)v1, "AT+QICLOSE=%d\r\n", (unsigned __int8)byte_200015EE);
    result = sub_800E7A4(v1, "OK", 0, 400);
    byte_200015EE = -1;
  }
  return result;
}
// 200015DC: using guessed type char byte_200015DC;
// 200015DD: using guessed type char byte_200015DD;
// 200015E1: using guessed type char byte_200015E1;
// 200015E2: using guessed type char byte_200015E2;
// 200015E3: using guessed type char byte_200015E3;
// 200015EC: using guessed type char byte_200015EC;
// 200015EE: using guessed type char byte_200015EE;
// 200015EF: using guessed type char byte_200015EF;
// 200015F4: using guessed type __int16 word_200015F4;
// 200111D2: using guessed type __int16 word_200111D2;

//----- (080174B4) --------------------------------------------------------
unsigned int sub_80174B4()
{
  unsigned int result; // r0

  result = dword_20000470;
  if ( dword_20000470 != dword_20000468 )
  {
    sub_801750C(&dword_200028F8[5 * dword_20000470]);
    result = dword_20000470 + 1;
    dword_20000470 = result;
    if ( result >= 0x32 )
    {
      result = 0;
      dword_20000470 = 0;
    }
  }
  return result;
}
// 801750C: using guessed type int __fastcall sub_801750C(_DWORD);
// 20000468: using guessed type int dword_20000468;
// 20000470: using guessed type int dword_20000470;
// 200028F8: using guessed type _DWORD dword_200028F8[250];

//----- (080174E8) --------------------------------------------------------
_DWORD *sub_80174E8()
{
  int i; // r4
  _DWORD *result; // r0

  for ( i = 0; i < 50; ++i )
  {
    result = &dword_200028F8[5 * i];
    if ( !result[1] )
      break;
    result = (_DWORD *)sub_801750C();
  }
  return result;
}
// 801750C: using guessed type int sub_801750C(void);
// 200028F8: using guessed type _DWORD dword_200028F8[250];

//----- (0801750C) --------------------------------------------------------
#error "8017EFE: call analysis failed (funcsize=522)"

//----- (08017B80) --------------------------------------------------------
#error "80176B4: call analysis failed (funcsize=24)"

//----- (08017BBC) --------------------------------------------------------
void sub_8017BBC()
{
  JUMPOUT(0x80176DA);
}
// 8017BC0: control flows out of bounds to 80176DA

//----- (080183C0) --------------------------------------------------------
int __fastcall sub_80183C0(int result, int a2)
{
  *(_DWORD *)(result + 4) = a2;
  return result;
}

//----- (080183CC) --------------------------------------------------------
float *sub_80183CC()
{
  int i; // r5
  int v1; // r4
  float *result; // r0

  for ( i = 0; i < 100; ++i )
  {
    if ( flt_20002E6C == 0.0 )
      v1 = i;
    else
      v1 = i + dword_2000046C - 1;
    if ( v1 >= 100 )
      v1 -= 100;
    result = (float *)((char *)&unk_20002CE0 + 4 * v1);
    if ( *result == 0.0 )
      break;
    result = (float *)sub_801E93C((int)"%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*result)), *result);
  }
  return result;
}
// 2000046C: using guessed type int dword_2000046C;
// 20002E6C: using guessed type float flt_20002E6C;

//----- (08018434) --------------------------------------------------------
_DWORD *__fastcall sub_8018434(int a1, int a2, int a3, int a4)
{
  int v7; // r0
  int v8; // r4
  int v9; // r1
  _DWORD *result; // r0

  dword_200028F8[5 * dword_20000468 + 1] = a1;
  v7 = sub_8012948();
  v8 = dword_20000468;
  v9 = 5 * dword_20000468;
  dword_200028F8[5 * dword_20000468] = v7;
  result = &dword_200028F8[v9];
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  dword_20000468 = v8 + 1;
  if ( (unsigned int)(v8 + 1) >= 0x32 )
  {
    result = 0;
    dword_20000468 = 0;
  }
  return result;
}
// 20000468: using guessed type int dword_20000468;
// 200028F8: using guessed type _DWORD dword_200028F8[250];

//----- (08018484) --------------------------------------------------------
int sub_8018484()
{
  dword_200017B8 = 1073774592;
  dword_200017BC = 115200;
  dword_200017C0 = 0;
  dword_200017C4 = 0;
  dword_200017C8 = 0;
  dword_200017D0 = 0;
  dword_200017CC = 12;
  dword_200017D4 = 0;
  sub_8015CE8((int)&dword_200017B8);
  sub_80158A2((int)&dword_200017B8, 0);
  sub_8015856((int)&dword_200017B8, 0);
  sub_801580A((int)&dword_200017B8);
  return sub_8015E8C((int)&dword_200017B8, (int)&byte_20000032, 1u);
}
// 20000032: using guessed type char byte_20000032;
// 200017B8: using guessed type int dword_200017B8;
// 200017BC: using guessed type int dword_200017BC;
// 200017C0: using guessed type int dword_200017C0;
// 200017C4: using guessed type int dword_200017C4;
// 200017C8: using guessed type int dword_200017C8;
// 200017CC: using guessed type int dword_200017CC;
// 200017D0: using guessed type int dword_200017D0;
// 200017D4: using guessed type int dword_200017D4;

//----- (080184DA) --------------------------------------------------------
unsigned int __fastcall sub_80184DA(int a1, unsigned int a2)
{
  unsigned int result; // r0
  unsigned int i; // r3
  unsigned int v5; // r2

  result = 0xFFFF;
  for ( i = 0; i < a2; i = (unsigned __int16)(i + 1) )
  {
    result ^= *(unsigned __int8 *)(a1 + i);
    LOBYTE(v5) = 0;
    do
    {
      if ( result << 31 )
        result = (result >> 1) ^ 0xA001;
      else
        result >>= 1;
      v5 = (unsigned __int8)(v5 + 1);
    }
    while ( v5 < 8 );
  }
  return result;
}

//----- (08018510) --------------------------------------------------------
int sub_8018510()
{
  unsigned int v0; // r0
  int v1; // r1
  int v2; // r2

  if ( sub_8025570(dword_2000044C, (unsigned int)&dword_2000052C, 10000) == 1 )
  {
    if ( !dword_2000052C )
      dword_2000052C = 256;
    if ( (unsigned int)(dword_2000052C - 4) <= 0xFC )
    {
      v0 = sub_80184DA((int)byte_20003164, (unsigned __int16)(dword_2000052C - 2));
      word_20000524 = v0;
      v1 = dword_2000052C;
      v2 = (unsigned __int8)byte_20003164[v1 - 2] | ((unsigned __int8)byte_20003164[v1 - 1] << 8);
      word_20000526 = (unsigned __int8)byte_20003164[v1 - 2] | ((unsigned __int8)byte_20003164[v1 - 1] << 8);
      if ( v0 == v2 )
      {
        if ( byte_20000512 == byte_20003164[0] )
        {
          byte_20003064[0] = byte_20000512;
          byte_20003065 = byte_20003165;
          switch ( byte_20003165 )
          {
            case 3:
              byte_20000520 = sub_80191E8(byte_20003166, dword_2000052C);
              break;
            case 6:
              byte_20000520 = sub_80192D0(byte_20003166, dword_2000052C);
              break;
            case 16:
              byte_20000520 = sub_8019364(byte_20003166, dword_2000052C, 16, (int)byte_20003164);
              break;
            default:
              byte_20000520 = 1;
              break;
          }
          if ( byte_20000520 )
          {
            byte_20003065 += 0x80;
            byte_20003066 = byte_20000520;
            word_20000524 = sub_80184DA((int)byte_20003064, 3u);
            word_20003067 = word_20000524;
            sub_801D5E8((int)byte_20003064, 5u);
          }
        }
        else if ( !byte_20003164[0] )
        {
          if ( byte_20003165 == 6 )
          {
            byte_20000520 = sub_8019334(byte_20003166, dword_2000052C);
          }
          else if ( byte_20003165 == 16 )
          {
            byte_20000520 = sub_801943C((int)byte_20003166, dword_2000052C, 16, (int)byte_20003164);
          }
        }
      }
    }
  }
  sub_8002364(byte_20003164, 256);
  return sub_801F468();
}
// 2000044C: using guessed type int dword_2000044C;
// 20000512: using guessed type char byte_20000512;
// 20000520: using guessed type char byte_20000520;
// 20000524: using guessed type __int16 word_20000524;
// 20000526: using guessed type __int16 word_20000526;
// 2000052C: using guessed type int dword_2000052C;
// 20003065: using guessed type char byte_20003065;
// 20003066: using guessed type char byte_20003066;
// 20003067: using guessed type __int16 word_20003067;
// 20003165: using guessed type char byte_20003165;
// 20003166: using guessed type unsigned __int8 byte_20003166[254];

//----- (0801861C) --------------------------------------------------------
int sub_801861C()
{
  sub_80158F4((int)&dword_20001728);
  return sub_802532C(dword_2000044C, (unsigned int)&dword_20000034, 0, 0);
}
// 20000034: using guessed type int dword_20000034;
// 2000044C: using guessed type int dword_2000044C;
// 20001728: using guessed type int dword_20001728;

//----- (08018648) --------------------------------------------------------
BOOL __fastcall sub_8018648(unsigned int a1)
{
  return (a1 >= 0x14 || (int)flt_2000244C > 1) && a1 >= 0xA;
}
// 2000244C: using guessed type float flt_2000244C;

//----- (08018674) --------------------------------------------------------
char *__fastcall sub_8018674(char *result)
{
  __int64 v1; // r4
  unsigned int v2; // r3
  int v3; // r2

  LODWORD(v1) = result;
  if ( result )
  {
    HIDWORD(v1) = (unsigned __int16)((unsigned __int8)result[2] + ((unsigned __int8)result[1] << 8));
    result = (char *)sub_8004AC0(result, HIDWORD(v1));
    if ( result )
    {
      result = byte_200037D4;
      byte_200037D7 = 1;
      word_200037DF = 0;
      v3 = *(unsigned __int8 *)(v1 + 3);
      if ( v3 == 80 )
      {
        return sub_801D01C((_BYTE *)v1, SHIDWORD(v1), 80, v2);
      }
      else if ( *(unsigned __int8 *)(v1 + 3) > 0x50u )
      {
        if ( v3 == 81 )
        {
          return sub_801D0C8((_BYTE *)v1, SHIDWORD(v1), 81, v2);
        }
        else if ( v3 == 82 )
        {
          return sub_801CF0C((_BYTE *)v1);
        }
      }
      else if ( v3 == 35 )
      {
        return sub_801D094((_BYTE *)v1, SHIDWORD(v1), 35, v2);
      }
      else if ( v3 == 58 )
      {
        return (char *)sub_801CFA0(v1, 58, v2);
      }
    }
  }
  return result;
}
// 80186B6: variable 'v2' is possibly undefined
// 200037D7: using guessed type char byte_200037D7;
// 200037DF: using guessed type __int16 word_200037DF;

//----- (080186F8) --------------------------------------------------------
int *__fastcall sub_80186F8(int *result, int a2, unsigned int a3, int a4)
{
  unsigned int i; // r4

  if ( result && a2 )
  {
    for ( i = 0; i < a3; ++i )
      *result += *(unsigned __int8 *)(a2 + i);
    if ( a4 )
      *result = ~*result;
  }
  return result;
}

//----- (08018720) --------------------------------------------------------
int __fastcall sub_8018720(_WORD *a1, unsigned int a2)
{
  if ( !*a1 )
    *a1 = word_20000028;
  if ( (unsigned __int16)(word_20000028 - *a1) < a2 )
    return 0;
  *a1 = word_20000028;
  return 1;
}
// 20000028: using guessed type __int16 word_20000028;

//----- (0801874C) --------------------------------------------------------
int __fastcall sub_801874C(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( word_2000008A[0] <= result && word_20000170 >= result )
  {
    v1 = 58;
    v2 = 58;
    v3 = 0;
    while ( 1 )
    {
      v2 /= 2;
      if ( !v2 )
        break;
      if ( word_2000008A[v1] >= result )
        v1 -= v2;
      else
        v1 += v2;
      if ( ++v3 >= 116 )
        return result;
    }
    return word_2000008A[v1 + 1] - word_2000008A[v1];
  }
  return result;
}
// 2000008A: using guessed type __int16 word_2000008A[115];
// 20000170: using guessed type __int16 word_20000170;

//----- (080187D8) --------------------------------------------------------
int __fastcall sub_80187D8(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( word_20000172[0] <= result && word_20000258 >= result )
  {
    v1 = 58;
    v2 = 58;
    v3 = 0;
    while ( 1 )
    {
      v2 /= 2;
      if ( !v2 )
        break;
      if ( word_20000172[v1] >= result )
        v1 -= v2;
      else
        v1 += v2;
      if ( ++v3 >= 116 )
        return result;
    }
    return word_20000172[v1 + 1] - word_20000172[v1];
  }
  return result;
}
// 20000172: using guessed type __int16 word_20000172[115];
// 20000258: using guessed type __int16 word_20000258;

//----- (08018864) --------------------------------------------------------
_BYTE *__fastcall sub_8018864(_BYTE *result, unsigned int a2, unsigned int a3)
{
  unsigned __int8 v3; // r7
  int v6; // r4
  unsigned __int8 v7[5]; // [sp+4h] [bp-114h] BYREF
  _BYTE v8[3]; // [sp+9h] [bp-10Fh] BYREF

  v3 = (unsigned __int8)result;
  if ( a2 )
  {
    sub_8002364(v7, 256);
    v6 = (unsigned __int16)(a3 + 6);
    v7[0] = 115;
    v7[1] = (unsigned __int16)(a3 + 6) >> 8;
    v7[2] = a3 + 6;
    v7[3] = v3;
    v7[4] = 0;
    qmemcpy((unsigned int)v8, a2, a3);
    v7[v6 - 1] = sub_80104CC((int)v7, (unsigned __int8)(a3 + 5));
    return sub_8007788(v7, v6);
  }
  return result;
}

//----- (080188C4) --------------------------------------------------------
int __fastcall sub_80188C4(int result, unsigned int a2, unsigned int a3)
{
  int v3; // r7
  int v6; // r4
  int v7; // r6
  _BYTE v8[156]; // [sp+4h] [bp-9Ch] BYREF

  v3 = result;
  if ( a2 )
  {
    sub_8002364(v8, 128);
    v6 = 6;
    if ( v3 == 3 )
    {
      v6 = 8;
      v8[5] = a3;
    }
    v8[0] = 115;
    v7 = a3 + v6;
    v8[1] = a3 + v6;
    v8[2] = 14;
    v8[3] = -1;
    v8[4] = v3;
    if ( a3 )
      qmemcpy((unsigned int)&v8[v6 - 1], a2, a3);
    v8[v6 - 1 + a3] = sub_80104CC((int)v8, (unsigned __int8)(v7 - 1));
    byte_200015B3 = 0;
    sub_8002364(byte_20011071, 64);
    sub_80250A8(dword_20000444, 0);
    sub_801D644((int)v8, v7);
    if ( sub_801CE9C(v3) )
    {
      if ( v3 != 2 )
        ++byte_200015B1;
    }
    else
    {
      byte_200015B1 = 6;
    }
    return sub_8023A34(20);
  }
  return result;
}
// 20000444: using guessed type int dword_20000444;
// 200015B1: using guessed type char byte_200015B1;
// 200015B3: using guessed type char byte_200015B3;
// 20011071: using guessed type unsigned __int8 byte_20011071[67];

//----- (0801897C) --------------------------------------------------------
int __fastcall sub_801897C(int result, int a2)
{
  int v2; // r9
  __int64 v4; // r4
  unsigned int i; // r2
  int v6; // r4
  int v7; // r0

  v2 = result;
  if ( result )
  {
    WORD2(v4) = 0;
    LOWORD(v4) = 0;
    sub_8002364(&dword_200111F4, 42);
    dword_200111F4 = dword_20003A0B;
    word_200111F8 = dword_20003A0F;
    byte_200111FA = BYTE2(dword_20003A0F);
    qmemcpy((unsigned int)&unk_200111FB, (unsigned int)&unk_20004152, 0xDu);
    if ( byte_20002FD1 == 3 )
    {
      strcpy((char *)&dword_20011208, "HME-4");
    }
    else if ( byte_20002FD1 == 4 )
    {
      strcpy((char *)&dword_20011208, "HME-3");
    }
    for ( i = 0; i < 3; ++i )
    {
      HIDWORD(v4) = (unsigned __int16)(byte_20011220[i + 8] + WORD2(v4));
      LODWORD(v4) = (unsigned __int16)(*((unsigned __int8 *)&dword_20004361 + i) + (_WORD)v4);
    }
    if ( (unsigned __int8)dword_20004361 == 48
      && BYTE2(dword_20004361) == 48
      && (unsigned __int8)dword_20004365 == 48
      && HIBYTE(dword_20004365) == 48 )
    {
      LODWORD(v4) = 0;
    }
    if ( v4 )
    {
      if ( (_DWORD)v4 )
      {
        dword_2001120E = dword_20004361;
        dword_20011212 = dword_20004365;
        dword_20011216 = dword_20004369;
      }
      else
      {
        qmemcpy((unsigned int)&dword_2001120E, (unsigned int)&byte_20011220[8], 0xDu);
      }
    }
    else
    {
      sub_8002356(&dword_2001120E, 12, 48);
    }
    if ( byte_200004AC )
    {
      switch ( byte_200004AC )
      {
        case 1:
          byte_2001121B = 65;
          break;
        case 2:
          byte_2001121B = 66;
          break;
        case 3:
          byte_2001121B = 67;
          break;
        case 4:
          byte_2001121B = 68;
          break;
        default:
          byte_2001121B = 48;
          break;
      }
    }
    else
    {
      byte_2001121B = 48;
    }
    if ( !byte_20002F60 || byte_20002F60 == 5 )
      word_2001121C = (int)*(float *)&dword_20002458;
    else
      word_2001121C = 0;
    v6 = (unsigned __int16)snprintf(
                             v2,
                             a2,
                             (const char *)dword_8018B58,
                             a2,
                             &dword_200111F4,
                             &unk_200111FB,
                             &dword_20011208,
                             &dword_2001120E,
                             (unsigned __int8)byte_2001121B,
                             word_2001121C);
    snprintf(
      v2,
      a2,
      (const char *)dword_8018B58,
      v6 + 2,
      &dword_200111F4,
      &unk_200111FB,
      &dword_20011208,
      &dword_2001120E,
      (unsigned __int8)byte_2001121B,
      word_2001121C);
    v7 = sub_80104CC(v2, (unsigned __int8)v6);
    return snprintf(
             v2,
             a2,
             (const char *)dword_8018B74,
             v6 + 2,
             &dword_200111F4,
             &unk_200111FB,
             &dword_20011208,
             &dword_2001120E,
             (unsigned __int8)byte_2001121B,
             word_2001121C,
             v7);
  }
  return result;
}
// 8018B58: using guessed type int dword_8018B58[7];
// 8018B74: using guessed type int dword_8018B74[8];
// 200004AC: using guessed type char byte_200004AC;
// 20002458: using guessed type int dword_20002458;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD1: using guessed type char byte_20002FD1;
// 20003A0B: using guessed type int dword_20003A0B;
// 20003A0F: using guessed type int dword_20003A0F;
// 20004361: using guessed type int dword_20004361;
// 20004365: using guessed type int dword_20004365;
// 20004369: using guessed type int dword_20004369;
// 200111F4: using guessed type int dword_200111F4;
// 200111F8: using guessed type __int16 word_200111F8;
// 200111FA: using guessed type char byte_200111FA;
// 20011208: using guessed type int dword_20011208;
// 2001120E: using guessed type int dword_2001120E;
// 20011212: using guessed type int dword_20011212;
// 20011216: using guessed type int dword_20011216;
// 2001121B: using guessed type char byte_2001121B;
// 2001121C: using guessed type __int16 word_2001121C;
// 20011220: using guessed type unsigned __int8 byte_20011220[44];

//----- (08018B94) --------------------------------------------------------
BOOL __fastcall sub_8018B94(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  if ( !a1 )
    return 0;
  sub_8002364(byte_20011328, 1024);
  word_200015F6 = 0;
  sub_80250A8(dword_20000440, 0);
  if ( !sub_8004200(a1) )
    return 0;
  sub_8023A34(a3);
  sub_801043C();
  sub_801ADD8(
    (int)"%s %d g_shelly_queue_recv:%s\r\n",
    "v=%d,b_rci=%d,b_rdi=%d,b_soc=%d,b_soh=%d,b_cap=%d,b_vol=%d,b_cur=%d,b_tem=%d,b_chf=%d,b_slf=%d,b_cpc=%d,b_err=%d,b_war=%d,b_ret=%d,b_ent=%d,b_mot=%d,b_tp1=%d,b_tp2=%d,b_tp3=%d,b_tp4=%d,b_vo1=%d,b_vo2=%d,b_vo3=%d,b_vo4=%d,b_vo5=%d,b_vo6=%d,b_vo7=%d,b_vo8=%d,b_vo9=%d,b_vo10=%d,b_vo11=%d,b_vo12=%d,b_vo13=%d,b_vo14=%d,b_vo15=%d,b_vo16=%d",
    1348,
    byte_20011328);
  return strstr(byte_20011328, a2) != 0;
}
// 20000440: using guessed type int dword_20000440;
// 200015F6: using guessed type __int16 word_200015F6;
// 20011328: using guessed type _BYTE byte_20011328[936];

//----- (08018C24) --------------------------------------------------------
char *__fastcall sub_8018C24(unsigned int a1, int a2, int a3)
{
  char *result; // r0

  if ( a1 >= 3 )
    return (char *)sub_801E93C((int)"err_num\r\n");
  if ( a2 )
    dword_200021BC[a1] = a2;
  else
    dword_200021BC[a1] = 1000000;
  result = (char *)(a3 - 51);
  if ( (unsigned int)(a3 - 51) < 0x4DED )
  {
    result = &byte_20000294;
    dword_200002A0 = a3;
  }
  return result;
}
// 20000294: using guessed type char byte_20000294;
// 200002A0: using guessed type int dword_200002A0;
// 200021BC: using guessed type int dword_200021BC[];

//----- (08018C68) --------------------------------------------------------
unsigned int sub_8018C68()
{
  unsigned int v0; // r0
  unsigned int v1; // r0

  v0 = (MEMORY[0x4002100C] >> 4) + 1;
  if ( (MEMORY[0x4002100C] & 3) == 3 )
    v1 = 0x7A1200 / v0 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
  else
    v1 = 0xF42400 / v0 * ((MEMORY[0x4002100C] >> 8) & 0x7F);
  return v1 / (2 * (((MEMORY[0x4002100C] >> 25) & 3u) + 1));
}

//----- (08018CB8) --------------------------------------------------------
int __fastcall sub_8018CB8(unsigned int a1)
{
  return (unsigned __int8)((a1 & 0xF) + 10 * (a1 >> 4));
}

//----- (08018CCA) --------------------------------------------------------
int __fastcall sub_8018CCA(unsigned int a1)
{
  int v1; // r1

  v1 = 0;
  while ( a1 >= 0xA )
  {
    ++v1;
    a1 = (unsigned __int8)(a1 - 10);
  }
  return MemManage_fault_handler();
}
// 8018CD8: using guessed type int MemManage_fault_handler(void);

//----- (08018CD8) --------------------------------------------------------
int __fastcall MemManage_fault_handler(int a1, char a2)
{
  return a1 | (unsigned __int8)(16 * a2);
}

//----- (08018CE0) --------------------------------------------------------
int __fastcall sub_8018CE0(_BYTE *a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r6

  v2 = 0;
  v3 = *(_DWORD *)a1;
  if ( (*(_DWORD *)(v3 + 12) & 0x40) == 0 )
  {
    *(_DWORD *)(v3 + 12) |= 0x80u;
    v4 = sub_8012948();
    while ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x40) == 0 && v2 != 3 )
    {
      if ( (unsigned int)(sub_8012948() - v4) > 0x3E8 )
      {
        v2 = 3;
        a1[37] = 3;
      }
    }
  }
  return v2;
}

//----- (08018D28) --------------------------------------------------------
int __fastcall sub_8018D28(_BYTE *a1)
{
  int v2; // r5
  int v3; // r0

  v2 = 0;
  *(_DWORD *)(*(_DWORD *)a1 + 12) &= ~0x80u;
  v3 = *(_DWORD *)a1;
  if ( (*(_DWORD *)(v3 + 24) & 0x20) != 0 )
  {
    *(_DWORD *)(v3 + 24) &= ~0x20u;
    if ( sub_8014850((int)a1) )
    {
      a1[37] = 3;
      v2 = 3;
    }
    *(_DWORD *)(*(_DWORD *)a1 + 24) |= 0x20u;
  }
  else if ( sub_8014850((int)a1) )
  {
    a1[37] = 3;
    return 3;
  }
  return v2;
}

//----- (08018D78) --------------------------------------------------------
int __fastcall sub_8018D78(_BYTE *a1, int *a2, int a3, int a4)
{
  int v7; // r6
  unsigned int i; // r4
  _DWORD v10[10]; // [sp+0h] [bp-28h] BYREF

  v10[0] = a4;
  *a2 = 0;
  if ( !sub_8025570(dword_2000043C, (unsigned int)v10, a3) )
    return -1;
  if ( LOBYTE(v10[0]) == 24 )
  {
    if ( sub_8025570(dword_2000043C, (unsigned int)v10, a3) && LOBYTE(v10[0]) == 24 )
    {
      *a2 = -1;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else if ( LOBYTE(v10[0]) > 0x18u )
  {
    if ( LOBYTE(v10[0]) != 65 && LOBYTE(v10[0]) != 97 )
      return -1;
    return 1;
  }
  else
  {
    switch ( LOBYTE(v10[0]) )
    {
      case 1u:
        v7 = 128;
        break;
      case 2u:
        v7 = 1024;
        break;
      case 4u:
        return 0;
      default:
        return -1;
    }
    *a1 = v10[0];
    for ( i = 1; i < v7 + 5; i = (unsigned __int16)(i + 1) )
    {
      if ( !sub_8025570(dword_2000043C, (unsigned int)&a1[i], a3) )
        return -1;
    }
    if ( (unsigned __int8)a1[1] == ((unsigned __int8)a1[2] ^ 0xFF) )
    {
      *a2 = v7;
      return 0;
    }
    else
    {
      return -1;
    }
  }
}
// 2000043C: using guessed type int dword_2000043C;

//----- (08018E44) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall NMI_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  __int64 v12; // r4
  int v13; // r8
  unsigned int i; // r7
  char *v15; // r6
  int v16; // r0
  _WORD v17[8]; // [sp-20h] [bp-20h] BYREF
  _WORD v18[4]; // [sp-10h] [bp-10h] BYREF
  int v19; // [sp-8h] [bp-8h]
  __int16 v20; // [sp-4h] [bp-4h]

  HIDWORD(v12) = a1;
  if ( a1 && qword_20000908 != v12 )
  {
    v13 = 0;
    v19 = dword_20003D81;
    v20 = word_20003D85;
    sub_8010328((int)v18);
    v17[0] = v18[0];
    v17[1] = v18[1];
    v17[2] = *(_WORD *)((char *)&v18[2] + 1);
    *(_QWORD *)&v17[3] = v12;
    for ( i = 0; i < 0x14; ++i )
    {
      v15 = (char *)&dword_20003D81 + 14 * i;
      if ( *(_QWORD *)(v15 + 6) == *(_QWORD *)&v17[3]
        && (unsigned __int8)v15[2] == LOBYTE(v17[1])
        && (unsigned __int8)v15[3] == HIBYTE(v17[1]) )
      {
        v16 = HIBYTE(v17[2]) - (unsigned __int8)v15[5] + 60 * (LOBYTE(v17[2]) - (unsigned __int8)v15[4]);
        if ( v16 < 0 )
          v16 = -v16;
        if ( v16 <= 30 )
          goto LABEL_14;
      }
      if ( sub_8004F52(v19, v20, *(_DWORD *)v15, *((_WORD *)v15 + 2)) > 0 )
      {
        v19 = *(_DWORD *)v15;
        v20 = *((_WORD *)v15 + 2);
        v13 = (unsigned __int8)i;
      }
    }
    qmemcpy((unsigned int)&dword_20003D81 + 14 * v13, (unsigned int)v17, 0xEu);
    qword_20000908 = v12;
    sub_800591C(14 * v13 + 4352, v17, 0xEu);
  }
LABEL_14:
  __asm { POP.W           {R4-R10,PC} }
}
// 8018F50: positive sp value 28 has been found
// 8018F50: unbalanced stack, ignored a potential tail call
// 8018E50: variable 'v12' is possibly undefined
// 20000908: using guessed type __int64 qword_20000908;
// 20003D81: using guessed type int dword_20003D81;
// 20003D85: using guessed type __int16 word_20003D85;

//----- (08018F5C) --------------------------------------------------------
int __fastcall sub_8018F5C(int result, int a2)
{
  int v2; // r4
  int v4; // r3
  unsigned __int16 *v5; // r2
  int v6; // r1
  int v7; // r8
  int v8; // r7
  char *v9; // r0
  char *v10; // r0
  int v11; // [sp+10h] [bp-38h] BYREF
  _BYTE v12[5]; // [sp+14h] [bp-34h]
  int v13; // [sp+1Ch] [bp-2Ch] BYREF
  __int16 v14; // [sp+21h] [bp-27h]

  v2 = result;
  if ( result )
  {
    if ( a2 )
    {
      if ( (unsigned __int8)byte_200008FB != result
        || (result = (unsigned __int16)word_20000900, (unsigned __int16)word_20000900 != a2) )
      {
        sub_8010328((int)&v13);
        v11 = v13;
        result = (unsigned __int8)v14;
        *(_WORD *)v12 = v14;
        v12[2] = v2;
        *(_WORD *)&v12[3] = a2;
        v4 = 0;
        while ( 1 )
        {
          v5 = (unsigned __int16 *)((char *)&unk_20003E99 + 9 * v4);
          if ( *(unsigned __int16 *)((char *)v5 + 7) == a2
            && *((unsigned __int8 *)v5 + 6) == v2
            && *v5 == (unsigned __int16)v13
            && __PAIR64__(*((unsigned __int8 *)v5 + 3), *((unsigned __int8 *)v5 + 2)) == __PAIR64__(
                                                                                           HIBYTE(v13),
                                                                                           BYTE2(v13)) )
          {
            v6 = HIBYTE(v14) - *((unsigned __int8 *)v5 + 5) + 60 * ((unsigned __int8)v14 - *((unsigned __int8 *)v5 + 4));
            if ( v6 < 0 )
              v6 = -v6;
            if ( v6 <= 30 )
              break;
          }
          if ( (unsigned int)++v4 >= 0x14 )
          {
            v7 = 0;
            v8 = 0;
            while ( 1 )
            {
              v9 = (char *)&unk_20003E99 + 9 * v8;
              if ( !*(_WORD *)(v9 + 7) && !v9[6] )
                break;
              if ( sub_8004F52(
                     *(_DWORD *)v9,
                     *((_WORD *)v9 + 2),
                     *(_DWORD *)((char *)&unk_20003E99 + 9 * v7),
                     *(_WORD *)((char *)&unk_20003E99 + 9 * v7 + 4)) < 0 )
                v7 = v8;
              if ( (unsigned int)++v8 >= 0x14 )
                goto LABEL_20;
            }
            v7 = v8;
LABEL_20:
            v10 = (char *)&unk_20003E99 + 9 * v7;
            *(_DWORD *)v10 = v11;
            *((_DWORD *)v10 + 1) = *(_DWORD *)v12;
            v10[8] = v12[4];
            result = sub_800591C(9 * v7 + 0x2000, &v11, 9u);
            byte_200008FB = v2;
            word_20000900 = a2;
            return result;
          }
        }
      }
    }
  }
  return result;
}
// 200008FB: using guessed type char byte_200008FB;
// 20000900: using guessed type __int16 word_20000900;

//----- (08019090) --------------------------------------------------------
int sub_8019090()
{
  byte_200004AA = 1;
  word_200004B6 = 0;
  return sub_8018720(&word_200004B6, 0xBB8u);
}
// 200004AA: using guessed type char byte_200004AA;
// 200004B6: using guessed type __int16 word_200004B6;

//----- (080190A8) --------------------------------------------------------
char *sub_80190A8()
{
  char *result; // r0

  result = (char *)(unsigned __int8)byte_2001104E;
  if ( byte_2001104E )
  {
    if ( byte_2001104D )
    {
      if ( byte_2001104D == 3 )
      {
        sub_801D258(dword_20011063, dword_20011057);
        sub_8002364(&byte_2001104C, 37);
        sub_8023DC8((_DWORD *)dword_20000008);
        sub_8023DC8((_DWORD *)dword_2000000C);
      }
    }
    else
    {
      sub_801F35C(dword_20011057);
      sub_8002364(&byte_2001104C, 37);
      byte_200037D7 = 0;
    }
    result = &byte_200015B0;
    dword_200015C0 = 0;
    byte_2001104E = 0;
  }
  return result;
}
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 200015B0: using guessed type char byte_200015B0;
// 200015C0: using guessed type int dword_200015C0;
// 200037D7: using guessed type char byte_200037D7;
// 2001104C: using guessed type char byte_2001104C;
// 2001104D: using guessed type char byte_2001104D;
// 2001104E: using guessed type char byte_2001104E;
// 20011057: using guessed type int dword_20011057;
// 20011063: using guessed type int dword_20011063;

//----- (08019118) --------------------------------------------------------
int __fastcall sub_8019118(int a1)
{
  int result; // r0

  *(_DWORD *)dword_20001728 &= ~0x20u;
  *(_DWORD *)dword_20001728 &= ~0x80u;
  *(_DWORD *)(dword_20001728 + 8) &= ~1u;
  sub_80157CE((int)&dword_20001728);
  sub_80159B8(&dword_20001728);
  dword_20001728 = 1073759232;
  dword_2000172C = a1;
  dword_20001730 = 0;
  dword_20001734 = 0;
  dword_20001738 = 0;
  dword_20001740 = 0;
  dword_2000173C = 12;
  dword_20001744 = 0;
  sub_80144CC((int)&dword_20001728, 0, 2, 2);
  sub_8015856((int)&dword_20001728, 0);
  sub_801580A((int)&dword_20001728);
  sub_8015E8C((int)&dword_20001728, (int)byte_20003164, 1u);
  result = dword_20001728;
  *(_DWORD *)(dword_20001728 + 8) &= ~1u;
  return result;
}
// 20001728: using guessed type int dword_20001728;
// 2000172C: using guessed type int dword_2000172C;
// 20001730: using guessed type int dword_20001730;
// 20001734: using guessed type int dword_20001734;
// 20001738: using guessed type int dword_20001738;
// 2000173C: using guessed type int dword_2000173C;
// 20001740: using guessed type int dword_20001740;
// 20001744: using guessed type int dword_20001744;

//----- (0801919C) --------------------------------------------------------
int __fastcall sub_801919C(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-8h] BYREF

  v5 = a4;
  return sub_80188C4(5, (unsigned int)&v5, 0);
}

//----- (080191AC) --------------------------------------------------------
void sub_80191AC()
{
  byte_200004BA = 1;
  byte_200004BB = 1;
  byte_200004A9 = 0;
  flt_200004D8 = 0.0;
  word_200004B8 = 0;
  byte_200004AB = 1;
  byte_200004AC = 0;
  sub_8004E5C();
  sub_8003234();
}
// 200004A9: using guessed type char byte_200004A9;
// 200004AB: using guessed type char byte_200004AB;
// 200004AC: using guessed type char byte_200004AC;
// 200004B8: using guessed type __int16 word_200004B8;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;
// 200004D8: using guessed type float flt_200004D8;

//----- (080191E8) --------------------------------------------------------
int __fastcall sub_80191E8(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r6
  unsigned int v4; // r4
  unsigned int v5; // r5
  unsigned int v6; // r7
  unsigned __int16 *v7; // r3
  unsigned int v8; // r0
  __int16 v9; // r0
  __int16 v10; // r0

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  v4 = a1[3] | (a1[2] << 8);
  if ( !v4 || v4 > 0x7D )
    return 3;
  v5 = 3;
  byte_20003066 = 2 * a1[3];
  if ( v3 < 0x9C40 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = (unsigned __int16 *)((char *)&unk_20000530 + 12 * v6);
      v8 = *v7;
      if ( v8 + (((*((_BYTE *)v7 + 9) & 0xF) * (unsigned int)*((unsigned __int8 *)v7 + 11)) >> 1) > v3 )
      {
        if ( v8 > v3 )
          return 2;
        v9 = sub_8023464((unsigned int)&byte_20003064[v5], v3, (unsigned __int8)v4, (int)v7);
        v5 = (unsigned __int16)(v5 + 2 * v9);
        v4 = (unsigned __int16)(v4 - v9);
        v3 = (unsigned __int16)(v9 + v3);
        if ( !v4 )
          goto LABEL_18;
      }
      v6 = (unsigned __int16)(v6 + 1);
      if ( v6 >= 0x4B )
        goto LABEL_18;
    }
  }
  while ( v4 )
  {
    if ( sub_802407C(&byte_20003064[v5], v3, 0, 0) )
      return 2;
    v4 = (unsigned __int16)(v4 - 1);
    v3 = (unsigned __int16)(v3 + 1);
    v5 = (unsigned __int16)(v5 + 2);
  }
LABEL_18:
  if ( v4 )
    return 3;
  v10 = sub_80184DA((int)byte_20003064, v5);
  byte_20003064[v5] = v10;
  byte_20003064[(unsigned __int16)(v5 + 1)] = HIBYTE(v10);
  sub_801D5E8((int)byte_20003064, v5 + 2);
  return 0;
}
// 20003066: using guessed type char byte_20003066;

//----- (080192D0) --------------------------------------------------------
int __fastcall sub_80192D0(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r1
  int v4; // r5

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  if ( v3 < 0x9C40 )
    return 2;
  v4 = sub_802407C(byte_20003064, v3, 1, a1[3] | (a1[2] << 8));
  if ( !v4 )
  {
    qmemcpy((unsigned int)&byte_20003066, (unsigned int)&unk_20003166, 6u);
    word_2000306A = sub_80184DA((int)byte_20003064, 6u);
    sub_801D5E8((int)byte_20003064, 8u);
  }
  return v4;
}
// 20003066: using guessed type char byte_20003066;
// 2000306A: using guessed type __int16 word_2000306A;

//----- (08019334) --------------------------------------------------------
int __fastcall sub_8019334(unsigned __int8 *a1, int a2)
{
  unsigned int v3; // r1

  if ( a2 != 8 )
    return 3;
  v3 = a1[1] | (*a1 << 8);
  if ( v3 >= 0x9C40 )
    return sub_802407C(byte_20003064, v3, 1, a1[3] | (a1[2] << 8));
  else
    return 2;
}

//----- (08019364) --------------------------------------------------------
int __fastcall sub_8019364(unsigned __int8 *a1, unsigned int a2, int a3, int a4)
{
  int v4; // r9
  __int16 v6; // r10
  int v7; // r4
  int result; // r0
  unsigned int v9; // r5
  int v10; // r8
  int v11; // r0
  int i; // r7
  int v13; // r1
  unsigned __int16 v14; // r10
  __int16 v15; // r0
  int v16; // [sp+0h] [bp-28h] BYREF

  v16 = a4;
  v6 = a2;
  v7 = 5;
  if ( a2 < 0xA )
    return 3;
  v9 = a1[1] | (*a1 << 8);
  v10 = a1[3] | (a1[2] << 8);
  v11 = a1[4];
  if ( v11 != 2 * v10 || v11 + 9 != a2 )
    return 3;
  if ( v9 < 0x9C40 )
    return 2;
  if ( !v10 || (unsigned int)v10 > 0x7D )
    return 3;
  for ( i = 0; i < v10; ++i )
  {
    sub_8004FA2((int)&v16, (int)&a1[v7], 2u);
    v7 = (unsigned __int16)(v7 + 2);
    v13 = v9;
    v9 = (unsigned __int16)(v9 + 1);
    result = sub_802407C(&byte_20003064[v7], v13, 1, (unsigned __int16)v16);
    v4 = result;
    if ( result )
      return result;
  }
  if ( !v4 )
  {
    v14 = v6 - 2;
    qmemcpy((unsigned int)&byte_20003066, (unsigned int)&unk_20003166, v14);
    v15 = sub_80184DA((int)byte_20003064, v14);
    byte_20003064[v14] = v15;
    byte_20003064[(unsigned __int16)(v14 + 1)] = HIBYTE(v15);
    sub_801D5E8((int)byte_20003064, v14 + 2);
  }
  return v4;
}
// 80193F8: variable 'v4' is possibly undefined
// 20003066: using guessed type char byte_20003066;

//----- (0801943C) --------------------------------------------------------
int __fastcall sub_801943C(int result, unsigned int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r4
  unsigned int v6; // r5
  int v7; // r8
  int v8; // r2
  int i; // r7
  int v10; // r1
  int v11; // [sp+0h] [bp-20h] BYREF

  v11 = a4;
  v4 = result;
  v5 = 5;
  if ( a2 < 0xA )
    return 3;
  v6 = *(unsigned __int8 *)(result + 1) | (*(unsigned __int8 *)result << 8);
  v7 = *(unsigned __int8 *)(result + 3) | (*(unsigned __int8 *)(result + 2) << 8);
  v8 = *(unsigned __int8 *)(result + 4);
  if ( v8 != 2 * v7 || v8 + 9 != a2 )
    return 3;
  if ( v6 < 0x9C40 )
    return 2;
  if ( !v7 || (unsigned int)v7 > 0x7D )
    return 3;
  for ( i = 0; i < v7; ++i )
  {
    sub_8004FA2((int)&v11, v4 + v5, 2u);
    v5 = (unsigned __int16)(v5 + 2);
    v10 = v6;
    v6 = (unsigned __int16)(v6 + 1);
    result = sub_802407C(&byte_20003064[v5], v10, 1, (unsigned __int16)v11);
    if ( result )
      break;
  }
  return result;
}

//----- (080194C8) --------------------------------------------------------
int __fastcall sub_80194C8(_BYTE *a1, int a2)
{
  sub_80145A4((int)&dword_20002148, a2, 0);
  return sub_8014560((int)&dword_20002148, a1, 0);
}
// 20002148: using guessed type int dword_20002148;

//----- (080194E8) --------------------------------------------------------
int sub_80194E8()
{
  sub_8025904(134367101, (int)"vtask_led", 128, 0, 0x10u, dword_20000014);
  sub_8025904(134367325, (int)"vtask_time", 256, 0, 0xFu, &dword_20000020);
  sub_8025904(134367161, (int)"vtask_modbus", 128, 0, 0xEu, &dword_20000024);
  sub_8025904(134367197, (int)"vtask_shell", 512, 0, 9u, &dword_20000014[1]);
  sub_8025904(134367185, (int)"vtask_prt", 256, 0, 8u, &dword_2000001C);
  sub_8025904(134367069, (int)"vtask_fc41d", 256, 0, 0xBu, &dword_20000008);
  sub_8025904(134367173, (int)"vtask_parser", 256, 0, 0xDu, &dword_2000000C);
  sub_8025904(134367085, (int)"vtask_http", 256, 0, 0xAu, &dword_20000010);
  sub_8025904(134367053, (int)"vtask_ct", 512, 0, 0xCu, &dword_20000004);
  return sub_8023D38();
}
// 20000004: using guessed type int dword_20000004;
// 20000008: using guessed type int dword_20000008;
// 2000000C: using guessed type int dword_2000000C;
// 20000010: using guessed type int dword_20000010;
// 20000014: using guessed type _DWORD dword_20000014[2];
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 20000024: using guessed type int dword_20000024;

//----- (08019658) --------------------------------------------------------
void sub_8019658()
{
  int v0; // r0
  int v1; // r0
  int v2; // r1
  float v3; // s0
  float v4; // s16
  int v5[7]; // [sp+0h] [bp-68h] BYREF
  int v6; // [sp+1Ch] [bp-4Ch] BYREF
  int v7; // [sp+20h] [bp-48h]
  int v8; // [sp+24h] [bp-44h]
  _DWORD v9[7]; // [sp+28h] [bp-40h] BYREF
  unsigned int v10; // [sp+44h] [bp-24h] BYREF

  if ( !byte_200015E6 )
  {
    flt_200004D8 = 0.01;
    sub_8003234();
  }
  v10 = 0;
  sub_8002364(&v6, 40);
  v0 = sub_8025570(dword_20000434, (unsigned int)&v6, 0);
  if ( !v0 && byte_200015E4 == 1 )
  {
    if ( (unsigned __int8)++byte_200004B0 > 0xFu )
    {
      dword_20002EC4[0] = 0;
      dword_20002EC8 = 0;
      dword_20002ECC = 0;
      dword_20002ED0 = 0;
      flt_200004D8 = 0.1;
      sub_8003234();
    }
  }
  else
  {
    byte_200004B0 = 0;
    if ( v0 )
    {
      byte_200004A8 = 1;
      dword_20002EC4[0] = v7;
      dword_20002EC8 = v8;
      dword_20002ECC = v9[0];
      dword_20002ED0 = v6;
    }
    sub_8019AA0();
    if ( !sub_8004B08() )
    {
      byte_200004A8 = 0;
      return;
    }
    if ( byte_200004AC && byte_200004AC != 5 )
    {
      if ( (unsigned int)(unsigned __int8)byte_200015E4 - 2 >= 8 )
      {
        if ( !byte_200004AC || (unsigned __int8)byte_200004AC >= 4u || byte_200015E4 != 1 )
          return;
        v10 = dword_20002EC4[(unsigned __int8)byte_200004AC - 1];
      }
      else if ( byte_20002FD0 || byte_200004AC == 4 )
      {
        v10 = dword_20002ED0;
      }
      else
      {
        if ( !byte_200004AC || (unsigned __int8)byte_200004AC >= 4u )
          return;
        v10 = dword_20002EC4[(unsigned __int8)byte_200004AC - 1];
      }
      qmemcpy((unsigned int)v5, (unsigned int)v9, sizeof(v5));
      v1 = sub_8004790(&v10, v6, v7, v8, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6]);
      if ( v1 )
      {
        if ( v1 == 1 )
        {
          byte_200004A8 = 0;
          flt_200004D8 = 0.1;
          sub_8003234();
        }
      }
      else
      {
        if ( !sub_8018648(v10) )
        {
          byte_200004AA = 2;
          return;
        }
        if ( byte_200015E4 == 1 )
        {
          if ( !sub_801B018(algn_200004C6, 0xBB8u) )
            return;
        }
        else if ( byte_200004AA != 2 )
        {
          return;
        }
        if ( byte_200015E4 == 1 )
        {
          if ( flt_200004D8 <= flt_2000030C )
          {
            if ( flt_200004D8 >= flt_20000310 )
            {
              v2 = dword_200004F4;
              if ( dword_200004F4 >= v10 )
                v2 = v10;
              dword_200004F4 = v2;
              if ( (int)v10 <= word_200004B4 )
              {
                if ( byte_200004B1 <= 0 )
                {
                  if ( --byte_200004B1 < -5 )
                    byte_200004B1 = -5;
                }
                else if ( ++byte_200004B1 > 5 )
                {
                  byte_200004B1 = 5;
                }
              }
              else
              {
                if ( byte_200004B1 <= 0 )
                  byte_200004B1 = 1;
                else
                  byte_200004B1 = -1;
                dword_200004F8 = v2;
                dword_200004F4 = v10;
              }
              v3 = (float)(v10 * v10 - dword_200004F8 * dword_200004F8);
              if ( v3 < 0.0 )
                v3 = -v3;
              sub_800323E();
              v4 = v3 + 10.0;
              sub_80052E8(byte_200004B1);
              if ( v3 < (float)(v3 + 10.0) )
              {
                sub_80052E8(byte_200004B1);
                v4 = v3;
              }
              if ( v4 > (float)(int)v10 )
                v4 = (float)(int)v10;
              if ( byte_200004B1 <= 0 )
                flt_200004D8 = flt_200004D8 - v4;
              else
                flt_200004D8 = flt_200004D8 + v4;
            }
            else
            {
              flt_200004D8 = flt_20000310 + 100.0;
              byte_200004B1 = 1;
            }
          }
          else
          {
            flt_200004D8 = flt_2000030C - 100.0;
            byte_200004B1 = -1;
          }
          sub_8004FC8(&flt_200004D8);
          if ( SLODWORD(flt_200004D8) <= 1159479296 )
          {
            if ( LODWORD(flt_200004D8) > 0xC51C4000 )
              flt_200004D8 = -2500.0;
          }
          else
          {
            flt_200004D8 = 2500.0;
          }
          sub_8003234();
          word_200004B4 = v10;
        }
        else if ( byte_200004A8 )
        {
          byte_200004A8 = 0;
          sub_8019950(v10, LOBYTE(v9[6]));
        }
      }
    }
  }
}
// 2000030C: using guessed type float flt_2000030C;
// 20000310: using guessed type float flt_20000310;
// 20000434: using guessed type int dword_20000434;
// 200004A8: using guessed type char byte_200004A8;
// 200004AA: using guessed type char byte_200004AA;
// 200004AC: using guessed type char byte_200004AC;
// 200004B0: using guessed type char byte_200004B0;
// 200004B1: using guessed type char byte_200004B1;
// 200004B4: using guessed type __int16 word_200004B4;
// 200004C6: using guessed type _BYTE[2];
// 200004D8: using guessed type float flt_200004D8;
// 200004F4: using guessed type int dword_200004F4;
// 200004F8: using guessed type int dword_200004F8;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 20002EC4: using guessed type int dword_20002EC4[];
// 20002EC8: using guessed type int dword_20002EC8;
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;
// 20002FD0: using guessed type char byte_20002FD0;

//----- (08019950) --------------------------------------------------------
void __fastcall sub_8019950(int a1, unsigned int a2)
{
  float v4; // s0
  int v5; // r5
  float v6; // s0
  int v7; // r0
  int v8; // r0

  LODWORD(v4) = (int)flt_200027A4;
  v5 = (int)flt_200027A4;
  sub_8005464();
  if ( v5 < 0 || a1 <= 10 )
  {
    if ( v5 > 0 || a1 >= -10 )
    {
      if ( v5 * a1 >= 0 )
      {
        if ( v5 < 0 && (unsigned int)a1 >= 0xFFFFFFF6 )
          flt_200004D8 = flt_200004D8 + (float)(a1 - 5);
      }
      else
      {
        flt_200004D8 = flt_200004D8 + (float)a1;
      }
    }
    else
    {
      flt_200004D8 = flt_200004D8 + (float)((float)a1 * v4);
    }
  }
  else
  {
    flt_200004D8 = (float)((float)((float)a1 * v4) - 5.0) + flt_200004D8;
  }
  sub_8004FC8(&flt_200004D8);
  v6 = flt_200004D8;
  if ( flt_200004D8 > flt_2000030C )
    v6 = flt_2000030C;
  flt_200004D8 = v6;
  if ( v6 < flt_20000310 )
    v6 = flt_20000310;
  flt_200004D8 = v6;
  if ( a2 <= 1 )
  {
    v8 = (int)v6;
    if ( (int)v6 < 0 )
      v8 = -v8;
    if ( v8 <= 20 && a1 <= 15 )
      flt_200004D8 = 0.01;
  }
  else
  {
    v7 = (int)v6;
    if ( (int)v6 < 0 )
      v7 = -v7;
    if ( v7 < 15 && a1 < 15 )
      flt_200004D8 = 0.01;
  }
  sub_8019090();
  sub_8003234();
}
// 2000030C: using guessed type float flt_2000030C;
// 20000310: using guessed type float flt_20000310;
// 200004D8: using guessed type float flt_200004D8;
// 200027A4: using guessed type float flt_200027A4;

//----- (08019A94) --------------------------------------------------------
int __fastcall sub_8019A94(int a1)
{
  sub_801D5CC(a1);
  return 0;
}

//----- (08019AA0) --------------------------------------------------------
void sub_8019AA0()
{
  BOOL v0; // r5
  int v1; // r4
  char v2; // r6
  int v3; // r0
  float v4; // s0
  unsigned int v5; // r3
  int v6; // r2
  int j; // r0
  int v8; // r1
  int v9; // r11
  int v10; // r0
  int i; // r0
  int v12; // r1
  int v13; // r3
  bool v14; // cc
  int v15; // r1
  int v16; // r5
  int v17; // r1
  unsigned int v18; // [sp+0h] [bp-30h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v18 = 20;
  if ( byte_200004AB )
  {
    word_200004C8 = 0;
    word_200004CA = 0;
    word_200004CC[0] = 0;
    byte_200004B2 = 0;
    byte_200004B3 = 0;
    byte_200004AB = 0;
  }
  if ( byte_200004BA
    && ((unsigned __int16)dword_20002E7A <= 0x32u || word_20002E78)
    && ((unsigned __int16)dword_20002E7A > 0x32u || HIWORD(dword_20002E74)) )
  {
    if ( byte_200004AC == 5 )
      sub_8003234();
    if ( byte_200004AC == 5 && sub_801B040(word_200004CC, 0x3Cu) )
    {
      if ( (unsigned __int8)++byte_200004A9 >= 3u )
      {
        byte_200004BA = 0;
        byte_200004BB = 2;
        byte_200004A9 = 3;
        return;
      }
      byte_200004AC = 0;
    }
    if ( !byte_200004AC && byte_200015E6 )
    {
      if ( word_200004B8 )
      {
        if ( !byte_200004B2 && !sub_801B040(&word_200004C8, 3u) )
        {
          *(_QWORD *)&dword_20002EDC = *(_QWORD *)&dword_20002ECC;
          *(_QWORD *)dword_20002ED4 = *(_QWORD *)dword_20002EC4;
          *(_QWORD *)dword_20002EE4 = *(_QWORD *)dword_20002EC4;
          dword_20002EEC = dword_20002ECC;
          *(_QWORD *)dword_20002EF0 = *(_QWORD *)dword_20002EC4;
          dword_20002EF8 = dword_20002ECC;
          dword_20002EFC[0] = 0;
          dword_20002F00 = 0;
          dword_20002F04 = 0;
          sub_8003234();
          byte_200004B2 = 1;
        }
        if ( byte_200004B2 )
        {
          v3 = (int)flt_2000030C;
          if ( (int)flt_2000030C < 0 )
            v3 = -v3;
          if ( v3 <= 2000 )
            v4 = flt_2000030C;
          else
            v4 = 2000.0;
          v5 = (unsigned __int16)(unsigned int)v4;
          v6 = (unsigned __int8)byte_200015E4;
          if ( byte_200015E4 == 1 )
          {
            for ( i = 0; i < 3; ++i )
            {
              v12 = dword_20002EC4[i];
              v13 = dword_20002ED4[i];
              v14 = v12 < v13;
              if ( v12 <= v13 )
                v15 = v13 - v12;
              else
                v15 = v12 - v13;
              if ( v14 && v15 >= 50 && (unsigned int)(v13 - 701) < 0x257 )
              {
                if ( dword_20002EFC[i] >= v15 )
                  v15 = dword_20002EFC[i];
                dword_20002EFC[i] = v15;
              }
              v16 = dword_20002EF0[i];
              if ( v16 <= dword_20002EC4[i] )
                v16 = dword_20002EC4[i];
              dword_20002EF0[i] = v16;
              v17 = dword_20002EE4[i];
              if ( v17 >= dword_20002EC4[i] )
                v17 = dword_20002EC4[i];
              dword_20002EE4[i] = v17;
              if ( (unsigned int)(v16 - v17 + dword_20002EFC[i] - 800) <= 0x6A4 )
              {
                ++byte_200004B3;
                v1 = (unsigned __int8)(v1 + 1);
                v2 = i + 1;
              }
            }
          }
          else
          {
            for ( j = 0; j < 3; ++j )
            {
              v8 = dword_20002EC4[j];
              v9 = v8 - dword_20002ED4[j];
              if ( v9 < 0 )
                v9 = dword_20002ED4[j] - v8;
              if ( !v0 )
                v0 = v8 != 0;
              if ( v9 >= (int)(v5 >> 1) && v9 <= 2500 )
              {
                v0 = 1;
                ++byte_200004B3;
                v1 = (unsigned __int8)(v1 + 1);
                v2 = j + 1;
              }
            }
            if ( (unsigned int)(unsigned __int8)byte_200015E4 - 5 <= 4 && !v0 )
            {
              v10 = dword_20002ED0 - dword_20002EE0;
              if ( dword_20002ED0 - dword_20002EE0 < 0 )
                v10 = dword_20002EE0 - dword_20002ED0;
              if ( v10 >= (int)(v5 >> 1) && v10 <= 2500 )
              {
                byte_200004B3 = 2;
                v1 = 1;
                v2 = 4;
              }
            }
          }
          if ( v1 && byte_200004B3 == 2 )
          {
            word_200004B8 = 0;
            byte_200004BA = 0;
            byte_200004BB = 3;
            byte_200004B2 = 0;
            byte_200004B3 = 0;
            word_200004CA = 0;
            if ( v1 != 1 )
              v2 = 5;
            byte_200004AC = v2;
            sub_8003234();
            sub_8005AA4((unsigned __int8)byte_200004AC);
            flt_200004D8 = 0.1;
          }
          else
          {
            if ( v6 == 5 || v6 == 9 || v6 == 6 )
              v18 = 40;
            if ( word_200004B8 )
            {
              if ( sub_801B040(&word_200004CA, v18) )
              {
                word_200004B8 = 0;
                byte_200004AC = 5;
                byte_200004B2 = 0;
                byte_200004B3 = 0;
                sub_8003234();
                flt_200004D8 = 0.1;
              }
            }
          }
        }
      }
      else
      {
        sub_8003234();
        word_200004B8 = 1;
      }
    }
  }
}
// 2000030C: using guessed type float flt_2000030C;
// 200004A9: using guessed type char byte_200004A9;
// 200004AB: using guessed type char byte_200004AB;
// 200004AC: using guessed type char byte_200004AC;
// 200004B2: using guessed type char byte_200004B2;
// 200004B3: using guessed type char byte_200004B3;
// 200004B8: using guessed type __int16 word_200004B8;
// 200004BA: using guessed type char byte_200004BA;
// 200004BB: using guessed type char byte_200004BB;
// 200004C8: using guessed type __int16 word_200004C8;
// 200004CA: using guessed type __int16 word_200004CA;
// 200004CC: using guessed type __int16 word_200004CC[3];
// 200004D8: using guessed type float flt_200004D8;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 20002E74: using guessed type int dword_20002E74;
// 20002E78: using guessed type __int16 word_20002E78;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002EC4: using guessed type int dword_20002EC4[];
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;
// 20002ED4: using guessed type int dword_20002ED4[];
// 20002EDC: using guessed type int dword_20002EDC;
// 20002EE0: using guessed type int dword_20002EE0;
// 20002EE4: using guessed type int dword_20002EE4[];
// 20002EEC: using guessed type int dword_20002EEC;
// 20002EF0: using guessed type int dword_20002EF0[];
// 20002EF8: using guessed type int dword_20002EF8;
// 20002EFC: using guessed type int dword_20002EFC[];
// 20002F00: using guessed type int dword_20002F00;
// 20002F04: using guessed type int dword_20002F04;

//----- (08019DCC) --------------------------------------------------------
#error "8019DF4: call analysis failed (funcsize=79)"

//----- (08019FDC) --------------------------------------------------------
int __fastcall sub_8019FDC(int a1)
{
  if ( a1 == 27 )
    dword_20000298 = 1;
  return sub_8020EAC((int)&dword_200021C8, a1);
}
// 20000298: using guessed type int dword_20000298;
// 200021C8: using guessed type int dword_200021C8;

//----- (08019FF8) --------------------------------------------------------
int sub_8019FF8()
{
  int result; // r0
  int v1; // r5
  int v2; // r10
  unsigned __int8 *v3; // r0
  __int16 v4; // r0
  char v5; // r0
  unsigned __int8 *v6; // r3
  unsigned __int8 *v7; // r0
  int v8; // r0
  char *v9; // r0
  unsigned __int16 v10; // r0
  char v11; // r0
  unsigned __int8 *v12; // r9
  __int16 v13; // r10
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 *v16; // r0
  unsigned __int8 *v17; // r0
  int v18; // r2
  int v19; // r3
  char v20; // r0
  unsigned __int8 *v21; // r0
  __int64 v22; // r0
  __int16 v23; // r0
  unsigned __int8 v24[128]; // [sp+Ch] [bp-10Ch] BYREF
  unsigned __int8 v25[64]; // [sp+8Ch] [bp-8Ch] BYREF
  int v26; // [sp+CCh] [bp-4Ch] BYREF
  int v27; // [sp+D0h] [bp-48h]
  int v28; // [sp+D4h] [bp-44h]
  int v29; // [sp+D8h] [bp-40h]

  result = (unsigned __int8)byte_20000930;
  if ( byte_20000930 )
  {
    v1 = 0;
    v2 = 0;
    sub_8002364(&v26, 40);
    sub_8002364(v25, 64);
    sub_8002364(v24, 128);
    if ( byte_200015DF == 4 )
    {
      word_20001600 = 0;
    }
    else if ( sub_801B040(&word_20001600, 0x19u) && byte_200015E6 )
    {
      byte_200015E6 = 0;
    }
    switch ( byte_200015DF )
    {
      case 0:
        sub_80173B0();
        if ( sub_8018B94("AT+QICFG=\"accept/mode\",0\r\n", (unsigned __int8 *)&dword_801A3E8, 300) )
          byte_200015DF = 1;
        break;
      case 1:
        sub_8002364(v24, 128);
        sprintf(
          (int)v24,
          "AT+QIOPEN=%d,\"UDP SERVICE\",\"%s\",%d,%d,0\r\n",
          (unsigned __int8)byte_200015EA,
          (const char *)&qword_20011298,
          1010,
          22222);
        if ( sub_8018B94(v24, "+QIOPEN", 300) )
        {
          v3 = strstr(byte_20011328, ",");
          v4 = sub_8002644((char *)v3);
          byte_200015EF = byte_200015EA;
          if ( v4 )
          {
            v5 = byte_200015EA;
            if ( (unsigned __int8)byte_200015EA >= 0xBu )
              --byte_200015EA;
            else
              ++byte_200015EA;
            byte_200015EA = v5;
            byte_200015DF = 0;
          }
          else
          {
            byte_200015E1 = 0;
            byte_200015DF = 2;
          }
        }
        else
        {
          ++byte_200015E1;
        }
        break;
      case 2:
        sub_8002364(v25, 64);
        switch ( byte_20002FD1 )
        {
          case 1:
            sprintf(
              (int)v25,
              "{\"id\":%d,\"method\":\"EM.GetStatus\",\"params\":{\"id\":0}}",
              (unsigned __int8)byte_200015E0);
            v2 = sub_8005494();
            break;
          case 3:
          case 4:
            sub_801897C((int)v25, 64);
            v2 = 12345;
            break;
          case 5:
          case 6:
            v2 = sub_8005494();
            sprintf(
              (int)v25,
              "{\"id\":%d,\"method\":\"EM1.GetStatus\",\"params\":{\"id\":0}}",
              (unsigned __int8)byte_200015E0);
            break;
        }
        sub_8002364(v24, 128);
        v6 = sub_80023E2(v25);
        sprintf(
          (int)v24,
          "AT+QISEND=%d,%d,\"%s\",\"%s\",%d\r\n",
          (unsigned __int8)byte_200015EA,
          v6,
          (const char *)v25,
          (const char *)&qword_20011298,
          v2);
        if ( sub_8018B94(v24, (unsigned __int8 *)&dword_801A3E8, 300) )
          ++byte_200015E1;
        byte_200015DF = 3;
        break;
      case 3:
        sub_8002364(v24, 128);
        sprintf((int)v24, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015EA);
        if ( sub_8018B94(v24, "+QIRD", 300) )
        {
          v7 = strstr(byte_20011328, "+QIRD");
          if ( v7 )
          {
            v8 = sub_80023CE((int)v7, 0x2Cu);
            if ( v8 )
            {
              v9 = (char *)(sub_80023CE(v8 + 1, 0x2Cu) + 1);
              if ( v9 != (char *)1 )
              {
                v10 = sub_8002644(v9);
                word_200015F2 = v10;
                if ( v10 )
                {
                  if ( v10 > (unsigned int)(unsigned __int16)word_200015F4 )
                    byte_200015E3 = 1;
                  byte_200015E1 = 0;
                  byte_200015DF = 4;
                }
                else
                {
                  byte_200015DF = 2;
                  ++byte_200015E1;
                }
              }
            }
          }
        }
        else
        {
          byte_200015DF = 2;
          ++byte_200015E1;
        }
        break;
      case 4:
        sub_8002364(v24, 128);
        sprintf((int)v24, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015EA, (unsigned __int16)word_200015F2);
        if ( sub_8018B94(v24, (unsigned __int8 *)&dword_801A3E8, 300) && !byte_200015E3 )
        {
          v12 = strstr(byte_20011328, "+QIRD:");
          v13 = sub_8002644((char *)v12 + 6);
          word_200015F4 = v13 + sub_8002644((char *)v12 + 6) / 2;
          byte_200015E1 = 0;
          if ( strstr(byte_20011328, "a_act_power") )
          {
            v14 = strstr(byte_20011328, "a_act_power");
            if ( v14 )
              v27 = (int)(double)sub_8002644((char *)v14 + 13);
            v15 = strstr(byte_20011328, "b_act_power");
            if ( v15 )
              v28 = (int)(double)sub_8002644((char *)v15 + 13);
            v16 = strstr(byte_20011328, "c_act_power");
            if ( v16 )
              v29 = (int)(double)sub_8002644((char *)v16 + 13);
            v17 = strstr(byte_20011328, "total_act_power");
            if ( v17 )
            {
              v26 = (int)(double)sub_8002644((char *)v17 + 17);
              v1 = 1;
            }
            byte_200015E4 = 4;
          }
          else if ( strstr(byte_20011328, "HME-") )
          {
            v1 = sub_801C838(byte_20011328, 1024, &v26);
          }
          else if ( strstr(byte_20011328, "shellyemg3") || strstr(byte_20011328, "shellyproem50") )
          {
            if ( strstr(byte_20011328, "shellyemg3") )
              v20 = 7;
            else
              v20 = 8;
            byte_200015E4 = v20;
            v1 = 1;
            v21 = strstr(byte_20011328, "act_power");
            v26 = (int)(double)sub_8002644((char *)v21 + 11);
          }
          if ( v1 )
          {
            byte_200015E6 = 1;
            byte_200015E2 = 0;
            HIDWORD(v22) = 1024;
            LODWORD(v22) = byte_20011328;
            sub_8010070(v22, v18, v19);
            if ( v1 == 1 )
            {
              sub_8025188(dword_20000434, (unsigned int)&v26, 0, 2);
              v23 = sub_800FBCC();
              sub_8023A34(1200 * v23);
            }
            sub_801ADD8((int)dword_802996C, 134382199, 1611, v27, v28, v29, v26);
          }
          byte_200015DF = 2;
        }
        else
        {
          ++byte_200015E2;
          if ( byte_200015E3 )
            v11 = 3;
          else
            v11 = 2;
          byte_200015DF = v11;
        }
        byte_200015E3 = 0;
        break;
      default:
        byte_200015E1 = 6;
        break;
    }
    result = (unsigned __int8)byte_200015E1;
    if ( (unsigned __int8)byte_200015E1 > 5u
      || (result = (unsigned __int8)byte_200015E2, (unsigned __int8)byte_200015E2 >= 3u) )
    {
      byte_200015E2 = 0;
      byte_200015E1 = 0;
      byte_200015DF = 0;
    }
  }
  else
  {
    byte_200015DF = 0;
  }
  return result;
}
// 801A378: variable 'v18' is possibly undefined
// 801A378: variable 'v19' is possibly undefined
// 801A3E8: using guessed type int dword_801A3E8;
// 802996C: using guessed type int dword_802996C[108];
// 20000434: using guessed type int dword_20000434;
// 20000930: using guessed type char byte_20000930;
// 200015DF: using guessed type char byte_200015DF;
// 200015E0: using guessed type char byte_200015E0;
// 200015E1: using guessed type char byte_200015E1;
// 200015E2: using guessed type char byte_200015E2;
// 200015E3: using guessed type char byte_200015E3;
// 200015E4: using guessed type char byte_200015E4;
// 200015E6: using guessed type char byte_200015E6;
// 200015EA: using guessed type char byte_200015EA;
// 200015EF: using guessed type char byte_200015EF;
// 200015F2: using guessed type __int16 word_200015F2;
// 200015F4: using guessed type __int16 word_200015F4;
// 20001600: using guessed type __int16 word_20001600;
// 20002FD1: using guessed type char byte_20002FD1;
// 20011298: using guessed type __int64 qword_20011298;
// 20011328: using guessed type _BYTE byte_20011328[936];

//----- (0801A574) --------------------------------------------------------
int __fastcall sub_801A574(int result, int a2, int (*a3)(void))
{
  if ( result == 1 )
  {
    off_20000064 = a3;
    *(_DWORD *)(dword_20001AF8 + 52) = *(_DWORD *)(dword_20001AF8 + 36) + a2;
    *(_DWORD *)(dword_20001AF8 + 16) = -3;
    result = dword_20001AF8;
    *(_DWORD *)(dword_20001AF8 + 12) |= 2u;
  }
  else if ( result == 2 )
  {
    off_20000068 = a3;
    *(_DWORD *)(dword_20001AF8 + 56) = *(_DWORD *)(dword_20001AF8 + 36) + a2;
    *(_DWORD *)(dword_20001AF8 + 16) = -5;
    result = dword_20001AF8;
    *(_DWORD *)(dword_20001AF8 + 12) |= 4u;
  }
  return result;
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AF8: using guessed type int dword_20001AF8;

//----- (0801A5C4) --------------------------------------------------------
int __fastcall sub_801A5C4(_BYTE *a1, _DWORD *a2)
{
  unsigned int v3; // r3
  int result; // r0
  int v5; // r4
  int v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r2
  int v10; // r2

  v3 = 0;
  result = 0;
  v5 = 0;
  if ( *a1 == 48 && ((v6 = (unsigned __int8)a1[1], v6 == 120) || v6 == 88) )
  {
    if ( a1[2] )
    {
      v7 = 2;
      while ( 1 )
      {
        v8 = (unsigned __int8)a1[v7];
        if ( !a1[v7] )
        {
          *a2 = v5;
          result = 1;
          goto LABEL_21;
        }
        if ( (unsigned int)(v8 - 65) > 5 && (unsigned int)(v8 - 97) > 5 && (unsigned int)(v8 - 48) > 9 )
          break;
        if ( (unsigned int)(v8 - 48) > 9 )
        {
          if ( (unsigned int)(v8 - 65) > 5 )
            v9 = v8 - 87;
          else
            v9 = v8 - 55;
        }
        else
        {
          v9 = v8 - 48;
        }
        v5 = v9 + 16 * v5;
        if ( ++v7 >= 0xB )
          goto LABEL_21;
      }
      result = 0;
LABEL_21:
      if ( v7 >= 0xB )
        return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    while ( 1 )
    {
      v10 = (unsigned __int8)a1[v3];
      if ( !a1[v3] )
      {
        *a2 = v5;
        result = 1;
        goto LABEL_39;
      }
      if ( (v10 == 107 || v10 == 75) && v3 )
      {
        *a2 = v5 << 10;
        result = 1;
        goto LABEL_39;
      }
      if ( (v10 == 109 || v10 == 77) && v3 )
      {
        *a2 = v5 << 20;
        result = 1;
        goto LABEL_39;
      }
      if ( (unsigned int)(v10 - 48) > 9 )
        break;
      v5 = 10 * v5 - 48 + v10;
      if ( ++v3 >= 0xB )
        goto LABEL_39;
    }
    result = 0;
LABEL_39:
    if ( v3 >= 0xB )
      return 0;
  }
  return result;
}

//----- (0801A68C) --------------------------------------------------------
int *sub_801A68C()
{
  int *result; // r0

  sub_80138A0();
  if ( sub_8025B14() != 1 )
    sub_8024FE8();
  result = (int *)(unsigned __int16)++word_20000262;
  ++word_20000028;
  if ( (unsigned __int16)word_20000262 >= 0x3E8u )
  {
    word_20000262 = 0;
    ++word_2000002A;
    result = &dword_2000002C;
    ++dword_2000002C;
  }
  return result;
}
// 20000028: using guessed type __int16 word_20000028;
// 2000002A: using guessed type __int16 word_2000002A;
// 2000002C: using guessed type int dword_2000002C;
// 20000262: using guessed type __int16 word_20000262;

//----- (0801A6DC) --------------------------------------------------------
int *sub_801A6DC()
{
  int *result; // r0

  result = &CPACR;
  CPACR |= 0xF00000u;
  return result;
}
// E000ED88: using guessed type int CPACR;

//----- (0801A6EC) --------------------------------------------------------
int __fastcall sub_801A6EC(_BYTE *a1)
{
  _BYTE *v2; // r0
  int v3; // r4
  int v4; // r0
  int v5; // r4
  int v6; // r0
  int v7; // r4
  unsigned __int8 *v8; // r0
  int v9; // r4
  int v10; // r0
  int v12; // [sp+Ch] [bp-34h] BYREF
  int v13; // [sp+10h] [bp-30h]
  int v14; // [sp+14h] [bp-2Ch]
  int v15; // [sp+18h] [bp-28h]

  if ( !a1 )
    return 0;
  sub_8002364(&v12, 40);
  v2 = sub_8002480(a1, 72);
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v13 = sub_8002644(v2 + 3);
  v4 = sub_80023CE(v3, 0x7Cu);
  v5 = v4;
  if ( !v4 )
    return 0;
  v14 = sub_8002644((char *)(v4 + 1));
  v6 = sub_80023CE(v5 + 1, 0x7Cu);
  v7 = v6;
  if ( v6 )
  {
    v15 = sub_8002644((char *)(v6 + 1));
    v8 = strstr((unsigned __int8 *)(v7 + 1), "HME-");
    v9 = (int)v8;
    if ( v8 )
    {
      byte_200015E4 = sub_8002644((char *)v8 + 4);
      v10 = sub_80023CE(v9, 0x7Cu);
      if ( v10 )
        v12 = (int)(double)sub_8002644((char *)(v10 + 1));
    }
    else
    {
      byte_200015E4 = 1;
    }
  }
  sub_8025188(dword_20000434, (unsigned int)&v12, 0, 2);
  sub_801ADD8(
    (int)"%s %d power1:%d power2:%d power3:%d,total_power:%d\r\n",
    "T] Set max discharge power = %d, real max discharge power = %d.\r\n",
    205,
    v13,
    v14,
    v15,
    v12);
  return 1;
}
// 20000434: using guessed type int dword_20000434;
// 200015E4: using guessed type char byte_200015E4;

//----- (0801A7FC) --------------------------------------------------------
int sub_801A7FC()
{
  return sub_8014E8C((int)&dword_20001A14);
}
// 20001A14: using guessed type int dword_20001A14;

//----- (0801A808) --------------------------------------------------------
int sub_801A808()
{
  return sub_8014E8C((int)&dword_20001AF8);
}
// 20001AF8: using guessed type int dword_20001AF8;

//----- (0801A814) --------------------------------------------------------
int sub_801A814()
{
  return sub_8014E8C((int)&dword_20001A60);
}
// 20001A60: using guessed type int dword_20001A60;

//----- (0801A820) --------------------------------------------------------
unsigned int *__fastcall sub_801A820(unsigned int *result, unsigned int *a2)
{
  unsigned int v2; // r2

  v2 = *result;
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)0x40000000
    || result == (unsigned int *)1073742848
    || result == (unsigned int *)1073743872
    || result == (unsigned int *)1073744896
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073827840 )
  {
    v2 = a2[1] | v2 & 0xFFFFFF8F;
  }
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)0x40000000
    || result == (unsigned int *)1073742848
    || result == (unsigned int *)1073743872
    || result == (unsigned int *)1073744896
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073823744
    || result == (unsigned int *)1073824768
    || result == (unsigned int *)1073825792
    || result == (unsigned int *)1073827840 )
  {
    v2 = a2[3] | v2 & 0xFFFFFCFF;
  }
  *result = v2 & 0xFFFFFF7F | a2[5];
  result[11] = a2[2];
  result[10] = *a2;
  if ( result == (unsigned int *)1073818624
    || result == (unsigned int *)1073820672
    || result == (unsigned int *)1073823744
    || result == (unsigned int *)1073824768
    || result == (unsigned int *)1073825792
    || result == (unsigned int *)1073827840 )
  {
    result[12] = a2[4];
  }
  result[5] = 1;
  return result;
}

//----- (0801A8F4) --------------------------------------------------------
int __fastcall sub_801A8F4(int result, char a2, int a3)
{
  char v3; // r1

  v3 = a2 & 0x1F;
  *(_DWORD *)(result + 32) &= ~(1 << v3);
  *(_DWORD *)(result + 32) |= a3 << v3;
  return result;
}

//----- (0801A90E) --------------------------------------------------------
int __fastcall sub_801A90E(int result, char a2, int a3)
{
  char v3; // r1

  v3 = a2 & 0x1F;
  *(_DWORD *)(result + 32) &= ~(4 << v3);
  *(_DWORD *)(result + 32) |= a3 << v3;
  return result;
}

//----- (0801A928) --------------------------------------------------------
_DWORD *__fastcall sub_801A928(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~1u;
  v2 = result[1];
  v3 = *a2 | result[6] & 0xFFFEFF8C;
  v4 = a2[2] | result[8] & 0xFFFFFFFD;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v4 = a2[3] & 0xFFFFFFFB | a2[2] & 0xFFFFFFF3 | result[8] & 0xFFFFFFF1;
  }
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = a2[6] | a2[5] | v2 & 0xFFFFFCFF;
  }
  result[1] = v2;
  result[6] = v3;
  result[13] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801A9D8) --------------------------------------------------------
_DWORD *__fastcall sub_801A9D8(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r5
  unsigned int v4; // r3

  result[8] &= ~0x10u;
  v2 = result[1];
  v3 = result[6] & 0xFEFF8CFF | (*a2 << 8);
  v4 = result[8] & 0xFFFFFFDF | (16 * a2[2]);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFFFF1F | (16 * a2[2]) & 0xFFFFFF3F | (16 * a2[3]) & 0xFFFFFFBF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFFF3FF | (4 * a2[5]) | (4 * a2[6]);
  }
  result[1] = v2;
  result[6] = v3;
  result[14] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801AA7C) --------------------------------------------------------
_DWORD *__fastcall sub_801AA7C(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x100u;
  v2 = result[1];
  v3 = *a2 | result[7] & 0xFFFEFF8C;
  v4 = result[8] & 0xFFFFFDFF | (a2[2] << 8);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFFF1FF | (a2[2] << 8) & 0xFFFFF3FF | (a2[3] << 8) & 0xFFFFFBFF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFFCFFF | (16 * a2[5]) | (16 * a2[6]);
  }
  result[1] = v2;
  result[7] = v3;
  result[15] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801AB20) --------------------------------------------------------
_DWORD *__fastcall sub_801AB20(_DWORD *result, _DWORD *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r5
  unsigned int v4; // r3

  result[8] &= ~0x1000u;
  v2 = result[1];
  v3 = result[7] & 0xFEFF8CFF | (*a2 << 8);
  v4 = result[8] & 0xFFFFDFFF | (a2[2] << 12);
  if ( result == (_DWORD *)1073818624 || result == (_DWORD *)1073820672 || result == (_DWORD *)1073827840 )
    v4 = result[8] & 0xFFFF1FFF | (a2[2] << 12) & 0xFFFF3FFF | (a2[3] << 12) & 0xFFFFBFFF;
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFF3FFF | (a2[5] << 6) | (a2[6] << 6);
  }
  result[1] = v2;
  result[7] = v3;
  result[16] = a2[1];
  result[8] = v4;
  return result;
}

//----- (0801ABC4) --------------------------------------------------------
_DWORD *__fastcall sub_801ABC4(_DWORD *result, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x10000u;
  v2 = result[1];
  v3 = *(_DWORD *)a2 | result[20] & 0xFFFEFF8F;
  v4 = result[8] & 0xFFFDFFFF | (*(unsigned __int16 *)(a2 + 8) << 16);
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFEFFFF | (*(_DWORD *)(a2 + 20) << 8);
  }
  result[1] = v2;
  result[20] = v3;
  result[18] = *(_DWORD *)(a2 + 4);
  result[8] = v4;
  return result;
}

//----- (0801AC3C) --------------------------------------------------------
_DWORD *__fastcall sub_801AC3C(_DWORD *result, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  unsigned int v4; // r3

  result[8] &= ~0x100000u;
  v2 = result[1];
  v3 = result[20] & 0xFEFF8FFF | (*(_DWORD *)a2 << 8);
  v4 = result[8] & 0xFFDFFFFF | (*(unsigned __int16 *)(a2 + 8) << 20);
  if ( result == (_DWORD *)1073818624
    || result == (_DWORD *)1073820672
    || result == (_DWORD *)1073823744
    || result == (_DWORD *)1073824768
    || result == (_DWORD *)1073825792
    || result == (_DWORD *)1073827840 )
  {
    v2 = v2 & 0xFFFBFFFF | (*(_DWORD *)(a2 + 20) << 10);
  }
  result[1] = v2;
  result[20] = v3;
  result[19] = *(_DWORD *)(a2 + 4);
  result[8] = v4;
  return result;
}

//----- (0801ACB8) --------------------------------------------------------
int __fastcall sub_801ACB8(int result, char a2, int a3, char a4)
{
  int v4; // r4
  int v5; // r5
  unsigned int v6; // r4

  *(_DWORD *)(result + 32) &= ~1u;
  v4 = *(_DWORD *)(result + 24);
  v5 = *(_DWORD *)(result + 32);
  if ( result == 1073818624
    || result == 0x40000000
    || result == 1073742848
    || result == 1073743872
    || result == 1073744896
    || result == 1073820672
    || result == 1073823744
    || result == 1073827840 )
  {
    v6 = v4 & 0xFFFFFFFC | a3;
  }
  else
  {
    v6 = v4 | 1;
  }
  *(_DWORD *)(result + 24) = v6 & 0xFFFFFF0F | (unsigned __int8)(16 * a4);
  *(_DWORD *)(result + 32) = a2 & 0xA | v5 & 0xFFFFFFF5;
  return result;
}

//----- (0801AD38) --------------------------------------------------------
int __fastcall sub_801AD38(int result, int a2, int a3, __int16 a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x10u;
  v4 = (16 * a2) & 0xA0 | *(_DWORD *)(result + 32) & 0xFFFFFF5F;
  *(_DWORD *)(result + 24) = (unsigned __int16)(a4 << 12)
                           | *(_DWORD *)(result + 24) & 0xFFFF0CFF
                           | (a3 << 8) & 0xFFFF0FFF;
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801AD6E) --------------------------------------------------------
int __fastcall sub_801AD6E(int result, int a2, int a3, char a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x100u;
  v4 = (a2 << 8) & 0xA00 | *(_DWORD *)(result + 32) & 0xFFFFF5FF;
  *(_DWORD *)(result + 28) = *(_DWORD *)(result + 28) & 0xFFFFFF0C | a3 & 0xFFFFFF0F | (unsigned __int8)(16 * a4);
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801ADA0) --------------------------------------------------------
int __fastcall sub_801ADA0(int result, int a2, int a3, __int16 a4)
{
  unsigned int v4; // r1

  *(_DWORD *)(result + 32) &= ~0x1000u;
  v4 = (a2 << 12) & 0xA000 | *(_DWORD *)(result + 32) & 0xFFFF5FFF;
  *(_DWORD *)(result + 28) = (unsigned __int16)(a4 << 12)
                           | *(_DWORD *)(result + 28) & 0xFFFF0CFF
                           | (a3 << 8) & 0xFFFF0FFF;
  *(_DWORD *)(result + 32) = v4;
  return result;
}

//----- (0801ADD8) --------------------------------------------------------
int sub_801ADD8(int a1, ...)
{
  int result; // r0
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  result = (unsigned __int8)byte_200037D5;
  if ( byte_200037D5 == 2 )
  {
    sub_801E9AC(a1, (int)varg_r1);
    return 0;
  }
  return result;
}
// 200037D5: using guessed type char byte_200037D5;

//----- (0801AE8C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall SysTick_handler(_DWORD **a1, _DWORD *a2, int a3)
{
  char v3; // r4
  int v4; // r5

  *(_BYTE *)(a3 + 3) = v3;
  sub_80152FC(a1, a2, a3);
  sub_8015588((int)&dword_20001B44, 0);
  return sub_8015588(v4 + 452, 4);
}
// 801AEA2: positive sp value 20 has been found
// 801AE8C: could not find valid save-restore pair for r6
// 801AE8C: could not find valid save-restore pair for r7
// 801AE8C: could not find valid save-restore pair for r8
// 801AE8C: could not find valid save-restore pair for r9
// 801AE8C: could not find valid save-restore pair for r10
// 801AE8C: variable 'v3' is possibly undefined
// 801AE9A: variable 'v4' is possibly undefined
// 20001B44: using guessed type int dword_20001B44;

//----- (0801AEB8) --------------------------------------------------------
int sub_801AEB8()
{
  return sub_80156B4((int)&dword_20001B44, 12);
}
// 20001B44: using guessed type int dword_20001B44;

//----- (0801AEC4) --------------------------------------------------------
int sub_801AEC4()
{
  return sub_8015588((int)&dword_20001B44, 12);
}
// 20001B44: using guessed type int dword_20001B44;

//----- (0801AED0) --------------------------------------------------------
int sub_801AED0()
{
  return sub_801AEDC();
}
// 801AEDC: using guessed type int sub_801AEDC(void);

//----- (0801AEDC) --------------------------------------------------------
void __fastcall sub_801AEDC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // r4
  int i; // r0

  dword_20001A14 = 1073827840;
  dword_20001A18 = 169;
  dword_20001A1C = v10;
  dword_20001A20 = 65534;
  sub_8014C78((int)&dword_20001A14);
  a5 = 10;
  a6 = 1;
  a7 = v10;
  a8 = v10;
  sub_8014BB8((int)&dword_20001A14, &a5, 0);
  if ( sub_80149B8(&dword_20001A14, 3, 0) )
    sub_8005C1C();
  for ( i = 0; i < 4; ++i )
    dword_20001A04[i] = 10000;
  sub_8014D04((unsigned __int8 *)&dword_20001A14, 0);
  __asm { POP             {R0-R4,PC} }
}
// 801AF34: unbalanced stack, ignored a potential tail call
// 801AEE6: variable 'v10' is possibly undefined
// 8005C1C: using guessed type void __noreturn sub_8005C1C(void);
// 20001A04: using guessed type _DWORD dword_20001A04[4];
// 20001A14: using guessed type int dword_20001A14;
// 20001A18: using guessed type int dword_20001A18;
// 20001A1C: using guessed type int dword_20001A1C;
// 20001A20: using guessed type int dword_20001A20;

//----- (0801AF40) --------------------------------------------------------
int sub_801AF40()
{
  dword_20001AAC = 1073818624;
  dword_20001AB0 = 16;
  dword_20001AB4 = 0;
  dword_20001AB8 = 399;
  dword_20001ABC = 0;
  dword_20001AC0 = 0;
  dword_20001AC4 = 128;
  sub_8015432((int)&dword_20001AAC);
  dword_200019B0 = 96;
  dword_200019B4 = 200;
  dword_200019BC = 0;
  dword_200019C0 = 0;
  dword_200019C8 = 0;
  sub_80152FC((_DWORD **)&dword_20001AAC, &dword_200019B0, 0);
  sub_80148DC((int)&dword_20001AAC, 0);
  return sub_801AF98(200);
}
// 200019B0: using guessed type int dword_200019B0;
// 200019B4: using guessed type int dword_200019B4;
// 200019BC: using guessed type int dword_200019BC;
// 200019C0: using guessed type int dword_200019C0;
// 200019C8: using guessed type int dword_200019C8;
// 20001AAC: using guessed type int dword_20001AAC;
// 20001AB0: using guessed type int dword_20001AB0;
// 20001AB4: using guessed type int dword_20001AB4;
// 20001AB8: using guessed type int dword_20001AB8;
// 20001ABC: using guessed type int dword_20001ABC;
// 20001AC0: using guessed type int dword_20001AC0;
// 20001AC4: using guessed type int dword_20001AC4;

//----- (0801AF98) --------------------------------------------------------
int __fastcall sub_801AF98(int result)
{
  if ( result <= 400 )
  {
    if ( result < 0 )
      result = 0;
  }
  else
  {
    result = 400;
  }
  *(_DWORD *)(dword_20001AAC + 52) = result;
  return result;
}
// 20001AAC: using guessed type int dword_20001AAC;

//----- (0801AFB8) --------------------------------------------------------
unsigned int __fastcall sub_801AFB8(unsigned int result)
{
  if ( result > 0xE77 )
    result = 3704;
  *(_DWORD *)(dword_20001B44 + 52) = result;
  return result;
}
// 20001B44: using guessed type int dword_20001B44;

//----- (0801AFD0) --------------------------------------------------------
unsigned int __fastcall sub_801AFD0(unsigned int result)
{
  if ( result > 0xE77 )
    result = 3704;
  *(_DWORD *)(dword_20001B90 + 56) = result;
  return result;
}
// 20001B90: using guessed type int dword_20001B90;

//----- (0801AFE8) --------------------------------------------------------
int sub_801AFE8()
{
  dword_20001A60 = 1073746944;
  dword_20001A64 = 169;
  dword_20001A68 = 0;
  return IRQ_80_handler();
}
// 801AFFC: using guessed type int IRQ_80_handler(void);
// 20001A60: using guessed type int dword_20001A60;
// 20001A64: using guessed type int dword_20001A64;
// 20001A68: using guessed type int dword_20001A68;

//----- (0801AFFC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall IRQ_80_handler(int a1, int a2)
{
  *(_DWORD *)(a1 + 12) = a2;
  sub_8014A4A(a1);
  return IRQ_30_handler(&dword_20001A60);
}
// 801B006: positive sp value 8 has been found
// 20001A60: using guessed type int dword_20001A60;

//----- (0801B018) --------------------------------------------------------
int __fastcall sub_801B018(_WORD *a1, unsigned int a2)
{
  if ( *a1 )
  {
    if ( (unsigned __int16)(word_20000028 - *a1) >= a2 )
    {
      *a1 = 0;
      return 1;
    }
  }
  else
  {
    *a1 = word_20000028;
  }
  return 0;
}
// 20000028: using guessed type __int16 word_20000028;

//----- (0801B040) --------------------------------------------------------
int __fastcall sub_801B040(_WORD *a1, unsigned int a2)
{
  if ( *a1 )
  {
    if ( (unsigned __int16)(word_2000002A - *a1) >= a2 )
    {
      *a1 = 0;
      return 1;
    }
  }
  else
  {
    *a1 = word_2000002A;
  }
  return 0;
}
// 2000002A: using guessed type __int16 word_2000002A;

//----- (0801B068) --------------------------------------------------------
void sub_801B068()
{
  if ( dword_200051A0 + 20 <= (unsigned int)dword_2000002C || (unsigned int)dword_2000002C <= 0x15 )
  {
    dword_200004FC = 0;
  }
  else if ( dword_20005198 >= dword_20002FC7 )
  {
    if ( dword_2000519C <= dword_20002FCB )
      dword_200004FC = 0;
    else
      dword_200004FC = 2500;
  }
  else
  {
    dword_200004FC = -2500;
  }
  sub_8003234();
}
// 2000002C: using guessed type int dword_2000002C;
// 200004FC: using guessed type int dword_200004FC;
// 20002FC7: using guessed type int dword_20002FC7;
// 20002FCB: using guessed type int dword_20002FCB;
// 20005198: using guessed type int dword_20005198;
// 2000519C: using guessed type int dword_2000519C;
// 200051A0: using guessed type int dword_200051A0;

//----- (0801B0C8) --------------------------------------------------------
int __fastcall sub_801B0C8(int result)
{
  int v1; // r1

  if ( *(_DWORD *)(result + 100) )
  {
    v1 = (*(_DWORD *)(*(_DWORD *)result + 8) >> 25) & 7;
    *(_WORD *)(result + 106) = 8
                             * (unsigned int)*((unsigned __int8 *)dword_80268A4
                                             + (*(_DWORD *)(*(_DWORD *)result + 8) >> 29))
                             / *((unsigned __int8 *)&dword_80268A4[2] + (*(_DWORD *)(*(_DWORD *)result + 8) >> 29));
    *(_WORD *)(result + 104) = 8
                             * (unsigned int)*((unsigned __int8 *)dword_80268A4 + v1)
                             / *((unsigned __int8 *)&dword_80268A4[2] + v1);
  }
  else
  {
    result += 104;
    *(_WORD *)(result + 2) = 1;
    *(_WORD *)result = 1;
  }
  return result;
}
// 80268A4: using guessed type int dword_80268A4[4];

//----- (0801B110) --------------------------------------------------------
int __fastcall sub_801B110(int result)
{
  int v1; // r1
  int v2; // r2

  if ( *(unsigned __int8 *)(result + 40) << 31 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFDFFFF | *(_DWORD *)(result + 44);
  if ( (*(_BYTE *)(result + 40) & 2) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFEFFFF | *(_DWORD *)(result + 48);
  if ( (*(_BYTE *)(result + 40) & 4) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFBFFFF | *(_DWORD *)(result + 52);
  if ( (*(_BYTE *)(result + 40) & 8) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFFF7FFF | *(_DWORD *)(result + 56);
  if ( (*(_BYTE *)(result + 40) & 0x10) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 8) = *(_DWORD *)(*(_DWORD *)result + 8) & 0xFFFFEFFF | *(_DWORD *)(result + 60);
  if ( (*(_BYTE *)(result + 40) & 0x20) != 0 )
    *(_DWORD *)(*(_DWORD *)result + 8) = *(_DWORD *)(*(_DWORD *)result + 8) & 0xFFFFDFFF | *(_DWORD *)(result + 64);
  if ( (*(_BYTE *)(result + 40) & 0x40) != 0 )
  {
    *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFFEFFFFF | *(_DWORD *)(result + 68);
    if ( *(_DWORD *)(result + 68) == 0x100000 )
      *(_DWORD *)(*(_DWORD *)result + 4) = *(_DWORD *)(*(_DWORD *)result + 4) & 0xFF9FFFFF | *(_DWORD *)(result + 72);
  }
  if ( (*(_BYTE *)(result + 40) & 0x80) != 0 )
  {
    v1 = *(_DWORD *)result;
    v2 = *(_DWORD *)(*(_DWORD *)result + 4);
    result = *(_DWORD *)(result + 76);
    *(_DWORD *)(v1 + 4) = v2 & 0xFFF7FFFF | result;
  }
  return result;
}

//----- (0801B1D8) --------------------------------------------------------
int __fastcall sub_801B1D8(int a1)
{
  int v2; // r7
  int v4; // r4

  *(_DWORD *)(a1 + 140) = 0;
  v2 = sub_8012948();
  if ( (**(_DWORD **)a1 & 8) != 0 && sub_801BC1C((unsigned int **)a1, 0x200000, 0, v2, 0x1FFFFFFu)
    || (**(_DWORD **)a1 & 4) != 0 && sub_801BC1C((unsigned int **)a1, 0x400000, 0, v2, 0x1FFFFFFu) )
  {
    return 3;
  }
  v4 = a1 + 108;
  *(_DWORD *)(v4 + 24) = 32;
  *(_DWORD *)(v4 + 28) = 32;
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(v4 + 20) = 0;
  return 0;
}

//----- (0801B238) --------------------------------------------------------
int __fastcall sub_801B238(int a1)
{
  int v1; // r0

  v1 = *(_DWORD *)(a1 + 40);
  *(_WORD *)(v1 + 94) = 0;
  *(_WORD *)(v1 + 86) = 0;
  return nullsub_32();
}
// 80159F8: using guessed type int nullsub_32(void);

//----- (0801B24C) --------------------------------------------------------
int __fastcall sub_801B24C(int a1)
{
  int v1; // r4
  int v2; // r5

  v1 = *(_DWORD *)(a1 + 40);
  v2 = *(_DWORD *)(v1 + 136);
  if ( (*(_DWORD *)(*(_DWORD *)v1 + 8) & 0x80) != 0 && *(_DWORD *)(v1 + 132) == 33 )
  {
    *(_WORD *)(v1 + 86) = 0;
    sub_801B388(v1);
  }
  if ( (*(_DWORD *)(*(_DWORD *)v1 + 8) & 0x40) != 0 && v2 == 34 )
  {
    *(_WORD *)(v1 + 94) = 0;
    sub_801B310(v1);
  }
  *(_DWORD *)(v1 + 140) |= 0x10u;
  return nullsub_32(v1);
}
// 80159F8: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801B29C) --------------------------------------------------------
int __fastcall sub_801B29C(int a1)
{
  _DWORD *v1; // r0

  v1 = *(_DWORD **)(a1 + 40);
  *((_WORD *)v1 + 47) = 0;
  *(_DWORD *)(*v1 + 32) = 15;
  *(_DWORD *)(*v1 + 24) |= 8u;
  v1[34] = 32;
  v1[27] = 0;
  return nullsub_30();
}
// 80158F2: using guessed type int nullsub_30(void);

//----- (0801B2C4) --------------------------------------------------------
int __fastcall sub_801B2C4(int a1)
{
  int result; // r0
  unsigned int *v3; // r1
  unsigned int v4; // r2
  unsigned int *v5; // r1
  unsigned int v6; // r2

  result = *(_DWORD *)(a1 + 40);
  if ( (**(_DWORD **)a1 & 0x20) != 0 )
    return nullsub_33(result);
  *(_WORD *)(result + 86) = 0;
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xFFFFFF7F, v3) );
  do
  {
    v5 = *(unsigned int **)result;
    v6 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v6 | 0x40, v5) );
  return result;
}
// 8016078: using guessed type int __fastcall nullsub_33(_DWORD);

//----- (0801B306) --------------------------------------------------------
int __fastcall sub_801B306(int a1)
{
  return nullsub_34(*(_DWORD *)(a1 + 40));
}
// 801607A: using guessed type int __fastcall nullsub_34(_DWORD);

//----- (0801B310) --------------------------------------------------------
int __fastcall sub_801B310(int result)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2
  unsigned int *v3; // r1
  unsigned int v4; // r2
  unsigned int *v5; // r1
  unsigned int v6; // r2

  do
  {
    v1 = *(unsigned int **)result;
    v2 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v2 & 0xFFFFFEDF, v1) );
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xEFFFFFFE, v3) );
  if ( *(_DWORD *)(result + 108) == 1 )
  {
    do
    {
      v5 = *(unsigned int **)result;
      v6 = __ldrex(*(unsigned int **)result);
    }
    while ( __strex(v6 & 0xFFFFFFEF, v5) );
  }
  *(_DWORD *)(result + 136) = 32;
  *(_DWORD *)(result + 108) = 0;
  *(_DWORD *)(result + 112) = 0;
  return result;
}

//----- (0801B364) --------------------------------------------------------
int __fastcall sub_801B364(int a1)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2

  do
  {
    v1 = *(unsigned int **)a1;
    v2 = __ldrex(*(unsigned int **)a1);
  }
  while ( __strex(v2 & 0xFFFFFFBF, v1) );
  *(_DWORD *)(a1 + 132) = 32;
  *(_DWORD *)(a1 + 116) = 0;
  return nullsub_33(a1);
}
// 8016078: using guessed type int __fastcall nullsub_33(_DWORD);

//----- (0801B388) --------------------------------------------------------
int __fastcall sub_801B388(int result)
{
  unsigned int *v1; // r1
  unsigned int v2; // r2
  unsigned int *v3; // r1
  unsigned int v4; // r2

  do
  {
    v1 = *(unsigned int **)result;
    v2 = __ldrex(*(unsigned int **)result);
  }
  while ( __strex(v2 & 0xFFFFFF3F, v1) );
  do
  {
    v3 = (unsigned int *)(*(_DWORD *)result + 8);
    v4 = __ldrex(v3);
  }
  while ( __strex(v4 & 0xFF7FFFFF, v3) );
  *(_DWORD *)(result + 132) = 32;
  return result;
}

//----- (0801B3B6) --------------------------------------------------------
int __fastcall sub_801B3B6(int *a1)
{
  __int16 v1; // r2
  int v2; // r1
  int result; // r0
  int *v4; // r0
  _WORD *v5; // t1
  int v6; // r1
  unsigned int *v7; // r1
  unsigned int v8; // r2
  unsigned int *v9; // r1
  unsigned int v10; // r2
  unsigned int *v11; // r1
  unsigned int v12; // r2

  v1 = *((_WORD *)a1 + 48);
  v2 = *a1;
  if ( a1[34] == 34 )
  {
    v5 = (_WORD *)a1[22];
    v4 = a1 + 22;
    *v5 = *(_DWORD *)(v2 + 36) & v1;
    *v4 += 2;
    v6 = (unsigned __int16)--*((_WORD *)v4 + 3);
    result = (int)(v4 - 22);
    if ( !v6 )
    {
      do
      {
        v7 = *(unsigned int **)result;
        v8 = __ldrex(*(unsigned int **)result);
      }
      while ( __strex(v8 & 0xFFFFFEDF, v7) );
      do
      {
        v9 = (unsigned int *)(*(_DWORD *)result + 8);
        v10 = __ldrex(v9);
      }
      while ( __strex(v10 & 0xFFFFFFFE, v9) );
      *(_DWORD *)(result + 136) = 32;
      *(_DWORD *)(result + 112) = 0;
      if ( *(_DWORD *)(result + 108) == 1 )
      {
        *(_DWORD *)(result + 108) = 0;
        do
        {
          v11 = *(unsigned int **)result;
          v12 = __ldrex(*(unsigned int **)result);
        }
        while ( __strex(v12 & 0xFFFFFFEF, v11) );
        if ( (~*(_DWORD *)(*(_DWORD *)result + 28) & 0x10) == 0 )
          *(_DWORD *)(*(_DWORD *)result + 32) = 16;
        return nullsub_26(result, *(unsigned __int16 *)(result + 92));
      }
      else
      {
        return sub_8015EE4((int *)result);
      }
    }
  }
  else
  {
    result = *(_DWORD *)(v2 + 24) | 8;
    *(_DWORD *)(v2 + 24) = result;
  }
  return result;
}
// 8015852: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);

//----- (0801B458) --------------------------------------------------------
unsigned int *__fastcall sub_801B458(_DWORD *a1)
{
  __int16 v2; // r7
  unsigned int *result; // r0
  unsigned int v4; // r5
  unsigned int v5; // r9
  unsigned int v6; // r6
  int v7; // r8
  unsigned int *v8; // r0
  unsigned int v9; // r1
  unsigned int *v10; // r0
  unsigned int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int *v15; // r0
  unsigned int v16; // r1

  v2 = *((_WORD *)a1 + 48);
  result = (unsigned int *)*a1;
  v4 = result[7];
  v5 = *result;
  v6 = result[2];
  if ( a1[34] == 34 )
  {
    v7 = *((unsigned __int16 *)a1 + 52);
    while ( v7 && (v4 & 0x20) != 0 )
    {
      *(_WORD *)a1[22] = *(_DWORD *)(*a1 + 36) & v2;
      a1[22] += 2;
      --*((_WORD *)a1 + 47);
      v4 = *(_DWORD *)(*a1 + 28);
      if ( v4 << 29 )
      {
        if ( v4 << 31 && (v5 & 0x100) != 0 )
        {
          *(_DWORD *)(*a1 + 32) = 1;
          a1[35] |= 1u;
        }
        if ( (v4 & 2) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 2;
          a1[35] |= 4u;
        }
        if ( (v4 & 4) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 4;
          a1[35] |= 2u;
        }
        if ( a1[35] )
        {
          nullsub_32(a1);
          a1[35] = 0;
        }
      }
      if ( !*((_WORD *)a1 + 47) )
      {
        do
        {
          v8 = (unsigned int *)*a1;
          v9 = __ldrex((unsigned int *)*a1);
        }
        while ( __strex(v9 & 0xFFFFFEFF, v8) );
        do
        {
          v10 = (unsigned int *)(*a1 + 8);
          v11 = __ldrex(v10);
        }
        while ( __strex(v11 & 0xEFFFFFFE, v10) );
        a1[34] = 32;
        a1[28] = 0;
        if ( a1[27] == 1 )
        {
          a1[27] = 0;
          do
          {
            v15 = (unsigned int *)*a1;
            v16 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v16 & 0xFFFFFFEF, v15) );
          if ( (~*(_DWORD *)(*a1 + 28) & 0x10) == 0 )
            *(_DWORD *)(*a1 + 32) = 16;
          nullsub_26(a1, *((unsigned __int16 *)a1 + 46));
        }
        else
        {
          sub_8015EE4(a1);
        }
      }
    }
    result = (unsigned int *)*((unsigned __int16 *)a1 + 47);
    if ( *((_WORD *)a1 + 47) && *((unsigned __int16 *)a1 + 52) > (unsigned int)result )
    {
      do
      {
        v12 = (unsigned int *)(*a1 + 8);
        v13 = __ldrex(v12);
      }
      while ( __strex(v13 & 0xEFFFFFFF, v12) );
      a1[28] = 134331319;
      do
      {
        result = (unsigned int *)*a1;
        v14 = __ldrex((unsigned int *)*a1);
      }
      while ( __strex(v14 | 0x20, result) );
    }
  }
  else
  {
    result[6] |= 8u;
  }
  return result;
}
// 8015852: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 80159F8: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801B5CC) --------------------------------------------------------
int __fastcall sub_801B5CC(int *a1)
{
  __int16 v1; // r2
  int v2; // r1
  int result; // r0
  int *v4; // r0
  _BYTE *v5; // t1
  int v6; // r1
  unsigned int *v7; // r1
  unsigned int v8; // r2
  unsigned int *v9; // r1
  unsigned int v10; // r2
  unsigned int *v11; // r1
  unsigned int v12; // r2

  v1 = *((_WORD *)a1 + 48);
  v2 = *a1;
  if ( a1[34] == 34 )
  {
    v5 = (_BYTE *)a1[22];
    v4 = a1 + 22;
    *v5 = *(_DWORD *)(v2 + 36) & v1;
    ++*v4;
    v6 = (unsigned __int16)--*((_WORD *)v4 + 3);
    result = (int)(v4 - 22);
    if ( !v6 )
    {
      do
      {
        v7 = *(unsigned int **)result;
        v8 = __ldrex(*(unsigned int **)result);
      }
      while ( __strex(v8 & 0xFFFFFEDF, v7) );
      do
      {
        v9 = (unsigned int *)(*(_DWORD *)result + 8);
        v10 = __ldrex(v9);
      }
      while ( __strex(v10 & 0xFFFFFFFE, v9) );
      *(_DWORD *)(result + 136) = 32;
      *(_DWORD *)(result + 112) = 0;
      if ( *(_DWORD *)(result + 108) == 1 )
      {
        *(_DWORD *)(result + 108) = 0;
        do
        {
          v11 = *(unsigned int **)result;
          v12 = __ldrex(*(unsigned int **)result);
        }
        while ( __strex(v12 & 0xFFFFFFEF, v11) );
        if ( (~*(_DWORD *)(*(_DWORD *)result + 28) & 0x10) == 0 )
          *(_DWORD *)(*(_DWORD *)result + 32) = 16;
        return nullsub_26(result, *(unsigned __int16 *)(result + 92));
      }
      else
      {
        return sub_8015EE4((int *)result);
      }
    }
  }
  else
  {
    result = *(_DWORD *)(v2 + 24) | 8;
    *(_DWORD *)(v2 + 24) = result;
  }
  return result;
}
// 8015852: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);

//----- (0801B66C) --------------------------------------------------------
unsigned int *__fastcall sub_801B66C(_DWORD *a1)
{
  __int16 v2; // r7
  unsigned int *result; // r0
  unsigned int v4; // r5
  unsigned int v5; // r9
  unsigned int v6; // r6
  int v7; // r8
  unsigned int *v8; // r0
  unsigned int v9; // r1
  unsigned int *v10; // r0
  unsigned int v11; // r1
  unsigned int *v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r1
  unsigned int *v15; // r0
  unsigned int v16; // r1

  v2 = *((_WORD *)a1 + 48);
  result = (unsigned int *)*a1;
  v4 = result[7];
  v5 = *result;
  v6 = result[2];
  if ( a1[34] == 34 )
  {
    v7 = *((unsigned __int16 *)a1 + 52);
    while ( v7 && (v4 & 0x20) != 0 )
    {
      *(_BYTE *)a1[22]++ = *(_DWORD *)(*a1 + 36) & v2;
      --*((_WORD *)a1 + 47);
      v4 = *(_DWORD *)(*a1 + 28);
      if ( v4 << 29 )
      {
        if ( v4 << 31 && (v5 & 0x100) != 0 )
        {
          *(_DWORD *)(*a1 + 32) = 1;
          a1[35] |= 1u;
        }
        if ( (v4 & 2) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 2;
          a1[35] |= 4u;
        }
        if ( (v4 & 4) != 0 && v6 << 31 )
        {
          *(_DWORD *)(*a1 + 32) = 4;
          a1[35] |= 2u;
        }
        if ( a1[35] )
        {
          nullsub_32(a1);
          a1[35] = 0;
        }
      }
      if ( !*((_WORD *)a1 + 47) )
      {
        do
        {
          v8 = (unsigned int *)*a1;
          v9 = __ldrex((unsigned int *)*a1);
        }
        while ( __strex(v9 & 0xFFFFFEFF, v8) );
        do
        {
          v10 = (unsigned int *)(*a1 + 8);
          v11 = __ldrex(v10);
        }
        while ( __strex(v11 & 0xEFFFFFFE, v10) );
        a1[34] = 32;
        a1[28] = 0;
        if ( a1[27] == 1 )
        {
          a1[27] = 0;
          do
          {
            v15 = (unsigned int *)*a1;
            v16 = __ldrex((unsigned int *)*a1);
          }
          while ( __strex(v16 & 0xFFFFFFEF, v15) );
          if ( (~*(_DWORD *)(*a1 + 28) & 0x10) == 0 )
            *(_DWORD *)(*a1 + 32) = 16;
          nullsub_26(a1, *((unsigned __int16 *)a1 + 46));
        }
        else
        {
          sub_8015EE4(a1);
        }
      }
    }
    result = (unsigned int *)*((unsigned __int16 *)a1 + 47);
    if ( *((_WORD *)a1 + 47) && *((unsigned __int16 *)a1 + 52) > (unsigned int)result )
    {
      do
      {
        v12 = (unsigned int *)(*a1 + 8);
        v13 = __ldrex(v12);
      }
      while ( __strex(v13 & 0xEFFFFFFF, v12) );
      a1[28] = 134331853;
      do
      {
        result = (unsigned int *)*a1;
        v14 = __ldrex((unsigned int *)*a1);
      }
      while ( __strex(v14 | 0x20, result) );
    }
  }
  else
  {
    result[6] |= 8u;
  }
  return result;
}
// 8015852: using guessed type int __fastcall nullsub_26(_DWORD, _DWORD);
// 80159F8: using guessed type int __fastcall nullsub_32(_DWORD);

//----- (0801B7E0) --------------------------------------------------------
int __fastcall sub_801B7E0(_DWORD *a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r2
  int v5; // r0
  int v6; // r1
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r6
  signed __int64 v15; // r0
  unsigned int v16; // r2
  unsigned __int64 v17; // r0
  unsigned int v18; // r0
  unsigned int v19; // r0
  _DWORD *v20; // r4

  v2 = 0;
  *(_DWORD *)*a1 = *(_DWORD *)*a1 & 0xCFFF69F3 | a1[2] | a1[4] | a1[5] | a1[7];
  *(_DWORD *)(*a1 + 4) = *(_DWORD *)(*a1 + 4) & 0xFFFFCFFF | a1[3];
  v3 = a1[6];
  if ( *a1 != 1073774592 )
    v3 |= a1[8];
  *(_DWORD *)(*a1 + 8) = *(_DWORD *)(*a1 + 8) & 0x11FFF4FF | v3;
  *(_DWORD *)(*a1 + 44) = *(_DWORD *)(*a1 + 44) & 0xFFFFFFF0 | a1[9];
  v4 = *a1;
  if ( *a1 == 1073821696 )
  {
    v5 = MEMORY[0x40021088] & 3;
    if ( (MEMORY[0x40021088] & 3) != 0 )
    {
      switch ( v5 )
      {
        case 1:
          v6 = 4;
          break;
        case 2:
          v6 = 2;
          break;
        case 3:
          v6 = 8;
          break;
        default:
          v6 = 16;
          break;
      }
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    switch ( v4 )
    {
      case 1073759232:
        v7 = MEMORY[0x40021088] & 0xC;
        if ( (MEMORY[0x40021088] & 0xC) != 0 )
        {
          switch ( v7 )
          {
            case 4:
              v6 = 4;
              break;
            case 8:
              v6 = 2;
              break;
            case 12:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073760256:
        v8 = MEMORY[0x40021088] & 0x30;
        if ( (MEMORY[0x40021088] & 0x30) != 0 )
        {
          switch ( v8 )
          {
            case 16:
              v6 = 4;
              break;
            case 32:
              v6 = 2;
              break;
            case 48:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073761280:
        v9 = MEMORY[0x40021088] & 0xC0;
        if ( (MEMORY[0x40021088] & 0xC0) != 0 )
        {
          switch ( v9 )
          {
            case 64:
              v6 = 4;
              break;
            case 128:
              v6 = 2;
              break;
            case 192:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073762304:
        v10 = MEMORY[0x40021088] & 0x300;
        if ( (MEMORY[0x40021088] & 0x300) != 0 )
        {
          switch ( v10 )
          {
            case 256:
              v6 = 4;
              break;
            case 512:
              v6 = 2;
              break;
            case 768:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      case 1073774592:
        v11 = MEMORY[0x40021088] & 0xC00;
        if ( (MEMORY[0x40021088] & 0xC00) != 0 )
        {
          switch ( v11 )
          {
            case 1024:
              v6 = 4;
              break;
            case 2048:
              v6 = 2;
              break;
            case 3072:
              v6 = 8;
              break;
            default:
              v6 = 16;
              break;
          }
        }
        else
        {
          v6 = 0;
        }
        break;
      default:
        v6 = 16;
        break;
    }
  }
  v12 = 16000000;
  if ( v4 == 1073774592 )
  {
    if ( v6 )
    {
      if ( v6 != 2 )
      {
        if ( v6 == 4 )
        {
          v12 = sub_8014000();
        }
        else if ( v6 == 8 )
        {
          v12 = 0x8000;
        }
        else
        {
          v12 = 0;
          v2 = 1;
        }
      }
    }
    else
    {
      v12 = sub_8013FB8();
    }
    if ( v12 )
    {
      v13 = v12 / *((unsigned __int16 *)dword_802688C + a1[9]);
      v14 = a1[1];
      if ( 3 * v14 <= v13 && v13 <= v14 << 12 )
      {
        v15 = v12 / (unsigned __int64)*((unsigned __int16 *)dword_802688C + a1[9]);
        HIDWORD(v15) = v15 >> 24;
        v16 = (_DWORD)v15 << 8;
        LODWORD(v15) = v14 >> 1;
        v17 = ((unsigned __int64)v16 + v15) / v14;
        if ( (unsigned int)(v17 - 768) > 0xFFCFF )
          v2 = 1;
        else
          *(_DWORD *)(*a1 + 12) = v17;
      }
      else
      {
        v2 = 1;
      }
    }
  }
  else if ( a1[7] == 0x8000 )
  {
    switch ( v6 )
    {
      case 0:
        v12 = sub_8013FB8();
        break;
      case 1:
        v12 = sub_8013FDC();
        break;
      case 2:
        break;
      case 4:
        v12 = sub_8014000();
        break;
      case 8:
        v12 = 0x8000;
        break;
      default:
        v12 = 0;
        v2 = 1;
        break;
    }
    if ( v12 )
    {
      v18 = (2 * (v12 / *((unsigned __int16 *)dword_802688C + a1[9])) + (a1[1] >> 1)) / a1[1];
      if ( v18 - 16 > 0xFFEF )
        v2 = 1;
      else
        *(_DWORD *)(*a1 + 12) = v18 & 0xFFF0 | (v18 >> 1) & 7;
    }
  }
  else
  {
    switch ( v6 )
    {
      case 0:
        v12 = sub_8013FB8();
        break;
      case 1:
        v12 = sub_8013FDC();
        break;
      case 2:
        break;
      case 4:
        v12 = sub_8014000();
        break;
      case 8:
        v12 = 0x8000;
        break;
      default:
        v12 = 0;
        v2 = 1;
        break;
    }
    if ( v12 )
    {
      v19 = (v12 / *((unsigned __int16 *)dword_802688C + a1[9]) + (a1[1] >> 1)) / a1[1];
      if ( v19 - 16 > 0xFFEF )
        v2 = 1;
      else
        *(_DWORD *)(*a1 + 12) = (unsigned __int16)v19;
    }
  }
  v20 = a1 + 26;
  *((_WORD *)v20 + 1) = 1;
  *(_WORD *)v20 = 1;
  v20[2] = 0;
  v20[3] = 0;
  return v2;
}
// 801BAC4: using guessed type int dword_801BAC4;
// 802688C: using guessed type int dword_802688C[6];

//----- (0801BAF0) --------------------------------------------------------
int __fastcall sub_801BAF0(int a1, int a2, unsigned int a3)
{
  int v3; // r1
  unsigned int *v4; // r1
  unsigned int v5; // r3
  unsigned int *v6; // r1
  unsigned int v7; // r2
  unsigned int *v8; // r1
  unsigned int v9; // r2
  unsigned int *v10; // r1
  unsigned int v11; // r2
  unsigned int *v12; // r1
  unsigned int v13; // r2

  *(_DWORD *)(a1 + 88) = a2;
  *(_WORD *)(a1 + 92) = a3;
  *(_WORD *)(a1 + 94) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 == 4096 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      *(_WORD *)(a1 + 96) = 255;
    else
      *(_WORD *)(a1 + 96) = 511;
  }
  else if ( v3 )
  {
    if ( v3 == 0x10000000 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        *(_WORD *)(a1 + 96) = 63;
      else
        *(_WORD *)(a1 + 96) = 127;
    }
    else
    {
      *(_WORD *)(a1 + 96) = 0;
    }
  }
  else if ( *(_DWORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 96) = 127;
  }
  else
  {
    *(_WORD *)(a1 + 96) = 255;
  }
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 136) = 34;
  do
  {
    v4 = (unsigned int *)(*(_DWORD *)a1 + 8);
    v5 = __ldrex(v4);
  }
  while ( __strex(v5 | 1, v4) );
  if ( *(_DWORD *)(a1 + 100) == 0x20000000 && *(unsigned __int16 *)(a1 + 104) <= a3 )
  {
    if ( *(_DWORD *)(a1 + 8) == 4096 && !*(_DWORD *)(a1 + 16) )
      *(_DWORD *)(a1 + 112) = 134331481;
    else
      *(_DWORD *)(a1 + 112) = 134332013;
    *(_BYTE *)(a1 + 128) = 0;
    if ( *(_DWORD *)(a1 + 16) )
    {
      do
      {
        v6 = *(unsigned int **)a1;
        v7 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v7 | 0x100, v6) );
    }
    do
    {
      v8 = (unsigned int *)(*(_DWORD *)a1 + 8);
      v9 = __ldrex(v8);
    }
    while ( __strex(v9 | 0x10000000, v8) );
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) == 4096 && !*(_DWORD *)(a1 + 16) )
      *(_DWORD *)(a1 + 112) = 134331319;
    else
      *(_DWORD *)(a1 + 112) = 134331853;
    *(_BYTE *)(a1 + 128) = 0;
    if ( *(_DWORD *)(a1 + 16) )
    {
      do
      {
        v10 = *(unsigned int **)a1;
        v11 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v11 | 0x120, v10) );
    }
    else
    {
      do
      {
        v12 = *(unsigned int **)a1;
        v13 = __ldrex(*(unsigned int **)a1);
      }
      while ( __strex(v13 | 0x20, v12) );
    }
  }
  return 0;
}

//----- (0801BC1C) --------------------------------------------------------
int __fastcall sub_801BC1C(unsigned int **a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int *v9; // r0
  unsigned int v10; // r1
  unsigned int *v11; // r0
  unsigned int v12; // r1
  unsigned int **v13; // r4
  unsigned int *v15; // r0
  unsigned int v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r1
  unsigned int **v19; // r4

  while ( 1 )
  {
    do
    {
      if ( ((a2 & ~(*a1)[7]) == 0) != a3 )
        return 0;
    }
    while ( a5 == -1 );
    if ( sub_8012948() - a4 > a5 || !a5 )
      break;
    if ( (**a1 & 4) != 0 && (~(*a1)[7] & 0x800) == 0 )
    {
      (*a1)[8] = 2048;
      do
      {
        v9 = *a1;
        v10 = __ldrex(*a1);
      }
      while ( __strex(v10 & 0xFFFFFE5F, v9) );
      do
      {
        v11 = *a1 + 2;
        v12 = __ldrex(v11);
      }
      while ( __strex(v12 & 0xFFFFFFFE, v11) );
      v13 = a1 + 32;
      v13[1] = (unsigned int *)32;
      v13[2] = (unsigned int *)32;
      v13[3] = (unsigned int *)32;
      *(_BYTE *)v13 = 0;
      return 3;
    }
  }
  do
  {
    v15 = *a1;
    v16 = __ldrex(*a1);
  }
  while ( __strex(v16 & 0xFFFFFE5F, v15) );
  do
  {
    v17 = *a1 + 2;
    v18 = __ldrex(v17);
  }
  while ( __strex(v18 & 0xFFFFFFFE, v17) );
  v19 = a1 + 32;
  v19[1] = (unsigned int *)32;
  v19[2] = (unsigned int *)32;
  *(_BYTE *)v19 = 0;
  return 3;
}

//----- (0801BCDC) --------------------------------------------------------
BOOL __fastcall sub_801BCDC(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r0
  int v2; // r0
  unsigned int v3; // r5
  int v4; // r4
  int v5; // r0
  int v6; // r4

  v1 = strstr(a1, "+QIRD:");
  if ( !v1 )
    return 0;
  v2 = sub_80023CE((int)v1, 0x22u);
  if ( !v2 )
    return 0;
  v3 = v2 + 1;
  v4 = sub_80023CE(v2 + 1, 0x22u);
  if ( !v4 )
    return 0;
  dword_20011728 = 0;
  dword_2001172C = 0;
  dword_20011730 = 0;
  dword_20011734 = 0;
  if ( (int)(v4 - v3) > 16 )
    return 0;
  qmemcpy((unsigned int)&dword_20011728, v3, v4 - v3);
  v5 = sub_80023CE(v4, 0x2Cu);
  if ( !v5 )
    return 0;
  v6 = v5 + 1;
  word_200111D2 = sub_8002644((char *)(v5 + 1));
  return sub_80023CE(v6, 0xAu) != 0;
}
// 200111D2: using guessed type __int16 word_200111D2;
// 20011728: using guessed type int dword_20011728;
// 2001172C: using guessed type int dword_2001172C;
// 20011730: using guessed type int dword_20011730;
// 20011734: using guessed type int dword_20011734;

//----- (0801BD64) --------------------------------------------------------
int sub_801BD64()
{
  return sub_80159FC(&dword_20001728);
}
// 20001728: using guessed type int dword_20001728;

//----- (0801BD70) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_801BD70(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  unsigned __int8 *v13; // r5
  unsigned int v14; // r7
  int v15; // r0
  unsigned int v16; // r5
  _BYTE *v17; // r0
  unsigned __int8 *v18; // r0
  __int16 v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r0
  char *v22; // r0
  char *v23; // r0
  __int16 v24; // r0
  unsigned __int8 *v25; // r0
  int v26; // r0
  char *v27; // r0
  unsigned __int8 v28[128]; // [sp-100h] [bp-228h] BYREF
  unsigned __int8 v29[132]; // [sp-80h] [bp-1A8h] BYREF

  sub_8002364(v29, 128);
  sub_8002364(v28, 128);
  if ( byte_200015E9 )
LABEL_108:
    __asm { POP.W           {R4-R11,PC} }
  switch ( byte_200015E7 )
  {
    case 0:
      sub_801ADD8((int)"00000000000000000000000 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801F42C();
        if ( strstr(v29, "OK") )
        {
          sub_801ADD8(
            (int)"%s %d success: %s\r\n",
            " discharge power = %d, real max discharge power = %d.\r\n",
            393,
            (const char *)v29);
          byte_200015E7 = 1;
        }
        else
        {
          sub_801ADD8(
            (int)"%s %d fail: %s\r\n",
            " discharge power = %d, real max discharge power = %d.\r\n",
            398,
            (const char *)v29);
        }
      }
      else
      {
        sub_801F42C();
      }
      goto LABEL_106;
    case 1:
      sub_801ADD8((int)"111111111111111111111111111 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801F42C();
      v13 = strstr(v29, "ip:");
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        412,
        (const char *)v29);
      if ( v13[3] == 48 )
      {
        sub_8023A34(2000);
        byte_200015E7 = 0;
      }
      else if ( v13 )
      {
        v14 = (unsigned int)(v13 + 3);
        v15 = sub_80023CE((int)(v13 + 3), 0x2Cu);
        if ( v15 )
        {
          v16 = v15 - v14;
          if ( (int)(v15 - v14) <= 16 )
          {
            sub_8002364(byte_200111D4, 32);
            dword_20011298 = 0;
            dword_2001129C = 0;
            dword_200112A0 = 0;
            dword_200112A4 = 0;
            qmemcpy((unsigned int)byte_200111D4, v14, v16);
            qmemcpy((unsigned int)&dword_20011298, (unsigned int)byte_200111D4, v16);
            sub_801ADD8(
              (int)"ip:%s %d %s",
              " discharge power = %d, real max discharge power = %d.\r\n",
              429,
              byte_200111D4);
            v17 = sub_8002480(&dword_20011298, 46);
            if ( v17 )
            {
              *v17 = 0;
              sub_800237A((int)&dword_20011298, ".255");
            }
            byte_200015E7 = 2;
          }
        }
      }
      else
      {
        ++byte_200015EC;
      }
      goto LABEL_106;
    case 2:
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        if ( strstr(v29, "OK") )
        {
          sub_801ADD8(
            (int)"%s %d %s\r\n",
            " discharge power = %d, real max discharge power = %d.\r\n",
            453,
            (const char *)v29);
          if ( sub_8025570(dword_20000430, (unsigned int)v28, 400) == 1 )
          {
            sub_801ADD8(
              (int)"%s %d %s\r\n",
              " discharge power = %d, real max discharge power = %d.\r\n",
              455,
              (const char *)v28);
            if ( strstr(v28, "+QIOPEN") )
            {
              v18 = strstr(v28, ",");
              v19 = sub_8002644((char *)v18);
              byte_200015EF = byte_200015EA;
              if ( v19 )
              {
                if ( v19 == 553 )
                {
                  if ( (unsigned __int8)byte_200015EA >= 0xBu )
                    --byte_200015EA;
                  else
                    ++byte_200015EA;
                  byte_200015E7 = 0;
                }
              }
              else
              {
                byte_200015E7 = 3;
              }
            }
            else
            {
              ++byte_200015EC;
            }
            sub_801F42C();
            sub_8002364(&byte_2000401D, 128);
          }
        }
        else
        {
          ++byte_200015EC;
        }
      }
      else
      {
        ++byte_200015EC;
        sub_801F42C();
      }
      goto LABEL_106;
    case 3:
      sub_801ADD8((int)"33333333333333333333333333 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801ADD8(
          (int)"\r\n%s %d %s",
          " discharge power = %d, real max discharge power = %d.\r\n",
          490,
          (const char *)v29);
        JUMPOUT(0x801BFB8);
      }
      goto LABEL_100;
    case 4:
      sub_801ADD8((int)"444444444444444444444444444 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801F42C();
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        521,
        (const char *)v29);
      v20 = strstr(v29, "+QIRD");
      if ( v20
        && (v21 = sub_80023CE((int)v20, 0x2Cu)) != 0
        && (v22 = (char *)(sub_80023CE(v21 + 1, 0x2Cu) + 1), v22 != (char *)1)
        && (word_200015F2 = sub_8002644(v22)) != 0 )
      {
        byte_200015E7 = 5;
        byte_200015E5 = 0;
        byte_200015EC = 0;
        byte_200015DC = 0;
      }
      else
      {
        if ( strstr(v29, "ERROR") )
          ++byte_200015EC;
        if ( (unsigned __int8)byte_200015DC < 5u )
        {
          byte_200015E7 = 4;
          ++byte_200015DC;
        }
        else
        {
          byte_200015DC = 0;
          byte_200015E7 = 3;
          ++byte_200015EC;
        }
      }
      goto LABEL_106;
    case 5:
      sub_801ADD8((int)"55555555555555555555555555 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        565,
        (const char *)v29);
      if ( sub_801BCDC(v29) )
      {
        sub_8002364(v29, 128);
        if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
        {
          sub_801F42C();
          if ( strstr(v29, "ack") )
          {
            byte_200015E7 = 6;
            goto LABEL_106;
          }
        }
        else
        {
          sub_801F42C();
        }
      }
      else
      {
        ++byte_200015DC;
      }
      byte_200015E7 = 4;
LABEL_106:
      if ( (unsigned __int8)byte_200015EC > 5u )
      {
        byte_200015EC = 0;
        byte_200015E7 = 0;
      }
      goto LABEL_108;
    case 6:
      sub_801ADD8((int)"6666666666666666666666666 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        595,
        (const char *)v29);
      if ( strstr(v29, "OK") )
      {
        sub_8002364(v29, 128);
        if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
        {
          sub_801F42C();
          if ( strstr(v29, "ERROR") )
            ++byte_200015EC;
          sub_801ADD8(
            (int)"\r\n%s %d %s",
            " discharge power = %d, real max discharge power = %d.\r\n",
            605,
            (const char *)v29);
          v23 = (char *)(strstr(v29, ",") + 1);
          v24 = sub_8002644(v23);
          byte_200015EE = byte_200015EB;
          if ( v24 )
          {
            if ( v24 == 553 )
            {
              if ( (unsigned __int8)byte_200015EB >= 0xBu )
                --byte_200015EB;
              else
                ++byte_200015EB;
              byte_200015E7 = 6;
              goto LABEL_106;
            }
          }
          else
          {
            byte_200015E7 = 7;
          }
        }
        else
        {
          sub_801F42C();
        }
        byte_200015E7 = 7;
      }
      else
      {
        ++byte_200015EC;
      }
      goto LABEL_106;
    case 7:
      sub_801ADD8((int)"777777777777777777777777777 \r\n");
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801F42C();
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        643,
        (const char *)v29);
      if ( strstr(v29, "+QISEND") )
        byte_200015E7 = 8;
      else
        ++byte_200015EC;
      goto LABEL_106;
    case 8:
      sub_801ADD8((int)sub_801C4D0);
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) != 1 )
        goto LABEL_100;
      sub_801F42C();
      sub_801ADD8(
        (int)"\r\n%s %d %s",
        " discharge power = %d, real max discharge power = %d.\r\n",
        662,
        (const char *)v29);
      v25 = strstr(v29, "+QIRD");
      if ( v25 )
      {
        v26 = sub_80023CE((int)v25, 0x2Cu);
        if ( v26 )
        {
          v27 = (char *)(sub_80023CE(v26 + 1, 0x2Cu) + 1);
          if ( v27 == (char *)1 )
          {
            ++byte_200015EC;
          }
          else
          {
            word_200015F8 = sub_8002644(v27);
            if ( word_200015F8 )
            {
              if ( (unsigned __int16)word_200015F8 > 0x64u )
                word_200015F8 = 100;
              byte_200015E7 = 9;
              byte_200015E5 = 1;
              byte_200015EC = 0;
              byte_200015DD = 0;
            }
            else if ( (unsigned __int8)byte_200015DD >= 5u )
            {
              byte_200015E7 = 7;
              byte_200015DD = 0;
              ++byte_200015EC;
            }
            else
            {
              ++byte_200015DD;
            }
          }
        }
        else
        {
          ++byte_200015EC;
        }
      }
      else
      {
        ++byte_200015EC;
      }
      goto LABEL_106;
    case 9:
      sub_801ADD8((int)&loc_801C4F0);
      if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
      {
        sub_801ADD8(
          (int)"\r\n%s %d %s",
          " discharge power = %d, real max discharge power = %d.\r\n",
          711,
          (const char *)v29);
        if ( strstr(v29, "+QIRD") )
        {
          sub_8002364(v29, 128);
          if ( sub_8025570(dword_20000430, (unsigned int)v29, 400) == 1 )
          {
            sub_801F42C();
            sub_801ADD8(
              (int)"\r\n%s %d %s",
              " discharge power = %d, real max discharge power = %d.\r\n",
              718,
              (const char *)v29);
            if ( sub_801A6EC(v29) )
            {
              byte_200015EC = 0;
              byte_200015E7 = 0;
              sub_801ADD8((int)&loc_801C510);
              byte_200015E6 = 1;
              byte_200015E8 = 0;
            }
            else
            {
              ++byte_200015EC;
            }
          }
          else
          {
LABEL_100:
            sub_801F42C();
          }
        }
        else
        {
          ++byte_200015EC;
        }
      }
      else
      {
        sub_801F42C();
        byte_200015E7 = 8;
      }
      goto LABEL_106;
    default:
      ++byte_200015EC;
      goto LABEL_106;
  }
}
// 801C4A0: positive sp value 104 has been found
// 801BFB4: control flows out of bounds to 801BFB8
// 801C4D0: using guessed type int sub_801C4D0();
// 20000430: using guessed type int dword_20000430;
// 200015DC: using guessed type char byte_200015DC;
// 200015DD: using guessed type char byte_200015DD;
// 200015E5: using guessed type char byte_200015E5;
// 200015E6: using guessed type char byte_200015E6;
// 200015E7: using guessed type char byte_200015E7;
// 200015E8: using guessed type char byte_200015E8;
// 200015E9: using guessed type char byte_200015E9;
// 200015EA: using guessed type char byte_200015EA;
// 200015EB: using guessed type char byte_200015EB;
// 200015EC: using guessed type char byte_200015EC;
// 200015EE: using guessed type char byte_200015EE;
// 200015EF: using guessed type char byte_200015EF;
// 200015F2: using guessed type __int16 word_200015F2;
// 200015F8: using guessed type __int16 word_200015F8;
// 2000401D: using guessed type char byte_2000401D;
// 20011298: using guessed type int dword_20011298;
// 2001129C: using guessed type int dword_2001129C;
// 200112A0: using guessed type int dword_200112A0;
// 200112A4: using guessed type int dword_200112A4;

//----- (0801C528) --------------------------------------------------------
void sub_801C528()
{
  int v0; // r6
  unsigned __int8 v1[160]; // [sp+10h] [bp-A0h] BYREF

  sub_8002364(v1, 128);
  v0 = (unsigned __int16)word_200111D2;
  switch ( byte_200015E7 )
  {
    case 0:
      JUMPOUT(0x801C568);
    case 1:
      if ( byte_200015E9 )
      {
        if ( sub_8004200("AT+QGETIP=station\r\n") )
          byte_200015E9 = 0;
      }
      break;
    case 2:
      if ( byte_200015E9 )
      {
        sub_8002364(v1, 128);
        sprintf(
          (int)v1,
          "AT+QIOPEN=%d,\"UDP SERVICE\",\"%s\",%d,%d,0\r\n",
          (unsigned __int8)byte_200015EA,
          (const char *)&dword_20011298,
          v0,
          22222);
        if ( sub_8004200(v1) )
          byte_200015E9 = 0;
      }
      break;
    case 3:
      if ( byte_200015E9 )
      {
        sub_8002364(v1, 128);
        sprintf(
          (int)v1,
          "AT+QISEND=%d,%d,\"%s\",\"%s\",%d\r\n",
          (unsigned __int8)byte_200015EA,
          4,
          "hame",
          (const char *)&dword_20011298,
          12345);
        if ( sub_8004200(v1) )
          byte_200015E9 = 0;
      }
      break;
    case 4:
      if ( sub_80256C8(dword_2000042C, 400) == 1 || sub_801B018(&word_200015FA, 0x190u) )
      {
        byte_200015E5 = 1;
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,0\r\n", (unsigned __int8)byte_200015EA);
        if ( sub_8004200(v1) )
          byte_200015E9 = 0;
      }
      break;
    case 5:
      if ( byte_200015E9 )
      {
        sub_8002364(v1, 128);
        sprintf((int)v1, "AT+QIRD=%d,%d\r\n", (unsigned __int8)byte_200015EA, (unsigned __int16)word_200015F2);
        if ( sub_8004200(v1) )
          byte_200015E9 = 0;
      }
      break;
    default:
      break;
  }
  JUMPOUT(0x801C57E);
}
// 801C55A: control flows out of bounds to 801C568
// 801C55A: control flows out of bounds to 801C57E
// 2000042C: using guessed type int dword_2000042C;
// 200015E5: using guessed type char byte_200015E5;
// 200015E7: using guessed type char byte_200015E7;
// 200015E9: using guessed type char byte_200015E9;
// 200015EA: using guessed type char byte_200015EA;
// 200015F2: using guessed type __int16 word_200015F2;
// 200015FA: using guessed type _WORD;
// 200111D2: using guessed type __int16 word_200111D2;
// 20011298: using guessed type int dword_20011298;

//----- (0801C564) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall IRQ_38_handler(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int *v13; // r5
  int v14; // r4
  char v15; // cf
  char v16; // zf
  int v17; // r4
  char v18; // r5
  char v19; // r6
  int v20; // r7
  char v21; // r8
  char v22; // r10
  unsigned __int8 v23[40]; // [sp-80h] [bp-80h] BYREF

  if ( !(!v16 & v15) )
  {
    v13 = (int *)((unsigned int)(a2 - 684) >> 8);
    v14 = v17 * a2;
    if ( strstr(v23, "QISEND") )
    {
      if ( sub_8025570(*v13, (unsigned int)v23, v20) == 1 )
      {
        sub_801F42C();
        if ( strstr(v23, "OK") )
        {
          *(_BYTE *)(v14 + 9) = v21;
          *(_BYTE *)(v14 + 11) = v22;
        }
        else
        {
          *(_BYTE *)(v14 + 9) = v21;
          ++*(_BYTE *)(v14 + 16);
        }
      }
      sub_801F42C();
    }
    else
    {
      ++*(_BYTE *)(v14 + 16);
    }
    if ( *(unsigned __int8 *)(v14 + 16) > 5u )
    {
      *(_BYTE *)(v14 + 16) = v19;
      *(_BYTE *)(v14 + 11) = v19;
    }
    __asm { POP.W           {R4-R11,PC} }
  }
  sub_80173B0();
  if ( *(_BYTE *)(v17 + 13) && sub_8004200("AT+QICFG=\"accept/mode\",0\r\n") )
    *(_BYTE *)(v17 + 13) = v18;
  __asm { POP.W           {R4-R10,PC} }
}
// 801C4A0: positive sp value 104 has been found
// 801C580: unbalanced stack, ignored a potential tail call
// 801C566: variable 'v16' is possibly undefined
// 801C566: variable 'v15' is possibly undefined
// 801C512: variable 'v17' is possibly undefined
// 801C57C: variable 'v18' is possibly undefined
// 801BFC8: variable 'v20' is possibly undefined
// 801BFDE: variable 'v21' is possibly undefined
// 801BFE2: variable 'v22' is possibly undefined
// 801C49A: variable 'v19' is possibly undefined

//----- (0801C838) --------------------------------------------------------
int __fastcall sub_801C838(unsigned __int8 *a1, int a2, _DWORD *a3)
{
  unsigned int v5; // r4
  unsigned __int8 *v6; // r0
  int v7; // r6
  int v8; // r8
  int v9; // r0
  int v10; // r7
  int v12; // r0
  unsigned __int8 *v13; // r0
  unsigned __int8 *i; // r0
  unsigned int v15; // r1
  _BYTE v16[256]; // [sp+4h] [bp-19Ch] BYREF
  unsigned __int8 *v17[32]; // [sp+104h] [bp-9Ch] BYREF
  int v18; // [sp+184h] [bp-1Ch] BYREF

  if ( !a1 || !a3 )
    return 0;
  v18 = 0;
  v5 = 0;
  sub_8002364(v17, 128);
  sub_8002364(v16, 256);
  sub_8002364(byte_20011220, 120);
  v6 = strstr(a1, (unsigned __int8 *)&dword_801CB30);
  v7 = (int)v6;
  if ( !v6 )
    return 0;
  v8 = (unsigned __int8)sub_8002644((char *)v6 + 2);
  v9 = sub_80023CE(v7, 3u);
  if ( !v9 )
    return 0;
  v10 = (unsigned __int8)(v9 - v7 + 3);
  if ( v10 != v8 )
    return 0;
  scanf(v9, (int)dword_801CB34, &v18);
  v12 = sub_80104CC(v7, (unsigned __int8)(v10 - 2));
  if ( (unsigned __int8)v18 != v12 )
    return 0;
  v13 = (unsigned __int8 *)sub_80023CE(v7, 0x7Cu);
  if ( !v13 )
    return 0;
  sub_80023B6(v16, v13, v10 - (unsigned __int8)((_BYTE)v13 - v7) - 3);
  for ( i = (unsigned __int8 *)sub_800243C(v16, &dword_801CB3C);
        i && v5 < 0x20;
        i = (unsigned __int8 *)sub_800243C(0, &dword_801CB3C) )
  {
    v15 = v5;
    v5 = (unsigned __int8)(v5 + 1);
    v17[v15] = i;
  }
  sub_80023B6(&byte_20011220[2], v17[0], 6);
  sub_80023B6(&byte_20011220[8], v17[1], 13);
  sub_80023B6(&byte_20011220[21], v17[2], 7);
  sub_80023B6(&byte_20011220[28], v17[3], 13);
  dword_2001124C = sub_8002644((char *)v17[4]);
  dword_20011250 = sub_8002644((char *)v17[5]);
  dword_20011254 = sub_8002644((char *)v17[6]);
  dword_20011258 = sub_8002644((char *)v17[7]);
  byte_2001125C = sub_8002644((char *)v17[8]);
  dword_20011260 = sub_8002644((char *)v17[9]);
  byte_20011264 = sub_8002644((char *)v17[10]);
  dword_20011268 = sub_8002644((char *)v17[11]);
  byte_2001126C = sub_8002644((char *)v17[12]);
  byte_2001126D = sub_8002644((char *)v17[13]);
  dword_20011270 = sub_8002644((char *)v17[14]);
  dword_20011274 = sub_8002644((char *)v17[15]);
  dword_20011278 = sub_8002644((char *)v17[16]);
  dword_2001127C = sub_8002644((char *)v17[17]);
  dword_20011280 = sub_8002644((char *)v17[18]);
  dword_20011284 = sub_8002644((char *)v17[19]);
  dword_20011288 = sub_8002644((char *)v17[20]);
  dword_2001128C = sub_8002644((char *)v17[21]);
  dword_20011290 = sub_8002644((char *)v17[22]);
  dword_20011294 = sub_8002644((char *)v17[23]);
  sub_801ADD8((int)"ct002_get_info.meter_dev_type=%s\r\n", (const char *)&byte_20011220[2]);
  sub_801ADD8((int)"ct002_get_info.meter_mac_code=%s\r\n", (const char *)&byte_20011220[8]);
  sub_801ADD8((int)"ct002_get_info.hhm_dev_type=%s\r\n", (const char *)&byte_20011220[21]);
  sub_801ADD8((int)"ct002_get_info.hhm_mac_code=%s\r\n", (const char *)&byte_20011220[28]);
  sub_801ADD8((int)"ct002_get_info.A_phase_power=%d\r\n", dword_2001124C);
  sub_801ADD8((int)"ct002_get_info.B_phase_power=%d\r\n", dword_20011250);
  sub_801ADD8((int)"ct002_get_info.C_phase_power=%d\r\n", dword_20011254);
  sub_801ADD8((int)"ct002_get_info.total_power=%d\r\n", dword_20011258);
  sub_801ADD8((int)"ct002_get_info.A_chrg_nb=%d\r\n", (unsigned __int8)byte_2001125C);
  sub_801ADD8((int)"ct002_get_info.B_chrg_nb=%d\r\n", dword_20011260);
  sub_801ADD8((int)"ct002_get_info.C_chrg_nb=%d\r\n", (unsigned __int8)byte_20011264);
  sub_801ADD8((int)"ct002_get_info.ABC_chrg_nb=%d\r\n", dword_20011268);
  sub_801ADD8((int)"ct002_get_info.wifi_rssi=%d\r\n", byte_2001126C);
  sub_801ADD8((int)"ct002_get_info.info_idx=%d\r\n", (unsigned __int8)byte_2001126D);
  sub_801ADD8((int)"ct002_get_info.x_chrg_power=%d\r\n", dword_20011270);
  sub_801ADD8((int)"ct002_get_info.A_chrg_power=%d\r\n", dword_20011274);
  sub_801ADD8((int)"ct002_get_info.B_chrg_power=%d\r\n", dword_20011278);
  sub_801ADD8((int)"ct002_get_info.C_chrg_power=%d\r\n", dword_2001127C);
  sub_801ADD8((int)"ct002_get_info.ABC_chrg_power=%d\r\n", dword_20011280);
  sub_801ADD8((int)"ct002_get_info.x_dchrg_power=%d\r\n", dword_20011284);
  sub_801ADD8((int)"ct002_get_info.A_dchrg_power=%d\r\n", dword_20011288);
  sub_801ADD8((int)"ct002_get_info.B_dchrg_power=%d\r\n", dword_2001128C);
  sub_801ADD8((int)"ct002_get_info.C_dchrg_power=%d\r\n", dword_20011290);
  sub_801ADD8((int)"ct002_get_info.ABC_dchrg_power=%d\r\n", dword_20011294);
  if ( sub_80023F0((int)&byte_20011220[2], (int)&dword_20011208)
    || sub_80023F0((int)&byte_20011220[8], (int)&dword_20004361) && (_BYTE)dword_20004361 && BYTE1(dword_20004365) )
  {
    sub_8002364(byte_20011220, 120);
    return 0;
  }
  if ( sub_80023F0((int)&byte_20011220[2], (int)"HME-4") )
  {
    if ( !sub_80023F0((int)&byte_20011220[2], (int)"HME-3") )
      byte_200015E4 = 6;
  }
  else
  {
    byte_200015E4 = 3;
  }
  if ( byte_2001126D == byte_200015F1 )
  {
    byte_200015F1 = byte_2001126D;
    if ( byte_2001126D )
      return 2;
  }
  else
  {
    byte_200015F1 = byte_2001126D;
  }
  sub_80046BC((int)a3);
  a3[1] = dword_2001124C;
  a3[2] = dword_20011250;
  a3[3] = dword_20011254;
  *a3 = dword_20011258;
  return 1;
}
// 801CB30: using guessed type int dword_801CB30;
// 801CB34: using guessed type int dword_801CB34[2];
// 801CB3C: using guessed type int dword_801CB3C;
// 200015E4: using guessed type char byte_200015E4;
// 200015F1: using guessed type char byte_200015F1;
// 20004361: using guessed type int dword_20004361;
// 20004365: using guessed type int dword_20004365;
// 20011208: using guessed type int dword_20011208;
// 20011220: using guessed type unsigned __int8 byte_20011220[44];
// 2001124C: using guessed type int dword_2001124C;
// 20011250: using guessed type int dword_20011250;
// 20011254: using guessed type int dword_20011254;
// 20011258: using guessed type int dword_20011258;
// 2001125C: using guessed type char byte_2001125C;
// 20011260: using guessed type int dword_20011260;
// 20011264: using guessed type char byte_20011264;
// 20011268: using guessed type int dword_20011268;
// 2001126C: using guessed type char byte_2001126C;
// 2001126D: using guessed type char byte_2001126D;
// 20011270: using guessed type int dword_20011270;
// 20011274: using guessed type int dword_20011274;
// 20011278: using guessed type int dword_20011278;
// 2001127C: using guessed type int dword_2001127C;
// 20011280: using guessed type int dword_20011280;
// 20011284: using guessed type int dword_20011284;
// 20011288: using guessed type int dword_20011288;
// 2001128C: using guessed type int dword_2001128C;
// 20011290: using guessed type int dword_20011290;
// 20011294: using guessed type int dword_20011294;

//----- (0801CE9C) --------------------------------------------------------
BOOL __fastcall sub_801CE9C(int a1)
{
  int v2; // r0
  unsigned int v3; // r3
  int v4; // [sp+0h] [bp-20h] BYREF
  int v5; // [sp+4h] [bp-1Ch] BYREF

  v5 = 0;
  v4 = 0;
  if ( a1 == 5 )
    return 1;
  do
  {
    if ( sub_801B018(&v4, 0xBB8u) )
      return 0;
    if ( !sub_8025570(dword_20000444, (unsigned int)&v5, 300) )
      break;
    v2 = (unsigned __int8)byte_200015B3++;
    v3 = (unsigned __int8)byte_200015B3;
    byte_20011071[v2] = v5;
  }
  while ( v3 < 7 );
  return sub_8004A58();
}
// 20000444: using guessed type int dword_20000444;
// 200015B3: using guessed type char byte_200015B3;
// 20011071: using guessed type unsigned __int8 byte_20011071[67];

//----- (0801CF0C) --------------------------------------------------------
_BYTE *__fastcall sub_801CF0C(_BYTE *result)
{
  int v1; // r0

  if ( result )
  {
    v1 = 0;
    if ( byte_2001104D || word_20011067 && (unsigned __int16)word_20011067 != 0xFFFF )
    {
      if ( byte_2001104D == 3 && word_20011067 == 13107 )
        v1 = 1;
    }
    else
    {
      v1 = 1;
    }
    byte_200015B4 = 4;
    if ( dword_20011053 == dword_2001106D && v1 && dword_2001105F + 128 == dword_20011057 )
    {
      if ( byte_2001104D )
        byte_2001104E = 1;
      else
        byte_2001104E = MEMORY[0x8050004] == *(_DWORD *)((char *)&loc_8010002 + 2);
    }
    else
    {
      byte_2001104E = 0;
    }
    return sub_8018864((_BYTE *)0x52, (unsigned int)&byte_2001104E, 1u);
  }
  return result;
}
// 200015B4: using guessed type char byte_200015B4;
// 2001104D: using guessed type char byte_2001104D;
// 2001104E: using guessed type char byte_2001104E;
// 20011053: using guessed type int dword_20011053;
// 20011057: using guessed type int dword_20011057;
// 2001105F: using guessed type int dword_2001105F;
// 20011067: using guessed type __int16 word_20011067;
// 2001106D: using guessed type int dword_2001106D;

//----- (0801CFA0) --------------------------------------------------------
__int64 __fastcall sub_801CFA0(__int64 a1, int a2, unsigned int a3)
{
  unsigned int v3; // r4
  __int64 v5; // [sp+0h] [bp-20h] BYREF
  int v6; // [sp+8h] [bp-18h]
  unsigned int v7; // [sp+Ch] [bp-14h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  if ( (_DWORD)a1 )
  {
    v6 = 0;
    v5 = 0;
    v6 = *(unsigned __int16 *)(a1 + 5);
    v3 = *(unsigned __int8 *)(a1 + 7);
    v7 = v3;
    if ( (unsigned __int8)byte_2001104D == v3 && (unsigned __int16)word_2001104F == (unsigned __int16)v6 && !(_WORD)v6 )
    {
      LODWORD(v5) = dword_2001105F;
    }
    else
    {
      sub_8002364(&byte_2001104C, 37);
      dword_200015C0 = 0;
      word_20011051 = -1;
      dword_20011069 = 0xFFFF;
    }
    word_2001104F = v6;
    byte_2001104D = v3;
    if ( v3 <= 3 )
      BYTE4(v5) = 1;
    BYTE5(v5) = -86;
    sub_8018864((_BYTE *)0x3A, (unsigned int)&v5, 6u);
  }
  return v5;
}
// 200015C0: using guessed type int dword_200015C0;
// 2001104C: using guessed type char byte_2001104C;
// 2001104D: using guessed type char byte_2001104D;
// 2001104F: using guessed type __int16 word_2001104F;
// 20011051: using guessed type __int16 word_20011051;
// 2001105F: using guessed type int dword_2001105F;
// 20011069: using guessed type int dword_20011069;

//----- (0801D01C) --------------------------------------------------------
_BYTE *__fastcall sub_801D01C(_BYTE *result, int a2, int a3, int a4)
{
  unsigned int v4; // r1
  int v5; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+4h] [bp-Ch]

  v5 = a3;
  v6 = a4;
  if ( result )
  {
    byte_200015B4 = 2;
    v6 = 0;
    dword_20011057 = *(_DWORD *)(result + 5);
    dword_20011053 = *(_DWORD *)(result + 9);
    v5 = *(_DWORD *)(result + 5);
    v6 = *(_DWORD *)(result + 9);
    if ( !dword_2001105F )
    {
      if ( MEMORY[0x1FFF75E0] == 0xFFFF )
        v4 = 0x80000;
      else
        v4 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
      sub_800F808(0x8040000u, (v4 >> 1) + 134479872);
      dword_2001105B = 134490112;
    }
    return sub_8018864((_BYTE *)0x50, (unsigned int)&v5, 8u);
  }
  return result;
}
// 200015B4: using guessed type char byte_200015B4;
// 20011053: using guessed type int dword_20011053;
// 20011057: using guessed type int dword_20011057;
// 2001105B: using guessed type int dword_2001105B;
// 2001105F: using guessed type int dword_2001105F;

//----- (0801D094) --------------------------------------------------------
_BYTE *__fastcall sub_801D094(_BYTE *result, int a2, int a3, int a4)
{
  int v4; // [sp+0h] [bp-8h] BYREF

  v4 = a4;
  if ( result )
  {
    sub_801FF60();
    byte_200015B4 = 1;
    v4 = 43521;
    byte_200015B0 = 2;
    return sub_8018864((_BYTE *)0x23, (unsigned int)&v4, 2u);
  }
  return result;
}
// 200015B0: using guessed type char byte_200015B0;
// 200015B4: using guessed type char byte_200015B4;

//----- (0801D0C8) --------------------------------------------------------
_BYTE *__fastcall sub_801D0C8(_BYTE *result, int a2, int a3, int a4)
{
  _BYTE *v4; // r4
  int v5; // r5
  int v6; // r0
  int v7; // [sp+0h] [bp-20h] BYREF

  v7 = a4;
  v4 = result;
  if ( result )
  {
    v5 = 0;
    v7 = 0;
    byte_200015B4 = 3;
    v6 = *(_DWORD *)(result + 5);
    dword_2001105F = v6;
    if ( v6 == dword_200015C0 || !dword_200015C0 )
    {
      if ( v6 + 128 == dword_20011057 )
        v5 = 1;
      sub_80186F8(&dword_2001106D, (int)(v4 + 9), 0x80u, v5);
      if ( v5 )
      {
        word_20011067 = *(_WORD *)(v4 + 135);
        sub_8002356(v4 + 135, 2, 255);
      }
      sub_80186F8(&dword_20011063, (int)(v4 + 9), 0x80u, v5);
      sub_800F86C((_DWORD *)(dword_2001105B + dword_2001105F), (int)(v4 + 9), 0x10u);
      dword_200015C0 += 128;
    }
    byte_2001104C = 1;
    v7 = dword_2001105F;
    return sub_8018864((_BYTE *)0x51, (unsigned int)&v7, 4u);
  }
  return result;
}
// 200015B4: using guessed type char byte_200015B4;
// 200015C0: using guessed type int dword_200015C0;
// 2001104C: using guessed type char byte_2001104C;
// 20011057: using guessed type int dword_20011057;
// 2001105B: using guessed type int dword_2001105B;
// 2001105F: using guessed type int dword_2001105F;
// 20011063: using guessed type int dword_20011063;
// 20011067: using guessed type __int16 word_20011067;
// 2001106D: using guessed type int dword_2001106D;

//----- (0801D16C) --------------------------------------------------------
char *__fastcall sub_801D16C(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  char *result; // r0
  int v6; // r0

  v4 = 0;
  result = &byte_200015B0;
  switch ( byte_200015B1 )
  {
    case 1:
      result = (char *)sub_801D288();
      break;
    case 2:
      result = (char *)sub_801D2B8();
      break;
    case 3:
      result = (char *)sub_801D31C();
      break;
    case 4:
      result = (char *)sub_801D2B4((int)&byte_200015B0, (unsigned __int8)byte_200015B1, a3, a4);
      break;
    case 5:
      v4 = 1;
      break;
    default:
      byte_200015B1 = 0;
      v4 = 2;
      break;
  }
  if ( v4 )
  {
    sub_8019118(115200);
    sub_8023A34(2000);
    if ( v4 == 2 )
      sub_801E93C((int)"\r\nBMS upgrade failed, system will reboot!\r\n");
    else
      sub_801E93C((int)"\r\nBMS upgrade successful, system will reboot!\r\n");
    sub_80031E4();
    sub_801F610(v6);
    sub_8023A34(300);
    _R0 = 1;
    __asm { MSR.W           FAULTMASK, R0 }
    sub_80139D4();
  }
  return result;
}
// 801D1D0: variable 'v6' is possibly undefined
// 801F610: using guessed type __int64 __fastcall sub_801F610(_DWORD);
// 200015B0: using guessed type char byte_200015B0;
// 200015B1: using guessed type char byte_200015B1;

//----- (0801D258) --------------------------------------------------------
int __fastcall sub_801D258(int result, int a2)
{
  byte_20000294 = 1;
  byte_20000031 = 3;
  byte_200015B1 = 1;
  byte_200110B4 = 2;
  dword_200110B8 = result;
  dword_200110BC = a2;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200015B1: using guessed type char byte_200015B1;
// 200110B4: using guessed type char byte_200110B4;
// 200110B8: using guessed type int dword_200110B8;
// 200110BC: using guessed type int dword_200110BC;

//----- (0801D288) --------------------------------------------------------
int sub_801D288()
{
  _DWORD v1[4]; // [sp+0h] [bp-10h] BYREF

  sub_8019118(9600);
  sub_8023A34(2000);
  v1[0] = dword_200110BC;
  v1[1] = dword_200110B8;
  return sub_80188C4(1, (unsigned int)v1, 8u);
}
// 200110B8: using guessed type int dword_200110B8;
// 200110BC: using guessed type int dword_200110BC;

//----- (0801D2B8) --------------------------------------------------------
int sub_801D2B8()
{
  unsigned int v0; // r6
  int v1; // r4
  _BYTE v3[80]; // [sp+0h] [bp-50h] BYREF

  v0 = 64;
  v1 = 2;
  sub_8002356(v3, 64, 255);
  if ( (unsigned int)(dword_200110BC - dword_200015D8) <= 0x40 )
  {
    v1 = 3;
    v0 = (unsigned __int8)(dword_200110BC - dword_200015D8);
  }
  qmemcpy((unsigned int)v3, ((unsigned __int16)word_200015BC++ << 6) + 134490112, v0);
  dword_200015D8 = (unsigned __int16)word_200015BC << 6;
  if ( v1 == 3 )
  {
    word_200015BC = 0;
    dword_200015D8 = 0;
  }
  return sub_80188C4(v1, (unsigned int)v3, v0);
}
// 200015BC: using guessed type __int16 word_200015BC;
// 200015D8: using guessed type int dword_200015D8;
// 200110BC: using guessed type int dword_200110BC;

//----- (0801D31C) --------------------------------------------------------
int sub_801D31C()
{
  int v1; // [sp+0h] [bp-8h] BYREF

  v1 = dword_200110B8;
  return sub_80188C4(4, (unsigned int)&v1, 4u);
}
// 200110B8: using guessed type int dword_200110B8;

//----- (0801D334) --------------------------------------------------------
int sub_801D334()
{
  int result; // r0

  result = 0;
  if ( BYTE2(dword_20002E90) != 1 )
  {
    if ( SHIWORD(dword_20002E82) <= 9 )
    {
      if ( SHIWORD(dword_20002E82) >= -9 )
        return 1;
      else
        return 3;
    }
    else
    {
      return 2;
    }
  }
  return result;
}
// 20002E82: using guessed type int dword_20002E82;
// 20002E90: using guessed type int dword_20002E90;

//----- (0801D35C) --------------------------------------------------------
int sub_801D35C()
{
  sprintf(
    (int)&unk_20003C93,
    "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
    (unsigned __int16)dword_20002E9F,
    HIWORD(dword_20002E9F),
    (unsigned __int16)dword_20002EA3,
    HIWORD(dword_20002EA3),
    (unsigned __int16)dword_20002EA7,
    HIWORD(dword_20002EA7),
    (unsigned __int16)dword_20002EAB,
    HIWORD(dword_20002EAB),
    (unsigned __int16)dword_20002EAF,
    HIWORD(dword_20002EAF),
    (unsigned __int16)dword_20002EB3,
    HIWORD(dword_20002EB3),
    (unsigned __int16)dword_20002EB7,
    HIWORD(dword_20002EB7),
    (unsigned __int16)dword_20002EBB,
    HIWORD(dword_20002EBB));
  sprintf(
    (int)&unk_20003D13,
    "%d,%d,%d,%d",
    (__int16)dword_20002E97,
    SHIWORD(dword_20002E97),
    (__int16)dword_20002E9B,
    SHIWORD(dword_20002E9B));
  return sprintf((int)&unk_20003D5B, "%d,%d,%d,%d", dword_20002EC4, dword_20002EC8, dword_20002ECC, dword_20002ED0);
}
// 20002E97: using guessed type int dword_20002E97;
// 20002E9B: using guessed type int dword_20002E9B;
// 20002E9F: using guessed type int dword_20002E9F;
// 20002EA3: using guessed type int dword_20002EA3;
// 20002EA7: using guessed type int dword_20002EA7;
// 20002EAB: using guessed type int dword_20002EAB;
// 20002EAF: using guessed type int dword_20002EAF;
// 20002EB3: using guessed type int dword_20002EB3;
// 20002EB7: using guessed type int dword_20002EB7;
// 20002EBB: using guessed type int dword_20002EBB;
// 20002EC4: using guessed type int dword_20002EC4;
// 20002EC8: using guessed type int dword_20002EC8;
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;

//----- (0801D41C) --------------------------------------------------------
int sub_801D41C()
{
  int v0; // r0
  unsigned int v1; // r6
  unsigned int v2; // r3
  unsigned int v3; // r1
  unsigned int v4; // r6
  unsigned int v5; // r1
  int result; // r0

  v0 = 0;
  v1 = dword_200004EC;
  v2 = dword_200051A0 + 20;
  if ( (unsigned int)dword_200004EC > 0xE10 )
  {
    v3 = dword_200004EC / 0xE10u;
    dword_200004EC %= 0xE10u;
    dword_20003040 += v1 / 0xE10;
    dword_2000304C += v1 / 0xE10;
    dword_20003058 += v1 / 0xE10;
    if ( byte_20002F60 == 2 )
    {
      if ( v2 > dword_2000002C && (unsigned int)dword_2000002C > 0x15 )
        v0 = dword_20005198 * v3;
      dword_20003048 -= v0 / 10;
      dword_20003054 -= v0 / 10;
      dword_20003060 -= v0 / 10;
    }
  }
  v4 = dword_200004F0;
  if ( (unsigned int)dword_200004F0 > 0xE10 )
  {
    v5 = dword_200004F0 / 0xE10u;
    dword_200004F0 %= 0xE10u;
    dword_20003044 += v4 / 0xE10;
    dword_20003050 += v4 / 0xE10;
    dword_2000305C += v4 / 0xE10;
    if ( byte_20002F60 == 2 )
    {
      if ( v2 > dword_2000002C && (unsigned int)dword_2000002C > 0x15 )
        v0 = dword_2000519C * v5;
      dword_20003048 += v0 / 10;
      dword_20003054 += v0 / 10;
      dword_20003060 += v0 / 10;
    }
  }
  if ( (unsigned __int8)byte_20000504 >= (unsigned int)(unsigned __int8)byte_2000303C )
  {
    if ( byte_20000505 == byte_2000303D )
    {
      if ( byte_20000506 != byte_2000303E )
      {
        byte_2000303C = byte_20000504;
        byte_2000303D = byte_20000505;
        byte_2000303E = byte_20000506;
        sub_80053F8(1);
      }
    }
    else
    {
      byte_2000303C = byte_20000504;
      byte_2000303D = byte_20000505;
      byte_2000303E = byte_20000506;
      sub_80053F8(2);
    }
    byte_2000303C = byte_20000504;
    byte_2000303D = byte_20000505;
    byte_2000303E = byte_20000506;
  }
  result = sub_801B040(&word_200004D0, 0x258u);
  if ( result )
    return sub_800590C();
  return result;
}
// 2000002C: using guessed type int dword_2000002C;
// 200004D0: using guessed type _WORD;
// 200004EC: using guessed type int dword_200004EC;
// 200004F0: using guessed type int dword_200004F0;
// 20000504: using guessed type char byte_20000504;
// 20000505: using guessed type char byte_20000505;
// 20000506: using guessed type char byte_20000506;
// 20002F60: using guessed type char byte_20002F60;
// 2000303C: using guessed type char byte_2000303C;
// 2000303D: using guessed type char byte_2000303D;
// 2000303E: using guessed type char byte_2000303E;
// 20003040: using guessed type int dword_20003040;
// 20003044: using guessed type int dword_20003044;
// 20003048: using guessed type int dword_20003048;
// 2000304C: using guessed type int dword_2000304C;
// 20003050: using guessed type int dword_20003050;
// 20003054: using guessed type int dword_20003054;
// 20003058: using guessed type int dword_20003058;
// 2000305C: using guessed type int dword_2000305C;
// 20003060: using guessed type int dword_20003060;
// 20005198: using guessed type int dword_20005198;
// 2000519C: using guessed type int dword_2000519C;
// 200051A0: using guessed type int dword_200051A0;

//----- (0801D570) --------------------------------------------------------
int sub_801D570()
{
  int result; // r0

  dword_20001728 = 1073759232;
  dword_2000172C = 115200;
  dword_20001730 = 0;
  dword_20001734 = 0;
  dword_20001738 = 0;
  dword_20001740 = 0;
  dword_2000173C = 12;
  dword_20001744 = 0;
  sub_80144CC((int)&dword_20001728, 0, 2, 2);
  sub_8015856((int)&dword_20001728, 0);
  sub_801580A((int)&dword_20001728);
  sub_8015E8C((int)&dword_20001728, (int)byte_20003164, 1u);
  result = dword_20001728;
  *(_DWORD *)(dword_20001728 + 8) &= ~1u;
  return result;
}
// 20001728: using guessed type int dword_20001728;
// 2000172C: using guessed type int dword_2000172C;
// 20001730: using guessed type int dword_20001730;
// 20001734: using guessed type int dword_20001734;
// 20001738: using guessed type int dword_20001738;
// 2000173C: using guessed type int dword_2000173C;
// 20001740: using guessed type int dword_20001740;
// 20001744: using guessed type int dword_20001744;

//----- (0801D5CC) --------------------------------------------------------
int __fastcall sub_801D5CC(int result)
{
  int v1; // r1

  v1 = 5000;
  do
    --v1;
  while ( v1 && (MEMORY[0x4000441C] & 0x40) == 0 );
  MEMORY[0x40004428] = result;
  return result;
}

//----- (0801D5E8) --------------------------------------------------------
unsigned int *__fastcall sub_801D5E8(int a1, unsigned __int16 a2)
{
  unsigned int *result; // r0
  unsigned int v3; // r1

  sub_8015FD4((int)&dword_20001728, a1, a2);
  *(_DWORD *)(dword_20001728 + 32) = 64;
  do
  {
    result = (unsigned int *)(dword_20001728 + 8);
    v3 = __ldrex((unsigned int *)(dword_20001728 + 8));
  }
  while ( __strex(v3 | 0x80, result) );
  return result;
}
// 20001728: using guessed type int dword_20001728;

//----- (0801D618) --------------------------------------------------------
int __fastcall sub_801D618(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 5000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000441C] & 0x40) == 0 );
    MEMORY[0x40004428] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801D644) --------------------------------------------------------
int __fastcall sub_801D644(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 60000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000441C] & 0x40) == 0 );
    MEMORY[0x40004428] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801D6B0) --------------------------------------------------------
int __fastcall sub_801D6B0(int result)
{
  int v1; // r1

  v1 = 5000;
  do
    --v1;
  while ( v1 && (MEMORY[0x4000801C] & 0x40) == 0 );
  MEMORY[0x40008028] = result;
  return result;
}

//----- (0801D6C8) --------------------------------------------------------
int __fastcall sub_801D6C8(int result, int a2)
{
  int i; // r2
  int v3; // r3

  for ( i = 0; i < a2; ++i )
  {
    v3 = 5000;
    do
      --v3;
    while ( v3 && (MEMORY[0x4000801C] & 0x40) == 0 );
    MEMORY[0x40008028] = *(unsigned __int8 *)(result + i);
  }
  return result;
}

//----- (0801D6F0) --------------------------------------------------------
int sub_801D6F0()
{
  sub_801D570();
  return sub_8018484();
}

//----- (0801D700) --------------------------------------------------------
int sub_801D700()
{
  dword_20002230 = 134340381;
  return sub_80210B4((int)&dword_200021C8, (int)&unk_20002234, 0x200u);
}
// 200021C8: using guessed type int dword_200021C8;
// 20002230: using guessed type int dword_20002230;

//----- (0801D71C) --------------------------------------------------------
int __fastcall sub_801D71C(int a1, __int16 a2)
{
  if ( byte_20000030 == 1 && byte_20000508 )
    sub_801D618(a1, a2);
  return a2;
}
// 20000030: using guessed type char byte_20000030;
// 20000508: using guessed type char byte_20000508;

//----- (0801D740) --------------------------------------------------------
void sub_801D740()
{
  if ( dword_20000298 == 1 )
  {
    dword_20000298 = 0;
    dword_200002A0 = 1000;
    dword_200021BC[0] = 0;
    dword_200021C0 = 0;
    dword_200021C4 = 0;
  }
  if ( dword_2000029C )
    sub_80174B4();
  JUMPOUT(0x801D76C);
}
// 801D76A: control flows out of bounds to 801D76C
// 20000298: using guessed type int dword_20000298;
// 2000029C: using guessed type int dword_2000029C;
// 200002A0: using guessed type int dword_200002A0;
// 200021BC: using guessed type int dword_200021BC[];
// 200021C0: using guessed type int dword_200021C0;
// 200021C4: using guessed type int dword_200021C4;

//----- (0801DD6C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall UsageFault_handler(int *a1, unsigned int a2, int a3, char a4)
{
  double v4; // r0
  double v5; // r0
  __int128 v6; // r0
  int v7; // r4
  int v8; // r5
  int v9; // r6
  int v10; // r7
  int v11; // r9
  float *v12; // r11
  unsigned int v13; // r4
  int v14; // r6
  unsigned int v16; // r1
  int v17; // r4
  double v18; // r0
  float v19; // s0

  *(_BYTE *)(v7 + 21) = a4;
  *(_DWORD *)(v7 + 64) = v8 - 114;
  *(_DWORD *)(v7 + 20) = a3;
  v13 = *(__int16 *)(v9 + (a2 >> 8));
  v14 = *(_DWORD *)(v9 + 116);
  *(_DWORD *)(v13 + 64) = (a2 >> 8) - 108;
  *(_DWORD *)(v14 + 20) = v14;
  *(_DWORD *)((a2 >> 8) + 0x64) = v10;
  *(_DWORD *)(v13 + 116) = v14;
  *(_DWORD *)(v13 + 64) = (a2 >> 8) - 100;
  *(_DWORD *)(v14 + 20) = v14;
  *(_DWORD *)((a2 >> 8) + 0x64) = v10;
  *(_BYTE *)(v13 + 13) = v14;
  *(_BYTE *)(v13 + 17) = BYTE1(a2);
  v13 >>= 21;
  MEMORY[0x51] = a2;
  MEMORY[0xA1] = v10;
  *(_BYTE *)(v13 + 13) = v14;
  *(_BYTE *)(v13 + 17) = 61;
  v16 = MEMORY[0xA1];
  *(_DWORD *)((v13 >> 21) + 0x40) = -57;
  *(_BYTE *)((v16 >> 8) + 0x11) = v14;
  *(_DWORD *)(v14 + 20) = a2;
  MEMORY[0x4E] = v14;
  *(_DWORD *)(v14 + 20) = v16 + 100;
  v17 = 0;
LABEL_8:
  sub_801E93C(
    (int)"temp_3=%d,temp_4=%d,temp_5=%d,485_c=%d",
    (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*((float *)a1 + 6))),
    (unsigned int)COERCE_UNSIGNED_INT64(*((float *)a1 + 6)),
    (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*((float *)a1 + 6))),
    v11);
  sub_801E93C((int)dword_801DB24, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v12[12])), v12[12]);
  sub_801E93C((int)dword_801DB44, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v12[13])), v12[13]);
  sub_801E93C(
    (int)"\r\nctl_state = %d ,llc_run_state = %d,inverter_run_state %d\r\n",
    (unsigned __int8)byte_200002A8,
    (unsigned __int8)byte_200002A5,
    (unsigned __int8)byte_200002A4);
  sub_801E93C((int)sub_801DBB4, dword_20003058, dword_2000305C, dword_20003060);
  sub_801E93C(
    (int)"\r\nwork_mode = %d , bat_mode = %d, backup = %d par = %d\r\n",
    (unsigned __int8)byte_20002F60,
    (unsigned __int8)byte_20000513,
    (unsigned __int8)byte_20002F5F[0],
    (unsigned __int8)byte_20002FD3);
  sub_801E93C(
    (int)sub_801DC34,
    (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_200002F8)),
    *(float *)&dword_200002F8,
    *(float *)&dword_200002FC,
    *(float *)&dword_20002458);
  v5 = *(float *)&dword_200026B8;
  v19 = *(float *)&v5;
  sub_801E93C((int)sub_801DC74, HIDWORD(v5), v5, *(float *)&dword_200026BC, *(float *)&dword_200026E8);
  sub_801E93C((int)dword_801DCA8, (unsigned __int8)byte_2000003C, (unsigned __int8)byte_2000003D);
  sub_801E93C((int)"err1 = %x err2 = %x,war1 = %x\r\n", dword_200028C0, dword_200028C4, dword_200028C8);
LABEL_11:
  --dword_200021BC[v17];
  while ( ++v17 < 3 )
  {
    if ( dword_200021BC[v17] )
    {
      switch ( v17 )
      {
        case 0:
          sub_801E93C((int)"\x1B[2J\x1B[1H");
          sub_800F7A4();
          sub_801E93C((int)sub_801DA60, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v19)), v19);
          sub_801E93C(
            (int)dword_801DA7C,
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20002610)),
            *(float *)&dword_20002610);
          sub_801E93C(
            (int)&unk_801DAA4,
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(flt_20002798)),
            flt_20002798,
            *(float *)&dword_2000031C,
            *(float *)&dword_20000328);
          v12 = (float *)&unk_20002738;
          sub_801E93C(
            (int)dword_801DADC,
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20002774)),
            *(float *)&dword_20002774);
          sub_801E93C(
            (int)dword_801DAFC,
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20002770)),
            *(float *)&dword_20002770);
          v4 = *(float *)&dword_20002778;
          v11 = LODWORD(v4);
          a1 = &dword_20001BEC;
          goto LABEL_8;
        case 1:
          sub_801E93C((int)"\x1B[2J\x1B[1H");
          sub_801E93C((int)dword_801E114);
          sub_801E93C((int)"charge_u = %d\r\n", (unsigned __int16)dword_20002E74);
          sub_801E93C((int)"charge_i = %d\r\n", HIWORD(dword_20002E74));
          sub_801E93C((int)"discharge_i = %d\r\n", (unsigned __int16)word_20002E78);
          sub_801E93C((int)"soc = %d\r\n", (unsigned __int16)dword_20002E7A);
          sub_801E93C((int)"soh = %d\r\n", HIWORD(dword_20002E7A));
          sub_801E93C((int)"bat_vol = %d\r\n", (unsigned __int16)dword_20002E82);
          sub_801E93C((int)"bat_cur = %d\r\n", SHIWORD(dword_20002E82));
          sub_801E93C((int)"max_temp = %d\r\n", word_20002E86);
          sub_801E93C((int)"charge_flag = %d\r\n", (unsigned __int16)dword_20002E90);
          sub_801E93C((int)"sleep_flag = %d\r\n", BYTE2(dword_20002E90));
          sub_801E93C((int)"err = %x warn = %x\r\n", dword_20002E88, dword_20002E8C);
          sub_801E93C((int)dword_801E1E8, dword_20000474);
          sub_801E93C((int)"ver1 = %d,ver2 = %d", BYTE2(dword_20002E7E), HIBYTE(dword_20002E7E));
          break;
        case 2:
          sub_801E93C((int)"\x1B[2J\x1B[1H");
          sub_801E93C((int)sub_801DCE8);
          sub_801E93C((int)"grid_vol=%d\r\n", word_20001C38);
          sub_801E93C((int)"grid_vref=%d\r\n", word_20001C3A);
          sub_801E93C((int)"out_vol=%d\r\n", word_20001C3C);
          sub_801E93C((int)"grid_cur=%d\r\n", word_20001C3E);
          sub_801E93C((int)"offgrid_cur=%d\r\n", word_20001C40);
          sub_801E93C((int)"highv_vol=%d\r\n", word_20001C42);
          sub_801E93C((int)sub_801DD68, word_20001C44);
          sub_801E93C((int)&loc_801DD78, word_20001C46);
          sub_801E93C((int)&loc_801DD88, word_20001C48);
          sub_801E93C((int)&loc_801DD9C, word_20001C4A);
          sub_801E93C((int)&loc_801DDAC, word_20001C4C);
          sub_801E93C((int)&loc_801DDBC, word_20001C4E);
          sub_801E93C((int)&loc_801DDCC, word_20001C50);
          sub_801E93C((int)&loc_801DDDC, word_20001C52);
          sub_801E93C((int)&loc_801DDEC);
          sub_801E93C(
            (int)"grid_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001BEC)),
            *(float *)&dword_20001BEC);
          sub_801E93C(
            (int)"grid_cur=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001BF0)),
            *(float *)&dword_20001BF0);
          sub_801E93C(
            (int)"highv_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001BF4)),
            *(float *)&dword_20001BF4);
          *(double *)&v6 = *(float *)&dword_20001C10;
          DWORD2(v6) = v6;
          sub_801E93C((int)"highv_notch_vol=%f\r\n", *(double *)((char *)&v6 + 4));
          sub_801E93C(
            (int)"out_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001BF8)),
            *(float *)&dword_20001BF8);
          sub_801E93C(
            (int)"bat_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001BFC)),
            *(float *)&dword_20001BFC);
          sub_801E93C((int)"bat_vol_avg=%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(flt_20001C14)), flt_20001C14);
          sub_801E93C(
            (int)"bat_cur=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001C00)),
            *(float *)&dword_20001C00);
          sub_801E93C((int)"bat_cur_avg=%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(flt_20001C18)), flt_20001C18);
          sub_801E93C(
            (int)"offgrid_cur=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001C08)),
            *(float *)&dword_20001C08);
          sub_801E93C(
            (int)"vac_offgrid=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001C20)),
            *(float *)&dword_20001C20);
          sub_801E93C(
            (int)"vac_offset=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001C24)),
            *(float *)&dword_20001C24);
          sub_801E93C(
            (int)"iac_offset=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20001C28)),
            *(float *)&dword_20001C28);
          sub_801E93C(
            (int)"g_offset_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_2000033C)),
            *(float *)&dword_2000033C);
          sub_801E93C(
            (int)"real_offset_vol=%f\r\n",
            (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(*(float *)&dword_20000348)),
            *(float *)&dword_20000348);
          sub_801E93C((int)"ntc_inv=%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(flt_20001C2C)), flt_20001C2C);
          sub_801E93C((int)"ntc_rad1=%f\r\n", (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(flt_20001C30)), flt_20001C30);
          v18 = flt_20001C34;
          v19 = *(float *)&v18;
          sub_801E93C((int)"ntc_rad2=%f\r\n", HIDWORD(v18), v18);
          break;
      }
      goto LABEL_11;
    }
  }
  return sub_8023A34(dword_200002A0);
}
// 801DFF4: positive sp value 40 has been found
// 801DD6C: could not find valid save-restore pair for r8
// 801DD6C: could not find valid save-restore pair for r10
// 801DD6C: variable 'v7' is possibly undefined
// 801DD6E: variable 'v8' is possibly undefined
// 801DD7A: variable 'v9' is possibly undefined
// 801DD8C: variable 'v10' is possibly undefined
// 801D864: variable 'v11' is possibly undefined
// 801D868: variable 'v12' is possibly undefined
// 801DA60: using guessed type int sub_801DA60();
// 801DA7C: using guessed type int dword_801DA7C[7];
// 801DADC: using guessed type int dword_801DADC[8];
// 801DAFC: using guessed type int dword_801DAFC[8];
// 801DB24: using guessed type int dword_801DB24[8];
// 801DB44: using guessed type int dword_801DB44[8];
// 801DBB4: using guessed type int sub_801DBB4();
// 801DC34: using guessed type int sub_801DC34();
// 801DC74: using guessed type int sub_801DC74();
// 801DCA8: using guessed type int dword_801DCA8[7];
// 801DCE8: using guessed type int sub_801DCE8();
// 801DD68: using guessed type int sub_801DD68();
// 801E114: using guessed type int dword_801E114[4];
// 801E1E8: using guessed type int dword_801E1E8[7];
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 200002A0: using guessed type int dword_200002A0;
// 200002A4: using guessed type char byte_200002A4;
// 200002A5: using guessed type char byte_200002A5;
// 200002A8: using guessed type char byte_200002A8;
// 200002F8: using guessed type int dword_200002F8;
// 200002FC: using guessed type int dword_200002FC;
// 2000031C: using guessed type int dword_2000031C;
// 20000328: using guessed type int dword_20000328;
// 2000033C: using guessed type int dword_2000033C;
// 20000348: using guessed type int dword_20000348;
// 20000474: using guessed type int dword_20000474;
// 20000513: using guessed type char byte_20000513;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BF8: using guessed type int dword_20001BF8;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C00: using guessed type int dword_20001C00;
// 20001C08: using guessed type int dword_20001C08;
// 20001C10: using guessed type int dword_20001C10;
// 20001C14: using guessed type float flt_20001C14;
// 20001C18: using guessed type float flt_20001C18;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 20001C2C: using guessed type float flt_20001C2C;
// 20001C30: using guessed type float flt_20001C30;
// 20001C34: using guessed type float flt_20001C34;
// 20001C38: using guessed type __int16 word_20001C38;
// 20001C3A: using guessed type __int16 word_20001C3A;
// 20001C3C: using guessed type __int16 word_20001C3C;
// 20001C3E: using guessed type __int16 word_20001C3E;
// 20001C40: using guessed type __int16 word_20001C40;
// 20001C42: using guessed type __int16 word_20001C42;
// 20001C44: using guessed type __int16 word_20001C44;
// 20001C46: using guessed type __int16 word_20001C46;
// 20001C48: using guessed type __int16 word_20001C48;
// 20001C4A: using guessed type __int16 word_20001C4A;
// 20001C4C: using guessed type __int16 word_20001C4C;
// 20001C4E: using guessed type __int16 word_20001C4E;
// 20001C50: using guessed type __int16 word_20001C50;
// 20001C52: using guessed type __int16 word_20001C52;
// 200021BC: using guessed type int dword_200021BC[];
// 20002458: using guessed type int dword_20002458;
// 20002610: using guessed type int dword_20002610;
// 200026B8: using guessed type int dword_200026B8;
// 200026BC: using guessed type int dword_200026BC;
// 200026E8: using guessed type int dword_200026E8;
// 20002770: using guessed type int dword_20002770;
// 20002774: using guessed type int dword_20002774;
// 20002778: using guessed type int dword_20002778;
// 2000277C: using guessed type float flt_2000277C;
// 20002798: using guessed type float flt_20002798;
// 200027A4: using guessed type float flt_200027A4;
// 200028C0: using guessed type int dword_200028C0;
// 200028C4: using guessed type int dword_200028C4;
// 200028C8: using guessed type int dword_200028C8;
// 20002E74: using guessed type int dword_20002E74;
// 20002E78: using guessed type __int16 word_20002E78;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002E7E: using guessed type int dword_20002E7E;
// 20002E82: using guessed type int dword_20002E82;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E88: using guessed type int dword_20002E88;
// 20002E8C: using guessed type int dword_20002E8C;
// 20002E90: using guessed type int dword_20002E90;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD3: using guessed type char byte_20002FD3;
// 20003058: using guessed type int dword_20003058;
// 2000305C: using guessed type int dword_2000305C;
// 20003060: using guessed type int dword_20003060;

//----- (0801E220) --------------------------------------------------------
int sub_801E220()
{
  int v0; // r0
  int result; // r0
  _DWORD v2[9]; // [sp+4h] [bp-5Ch] BYREF
  int v3; // [sp+28h] [bp-38h] BYREF

  sub_80194C8(&byte_20000500, (int)&byte_20002F1C);
  byte_20000504 = byte_20000503;
  byte_20000505 = byte_20000501;
  byte_20000506 = byte_20000502;
  byte_20000507 = byte_20002F1C;
  sub_801D41C();
  sub_8004688();
  if ( byte_20000511 == 1 )
  {
    byte_200004AD = 0;
  }
  else if ( dword_20001C1C <= 10 )
  {
    if ( dword_20001C1C >= -10 && SHIWORD(dword_20002E82) <= 4 )
    {
      if ( (byte_20002F5F[0] || byte_20002FD3) && (unsigned __int8)byte_200002A8 == 204 )
      {
        byte_200004AD = 6;
      }
      else if ( (byte_20002F5F[0] || byte_20002FD3) && (unsigned int)(unsigned __int8)byte_200002A8 - 212 <= 2 )
      {
        byte_200004AD = 4;
      }
      else
      {
        byte_200004AD = 1;
      }
    }
    else
    {
      byte_200004AD = 2;
    }
  }
  else
  {
    byte_200004AD = 3;
  }
  sub_8023280();
  sub_801B040(&word_200004CE, 0x3Cu);
  if ( byte_20000528 == 1 )
  {
    sub_80031E4();
    sub_801F610(v0);
    sub_802325C();
  }
  if ( byte_20002F60 != byte_200004AF )
  {
    sub_8003234();
    if ( !byte_20002F60 || byte_20002F60 == 5 )
      sub_8019090();
    dword_20002EC4[0] = 0;
    dword_20002EC8 = 0;
    dword_20002ECC = 0;
    dword_20002ED0 = 0;
    byte_200004AF = byte_20002F60;
  }
  switch ( byte_20002F60 )
  {
    case 0:
    case 5:
      sub_8019658();
      goto LABEL_89;
    case 1:
      sub_80102C0();
      sub_8003234();
      goto LABEL_89;
    case 2:
      sub_801B068();
      goto LABEL_89;
    case 3:
      sub_8003EBC();
      goto LABEL_89;
    case 10:
      if ( !byte_20000529
        || byte_20000529 != 3
        || (unsigned __int8)byte_2000052A < (unsigned int)(unsigned __int16)dword_20002E7A
        || (unsigned __int8)byte_2000052A > (unsigned int)(unsigned __int16)dword_20002E7A )
      {
        goto LABEL_88;
      }
      byte_20000529 = 0;
      goto LABEL_89;
    case 11:
      if ( (unsigned __int16)dword_20002E7A < 0xFu && byte_200004AE == 1
        || (unsigned __int16)dword_20002E7A > 0x63u && byte_200004AE == 2 )
      {
        byte_200004AE = 0;
        sub_8018434(2, (unsigned int)flt_20001C30, (unsigned __int16)dword_20002E7A, word_20002E86);
      }
      if ( byte_200004AE )
      {
        if ( byte_200004AE == 1 )
        {
          flt_200004E4 = 2500.0;
          if ( !sub_801B040(&word_200004BC[1], 0x258u) )
            goto LABEL_88;
          goto LABEL_53;
        }
        if ( byte_200004AE == 2 )
        {
          flt_200004E4 = -2500.0;
          if ( sub_801B040(&word_200004BC[2], 0x258u) )
LABEL_53:
            sub_8018434(2, (unsigned int)flt_20001C30, (unsigned __int16)dword_20002E7A, word_20002E86);
        }
      }
      else
      {
        if ( byte_20000478 == 1 && sub_801B040(word_200004BC, 0xE10u) )
        {
          if ( (unsigned __int16)dword_20002E7A <= 0x32u )
            byte_200004AE = 2;
          else
            byte_200004AE = 1;
        }
        flt_200004E4 = 0.0;
      }
LABEL_88:
      sub_8003234();
LABEL_89:
      if ( byte_20002F60 && byte_20002F60 != 5 || (result = (unsigned __int8)byte_200015E6, !byte_200015E6) )
      {
        flt_200004D8 = 0.01;
        dword_200004DC = 0;
        byte_200004A8 = 0;
        byte_200004AA = 0;
        sub_8002364(v2, 40);
        if ( byte_200015E6 )
        {
          result = sub_8025570(dword_20000434, (unsigned int)v2, 0);
          if ( result )
          {
            result = (int)dword_20002EC4;
            dword_20002EC4[0] = v2[1];
            dword_20002EC8 = v2[2];
            dword_20002ECC = v2[3];
            dword_20002ED0 = v2[0];
          }
        }
        else
        {
          result = (int)dword_20002EC4;
          dword_20002EC4[0] = 0;
          dword_20002EC8 = 0;
          dword_20002ECC = 0;
          dword_20002ED0 = 0;
        }
      }
      return result;
    case 12:
      if ( (unsigned __int16)dword_20002E7A < 0x50u )
        sub_8003234();
      if ( (unsigned __int16)dword_20002E7A > 0x55u )
        goto LABEL_88;
      goto LABEL_89;
    case 14:
      switch ( word_20002F08 )
      {
        case 0:
          byte_2000050B = 0;
          word_2000051A = 2500;
          word_20002F08 = 1;
          dword_20002F18 = dword_2000002C;
          dword_200004E8 = 7200;
          if ( (unsigned __int16)dword_20002E7E > 0xBB8u )
            dword_200004E8 = 14400;
          break;
        case 1:
          sub_8003234();
          if ( (unsigned __int16)dword_20002E7A == 100 || dword_2000002C - dword_20002F18 > (unsigned int)dword_200004E8 )
          {
            word_20002F08 = 2;
            dword_20002F18 = dword_2000002C;
          }
          break;
        case 2:
          sub_8003234();
          if ( (unsigned int)(dword_2000002C - dword_20002F18) >= 0x3C
            && (word_20002E86 < 450 || (unsigned int)(dword_2000002C - dword_20002F18) > 0x708) )
          {
            dword_20002F18 = dword_2000002C;
            dword_20002F14 = dword_20003044;
            word_20002F08 = 3;
          }
          break;
        case 3:
          sub_8003234();
          word_20002F0C = dword_20003044 - dword_20002F14;
          if ( (dword_20002E90 & 0x40) == 0 && (unsigned __int16)dword_20002E7A < 0x1Eu
            || dword_2000002C - dword_20002F18 > (unsigned int)dword_200004E8
            || !byte_200002B4 )
          {
            word_20002F08 = 4;
            dword_20002F18 = dword_2000002C;
          }
          break;
        case 4:
          sub_8003234();
          if ( (unsigned int)(dword_2000002C - dword_20002F18) >= 0x3C
            && (word_20002E86 < 500 || (unsigned int)(dword_2000002C - dword_20002F18) > 0x708 || byte_200002B7 == 1) )
          {
            word_20002F08 = 5;
            dword_20002F18 = dword_2000002C;
            dword_20002F10 = dword_20003040;
          }
          break;
        case 5:
          sub_8003234();
          word_20002F0A = dword_20003040 - dword_20002F10;
          if ( (unsigned __int16)dword_20002E7A >= 0x50u
            || dword_2000002C - dword_20002F18 > (unsigned int)dword_200004E8 )
          {
            word_20002F08 = 6;
            dword_20002F18 = dword_2000002C;
            dword_20002F14 = dword_20003044;
            sub_800591C(0x950u, &word_20002F0A, 2u);
            sub_800591C(0x952u, &word_20002F0C, 2u);
            byte_2000050B = 1;
            word_2000051A = 800;
            sub_800591C(0x90u, &byte_2000050B, 1u);
            v3 = 2;
            sub_800591C(0, &v3, 1u);
          }
          break;
        case 6:
          sub_8003234();
          break;
        default:
          word_20002F08 = 7;
          sub_8003234();
          break;
      }
      if ( word_20002F08 == 1 )
        sub_8003234();
      goto LABEL_89;
    default:
      goto LABEL_89;
  }
}
// 801E2F2: variable 'v0' is possibly undefined
// 801F610: using guessed type __int64 __fastcall sub_801F610(_DWORD);
// 2000002C: using guessed type int dword_2000002C;
// 200002A8: using guessed type char byte_200002A8;
// 200002B4: using guessed type char byte_200002B4;
// 200002B7: using guessed type char byte_200002B7;
// 20000434: using guessed type int dword_20000434;
// 20000478: using guessed type char byte_20000478;
// 200004A8: using guessed type char byte_200004A8;
// 200004AA: using guessed type char byte_200004AA;
// 200004AD: using guessed type char byte_200004AD;
// 200004AE: using guessed type char byte_200004AE;
// 200004AF: using guessed type char byte_200004AF;
// 200004BC: using guessed type _WORD[3];
// 200004CE: using guessed type _WORD;
// 200004D8: using guessed type float flt_200004D8;
// 200004DC: using guessed type int dword_200004DC;
// 200004E4: using guessed type float flt_200004E4;
// 200004E8: using guessed type int dword_200004E8;
// 20000500: using guessed type char byte_20000500;
// 20000501: using guessed type char byte_20000501;
// 20000502: using guessed type char byte_20000502;
// 20000503: using guessed type char byte_20000503;
// 20000504: using guessed type char byte_20000504;
// 20000505: using guessed type char byte_20000505;
// 20000506: using guessed type char byte_20000506;
// 20000507: using guessed type char byte_20000507;
// 2000050B: using guessed type char byte_2000050B;
// 2000050D: using guessed type __int16 word_2000050D;
// 2000050F: using guessed type __int16 word_2000050F;
// 20000511: using guessed type char byte_20000511;
// 2000051A: using guessed type __int16 word_2000051A;
// 20000528: using guessed type char byte_20000528;
// 20000529: using guessed type char byte_20000529;
// 2000052A: using guessed type char byte_2000052A;
// 200015E6: using guessed type char byte_200015E6;
// 20001C1C: using guessed type int dword_20001C1C;
// 20001C30: using guessed type float flt_20001C30;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002E7E: using guessed type int dword_20002E7E;
// 20002E82: using guessed type int dword_20002E82;
// 20002E86: using guessed type __int16 word_20002E86;
// 20002E90: using guessed type int dword_20002E90;
// 20002EC4: using guessed type int dword_20002EC4[];
// 20002EC8: using guessed type int dword_20002EC8;
// 20002ECC: using guessed type int dword_20002ECC;
// 20002ED0: using guessed type int dword_20002ED0;
// 20002F08: using guessed type __int16 word_20002F08;
// 20002F0A: using guessed type __int16 word_20002F0A;
// 20002F0C: using guessed type __int16 word_20002F0C;
// 20002F10: using guessed type int dword_20002F10;
// 20002F14: using guessed type int dword_20002F14;
// 20002F18: using guessed type int dword_20002F18;
// 20002F1C: using guessed type char byte_20002F1C;
// 20002F60: using guessed type char byte_20002F60;
// 20002FD3: using guessed type char byte_20002FD3;
// 20003040: using guessed type int dword_20003040;
// 20003044: using guessed type int dword_20003044;

//----- (0801E774) --------------------------------------------------------
int __fastcall sub_801E774(int a1, int a2, int a3, int a4)
{
  int v4; // r8
  int v5; // r5
  int v6; // r7
  int v7; // r4
  int v8; // r6
  int v9; // r0
  int v11; // r0
  _BYTE *i; // r1
  int v13; // r3
  int v14; // r0
  unsigned __int8 *j; // r1
  int v16; // r12
  int v17; // r2
  int v18; // r1
  unsigned int v19; // r1
  unsigned int v20; // [sp+4h] [bp-444h] BYREF
  int v21; // [sp+8h] [bp-440h] BYREF
  _BYTE v22[16]; // [sp+Ch] [bp-43Ch] BYREF
  _BYTE v23[3]; // [sp+1Ch] [bp-42Ch] BYREF
  _BYTE v24[1065]; // [sp+1Fh] [bp-429h] BYREF

  v20 = 0;
  dword_200008B4 = 134490112;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = sub_8018D78(v23, &v21, 2000, a4);
      if ( v9 )
      {
        if ( v9 == 1 )
        {
          sub_8019A94(24);
          sub_8019A94(24);
          return -3;
        }
        if ( v6 > 0 )
          ++v5;
        if ( v5 > 5 )
        {
          sub_8019A94(24);
          sub_8019A94(24);
          return 0;
        }
        sub_8019A94(67);
      }
      else
      {
        v5 = 0;
        if ( v21 == -1 )
        {
          sub_8019A94(6);
          return 0;
        }
        if ( !v21 )
        {
          sub_8019A94(6);
          v8 = 1;
          continue;
        }
        if ( v23[1] != (unsigned __int8)v7 )
        {
          sub_8019A94(21);
          continue;
        }
        if ( v7 )
        {
          if ( sub_800F86C((_DWORD *)dword_200008B4, (int)v24, v21 / 8) )
          {
            sub_8019A94(24);
            sub_8019A94(24);
            return -2;
          }
          dword_200008B4 += v21;
          sub_8019A94(6);
        }
        else
        {
          if ( !v24[0] )
          {
            sub_8019A94(6);
            v8 = 1;
            v4 = 1;
            continue;
          }
          v11 = 0;
          for ( i = v24; *i && v11 <= 255; ++i )
          {
            v13 = v11++;
            byte_20003674[v13] = *i;
          }
          byte_20003674[v11] = 0;
          v14 = 0;
          for ( j = i + 1; ; ++j )
          {
            v17 = *j;
            if ( v17 == 32 || v14 >= 16 )
              break;
            v16 = v14++;
            v22[v16] = v17;
          }
          v22[v14] = 0;
          sub_801A5C4(v22, &v20);
          dword_200008B8 = v20;
          if ( MEMORY[0x1FFF75E0] == 0xFFFF )
            v18 = 0x80000;
          else
            v18 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
          if ( v18 - 1 < v20 )
          {
            sub_8019A94(24);
            sub_8019A94(24);
            return -1;
          }
          if ( MEMORY[0x1FFF75E0] == 0xFFFF )
            v19 = 0x80000;
          else
            v19 = (MEMORY[0x1FFF75E0] << 10) & 0x3FFFFFF;
          sub_800F808(0x8040000u, (v19 >> 1) + 134479872);
          sub_8019A94(6);
          sub_8019A94(67);
        }
        ++v7;
        v6 = 1;
      }
    }
    while ( !v8 );
  }
  while ( !v4 );
  return v20;
}
// 801E7A6: variable 'a4' is possibly undefined
// 200008B4: using guessed type int dword_200008B4;
// 200008B8: using guessed type int dword_200008B8;
// 20003674: using guessed type _BYTE byte_20003674[256];

//----- (0801E93C) --------------------------------------------------------
int sub_801E93C(int a1, ...)
{
  va_list varg_r1; // [sp+Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  return printf_core(a1, (int)varg_r1, (int)&unk_20000038, (void (*)(void))sub_801FD30);
}
// 801FD30: using guessed type int sub_801FD30();

//----- (0801E95C) --------------------------------------------------------
int snprintf(int a1, int a2, const char *a3, ...)
{
  int result; // r0
  _DWORD v4[3]; // [sp+0h] [bp-20h] BYREF
  va_list varg_r3; // [sp+1Ch] [bp-4h] BYREF

  va_start(varg_r3, a3);
  v4[0] = a1;
  v4[1] = a2 - 1;
  result = printf_core((int)a3, (int)varg_r3, (int)v4, (void (*)(void))&loc_801FB3A);
  *(_BYTE *)v4[0] = 0;
  return result;
}

//----- (0801E984) --------------------------------------------------------
int sprintf(int a1, const char *a2, ...)
{
  int v2; // r4
  int varg_r0; // [sp+8h] [bp-10h] BYREF
  va_list varg_r2; // [sp+10h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  v2 = printf_core((int)a2, (int)varg_r2, (int)&varg_r0, (void (*)(void))&loc_801FB50);
  sub_801F350(0, &varg_r0);
  return v2;
}

//----- (0801E9AC) --------------------------------------------------------
int __fastcall sub_801E9AC(int a1, int a2)
{
  return printf_core(a1, a2, (int)&unk_20000038, (void (*)(void))sub_801FD30);
}
// 801FD30: using guessed type int sub_801FD30();

//----- (0801E9DE) --------------------------------------------------------
int __fastcall _NVIC_SetPriority(int a1, char a2)
{
  char v2; // r1
  int result; // r0

  v2 = 16 * a2;
  if ( a1 < 0 )
  {
    result = (a1 & 0xF) - 536813568;
    *(_BYTE *)(result + 3348) = v2;
  }
  else
  {
    result = a1 - 536813568;
    *(_BYTE *)(result + 1024) = v2;
  }
  return result;
}
// 801E9DE: invalid function type 'void __fastcall _NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)' has been ignored

//----- (0801EA00) --------------------------------------------------------
void __noreturn sub_801EA00()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801EA24) --------------------------------------------------------
void __noreturn sub_801EA24()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801EA48) --------------------------------------------------------
void __noreturn sub_801EA48()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (0801EA6C) --------------------------------------------------------
void *sub_801EA6C()
{
  return &unk_200016C4;
}

//----- (0801EAA8) --------------------------------------------------------
__int64 __fastcall fp_digits(__int64 a1, double a2, int a3, int a4)
{
  int v4; // r11
  __int64 v5; // r4
  int v6; // r0
  double v7; // r8
  double v8; // kr00_8
  int i; // r7
  double v11; // r0
  unsigned __int64 v12; // r0
  int j; // r4
  unsigned __int64 v14; // r2
  int v15; // r4
  int v16; // r3
  int v17; // r2
  __int64 v18; // [sp+0h] [bp-38h]

  v18 = a1;
  v4 = a3;
  if ( a2 == 0.0 )
  {
    if ( a4 == 1 )
      HIDWORD(a1) = ~a3;
    else
      HIDWORD(a1) = 0;
    *(_DWORD *)a1 = &dword_801EC00;
    *(_DWORD *)(a1 + 4) = HIDWORD(a1);
    *(_DWORD *)(a1 + 8) = 1;
    *(_DWORD *)(a1 + 12) = a4;
  }
  else
  {
    HIDWORD(v5) = (signed int)(19728 * ((HIDWORD(a2) >> 20) - 1023)) >> 16;
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = a4 == 1 ? -v4 : HIDWORD(v5) - v4 + 1;
        v7 = 1.0;
        v8 = 10.0;
        for ( i = v6 >= 0 ? v6 : -v6; i; i >>= 1 )
        {
          if ( i << 31 )
            v7 = v7 * v8;
          v8 = v8 * v8;
        }
        v11 = v6 >= 0 ? a2 / v7 : a2 * v7;
        if ( v11 < 1.84467441e19 )
          LODWORD(v12) = sub_8002D00(COERCE_UNSIGNED_INT64(v11 + 0.5), HIDWORD(COERCE_UNSIGNED_INT64(v11 + 0.5)));
        else
          v12 = -1;
        for ( j = 16; v12 && j >= 0; --j )
        {
          v14 = v12 % 0xA;
          v12 /= 0xAu;
          *(_BYTE *)(HIDWORD(v18) + j) = v14 + 48;
        }
        v15 = j + 1;
        v16 = 17 - v15;
        LODWORD(v5) = v15 + HIDWORD(v18);
        if ( a4 == 1 )
          break;
        v17 = 1;
        if ( v12 || v16 > v4 )
        {
          v17 = 0;
          ++HIDWORD(v5);
        }
        else if ( v16 < v4 )
        {
          v17 = 0;
          --HIDWORD(v5);
        }
        if ( v17 )
          goto LABEL_40;
      }
      if ( !v12 )
        break;
      v4 = 17;
      a4 = 0;
    }
    HIDWORD(v5) = v16 - v4 - 1;
LABEL_40:
    *(_DWORD *)(v18 + 8) = v16;
    *(_DWORD *)(v18 + 12) = a4;
    *(_QWORD *)v18 = v5;
  }
  return v18;
}
// 801EB8C: variable 'v12' is possibly undefined
// 801EC00: using guessed type int dword_801EC00;

//----- (0801EC0C) --------------------------------------------------------
int __fastcall printf_core(int a1, int a2, int a3, void (*a4)(void))
{
  int v4; // r10
  int *v6; // r9
  unsigned __int8 *v7; // r6
  int v8; // r5
  unsigned int v9; // r4
  int v10; // r7
  char v11; // t1
  int v12; // r0
  int v13; // r0
  int v14; // r2
  _QWORD *v15; // t1
  int v16; // t1
  int v17; // r0
  int v18; // t1
  int v19; // r0
  __int64 v20; // r0
  bool v21; // zf
  bool v22; // cc
  int v23; // r0
  _BYTE *v24; // r1
  unsigned __int8 v25; // t1
  int v26; // r0
  int v27; // t1
  int v28; // r1
  int v29; // r8
  int v30; // r7
  int v31; // t1
  bool v32; // cf
  void (__fastcall *v33)(int, int); // r3
  __int16 v34; // r1
  int v35; // r0
  int v36; // r2
  int v37; // r2
  int v38; // r12
  int v39; // t1
  int *v40; // r2
  char v41; // r2
  int v42; // r2
  int v43; // r8
  int v44; // r1
  int v45; // r2
  int v46; // r2
  int v47; // t1
  int *v48; // r2
  int v49; // r2
  const char *v50; // r0
  unsigned __int64 v51; // r2
  int v52; // r0
  int i; // r7
  int v54; // r1
  int v55; // r0
  unsigned int v57; // r12
  double v58; // r2
  char *v59; // r12
  int v60; // r0
  __int64 v61; // r0
  int v62; // r0
  __int64 v63; // r0
  int v64; // r0
  int v65; // r0
  __int64 v66; // r0
  int v67; // r1
  int v68; // r1
  char *v69; // r7
  int v70; // r8
  unsigned int v71; // r1
  _BYTE *v72; // r8
  int v73; // r0
  int v74; // r0
  int v75; // r1
  int v76; // t1
  unsigned int v77; // [sp+0h] [bp-88h] BYREF
  int v78; // [sp+4h] [bp-84h]
  int v79; // [sp+8h] [bp-80h]
  const char *v80; // [sp+Ch] [bp-7Ch]
  int v81; // [sp+10h] [bp-78h]
  int v82; // [sp+14h] [bp-74h]
  _BYTE v83[32]; // [sp+18h] [bp-70h] BYREF
  int v84; // [sp+38h] [bp-50h] BYREF
  int v85; // [sp+3Ch] [bp-4Ch]
  int v86; // [sp+40h] [bp-48h]
  int v87; // [sp+44h] [bp-44h]
  _BYTE v88[7]; // [sp+48h] [bp-40h] BYREF
  char v89; // [sp+4Fh] [bp-39h] BYREF
  char *v90; // [sp+50h] [bp-38h]
  int v91; // [sp+54h] [bp-34h]
  int v92; // [sp+58h] [bp-30h]
  int v93; // [sp+5Ch] [bp-2Ch]
  int v94; // [sp+60h] [bp-28h]

  v91 = a1;
  v92 = a2;
  v93 = a3;
  v94 = (int)a4;
  v6 = (int *)a2;
  v7 = (unsigned __int8 *)a1;
  v8 = 0;
  while ( *v7 )
  {
    if ( *v7 != 37 )
    {
LABEL_57:
      a4();
      ++v8;
      goto LABEL_148;
    }
    v9 = 0;
    v10 = 0;
    v82 = 0;
    while ( 1 )
    {
      v11 = *++v7;
      v12 = 1 << (v11 - 32);
      if ( (v12 & 0x12809) == 0 )
        break;
      v9 |= v12;
    }
    if ( *v7 == 42 )
    {
      v15 = (_QWORD *)*v6++;
      v14 = (int)v15;
      v82 = (int)v15;
      if ( (int)v15 < 0 )
      {
        v9 |= 0x2000u;
        v82 = -v14;
      }
      v9 |= 2u;
      ++v7;
    }
    else
    {
      while ( 1 )
      {
        v13 = *v7;
        if ( (unsigned int)(v13 - 48) > 9 )
          break;
        v9 |= 2u;
        ++v7;
        v82 = v13 + 10 * v82 - 48;
      }
    }
    if ( *v7 == 46 )
    {
      v16 = *++v7;
      v9 |= 4u;
      if ( v16 == 42 )
      {
        v18 = *v6++;
        v10 = v18;
        ++v7;
      }
      else
      {
        while ( 1 )
        {
          v17 = *v7;
          if ( (unsigned int)(v17 - 48) > 9 )
            break;
          v10 = v17 + 10 * v10 - 48;
          ++v7;
        }
      }
    }
    v19 = *v7;
    if ( v19 == 108 )
    {
      v9 |= 0x100000u;
LABEL_28:
      if ( v7[1] == v19 )
      {
        v9 += 0x100000;
        ++v7;
      }
      goto LABEL_30;
    }
    if ( *v7 <= 0x6Cu )
    {
      if ( v19 != 76 )
      {
        if ( v19 == 104 )
        {
          v9 |= 0x300000u;
          goto LABEL_28;
        }
        if ( v19 != 106 )
          goto LABEL_31;
        v9 |= 0x200000u;
      }
LABEL_30:
      ++v7;
      goto LABEL_31;
    }
    if ( v19 == 116 || v19 == 122 )
      goto LABEL_30;
LABEL_31:
    LODWORD(v20) = *v7;
    v21 = (_DWORD)v20 == 102;
    v22 = (unsigned int)v20 <= 0x66;
    while ( 1 )
    {
      if ( v21 )
        goto LABEL_151;
      if ( !v22 )
        break;
      if ( (_DWORD)v20 == 88 )
      {
        v44 = 16;
        goto LABEL_102;
      }
      if ( *v7 > 0x58u )
      {
        if ( (_DWORD)v20 != 99 )
        {
          if ( (_DWORD)v20 != 100 )
          {
            if ( (_DWORD)v20 != 101 )
              goto LABEL_57;
LABEL_151:
            if ( (v9 & 4) == 0 )
              v10 = 6;
            v57 = ((unsigned int)v6 + 7) & 0xFFFFFFF8;
            v58 = *(double *)v57;
            v6 = (int *)(v57 + 8);
            if ( (*(_DWORD *)(v57 + 4) & 0x80000000) != 0 )
            {
              v59 = &byte_801F2DC;
            }
            else if ( (v9 & 0x800) != 0 )
            {
              v59 = &byte_801F2E0;
            }
            else if ( v9 << 31 )
            {
              v59 = &byte_801F2E4;
            }
            else
            {
              v59 = "";
            }
            HIDWORD(v58) &= ~0x80000000;
            v90 = v59;
            if ( (_DWORD)v20 == 101 )
              goto LABEL_169;
            if ( (int)v20 <= 101 )
            {
              if ( (_DWORD)v20 != 69 )
              {
                if ( (_DWORD)v20 != 70 )
                {
                  if ( (_DWORD)v20 == 71 )
                    goto LABEL_179;
LABEL_198:
                  if ( (v9 & 8) == 0 && v78 >= v4 )
                    v78 = -1;
                  v89 = 0;
                  v69 = &v89;
                  if ( v79 != 0x80000000 )
                  {
                    v84 = 43;
                    v70 = 2;
                    if ( v79 < 0 )
                    {
                      v79 = -v79;
                      v84 = 45;
                    }
                    while ( 1 )
                    {
                      v22 = v70-- <= 0;
                      if ( v22 && !v79 )
                        break;
                      v71 = v79 % 0xAu;
                      v79 /= 0xAu;
                      *--v69 = v71 + 48;
                    }
                    *(v69 - 1) = v84;
                    *(v69 - 2) = *v7 & 0x20 | 0x45;
                    v69 -= 2;
                  }
                  v72 = (_BYTE *)(v88 - v69 + 7);
                  v73 = (unsigned __int8)*v90;
                  if ( *v90 )
                    v73 = 1;
                  v82 = v82 - (_DWORD)&v72[v73 + v4 + (v78 >> 31)] - 1;
                  if ( (v9 & 0x10000) == 0 )
                    v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
                  if ( *v90 )
                  {
                    a4();
                    ++v8;
                  }
                  if ( (v9 & 0x10000) != 0 )
                    v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
                  while ( 1 )
                  {
                    v22 = v4-- <= 0;
                    if ( v22 )
                      break;
                    if ( v81 < 0 || (int)v80 <= v81 )
                    {
                      v75 = v93;
                      v74 = 48;
                    }
                    else
                    {
                      v74 = *(unsigned __int8 *)(v77 + v81);
                      v75 = v93;
                    }
                    ((void (__fastcall *)(int, int))a4)(v74, v75);
                    ++v8;
                    ++v81;
                    if ( !--v78 )
                    {
                      ((void (__fastcall *)(int, int))a4)(46, v93);
                      ++v8;
                    }
                  }
                  while ( 1 )
                  {
                    v22 = (int)v72-- <= 0;
                    if ( v22 )
                      break;
                    v76 = (unsigned __int8)*v69++;
                    ((void (__fastcall *)(int, int))a4)(v76, v93);
                    ++v8;
                  }
LABEL_227:
                  v33 = (void (__fastcall *)(int, int))a4;
                  v34 = v9;
                  v36 = v93;
                  v35 = v82;
LABEL_147:
                  v8 += printf_post_padding(v35, v34, v36, v33);
                  goto LABEL_148;
                }
LABEL_173:
                v79 = 0x80000000;
                HIDWORD(v63) = v83;
                LODWORD(v63) = &v84;
                fp_digits(v63, v58, v10, 1);
                v80 = (const char *)v86;
                v4 = v86;
                v77 = v84;
                v81 = 0;
                if ( !v87 )
                  v4 = v85 + v10 + 1;
                if ( v10 - v4 >= 0 )
                {
                  v64 = -1 - (v10 - v4);
                  v4 = v10 + 1;
                  v81 = v64;
                }
                v78 = v4 - v10;
                goto LABEL_198;
              }
LABEL_169:
              if ( v10 < 17 )
                v60 = v10 + 1;
              else
                v60 = 17;
              v77 = v60;
              HIDWORD(v61) = v83;
              LODWORD(v61) = &v84;
              fp_digits(v61, v58, v77, 0);
              v62 = v85;
              v80 = (const char *)v86;
              v77 = v84;
              v4 = v10 + 1;
              v81 = 0;
LABEL_191:
              v78 = 1;
              v79 = v62;
              goto LABEL_198;
            }
            if ( (_DWORD)v20 == 102 )
              goto LABEL_173;
            if ( (_DWORD)v20 != 103 )
              goto LABEL_198;
LABEL_179:
            if ( v10 < 1 )
              v10 = 1;
            if ( v10 <= 17 )
              v65 = v10;
            else
              v65 = 17;
            v77 = v65;
            HIDWORD(v66) = v83;
            LODWORD(v66) = &v84;
            fp_digits(v66, v58, v77, 0);
            v62 = v85;
            v80 = (const char *)v86;
            v81 = 0;
            v77 = v84;
            v4 = v10;
            if ( (v9 & 8) == 0 )
            {
              v67 = (int)v80;
              if ( (int)v80 >= v10 )
                goto LABEL_187;
              while ( 1 )
              {
                v4 = v67;
LABEL_187:
                if ( v4 <= 1 || *(_BYTE *)(v77 + v4 - 1) != 48 )
                  break;
                v67 = v4 - 1;
              }
            }
            if ( v85 >= v10 || v85 < -4 )
              goto LABEL_191;
            if ( v85 <= 0 )
            {
              v81 += v85;
              v68 = v4 - v85;
              goto LABEL_196;
            }
            v68 = v85 + 1;
            if ( v85 + 1 > v4 )
LABEL_196:
              v4 = v68;
            v78 = v85 - v81 + 1;
            v79 = 0x80000000;
            goto LABEL_198;
          }
LABEL_85:
          v77 = 10;
          v37 = (v9 >> 20) & 7;
          if ( v37 == 2 )
          {
            v40 = (int *)(((unsigned int)v6 + 7) & 0xFFFFFFF8);
            HIDWORD(v20) = v40[1];
            v38 = *v40;
            v6 = v40 + 2;
          }
          else
          {
            v39 = *v6++;
            v38 = v39;
            HIDWORD(v20) = v39 >> 31;
            if ( v37 == 3 )
            {
              v38 = (__int16)v38;
              HIDWORD(v20) = (__int16)v38 >> 31;
            }
            if ( v37 == 4 )
            {
              v38 = (char)v38;
              HIDWORD(v20) = (char)v38 >> 31;
            }
          }
          if ( v20 < 0 )
          {
            v32 = v38 == 0;
            v38 = -v38;
            HIDWORD(v20) = -(HIDWORD(v20) + !v32);
            v41 = 45;
            goto LABEL_98;
          }
          if ( (v9 & 0x800) != 0 )
          {
            v41 = 43;
            goto LABEL_98;
          }
          v42 = v9 << 31;
          if ( v9 << 31 )
          {
            v41 = 32;
LABEL_98:
            LOBYTE(v78) = v41;
            v42 = 1;
          }
          v43 = v42;
LABEL_123:
          if ( (_DWORD)v20 == 88 )
            v50 = "0123456789ABCDEF";
          else
            v50 = "0123456789abcdef";
          v80 = v50;
          v79 = (int)&v84;
          while ( v38 | HIDWORD(v20) )
          {
            LODWORD(v20) = v38;
            v51 = v20 % (unsigned __int64)v77;
            v20 /= (unsigned __int64)v77;
            v38 = v20;
            LOBYTE(v51) = v80[v51];
            *(_BYTE *)--v79 = v51;
          }
          v4 = (int)&v83[-v79 + 32];
          if ( (v9 & 4) != 0 )
            v9 &= ~0x10000u;
          else
            v10 = 1;
          if ( v10 <= v4 )
            v52 = 0;
          else
            v52 = v10 - v4;
          v77 = v52;
          v82 -= v52 + v4 + v43;
          if ( (v9 & 0x10000) == 0 )
            v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
          for ( i = 0; i < v43; ++i )
          {
            ((void (__fastcall *)(_DWORD, int))a4)(*((unsigned __int8 *)&v78 + i), v93);
            ++v8;
          }
          if ( (v9 & 0x10000) != 0 )
            v8 += printf_pre_padding_0(v82, v9, v93, (void (__fastcall *)(int, int))a4);
          while ( 1 )
          {
            v54 = v77--;
            if ( v54 <= 0 )
              break;
            ((void (__fastcall *)(int, int))a4)(48, v93);
            ++v8;
          }
          while ( 1 )
          {
            v22 = v4-- <= 0;
            if ( v22 )
              break;
            v55 = *(unsigned __int8 *)v79++;
            ((void (__fastcall *)(int, int))a4)(v55, v93);
            ++v8;
          }
          goto LABEL_227;
        }
        v25 = *(_BYTE *)v6++;
        LOWORD(v77) = v25;
        v4 = (int)&v77;
        v26 = 1;
LABEL_68:
        v28 = 0;
        if ( (v9 & 4) != 0 )
        {
          while ( 1 )
          {
            v29 = v28;
            if ( v28 >= v10 || v28 >= v26 && !*(_BYTE *)(v4 + v28) )
              break;
            ++v28;
          }
        }
        else
        {
          while ( 1 )
          {
            v29 = v28;
            if ( v28 >= v26 && !*(_BYTE *)(v4 + v28) )
              break;
            ++v28;
          }
        }
        v30 = v82 - v29;
        v8 += printf_pre_padding_0(v82 - v29, v9, v93, (void (__fastcall *)(int, int))a4) + v29;
        while ( 1 )
        {
          v32 = v29-- != 0;
          if ( !v32 )
            break;
          v31 = *(unsigned __int8 *)v4++;
          ((void (__fastcall *)(int, int))a4)(v31, v93);
        }
        v33 = (void (__fastcall *)(int, int))a4;
        v34 = v9;
        v35 = v30;
        v36 = v93;
        goto LABEL_147;
      }
      if ( !*v7 )
        return v8;
      v21 = (_DWORD)v20 == 69;
      v22 = *v7 <= 0x45u;
      if ( (_DWORD)v20 != 69 )
      {
        v21 = (_DWORD)v20 == 70;
        v22 = *v7 <= 0x46u;
        if ( (_DWORD)v20 != 70 )
        {
          if ( (_DWORD)v20 != 71 )
            goto LABEL_57;
          goto LABEL_151;
        }
      }
    }
    if ( (_DWORD)v20 == 112 )
    {
      v9 |= 4u;
      v10 = 8;
      v77 = 16;
      goto LABEL_104;
    }
    if ( *v7 > 0x70u )
    {
      switch ( (_DWORD)v20 )
      {
        case 's':
          v27 = *v6++;
          v4 = v27;
          v26 = -1;
          goto LABEL_68;
        case 'u':
          v44 = 10;
LABEL_102:
          v77 = v44;
          break;
        case 'x':
          v45 = 16;
LABEL_103:
          v77 = v45;
          break;
        default:
          goto LABEL_57;
      }
LABEL_104:
      v46 = (v9 >> 20) & 7;
      if ( v46 == 2 )
      {
        v48 = (int *)(((unsigned int)v6 + 7) & 0xFFFFFFF8);
        HIDWORD(v20) = v48[1];
        v38 = *v48;
        v6 = v48 + 2;
      }
      else
      {
        v47 = *v6++;
        v38 = v47;
        HIDWORD(v20) = 0;
        if ( v46 == 3 )
          v38 = (unsigned __int16)v38;
        if ( v46 == 4 )
          v38 = (unsigned __int8)v38;
      }
      v43 = 0;
      if ( (v9 & 8) == 0 )
        goto LABEL_123;
      if ( (_DWORD)v20 != 112 )
      {
        if ( v77 == 0x10 && v38 | HIDWORD(v20) )
        {
          LOBYTE(v78) = 48;
          BYTE1(v78) = v20;
          v49 = 2;
LABEL_118:
          v43 = v49;
        }
        if ( v77 == 8 && (v38 | HIDWORD(v20) || (v9 & 4) != 0) )
        {
          LOBYTE(v78) = 48;
          v43 = 1;
          --v10;
        }
        goto LABEL_123;
      }
      LOBYTE(v78) = 64;
      v49 = 1;
      goto LABEL_118;
    }
    if ( (_DWORD)v20 == 103 )
      goto LABEL_151;
    if ( (_DWORD)v20 == 105 )
      goto LABEL_85;
    if ( (_DWORD)v20 != 110 )
    {
      if ( (_DWORD)v20 != 111 )
        goto LABEL_57;
      v45 = 8;
      goto LABEL_103;
    }
    v23 = (v9 >> 20) & 7;
    if ( v23 == 2 )
    {
      *(_QWORD *)*v6 = v8;
    }
    else if ( v23 == 3 )
    {
      *(_WORD *)*v6 = v8;
    }
    else
    {
      v24 = (_BYTE *)*v6;
      if ( v23 == 4 )
        *v24 = v8;
      else
        *(_DWORD *)v24 = v8;
    }
    ++v6;
LABEL_148:
    ++v7;
  }
  return v8;
}
// 801F1BA: variable 'v4' is possibly undefined
// 801F2DC: using guessed type char byte_801F2DC;
// 801F2E0: using guessed type char byte_801F2E0;
// 801F2E4: using guessed type char byte_801F2E4;

//----- (0801F2E8) --------------------------------------------------------
int __fastcall printf_post_padding(int a1, __int16 a2, int a3, void (__fastcall *a4)(int, int))
{
  int v5; // r5

  v5 = 0;
  if ( (a2 & 0x2000) != 0 )
  {
    while ( --a1 >= 0 )
    {
      a4(32, a3);
      ++v5;
    }
  }
  return v5;
}

//----- (0801F30C) --------------------------------------------------------
int __fastcall printf_pre_padding_0(int a1, int a2, int a3, void (__fastcall *a4)(int, int))
{
  int v5; // r5
  int v8; // r7

  v5 = 0;
  if ( (a2 & 0x10000) != 0 )
    v8 = 48;
  else
    v8 = 32;
  if ( (a2 & 0x2000) == 0 )
  {
    while ( --a1 >= 0 )
    {
      a4(v8, a3);
      ++v5;
    }
  }
  return v5;
}

//----- (0801F33A) --------------------------------------------------------
int __fastcall sub_801F33A(int result, _DWORD *a2)
{
  _BYTE *v2; // r2

  if ( a2[1] )
  {
    v2 = (_BYTE *)(*a2)++;
    *v2 = result;
    result = a2[1] - 1;
    a2[1] = result;
  }
  return result;
}

//----- (0801F350) --------------------------------------------------------
char __fastcall sub_801F350(char result, _DWORD *a2)
{
  _BYTE *v2; // r2

  v2 = (_BYTE *)(*a2)++;
  *v2 = result;
  return result;
}

//----- (0801F35C) --------------------------------------------------------
__int64 __fastcall sub_801F35C(unsigned int a1)
{
  _QWORD v2[3]; // [sp+0h] [bp-18h] BYREF

  dword_20003664 = 134490112;
  dword_20003668 = a1;
  dword_2000366C = 1;
  dword_20003670 = sub_800FBB0(134490112, a1);
  qmemcpy((unsigned int)v2, (unsigned int)&dword_20003664, 0x10u);
  sub_800F86C((_DWORD *)0x8040000, (int)v2, 2u);
  return v2[0];
}
// 20003664: using guessed type int dword_20003664;
// 20003668: using guessed type int dword_20003668;
// 2000366C: using guessed type int dword_2000366C;
// 20003670: using guessed type int dword_20003670;

//----- (0801F3C4) --------------------------------------------------------
int sub_801F3C4()
{
  int result; // r0

  result = 0;
  dword_200004A0 = 0;
  return result;
}
// 200004A0: using guessed type int dword_200004A0;

//----- (0801F3CC) --------------------------------------------------------
int sub_801F3CC()
{
  int result; // r0

  if ( byte_20000480 )
    sub_801AEC4();
  else
    sub_801AEB8();
  if ( dword_200004A0 <= 0 )
  {
    dword_200004A0 = 0;
    byte_20000480 = 0;
  }
  else
  {
    --dword_200004A0;
    byte_20000480 = 1 - byte_20000480;
  }
  result = dword_200004A4;
  if ( dword_200004A4 > 0 )
  {
    --dword_200004A4;
    return sub_801AEC4();
  }
  return result;
}
// 20000480: using guessed type char byte_20000480;
// 200004A0: using guessed type int dword_200004A0;
// 200004A4: using guessed type int dword_200004A4;

//----- (0801F420) --------------------------------------------------------
int sub_801F420()
{
  int result; // r0

  result = 10;
  dword_200004A4 = 10;
  return result;
}
// 200004A4: using guessed type int dword_200004A4;

//----- (0801F42C) --------------------------------------------------------
int sub_801F42C()
{
  byte_200015E9 = 1;
  sub_80250A8(dword_20000430, 0);
  byte_200037D9 = 0;
  return sub_8025188(dword_20000458, 0, 0, 0);
}
// 20000430: using guessed type int dword_20000430;
// 20000458: using guessed type int dword_20000458;
// 200015E9: using guessed type char byte_200015E9;
// 200037D9: using guessed type char byte_200037D9;

//----- (0801F468) --------------------------------------------------------
int sub_801F468()
{
  dword_20000034 = 0;
  return sub_8015E8C((int)&dword_20001728, (int)&byte_20003164, 1u);
}
// 20000034: using guessed type int dword_20000034;
// 20001728: using guessed type int dword_20001728;
// 20003164: using guessed type char byte_20003164;

//----- (0801F484) --------------------------------------------------------
int __fastcall sub_801F484(int a1)
{
  int result; // r0
  int *v3; // r5
  int v4; // r6
  int v5; // r7
  int v6; // r1

  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1354);
  if ( a1 == dword_20001658 )
    return 0;
  sub_80237E4();
  v3 = *(int **)(a1 + 20);
  v4 = dword_20001690;
  v5 = dword_20001694;
  sub_8023864();
  if ( v3 == (int *)v4 || v3 == (int *)v5 )
    return 2;
  if ( v3 == &dword_20011A28 )
  {
    if ( *(_DWORD *)(a1 + 40) )
    {
      return 2;
    }
    else
    {
      result = 3;
      v6 = 0;
      while ( *(_BYTE *)(a1 + v6 + 88) != 1 )
      {
        if ( ++v6 >= 1 )
          return result;
      }
      return 2;
    }
  }
  else if ( v3 == dword_20011A14 || !v3 )
  {
    return 4;
  }
  else
  {
    return 1;
  }
}
// 20001658: using guessed type int dword_20001658;
// 20001690: using guessed type int dword_20001690;
// 20001694: using guessed type int dword_20001694;
// 20011A14: using guessed type _DWORD dword_20011A14[3];
// 20011A28: using guessed type int dword_20011A28;

//----- (0801F554) --------------------------------------------------------
int sub_801F554()
{
  int result; // r0

  dword_20000448 = sub_802502C(0x14u, 1u, 0);
  dword_2000044C = sub_802502C(1u, 4u, 0);
  dword_20000464 = (int)sub_8025014(1);
  dword_20000454 = sub_802502C(1u, 0, 3);
  dword_20000458 = (int)sub_8025014(1);
  dword_2000045C = sub_802502C(1u, 0, 3);
  dword_20000460 = sub_802502C(1u, 0, 3);
  dword_20000430 = sub_802502C(5u, 0x80u, 0);
  dword_20000450 = sub_802502C(2u, 0x100u, 0);
  dword_20000434 = sub_802502C(1u, 0x28u, 0);
  dword_20000438 = sub_802502C(1u, 4u, 0);
  dword_2000042C = sub_802502C(1u, 0, 3);
  dword_2000043C = sub_802502C(0x100u, 1u, 0);
  dword_20000444 = sub_802502C(0x40u, 1u, 0);
  result = sub_802502C(0x400u, 1u, 0);
  dword_20000440 = result;
  return result;
}
// 2000042C: using guessed type int dword_2000042C;
// 20000430: using guessed type int dword_20000430;
// 20000434: using guessed type int dword_20000434;
// 20000438: using guessed type int dword_20000438;
// 2000043C: using guessed type int dword_2000043C;
// 20000440: using guessed type int dword_20000440;
// 20000444: using guessed type int dword_20000444;
// 20000448: using guessed type int dword_20000448;
// 2000044C: using guessed type int dword_2000044C;
// 20000450: using guessed type int dword_20000450;
// 20000454: using guessed type int dword_20000454;
// 20000458: using guessed type int dword_20000458;
// 2000045C: using guessed type int dword_2000045C;
// 20000460: using guessed type int dword_20000460;
// 20000464: using guessed type int dword_20000464;

//----- (0801F614) --------------------------------------------------------
int __fastcall sub_801F614(int a1, unsigned int a2, int *a3)
{
  unsigned int i; // r3
  int result; // r0

  for ( i = 0; i < a2; ++i )
    *a3 += *(unsigned __int8 *)(a1 + i);
  result = ~*a3;
  *a3 = result;
  return result;
}

//----- (0801F630) --------------------------------------------------------
int sub_801F630()
{
  if ( (MEMORY[0x40021094] & 0x20000000) != 0 )
    sub_8018434(65, 0, 0, 0);
  MEMORY[0x40021094] |= 0x800000u;
  dword_20001BDC = 1073754112;
  dword_20001BE0 = 5;
  dword_20001BE4 = 1000;
  dword_20001BE8 = 4095;
  return sub_801382C(&dword_20001BDC);
}
// 20001BDC: using guessed type int dword_20001BDC;
// 20001BE0: using guessed type int dword_20001BE0;
// 20001BE4: using guessed type int dword_20001BE4;
// 20001BE8: using guessed type int dword_20001BE8;

//----- (0801F67C) --------------------------------------------------------
int sub_801F67C()
{
  int v0; // r2
  int v1; // r0
  int result; // r0

  v0 = 0;
  if ( (unsigned __int16)dword_20002E7A >= (unsigned int)(unsigned __int8)byte_20000517 )
  {
    if ( (unsigned __int16)dword_20002E7A >= 0x1Fu )
    {
      if ( (unsigned __int16)dword_20002E7A >= 0x37u )
      {
        if ( (unsigned __int16)dword_20002E7A >= 0x50u )
          v1 = 11;
        else
          v1 = 10;
      }
      else
      {
        v1 = 9;
      }
    }
    else
    {
      v1 = 8;
    }
  }
  else
  {
    v1 = 7;
  }
  if ( byte_200004AD == 3 )
  {
    v0 = 6;
  }
  else if ( byte_200004AD == 2 )
  {
    v0 = 5;
  }
  if ( (unsigned __int8)byte_20000479 != v1 )
  {
    byte_20000479 = v1;
    dword_20000488 = 0;
  }
  if ( (unsigned __int8)byte_2000047A != v0 )
  {
    byte_2000047A = v0;
    dword_20000488 = 0;
  }
  result = 2;
  if ( byte_200002AB )
    byte_2000047F = 2;
  else
    byte_2000047F = 0;
  if ( byte_20004360 == 2 )
    byte_2000047C = 2;
  else
    byte_2000047C = byte_20004360 == 1 || byte_20004360 == 3;
  if ( byte_20000930 )
    byte_2000047D = 2;
  else
    byte_2000047D = 0;
  if ( byte_200015E6 )
    byte_2000047B = 2;
  else
    byte_2000047B = 0;
  if ( (byte_20002F5F[0] || byte_20002FD3 == 2) && (unsigned int)(unsigned __int8)byte_200002A8 - 204 <= 0xD )
    byte_2000047E = 2;
  else
    byte_2000047E = 0;
  return result;
}
// 200002A8: using guessed type char byte_200002A8;
// 200002AB: using guessed type char byte_200002AB;
// 20000479: using guessed type char byte_20000479;
// 2000047A: using guessed type char byte_2000047A;
// 2000047B: using guessed type char byte_2000047B;
// 2000047C: using guessed type char byte_2000047C;
// 2000047D: using guessed type char byte_2000047D;
// 2000047E: using guessed type char byte_2000047E;
// 2000047F: using guessed type char byte_2000047F;
// 20000488: using guessed type int dword_20000488;
// 200004AD: using guessed type char byte_200004AD;
// 20000517: using guessed type char byte_20000517;
// 20000930: using guessed type char byte_20000930;
// 200015E6: using guessed type char byte_200015E6;
// 20002E7A: using guessed type int dword_20002E7A;
// 20002FD3: using guessed type char byte_20002FD3;
// 20004360: using guessed type char byte_20004360;

//----- (0801F76C) --------------------------------------------------------
int sub_801F76C()
{
  sub_801292E(1207963648, 64, 0);
  sub_801292E(1207961600, 2048, 0);
  sub_801292E(1207959552, 16, 0);
  sub_801292E(1207963648, 4, 0);
  sub_801292E(1207963648, 8, 0);
  sub_801292E(1207963648, 16, 0);
  sub_801292E(1207963648, 32, 0);
  sub_80106B8(0);
  sub_801292E(1207959552, 8, 0);
  return sub_801292E(1207959552, 32, 0);
}

//----- (0801F7E4) --------------------------------------------------------
int sub_801F7E4()
{
  sub_801F67C();
  if ( byte_20000511 )
  {
    sub_80106CC(0, 0);
    sub_80106CC(1, 0);
    sub_80106CC(2, 0);
    sub_80106CC(3, 0);
    sub_80106CC(4, 0);
    sub_80106CC(5, 0);
    sub_80106B8(0);
    sub_80106CC(7, 0);
    sub_80106CC(8, 0);
    sub_80106CC(9, 0);
    goto LABEL_158;
  }
  if ( byte_20002F60 != 13 )
  {
    if ( !byte_2000047C || byte_2000047C == 1 )
    {
      sub_80106CC(5, 0);
    }
    else if ( byte_2000047C == 2 )
    {
      sub_80106CC(5, 1);
    }
    if ( byte_2000047B )
    {
      if ( byte_2000047B != 1 )
      {
        if ( byte_2000047B == 2 )
          sub_80106CC(3, 1);
        goto LABEL_21;
      }
      if ( (unsigned int)dword_20000490 > 5 )
        dword_20000490 = 0;
      if ( !dword_20000490 )
        sub_80106CC(3, 1);
      if ( dword_20000490 != 3 )
      {
LABEL_21:
        if ( byte_2000047D )
        {
          if ( byte_2000047D != 1 )
          {
            if ( byte_2000047D == 2 )
              sub_80106CC(4, 1);
            goto LABEL_32;
          }
          if ( (unsigned int)dword_20000494 > 5 )
            dword_20000494 = 0;
          if ( !dword_20000494 )
            sub_80106CC(4, 1);
          if ( dword_20000494 != 3 )
          {
LABEL_32:
            if ( byte_2000047F && byte_2000047F == 2 )
              sub_80106CC(1, 1);
            else
              sub_80106CC(1, 0);
            if ( byte_2000047E && byte_2000047E == 2 )
              sub_80106CC(2, 1);
            else
              sub_80106CC(2, 0);
            if ( !byte_2000047A )
            {
              switch ( byte_20000479 )
              {
                case 7:
                  if ( (unsigned int)dword_20000488 >= 0x14 )
                    dword_20000488 = 0;
                  if ( (unsigned int)dword_20000488 <= 0xA )
                    sub_80106B8(100 * dword_20000488);
                  else
                    sub_80106B8(100 * (20 - dword_20000488));
                  sub_80106CC(7, 0);
                  sub_80106CC(8, 0);
                  sub_80106CC(9, 0);
                  break;
                case 8:
                  sub_80106B8(0x2710u);
                  sub_80106CC(7, 0);
                  sub_80106CC(8, 0);
                  sub_80106CC(9, 0);
                  break;
                case 9:
                  sub_80106B8(0x2710u);
                  sub_80106CC(7, 1);
                  sub_80106CC(8, 0);
                  sub_80106CC(9, 0);
                  break;
                case 10:
                  sub_80106B8(0x2710u);
                  sub_80106CC(7, 1);
                  sub_80106CC(8, 1);
                  sub_80106CC(9, 0);
                  break;
                case 11:
                  sub_80106B8(0x2710u);
                  sub_80106CC(7, 1);
                  sub_80106CC(8, 1);
                  sub_80106CC(9, 1);
                  break;
              }
              goto LABEL_157;
            }
            if ( byte_2000047A != 5 )
            {
              if ( byte_2000047A != 6 )
                goto LABEL_157;
              if ( byte_20000479 != 7 )
              {
                switch ( byte_20000479 )
                {
                  case 8:
                    if ( (unsigned int)dword_20000488 >= 0xA )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      sub_80106B8(0x2710u);
                      sub_80106CC(7, 0);
                      sub_80106CC(8, 0);
                      sub_80106CC(9, 0);
                    }
                    if ( dword_20000488 != 5 )
                      goto LABEL_157;
LABEL_156:
                    sub_80106B8(0);
                    goto LABEL_157;
                  case 9:
                    if ( (unsigned int)dword_20000488 >= 0xF )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      sub_80106B8(0x2710u);
                      sub_80106CC(7, 1);
                      sub_80106CC(8, 0);
                      sub_80106CC(9, 0);
                    }
                    if ( dword_20000488 != 5 )
                    {
                      if ( dword_20000488 != 10 )
                        goto LABEL_157;
                      goto LABEL_156;
                    }
                    break;
                  case 10:
                    if ( (unsigned int)dword_20000488 >= 0x14 )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      sub_80106B8(0x2710u);
                      sub_80106CC(7, 1);
                      sub_80106CC(8, 1);
                      sub_80106CC(9, 0);
                    }
                    if ( dword_20000488 == 5 )
                    {
LABEL_141:
                      sub_80106CC(8, 0);
                      goto LABEL_157;
                    }
                    if ( dword_20000488 != 10 )
                    {
                      if ( dword_20000488 != 15 )
                        goto LABEL_157;
                      goto LABEL_156;
                    }
                    break;
                  case 11:
                    if ( (unsigned int)dword_20000488 >= 0x19 )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      sub_80106B8(0x2710u);
                      sub_80106CC(7, 1);
                      sub_80106CC(8, 1);
                      sub_80106CC(9, 1);
                    }
                    if ( dword_20000488 == 5 )
                    {
                      sub_80106CC(9, 0);
                      goto LABEL_157;
                    }
                    if ( dword_20000488 != 10 )
                    {
                      if ( dword_20000488 != 15 )
                      {
                        if ( dword_20000488 != 20 )
                          goto LABEL_157;
                        goto LABEL_156;
                      }
                      break;
                    }
                    goto LABEL_141;
                  default:
                    goto LABEL_157;
                }
                sub_80106CC(7, 0);
                goto LABEL_157;
              }
              sub_80106B8(0);
              sub_80106CC(7, 0);
              sub_80106CC(8, 0);
              sub_80106CC(9, 0);
LABEL_157:
              ++dword_20000494;
              ++dword_2000048C;
              ++dword_20000490;
              ++dword_20000488;
              goto LABEL_158;
            }
            if ( byte_20000479 == 7 || byte_20000479 == 8 )
            {
              if ( (unsigned int)dword_20000488 >= 0x19 )
                dword_20000488 = 0;
              if ( !dword_20000488 )
              {
                sub_80106B8(0);
                sub_80106CC(7, 0);
                sub_80106CC(8, 0);
                sub_80106CC(9, 0);
              }
              if ( dword_20000488 == 5 )
              {
                sub_80106B8(0x2710u);
                goto LABEL_157;
              }
              if ( dword_20000488 != 10 )
              {
                if ( dword_20000488 != 15 )
                {
                  if ( dword_20000488 != 20 )
                    goto LABEL_157;
                  goto LABEL_102;
                }
                goto LABEL_101;
              }
            }
            else
            {
              if ( byte_20000479 != 9 )
              {
                if ( byte_20000479 != 10 )
                {
                  if ( byte_20000479 == 11 )
                  {
                    if ( (unsigned int)dword_20000488 >= 0xA )
                      dword_20000488 = 0;
                    if ( !dword_20000488 )
                    {
                      sub_80106B8(0x2710u);
                      sub_80106CC(7, 1);
                      sub_80106CC(8, 1);
                      sub_80106CC(9, 0);
                    }
                    if ( dword_20000488 == 5 )
                      sub_80106CC(9, 1);
                  }
                  goto LABEL_157;
                }
                if ( (unsigned int)dword_20000488 >= 0xF )
                  dword_20000488 = 0;
                if ( !dword_20000488 )
                {
                  sub_80106B8(0x2710u);
                  sub_80106CC(7, 1);
                  sub_80106CC(8, 0);
                  sub_80106CC(9, 0);
                }
                if ( dword_20000488 != 5 )
                {
                  if ( dword_20000488 != 10 )
                    goto LABEL_157;
LABEL_102:
                  sub_80106CC(9, 1);
                  goto LABEL_157;
                }
                goto LABEL_101;
              }
              if ( (unsigned int)dword_20000488 >= 0x14 )
                dword_20000488 = 0;
              if ( !dword_20000488 )
              {
                sub_80106B8(0x2710u);
                sub_80106CC(7, 0);
                sub_80106CC(8, 0);
                sub_80106CC(9, 0);
              }
              if ( dword_20000488 != 5 )
              {
                if ( dword_20000488 != 10 )
                {
                  if ( dword_20000488 != 15 )
                    goto LABEL_157;
                  goto LABEL_102;
                }
LABEL_101:
                sub_80106CC(8, 1);
                goto LABEL_157;
              }
            }
            sub_80106CC(7, 1);
            goto LABEL_157;
          }
        }
        sub_80106CC(4, 0);
        goto LABEL_32;
      }
    }
    sub_80106CC(3, 0);
    goto LABEL_21;
  }
LABEL_158:
  if ( (unsigned int)++dword_2000049C <= 4 )
    JUMPOUT(0x801FE20);
  if ( byte_2000050A != 1 )
    JUMPOUT(0x801FD68);
  return sub_801FD30();
}
// 801FD22: control flows out of bounds to 801FE20
// 801FD2E: control flows out of bounds to 801FD68
// 801FD30: using guessed type int sub_801FD30(void);
// 20000479: using guessed type char byte_20000479;
// 2000047A: using guessed type char byte_2000047A;
// 2000047B: using guessed type char byte_2000047B;
// 2000047C: using guessed type char byte_2000047C;
// 2000047D: using guessed type char byte_2000047D;
// 2000047E: using guessed type char byte_2000047E;
// 2000047F: using guessed type char byte_2000047F;
// 20000488: using guessed type int dword_20000488;
// 2000048C: using guessed type int dword_2000048C;
// 20000490: using guessed type int dword_20000490;
// 20000494: using guessed type int dword_20000494;
// 2000049C: using guessed type int dword_2000049C;
// 2000050A: using guessed type char byte_2000050A;
// 20000511: using guessed type char byte_20000511;
// 20002F60: using guessed type char byte_20002F60;

//----- (0801FD30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_801FD30(_BYTE *a1)
{
  int v1; // r4
  _BYTE *v2; // r5
  unsigned int v3; // r6
  int v4; // r7
  int v5; // r8
  int v6; // r0
  int (*v8)(void); // [sp-4h] [bp-4h]

  if ( byte_20000930 == 1 )
  {
    *a1 = v1;
    sub_801292E(v5, 1, 1);
    sub_80031E4();
    sub_801F610(v6);
    sub_8007D00(0);
    sub_8023A34(60000);
    sub_802325C();
  }
  sub_801291E(v5, 1);
  *(_DWORD *)(v4 + 36) = v1;
  sub_801F3CC();
  if ( (unsigned __int8)byte_20000509 >= 2u )
  {
    byte_20000509 -= 2;
    sub_800591C(0x150u, &byte_20000509, 1u);
  }
  if ( byte_200004AD != 1 || byte_200002AB || byte_200037D7 || byte_200037D8 )
  {
    sub_802368C();
  }
  else if ( (unsigned int)(dword_2000002C - *(_DWORD *)(v4 + 32) - 3601) < 0x63 )
  {
    *v2 = 1;
    sub_8004924();
  }
  sub_8003248();
  if ( *v2 )
  {
    if ( !BYTE2(dword_20002E90) && *(_BYTE *)v4 == 1 )
    {
      *v2 = v1;
      sub_800591C(0x100u, &byte_20000511, 1u);
    }
  }
  else if ( BYTE2(dword_20002E90) == 1 )
  {
    *v2 = 1;
    sub_8018434(21, 0, 0, 0);
  }
  if ( byte_200002C6 )
  {
    sub_801D5CC(15);
    byte_200002C6 = v1;
  }
  sub_8004918();
  if ( (unsigned int)(sub_8012948() - dword_20000474) <= 0x4E20 && dword_20000474 )
    *(_BYTE *)v4 = 1;
  else
    *(_BYTE *)v4 = v1;
  if ( sub_8012948() - dword_20000474 <= v3 || sub_8012948() - *(_DWORD *)(v4 + 12) <= v3 )
    return v8();
  *(_DWORD *)(v4 + 12) = sub_8012948();
  return sub_8004944();
}
// 801FE52: positive sp value 18 has been found
// 801FD38: variable 'v1' is possibly undefined
// 801FD40: variable 'v5' is possibly undefined
// 801FD52: variable 'v6' is possibly undefined
// 801FD70: variable 'v4' is possibly undefined
// 801FDB0: variable 'v2' is possibly undefined
// 801FE3A: variable 'v3' is possibly undefined
// 801FE5A: variable 'v8' is possibly undefined
// 801F610: using guessed type __int64 __fastcall sub_801F610(_DWORD);
// 2000002C: using guessed type int dword_2000002C;
// 200002AB: using guessed type char byte_200002AB;
// 200002C6: using guessed type char byte_200002C6;
// 20000474: using guessed type int dword_20000474;
// 200004AD: using guessed type char byte_200004AD;
// 20000509: using guessed type char byte_20000509;
// 20000511: using guessed type char byte_20000511;
// 20000930: using guessed type char byte_20000930;
// 20002E90: using guessed type int dword_20002E90;
// 200037D7: using guessed type char byte_200037D7;
// 200037D8: using guessed type char byte_200037D8;

//----- (0801FF60) --------------------------------------------------------
int sub_801FF60()
{
  sub_80031E4();
  sub_8023DC8((_DWORD *)dword_2000001C);
  sub_8023DC8((_DWORD *)dword_20000020);
  sub_8023DC8((_DWORD *)dword_20000024);
  sub_8023DC8((_DWORD *)dword_20000004);
  return sub_8023DC8((_DWORD *)dword_20000010);
}
// 20000004: using guessed type int dword_20000004;
// 20000010: using guessed type int dword_20000010;
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 20000024: using guessed type int dword_20000024;

//----- (0801FF9C) --------------------------------------------------------
_DWORD *__fastcall sub_801FF9C(int a1, int a2)
{
  unsigned int v4; // r6
  int v5; // r0
  _DWORD *result; // r0
  unsigned int v7; // r4

  v4 = dword_20001664;
  *(_BYTE *)(dword_20001658 + 89) = 0;
  if ( !sub_80236A0((_DWORD *)(dword_20001658 + 4)) )
    dword_20001668 &= ~(1 << *(_BYTE *)(dword_20001658 + 44));
  if ( a1 == -1 && a2 )
  {
    v5 = dword_20011A2C;
    *(_DWORD *)(dword_20001658 + 8) = dword_20011A2C;
    *(_DWORD *)(dword_20001658 + 12) = *(_DWORD *)(v5 + 8);
    *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4) = dword_20001658 + 4;
    *(_DWORD *)(v5 + 8) = dword_20001658 + 4;
    *(_DWORD *)(dword_20001658 + 20) = &dword_20011A28;
    return (_DWORD *)++dword_20011A28;
  }
  else
  {
    v7 = a1 + v4;
    *(_DWORD *)(dword_20001658 + 4) = v7;
    if ( v7 >= v4 )
    {
      sub_802379C((_DWORD *)dword_20001690, (_DWORD *)(dword_20001658 + 4));
      result = (_DWORD *)dword_20001680;
      if ( v7 < dword_20001680 )
        dword_20001680 = v7;
    }
    else
    {
      return sub_802379C((_DWORD *)dword_20001694, (_DWORD *)(dword_20001658 + 4));
    }
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001664: using guessed type int dword_20001664;
// 20001668: using guessed type int dword_20001668;
// 20001680: using guessed type int dword_20001680;
// 20001690: using guessed type int dword_20001690;
// 20001694: using guessed type int dword_20001694;
// 20011A28: using guessed type int dword_20011A28;
// 20011A2C: using guessed type int dword_20011A2C;

//----- (08020030) --------------------------------------------------------
unsigned int __fastcall sub_8020030(_DWORD *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  unsigned int result; // r0

  sub_80237E4();
  ++dword_20001660;
  if ( dword_20001658 )
  {
    if ( !dword_2000166C && *(_DWORD *)(dword_20001658 + 44) <= a1[11] )
      dword_20001658 = (int)a1;
  }
  else
  {
    dword_20001658 = (int)a1;
    if ( dword_20001660 == 1 )
      sub_8020354();
  }
  a1[17] = ++dword_2000167C;
  v2 = a1[11];
  dword_20001668 |= 1 << v2;
  v3 = dword_20011758[5 * v2 + 1];
  a1[2] = v3;
  a1[3] = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4) = a1 + 1;
  *(_DWORD *)(v3 + 8) = a1 + 1;
  v4 = 5 * a1[11];
  a1[5] = &dword_20011758[5 * a1[11]];
  ++dword_20011758[v4];
  sub_8023864();
  result = dword_2000166C;
  if ( dword_2000166C )
  {
    result = *(_DWORD *)(dword_20001658 + 44);
    if ( result < a1[11] )
    {
      result = 0x10000000;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001660: using guessed type int dword_20001660;
// 20001668: using guessed type int dword_20001668;
// 2000166C: using guessed type int dword_2000166C;
// 2000167C: using guessed type int dword_2000167C;
// 20011758: using guessed type int dword_20011758[160];
// E000ED04: using guessed type int ICSR;

//----- (080200DC) --------------------------------------------------------
int sub_80200DC()
{
  int v0; // r4
  int result; // r0

  while ( 1 )
  {
    result = dword_2000165C;
    if ( !dword_2000165C )
      break;
    sub_80237E4();
    v0 = *(_DWORD *)(dword_20011A20 + 12);
    sub_80236A0((_DWORD *)(v0 + 4));
    --dword_20001660;
    --dword_2000165C;
    sub_8023864();
    sub_80201AE(v0);
  }
  return result;
}
// 2000165C: using guessed type int dword_2000165C;
// 20001660: using guessed type int dword_20001660;
// 20011A20: using guessed type int dword_20011A20;

//----- (08020118) --------------------------------------------------------
_DWORD *__fastcall sub_8020118(_DWORD *result, unsigned int a2)
{
  unsigned int v3; // r2
  unsigned int v4; // r1

  v3 = result[16];
  if ( v3 )
  {
    v4 = result[3] + v3;
    result[3] = v4;
    if ( v4 >= result[2] )
      result[3] = *result;
    return (_DWORD *)qmemcpy(a2, result[3], v3);
  }
  return result;
}

//----- (08020140) --------------------------------------------------------
int __fastcall sub_8020140(unsigned int *a1, unsigned int a2, int a3)
{
  int v5; // r6
  unsigned int v6; // r5
  unsigned int v7; // r2
  unsigned int v8; // r0
  unsigned int v9; // r1
  unsigned int v10; // r0

  v5 = 0;
  v6 = a1[14];
  v7 = a1[16];
  if ( v7 )
  {
    if ( a3 )
    {
      qmemcpy(a1[3], a2, v7);
      v8 = a1[16];
      v9 = a1[3] - v8;
      a1[3] = v9;
      if ( v9 < *a1 )
        a1[3] = a1[2] - v8;
      if ( a3 == 2 && v6 )
        --v6;
    }
    else
    {
      qmemcpy(a1[1], a2, v7);
      v10 = a1[1] + a1[16];
      a1[1] = v10;
      if ( v10 >= a1[2] )
        a1[1] = *a1;
    }
  }
  else if ( !*a1 )
  {
    v5 = sub_8025C94(a1[2]);
    a1[2] = 0;
  }
  a1[14] = v6 + 1;
  return v5;
}

//----- (080201AE) --------------------------------------------------------
void __fastcall sub_80201AE(int a1)
{
  ((void (__fastcall *)(_DWORD))loc_80238D4)(*(_DWORD *)(a1 + 48));
  JUMPOUT(0x80238D4);
}
// 80201BE: control flows out of bounds to 80238D4

//----- (080201C2) --------------------------------------------------------
int __fastcall sub_80201C2(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
    return 32 - **(_DWORD **)(a1 + 48);
  else
    return 0;
}

//----- (08020248) --------------------------------------------------------
_DWORD *__fastcall sub_8020248(_DWORD *result)
{
  if ( result )
  {
    result[2] = 0;
    *result = 0;
    result[3] = 0;
    return (_DWORD *)sub_8025188((int)result, 0, 0, 0);
  }
  return result;
}

//----- (08020260) --------------------------------------------------------
int __fastcall sub_8020260(int a1, int a2, int a3, char a4, int a5)
{
  int result; // r0

  if ( a2 )
    *(_DWORD *)a5 = a3;
  else
    *(_DWORD *)a5 = a5;
  *(_DWORD *)(a5 + 60) = a1;
  *(_DWORD *)(a5 + 64) = a2;
  sub_80250A8(a5, 1);
  *(_BYTE *)(a5 + 80) = a4;
  result = 0;
  *(_DWORD *)(a5 + 72) = 0;
  return result;
}

//----- (08020288) --------------------------------------------------------
_DWORD *__fastcall sub_8020288(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, int a7)
{
  int v7; // r5
  unsigned int v12; // r7
  unsigned int i; // r0
  _DWORD *result; // r0

  v7 = a5;
  sub_8002356(*(_BYTE **)(a7 + 48), 4 * a3, 165);
  v12 = (*(_DWORD *)(a7 + 48) + 4 * (a3 - 1)) & 0xFFFFFFF8;
  if ( v12 << 29 )
    sub_801E93C((int)sub_8020344, "..\\..\\SDK\\FreeRTOS\\tasks.c", 861);
  if ( a2 )
  {
    for ( i = 0; i < 0x10; ++i )
    {
      *(_BYTE *)(a7 + i + 52) = *(_BYTE *)(a2 + i);
      if ( !*(_BYTE *)(a2 + i) )
        break;
    }
    *(_BYTE *)(a7 + 67) = 0;
  }
  if ( a5 >= 0x20 )
  {
    sub_801E93C((int)sub_8020344, "..\\..\\SDK\\FreeRTOS\\tasks.c", 914);
    v7 = 31;
  }
  *(_DWORD *)(a7 + 44) = v7;
  *(_DWORD *)(a7 + 76) = v7;
  sub_8023796(a7 + 4);
  sub_8023796(a7 + 24);
  *(_DWORD *)(a7 + 16) = a7;
  *(_DWORD *)(a7 + 24) = 32 - v7;
  *(_DWORD *)(a7 + 36) = a7;
  result = sub_80207A0(v12, a1, a4);
  *(_DWORD *)a7 = result;
  if ( a6 )
    *a6 = a7;
  return result;
}

//----- (08020344) --------------------------------------------------------
int __fastcall sub_8020344(int a1)
{
  char v1; // r5

  *(_BYTE *)(a1 + 9) = v1;
  return sub_8020354();
}
// 8020344: variable 'v1' is possibly undefined
// 8020354: using guessed type int sub_8020354(void);

//----- (08020354) --------------------------------------------------------
int *sub_8020354()
{
  unsigned int i; // r4
  int *result; // r0

  for ( i = 0; i < 0x20; ++i )
    sub_8023780(&dword_20011758[5 * i]);
  sub_8023780(dword_200119D8);
  sub_8023780(&dword_200119D8[5]);
  sub_8023780(&dword_20011A00);
  sub_8023780(dword_20011A14);
  sub_8023780(&dword_20011A28);
  result = &dword_20001658;
  dword_20001690 = (int)dword_200119D8;
  dword_20001694 = (int)&dword_200119D8[5];
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001690: using guessed type int dword_20001690;
// 20001694: using guessed type int dword_20001694;
// 20011758: using guessed type int dword_20011758[160];
// 200119D8: using guessed type _DWORD dword_200119D8[10];
// 20011A00: using guessed type int dword_20011A00;
// 20011A14: using guessed type _DWORD dword_20011A14[3];
// 20011A28: using guessed type int dword_20011A28;

//----- (080203AC) --------------------------------------------------------
int *__fastcall sub_80203AC(int *result)
{
  int *i; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r4

  for ( i = &dword_200016AC; ; i = (int *)*i )
  {
    v2 = *i;
    if ( *i >= (unsigned int)result )
      break;
  }
  v3 = i[1];
  if ( (int *)((char *)i + v3) == result )
  {
    i[1] = result[1] + v3;
    result = i;
  }
  v4 = result[1];
  if ( (int *)((char *)result + v4) == (int *)*i )
  {
    if ( v2 == dword_20001698 )
    {
      *result = dword_20001698;
    }
    else
    {
      result[1] = *(_DWORD *)(v2 + 4) + v4;
      *result = *(_DWORD *)*i;
    }
  }
  else
  {
    *result = v2;
  }
  if ( i != result )
    *i = (int)result;
  return result;
}
// 20001698: using guessed type int dword_20001698;
// 200016AC: using guessed type int dword_200016AC;

//----- (08020400) --------------------------------------------------------
BOOL __fastcall sub_8020400(int a1)
{
  BOOL v2; // r4

  sub_80237E4();
  v2 = *(_DWORD *)(a1 + 56) == 0;
  sub_8023864();
  return v2;
}

//----- (0802041A) --------------------------------------------------------
BOOL __fastcall sub_802041A(int a1)
{
  BOOL v2; // r4

  sub_80237E4();
  v2 = *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 60);
  sub_8023864();
  return v2;
}

//----- (08020438) --------------------------------------------------------
int __fastcall sub_8020438(int a1, _DWORD *a2, int a3)
{
  int v6; // r6
  _DWORD *v7; // r0
  _DWORD *v8; // r7
  int v9; // r10
  _DWORD *v10; // r5
  int v11; // r5

  v6 = 0;
  if ( *a2 )
  {
    v7 = *(_DWORD **)(a2[1] + 4);
    a2[1] = v7;
    v8 = a2 + 2;
    if ( v7 == a2 + 2 )
      a2[1] = v7[1];
    v9 = *(_DWORD *)(a2[1] + 12);
    do
    {
      v10 = *(_DWORD **)(a2[1] + 4);
      a2[1] = v10;
      if ( v10 == v8 )
        a2[1] = v10[1];
      v11 = *(_DWORD *)(a2[1] + 12);
      sub_8023AAC(v11, a1 + 36 * v6++, 1, a3);
    }
    while ( v11 != v9 );
  }
  return v6;
}

//----- (08020494) --------------------------------------------------------
int __fastcall sub_8020494(int a1)
{
  int v1; // r4
  int v2; // r6
  unsigned int v3; // r5
  int v5; // [sp+0h] [bp-18h] BYREF

  v5 = a1;
  v1 = *(_DWORD *)(a1 + 72);
  v2 = 0;
  if ( !v1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3043);
  if ( *(_DWORD *)(v1 + 56) >= *(_DWORD *)(v1 + 60) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3044);
  if ( *(_DWORD *)(v1 + 56) < *(_DWORD *)(v1 + 60) )
  {
    v3 = *(char *)(v1 + 69);
    v2 = sub_8020140((unsigned int *)v1, (unsigned int)&v5, 0);
    if ( v3 == -1 )
    {
      if ( *(_DWORD *)(v1 + 36) && sub_8025E24(v1 + 36) )
        return 1;
    }
    else if ( v3 < sub_80236C8() )
    {
      if ( v3 == 127 )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 3076);
      *(_BYTE *)(v1 + 69) = v3 + 1;
    }
  }
  return v2;
}

//----- (08020540) --------------------------------------------------------
int *sub_8020540()
{
  int *result; // r0

  result = &dword_20001658;
  if ( *(_DWORD *)dword_20001690 )
    dword_20001680 = **(_DWORD **)(dword_20001690 + 12);
  else
    dword_20001680 = -1;
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001680: using guessed type int dword_20001680;
// 20001690: using guessed type int dword_20001690;

//----- (08020560) --------------------------------------------------------
int __fastcall sub_8020560(unsigned __int8 *a1)
{
  unsigned int v1; // r1

  v1 = 0;
  while ( *a1 == 165 )
  {
    ++a1;
    ++v1;
  }
  return (unsigned __int16)(v1 >> 2);
}

//----- (080205E0) --------------------------------------------------------
int __fastcall sub_80205E0(int a1)
{
  int i; // r5
  int j; // r5

  sub_80237E4();
  for ( i = *(char *)(a1 + 69); i > 0; i = (char)(i - 1) )
  {
    if ( *(_DWORD *)(a1 + 72) )
    {
      if ( !sub_8020494(a1) )
        continue;
LABEL_7:
      sub_8023BDC();
      continue;
    }
    if ( !*(_DWORD *)(a1 + 36) )
      break;
    if ( sub_8025E24(a1 + 36) )
      goto LABEL_7;
  }
  *(_BYTE *)(a1 + 69) = -1;
  sub_8023864();
  sub_80237E4();
  for ( j = *(char *)(a1 + 68); j > 0 && *(_DWORD *)(a1 + 16); j = (char)(j - 1) )
  {
    if ( sub_8025E24(a1 + 16) )
      sub_8023BDC();
  }
  *(_BYTE *)(a1 + 68) = -1;
  return sub_8023864();
}

//----- (0802065C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_802065C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *i; // r0

  sub_800240C(a1, a2);
  for ( i = sub_80023E2(a1); (unsigned int)i < 0xF; ++i )
    i[(_DWORD)a1] = 32;
  i[(_DWORD)a1] = 0;
  return &a1[(_DWORD)i];
}

//----- (08020694) --------------------------------------------------------
void __fastcall sub_8020694(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  unsigned int v10; // r5
  int v11; // r6
  int **v12; // r7
  int v17; // r0
  int v18; // r5
  int *v19; // r1
  int *i; // r4
  int v21; // r1
  int *v22; // r0

  __asm { STC             p1, c11, [R1,#0x134]! }
  v17 = 16 - (v10 & 7);
  if ( v10 > ~v17 )
    v18 = 0;
  else
    v18 = v10 + v17;
  if ( v18 > 0 && v18 <= (unsigned int)v12[1] )
  {
    v19 = &dword_200016AC;
    for ( i = (int *)dword_200016AC; i[1] < (unsigned int)v18 && *i; i = (int *)*i )
      v19 = i;
    if ( i != *v12 )
    {
      v11 = *v19 + 8;
      *v19 = *i;
      if ( (unsigned int)(i[1] - v18) > 0x10 )
      {
        if ( ((_DWORD)i + v18) << 29 )
          sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 220);
        *(int *)((char *)i + v18 + 4) = i[1] - v18;
        i[1] = v18;
        sub_80203AC((int *)((char *)i + v18));
      }
      v21 = i[1];
      v22 = (int *)((char *)v12[1] - v21);
      v12[1] = v22;
      if ( v22 < v12[2] )
        v12[2] = v22;
      i[1] = v21 | 0x80000000;
      *i = 0;
      v12[3] = (int *)((char *)v12[3] + 1);
    }
  }
  sub_8025F2C();
  if ( v11 << 29 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 284);
  __asm { POP.W           {R4-R8,PC} }
}
// 8020740: unbalanced stack, ignored a potential tail call
// 8020698: variable 'v10' is possibly undefined
// 80206B0: variable 'v12' is possibly undefined
// 802072E: variable 'v11' is possibly undefined
// 200016AC: using guessed type int dword_200016AC;

//----- (08020788) --------------------------------------------------------
int sub_8020788()
{
  if ( dword_20001658 )
    ++*(_DWORD *)(dword_20001658 + 80);
  return dword_20001658;
}
// 20001658: using guessed type int dword_20001658;

//----- (080207A0) --------------------------------------------------------
_DWORD *__fastcall sub_80207A0(int a1, int a2, int a3)
{
  _DWORD *v3; // r0

  v3 = (_DWORD *)(a1 - 36);
  v3[8] = 0x1000000;
  v3[7] = a2 & 0xFFFFFFFE;
  v3[6] = 134352245;
  v3[1] = a3;
  *v3 = -3;
  return v3 - 8;
}

//----- (080207C4) --------------------------------------------------------
unsigned int __fastcall sub_80207C4(unsigned int a1, unsigned int a2, __int16 a3)
{
  unsigned int v3; // r3
  unsigned int v4; // r0
  unsigned int result; // r0

  v3 = a1 % 0x64 + 100;
  v4 = (unsigned __int16)((v3 + (v3 >> 2)) % 7 + a3 + *((unsigned __int8 *)dword_8026880 + a2 - 1));
  if ( !(v3 << 30) && a2 < 3 )
    v4 = (unsigned __int16)(v4 - 1);
  result = v4 % 7;
  if ( !result )
    LOBYTE(result) = 7;
  return (unsigned __int8)result;
}
// 8026880: using guessed type int dword_8026880[3];

//----- (08020810) --------------------------------------------------------
int sub_8020810()
{
  MEMORY[0x40021090] |= 0x8000u;
  MEMORY[0x40021058] |= 0x10000000u;
  dword_20002148 = 1073752064;
  dword_2000214C = 0;
  dword_20002150 = 127;
  dword_20002154 = 255;
  dword_20002158 = 0;
  dword_20002160 = 0;
  dword_20002164 = 0x40000000;
  dword_20002168 = 0;
  return sub_80145F8((int)&dword_20002148);
}
// 20002148: using guessed type int dword_20002148;
// 2000214C: using guessed type int dword_2000214C;
// 20002150: using guessed type int dword_20002150;
// 20002154: using guessed type int dword_20002154;
// 20002158: using guessed type int dword_20002158;
// 20002160: using guessed type int dword_20002160;
// 20002164: using guessed type int dword_20002164;
// 20002168: using guessed type int dword_20002168;

//----- (0802085C) --------------------------------------------------------
int __fastcall sub_802085C(unsigned int a1, unsigned int a2, __int16 a3)
{
  unsigned __int8 v3; // r4
  unsigned __int8 v5[16]; // [sp+0h] [bp-10h] BYREF

  v3 = a1;
  v5[2] = a3;
  v5[1] = a2;
  v5[0] = sub_80207C4(a1, a2, a3);
  v5[3] = v3;
  return sub_80146E0(&dword_20002148, v5, 0);
}
// 20002148: using guessed type int dword_20002148;

//----- (08020888) --------------------------------------------------------
int __fastcall sub_8020888(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  unsigned __int8 v4[12]; // [sp+0h] [bp-18h] BYREF
  int v5; // [sp+Ch] [bp-Ch]
  int v6; // [sp+10h] [bp-8h]

  v4[0] = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = 0;
  v5 = 0;
  v6 = 0;
  return sub_8014784(&dword_20002148, v4, 0);
}
// 20002148: using guessed type int dword_20002148;

//----- (080208B4) --------------------------------------------------------
int __fastcall sub_80208B4(int result)
{
  int v1; // r1

  v1 = 0;
  while ( dword_20011738[v1] )
  {
    v1 = (__int16)(v1 + 1);
    if ( v1 >= 5 )
      return result;
  }
  dword_20011738[v1] = result;
  return result;
}
// 20011738: using guessed type _DWORD dword_20011738[5];

//----- (080208DC) --------------------------------------------------------
int __fastcall sub_80208DC(int a1)
{
  int result; // r0

  if ( sub_80023F0(*(_DWORD *)(a1 + 16), *(_DWORD *)(*(_DWORD *)a1 + 8)) )
  {
    sub_80219C4(a1, (unsigned __int8 *)dword_20001638);
  }
  else
  {
    *(_BYTE *)(a1 + 96) |= 1u;
    sub_80219C4(a1, (unsigned __int8 *)dword_20001604);
  }
  result = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 14) = 0;
  return result;
}
// 20001604: using guessed type int dword_20001604;
// 20001638: using guessed type int dword_20001638;

//----- (0802091C) --------------------------------------------------------
int __fastcall sub_802091C(int a1, _BYTE *a2)
{
  if ( (!*a2 || (a2[1] & 0xF) == 8 || (*a2 & **(_BYTE **)a1) != 0)
    && (*(unsigned __int8 *)(a1 + 96) << 31 || (a2[1] & 0x10) != 0) )
  {
    return 0;
  }
  else
  {
    return -1;
  }
}

//----- (0802094C) --------------------------------------------------------
int sub_802094C()
{
  int result; // r0

  result = sub_8020E44();
  if ( result )
    return sub_80219C4(result, (unsigned __int8 *)dword_2000163C);
  return result;
}
// 2000163C: using guessed type int dword_2000163C;

//----- (08020968) --------------------------------------------------------
int __fastcall sub_8020968(int a1)
{
  int i; // r4

  for ( i = (__int16)(*(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 14)); i > 0; i = (__int16)(i - 1) )
    sub_802181A(a1, 32);
  return sub_8020A58(a1, *(unsigned __int8 *)(a1 + 12));
}

//----- (08020A58) --------------------------------------------------------
int __fastcall sub_8020A58(int result, int a2)
{
  int i; // r5
  bool v4; // cf

  for ( i = result; ; result = sub_80219C4(i, (unsigned __int8 *)sub_8020A70) )
  {
    v4 = a2 != 0;
    a2 = (unsigned __int8)(a2 - 1);
    if ( !v4 )
      break;
  }
  return result;
}

//----- (08020A70) --------------------------------------------------------
int __fastcall sub_8020A70(int a1, int a2)
{
  return sub_8020FAC(a2, -1);
}

//----- (08020A7C) --------------------------------------------------------
int __fastcall sub_8020A7C(int a1)
{
  sub_8020A94(a1);
  return sub_80218D8(a1, 1);
}

//----- (08020A94) --------------------------------------------------------
unsigned int __fastcall sub_8020A94(int a1)
{
  unsigned int result; // r0
  int v3; // r1

  result = *(unsigned __int16 *)(a1 + 12);
  if ( result )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 16) + result) = 0;
    if ( *(unsigned __int8 *)(a1 + 96) << 31 )
    {
      sub_8021046(a1);
      sub_8021328(a1);
      *(_WORD *)(a1 + 14) = 0;
      *(_WORD *)(a1 + 12) = 0;
      result = *(unsigned __int16 *)(a1 + 54);
      if ( *(_WORD *)(a1 + 54) )
      {
        sub_80219C4(a1, (unsigned __int8 *)&dword_8020B00);
        v3 = sub_8021488(a1, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 88), 0);
        if ( v3 )
          return sub_80213F6(a1, v3);
        else
          return sub_80219C4(a1, (unsigned __int8 *)dword_2000161C);
      }
    }
    else
    {
      return sub_80208DC(a1);
    }
  }
  return result;
}
// 8020B00: using guessed type int dword_8020B00;
// 2000161C: using guessed type int dword_2000161C;

//----- (08020B08) --------------------------------------------------------
int __fastcall sub_8020B08(unsigned __int8 *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r3

  v1 = 0;
  v2 = *a1;
  if ( v2 == 48 && ((v3 = a1[1], v3 == 120) || v3 == 88) )
  {
    v1 = 3;
  }
  else if ( v2 == 48 && ((v4 = a1[1], v4 == 98) || v4 == 66) )
  {
    v1 = 1;
  }
  else if ( v2 == 48 )
  {
    v1 = 2;
  }
  while ( *a1++ )
  {
    if ( *a1 == 46 && a1[1] )
      return 4;
  }
  return v1;
}

//----- (08020B56) --------------------------------------------------------
int __fastcall sub_8020B56(int a1)
{
  unsigned __int8 *v1; // r1
  int result; // r0
  int v3; // r1

  v1 = (unsigned __int8 *)(a1 + 1);
  result = 0;
  if ( *v1 != 92 )
    return *v1;
  v3 = v1[1];
  if ( v3 == 110 )
    return 10;
  if ( v3 > 110 )
  {
    if ( v3 == 114 )
      return 13;
    if ( v3 == 116 )
      return 9;
    return v3;
  }
  if ( v3 != 48 )
  {
    if ( v3 == 98 )
      return 8;
    return v3;
  }
  return result;
}

//----- (08020B92) --------------------------------------------------------
float __fastcall sub_8020B92(_BYTE *a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r7
  int v5; // r6
  unsigned int v6; // r5
  int v7; // r0
  int v8; // r9
  _BYTE *i; // r4
  int v10; // r0
  float result; // r0

  v2 = 10;
  v3 = 0;
  v4 = 1;
  v5 = 0;
  v6 = 0;
  if ( *a1 == 45 )
    v4 = -1;
  v7 = sub_8020B08(&a1[v4 == -1]);
  v8 = v7;
  switch ( v7 )
  {
    case 1:
      v2 = 2;
      v3 = 2;
      break;
    case 2:
      v2 = 8;
      v3 = 1;
      break;
    case 3:
      v2 = 16;
      v3 = 2;
      break;
  }
  for ( i = &a1[v3 + (v4 == -1)]; ; ++i )
  {
    v10 = (unsigned __int8)*i;
    if ( !*i )
      break;
    if ( v10 == 46 )
    {
      v6 = 1;
    }
    else
    {
      v5 = sub_8020DCC(v10) + v5 * v2;
      v6 *= 10;
    }
  }
  if ( v8 == 4 && v6 )
    return (float)((float)(unsigned int)v5 / (float)v6) * (float)v4;
  LODWORD(result) = v5 * v4;
  return result;
}

//----- (08020C54) --------------------------------------------------------
float __fastcall sub_8020C54(int a1, unsigned __int8 *a2)
{
  int v4; // r1
  unsigned __int8 *v6; // r6
  unsigned __int8 *v7; // r4
  int v8; // r5
  int v9; // r0
  int v10; // r4
  int v11; // r0

  v4 = *a2;
  if ( v4 == 39 && a2[1] )
    return COERCE_FLOAT(sub_8020B56((int)a2));
  if ( v4 == 45 || (unsigned int)(v4 - 48) <= 9 )
    return sub_8020B92(a2);
  if ( v4 == 36 && a2[1] )
  {
    v10 = a1;
    v11 = sub_8021488(a1, (int)(a2 + 1), *(_DWORD *)(a1 + 88), 0);
    if ( v11 )
      return COERCE_FLOAT(sub_8020E6C(v10, v11));
    else
      return 0.0;
  }
  else if ( v4 )
  {
    v6 = a2;
    v7 = a2;
    v8 = 0;
    if ( *a2 == 34 )
    {
      v7 = a2 + 1;
      v6 = a2 + 1;
    }
    while ( 1 )
    {
      v9 = *v7;
      if ( !*v7 )
        break;
      if ( v9 == 92 )
      {
        v6[v8] = sub_8020B56((int)(v7++ - 1));
      }
      else if ( v9 == 34 )
      {
        v6[v8] = 0;
      }
      else
      {
        v6[v8] = v9;
      }
      ++v7;
      v8 = (unsigned __int16)(v8 + 1);
    }
    v6[v8] = 0;
    return *(float *)&v6;
  }
  else
  {
    return 0.0;
  }
}

//----- (08020CF8) --------------------------------------------------------
int __fastcall sub_8020CF8(int a1, int a2, int a3, int a4)
{
  int v8; // r6
  int v9; // r7
  int i; // r4
  int result; // r0
  int v12; // [sp+10h] [bp-40h] BYREF
  int v13; // [sp+14h] [bp-3Ch]
  int v14; // [sp+18h] [bp-38h]
  int v15; // [sp+1Ch] [bp-34h]
  int v16; // [sp+20h] [bp-30h]
  int v17; // [sp+24h] [bp-2Ch]
  int v18; // [sp+28h] [bp-28h]

  sub_8002364(&v12, 32);
  v8 = a3 - 1;
  v9 = *(_BYTE *)(a2 + 2) & 0xF;
  if ( v9 <= a3 - 1 )
    v9 = a3 - 1;
  for ( i = 0; i < v8; ++i )
    *((float *)&v12 + i) = sub_8020C54(a1, *(unsigned __int8 **)(a4 + 4 * (i + 1)));
  switch ( v9 )
  {
    case 0:
      result = (*(int (**)(void))(a2 + 8))();
      break;
    case 1:
      result = (*(int (__fastcall **)(int))(a2 + 8))(v12);
      break;
    case 2:
      result = (*(int (__fastcall **)(int, int))(a2 + 8))(v12, v13);
      break;
    case 3:
      result = (*(int (__fastcall **)(int, int, int))(a2 + 8))(v12, v13, v14);
      break;
    case 4:
      result = (*(int (__fastcall **)(int, int, int, int))(a2 + 8))(v12, v13, v14, v15);
      break;
    case 5:
      result = (*(int (__fastcall **)(int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16);
      break;
    case 6:
      result = (*(int (__fastcall **)(int, int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16, v17);
      break;
    case 7:
      result = (*(int (__fastcall **)(int, int, int, int, int, int, int))(a2 + 8))(v12, v13, v14, v15, v16, v17, v18);
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (08020DCC) --------------------------------------------------------
int __fastcall sub_8020DCC(int a1)
{
  if ( (unsigned int)(a1 - 48) <= 9 )
    return (unsigned __int8)(a1 - 48);
  if ( (unsigned int)(a1 - 97) <= 5 )
    return (unsigned __int8)(a1 - 87);
  if ( (unsigned int)(a1 - 65) > 5 )
    return 0;
  return (unsigned __int8)(a1 - 55);
}

//----- (08020DF8) --------------------------------------------------------
int __fastcall sub_8020DF8(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08020E04) --------------------------------------------------------
_BYTE *__fastcall sub_8020E04(int a1)
{
  unsigned int i; // r1
  unsigned int v2; // r1

  for ( i = 0; i < 9; i = (unsigned __int8)(i + 1) )
    byte_2001174C[i] = 48;
  v2 = *(_BYTE *)(a1 + 1) & 0xF;
  if ( v2 <= 1 )
    return *(_BYTE **)(a1 + 4);
  if ( v2 <= 7 )
    return *(_BYTE **)(a1 + 4);
  if ( v2 <= 8 )
    return *(_BYTE **)(a1 + 4);
  sub_80217EA(*(_DWORD *)(a1 + 4), (int)byte_2001174C);
  return byte_2001174C;
}
// 2001174C: using guessed type _BYTE byte_2001174C[12];

//----- (08020E44) --------------------------------------------------------
int sub_8020E44()
{
  int i; // r0
  int v1; // r1

  for ( i = 0; i < 5; i = (__int16)(i + 1) )
  {
    v1 = dword_20011738[i];
    if ( v1 && (*(_BYTE *)(v1 + 96) & 2) != 0 )
      return dword_20011738[i];
  }
  return 0;
}
// 20011738: using guessed type _DWORD dword_20011738[5];

//----- (08020E6C) --------------------------------------------------------
int __fastcall sub_8020E6C(int a1, int a2)
{
  int result; // r0
  _DWORD *v3; // r0
  int (__fastcall *v4)(_DWORD); // r1

  result = 0;
  switch ( *(_BYTE *)(a2 + 1) & 0xF )
  {
    case 2:
      result = **(_DWORD **)(a2 + 8);
      break;
    case 3:
      result = **(__int16 **)(a2 + 8);
      break;
    case 4:
      result = **(unsigned __int8 **)(a2 + 8);
      break;
    case 5:
    case 6:
      result = *(_DWORD *)(a2 + 8);
      break;
    case 7:
      v3 = *(_DWORD **)(a2 + 8);
      v4 = (int (__fastcall *)(_DWORD))v3[1];
      if ( v4 )
        result = v4(*v3);
      else
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

//----- (08020EAC) --------------------------------------------------------
int __fastcall sub_8020EAC(int result, int a2)
{
  int v2; // r5
  int v3; // r8
  int v4; // r4
  int v5; // r9
  unsigned int v6; // r0
  int v7; // r10
  int i; // r6
  int v9; // r7
  int v10; // r0
  int v11; // r2
  void (__fastcall *v12)(int); // r1

  v2 = result;
  v3 = a2;
  if ( a2 )
  {
    v4 = 24;
    v5 = 0;
    v6 = *(_DWORD *)(result + 0x38);
    if ( (v6 & 0xFF00) != 0 )
    {
      v4 = 0;
      v5 = -256;
    }
    else if ( (v6 & 0xFF0000) != 0 )
    {
      v4 = 8;
      v5 = -65536;
    }
    else if ( HIBYTE(v6) )
    {
      v4 = 16;
      v5 = -16777216;
    }
    v7 = *(_DWORD *)(v2 + 0x58);
    for ( i = 0; *(unsigned __int16 *)(v2 + 0x5C) > i; i = (__int16)(i + 1) )
    {
      v9 = v7 + 16 * i;
      if ( (*(_BYTE *)(v9 + 1) & 0xF) == 9 && !sub_802091C(v2, (_BYTE *)(v7 + 16 * i)) )
      {
        v10 = *(_DWORD *)(v9 + 4);
        v11 = *(_DWORD *)(v2 + 0x38);
        if ( (v10 & v5) == v11 && (v10 & (255 << v4)) == v3 << v4 )
        {
          *(_DWORD *)(v2 + 0x38) = v11 | (v3 << v4);
          v3 = 0;
          if ( !v4 || (*(_DWORD *)(v9 + 4) & (255 << (v4 - 8))) == 0 )
          {
            v12 = *(void (__fastcall **)(int))(v7 + 16 * i + 8);
            if ( v12 )
              v12(v2);
            *(_DWORD *)(v2 + 0x38) = 0;
            break;
          }
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(v2 + 0x38) = 0;
      sub_8021318(v2, v3);
    }
    result = sub_8012948();
    if ( result )
    {
      result = sub_8012948();
      *(_DWORD *)(v2 + 4) = result;
    }
  }
  return result;
}

//----- (08020F84) --------------------------------------------------------
int __fastcall sub_8020F84(int a1, int a2)
{
  int result; // r0
  int v4; // r3

  result = sub_8020E44();
  if ( result )
  {
    if ( v4 == 1 )
    {
      return sub_802121E(result);
    }
    else if ( v4 > 1 )
    {
      return sub_8021878(result, *(_DWORD *)(a2 + 4));
    }
  }
  return result;
}
// 8020F94: variable 'v4' is possibly undefined

//----- (08020FAC) --------------------------------------------------------
int __fastcall sub_8020FAC(int result, int a2)
{
  int v2; // r4
  int v3; // r4
  int v4; // r2
  unsigned int v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r3

  v2 = result;
  if ( a2 <= 0 )
  {
    if ( a2 >= 0 )
      return result;
    result = (__int16)(*(_WORD *)(result + 84) + 1);
    *(_WORD *)(v2 + 84) = result;
    if ( result > 0 )
    {
      *(_WORD *)(v2 + 84) = 0;
      return result;
    }
  }
  else
  {
    v3 = result + 80;
    v4 = *(__int16 *)(result + 84);
    *(_WORD *)(result + 84) = v4 - 1;
    v5 = *(unsigned __int16 *)(result + 80);
    v6 = *(unsigned __int16 *)(v3 + 2);
    v2 = v3 - 80;
    if ( v5 <= v6 )
      v7 = v6;
    else
      v7 = v5;
    if ( v4 <= (signed int)-v7 )
    {
      if ( v5 <= v6 )
        LOWORD(v5) = v6;
      *(_WORD *)(v2 + 84) = -(__int16)v5;
    }
  }
  sub_8020968(v2);
  result = *(__int16 *)(v2 + 84);
  if ( *(_WORD *)(v2 + 84) )
  {
    result = sub_802163C(
               *(_DWORD *)(v2 + 16),
               *(_DWORD *)(v2 + 4 * ((result + *(unsigned __int16 *)(v2 + 82) + 5) % 5) + 60));
    *(_WORD *)(v2 + 12) = result;
    if ( result )
    {
      *(_WORD *)(v2 + 14) = result;
      return sub_80219C4(v2, *(unsigned __int8 **)(v2 + 16));
    }
  }
  else
  {
    *(_WORD *)(v2 + 12) = 0;
    *(_WORD *)(v2 + 14) = 0;
  }
  return result;
}
// 8020968: using guessed type int __fastcall sub_8020968(_DWORD);

//----- (08021046) --------------------------------------------------------
unsigned int __fastcall sub_8021046(int a1)
{
  int v2; // r0
  unsigned int result; // r0
  unsigned int v4; // r0

  *(_WORD *)(a1 + 84) = 0;
  if ( !*(_WORD *)(a1 + 80) )
    goto LABEL_13;
  v2 = *(unsigned __int16 *)(a1 + 82);
  if ( !*(_WORD *)(a1 + 82) )
    v2 = 5;
  result = sub_80023F0(*(_DWORD *)(a1 + 4 * (v2 - 1) + 60), *(_DWORD *)(a1 + 16));
  if ( result )
  {
LABEL_13:
    if ( sub_802163C(*(_DWORD *)(a1 + 4 * *(unsigned __int16 *)(a1 + 82) + 60), *(_DWORD *)(a1 + 16)) )
      ++*(_WORD *)(a1 + 82);
    v4 = (unsigned __int16)(*(_WORD *)(a1 + 80) + 1);
    *(_WORD *)(a1 + 80) = v4;
    if ( v4 > 5 )
      *(_WORD *)(a1 + 80) = 5;
    result = *(unsigned __int16 *)(a1 + 82);
    if ( result >= 5 )
      *(_WORD *)(a1 + 82) = 0;
  }
  return result;
}

//----- (080210B4) --------------------------------------------------------
int __fastcall sub_80210B4(int a1, int a2, unsigned int a3)
{
  int v4; // r0
  int v5; // r0

  v4 = 0;
  *(_WORD *)(a1 + 0xC) = 0;
  *(_WORD *)(a1 + 0xE) = 0;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x60) |= 1u;
  *(_DWORD *)(a1 + 0x10) = a2;
  *(_WORD *)(a1 + 0x34) = a3 / 6;
  *(_WORD *)(a1 + 0x54) = 0;
  *(_WORD *)(a1 + 0x50) = 0;
  *(_WORD *)(a1 + 0x52) = 0;
  do
  {
    *(_DWORD *)(a1 + 4 * v4 + 60) = a2 + *(unsigned __int16 *)(a1 + 0x34) * (v4 + 1);
    v4 = (__int16)(v4 + 1);
  }
  while ( v4 < 5 );
  *(_DWORD *)(a1 + 0x58) = dword_8029B4C;
  *(_WORD *)(a1 + 0x5C) = (unsigned int)(&loc_8029F0C - (_UNKNOWN *)dword_8029B4C) >> 4;
  sub_80208B4(a1);
  v5 = sub_8021488(a1, (int)"User", *(_DWORD *)(a1 + 0x58), 0);
  sub_80214FC(a1, v5);
  return sub_80218D8(a1, 1);
}
// 8029B4C: using guessed type int dword_8029B4C[9];

//----- (0802113C) --------------------------------------------------------
int __fastcall sub_802113C(int a1, char a2)
{
  int v3; // r2
  int result; // r0
  unsigned int v5; // r2
  int i; // r0
  int v7; // r3
  int v8; // r0
  int v9; // r1
  int v10; // r0
  int j; // r5
  int k; // r5

  v3 = *(unsigned __int16 *)(a1 + 52);
  result = *(unsigned __int16 *)(a1 + 12);
  if ( result < v3 - 1 )
  {
    v5 = *(unsigned __int16 *)(a1 + 14);
    if ( v5 == result )
    {
      *(_WORD *)(a1 + 12) = result + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + result) = a2;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(a1 + 12)) = 0;
      ++*(_WORD *)(a1 + 14);
      return sub_802181A(a1, a2);
    }
    else if ( v5 < result )
    {
      for ( i = (__int16)(result - v5); i > 0; i = (__int16)(i - 1) )
      {
        v7 = *(unsigned __int16 *)(a1 + 14) + *(_DWORD *)(a1 + 16);
        *(_BYTE *)(i + v7) = *(_BYTE *)(v7 + i - 1);
      }
      v8 = *(unsigned __int16 *)(a1 + 14);
      *(_WORD *)(a1 + 14) = v8 + 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + v8) = a2;
      v9 = *(_DWORD *)(a1 + 16);
      v10 = (unsigned __int16)(*(_WORD *)(a1 + 12) + 1);
      *(_WORD *)(a1 + 12) = v10;
      *(_BYTE *)(v9 + v10) = 0;
      for ( j = (__int16)(*(_WORD *)(a1 + 14) - 1); *(unsigned __int16 *)(a1 + 12) > j; j = (__int16)(j + 1) )
        sub_802181A(a1, *(_BYTE *)(*(_DWORD *)(a1 + 16) + j));
      result = *(unsigned __int16 *)(a1 + 12) - *(unsigned __int16 *)(a1 + 14);
      for ( k = (__int16)result; k > 0; k = (__int16)(k - 1) )
        result = sub_802181A(a1, 8);
    }
  }
  else
  {
    sub_80219C4(a1, (unsigned __int8 *)dword_20001608);
    sub_80218D8(a1, 1);
    return sub_80219C4(a1, *(unsigned __int8 **)(a1 + 16));
  }
  return result;
}
// 20001608: using guessed type int dword_20001608;

//----- (08021204) --------------------------------------------------------
int __fastcall sub_8021204(int a1)
{
  int result; // r0

  result = *(unsigned __int16 *)(a1 + 14);
  if ( result )
  {
    sub_802181A(a1, 8);
    result = *(unsigned __int16 *)(a1 + 14) - 1;
    *(_WORD *)(a1 + 14) = result;
  }
  return result;
}

//----- (0802121E) --------------------------------------------------------
int __fastcall sub_802121E(int a1)
{
  int v2; // r7
  int i; // r4
  int result; // r0

  v2 = *(_DWORD *)(a1 + 88);
  sub_80219C4(a1, (unsigned __int8 *)dword_2000160C);
  for ( i = 0; ; i = (__int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 92);
    if ( result <= i )
      break;
    if ( (*(_BYTE *)(v2 + 16 * i + 1) & 0xFu) <= 1 && !sub_802091C(a1, (_BYTE *)(v2 + 16 * i)) )
      sub_8021270(a1, v2 + 16 * i);
  }
  return result;
}
// 2000160C: using guessed type int dword_2000160C;

//----- (08021270) --------------------------------------------------------
int __fastcall sub_8021270(int a1, int a2)
{
  unsigned __int8 *v4; // r0
  int v5; // r4
  unsigned int v6; // r0
  _BYTE *v7; // r0

  v4 = sub_8020E04(a2);
  LOWORD(v5) = 22 - sub_80219C4(a1, v4);
  if ( (__int16)v5 <= 0 )
    LOWORD(v5) = 4;
  do
  {
    sub_802181A(a1, 32);
    v5 = (__int16)(v5 - 1);
  }
  while ( v5 );
  v6 = *(_BYTE *)(a2 + 1) & 0xF;
  if ( v6 > 1 )
  {
    if ( v6 > 7 )
    {
      if ( v6 > 8 )
      {
        if ( v6 > 9 )
          sub_80219C4(a1, (unsigned __int8 *)dword_20001654);
        else
          sub_80219C4(a1, (unsigned __int8 *)dword_20001650);
      }
      else
      {
        sub_80219C4(a1, (unsigned __int8 *)dword_2000164C);
      }
    }
    else
    {
      sub_80219C4(a1, (unsigned __int8 *)dword_20001648);
    }
  }
  else
  {
    sub_80219C4(a1, (unsigned __int8 *)dword_20001644);
  }
  sub_80219C4(a1, (unsigned __int8 *)&dword_8021310);
  v7 = (_BYTE *)sub_8020DF8(a2);
  sub_8021828(a1, v7);
  return sub_80219C4(a1, (unsigned __int8 *)&dword_8021314);
}
// 8021310: using guessed type int dword_8021310;
// 8021314: using guessed type int dword_8021314;
// 20001644: using guessed type int dword_20001644;
// 20001648: using guessed type int dword_20001648;
// 2000164C: using guessed type int dword_2000164C;
// 20001650: using guessed type int dword_20001650;
// 20001654: using guessed type int dword_20001654;

//----- (08021318) --------------------------------------------------------
int __fastcall sub_8021318(int a1, char a2)
{
  *(_BYTE *)(a1 + 96) &= ~4u;
  return sub_802113C(a1, a2);
}

//----- (08021328) --------------------------------------------------------
int __fastcall sub_8021328(int result)
{
  BOOL v1; // r2
  int v2; // r3
  int i; // r1
  unsigned int j; // r1
  int v5; // r5
  int v6; // r4
  unsigned int v7; // r3
  int v8; // r5

  v1 = 0;
  v2 = 1;
  for ( i = 0; i < 8; i = (__int16)(i + 1) )
    *(_DWORD *)(result + 4 * i + 20) = 0;
  *(_WORD *)(result + 54) = 0;
  for ( j = 0; *(unsigned __int16 *)(result + 12) > j; j = (unsigned __int16)(j + 1) )
  {
    if ( v1 || (v5 = *(_DWORD *)(result + 16), *(_BYTE *)(v5 + j) != 32) && *(_BYTE *)(v5 + j) )
    {
      v6 = *(_DWORD *)(result + 16);
      if ( *(_BYTE *)(v6 + j) == 34 )
        v1 = !v1;
      if ( v2 == 1 )
      {
        v7 = *(unsigned __int16 *)(result + 54);
        if ( v7 < 8 )
        {
          *(_WORD *)(result + 54) = v7 + 1;
          *(_DWORD *)(result + 4 * v7 + 20) = v6 + j;
        }
        v2 = 0;
      }
      v8 = *(_DWORD *)(result + 16);
      if ( *(_BYTE *)(v8 + j) == 92 )
      {
        if ( *(_BYTE *)(v8 + j + 1) )
          LOWORD(j) = j + 1;
      }
    }
    else
    {
      *(_BYTE *)(v5 + j) = 0;
      v2 = 1;
    }
  }
  return result;
}

//----- (0802139E) --------------------------------------------------------
unsigned int __fastcall sub_802139E(int a1)
{
  unsigned int i; // r5
  int v3; // r4
  _BYTE *v4; // r1
  unsigned __int16 v5; // r0
  int v6; // r2
  int v7; // r1
  unsigned int result; // r0

  for ( i = 0; ; i = (unsigned __int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 54);
    if ( result <= i )
      break;
    v3 = a1 + 4 * i;
    v4 = *(_BYTE **)(v3 + 20);
    if ( *v4 == 34 )
    {
      *v4 = 0;
      ++*(_DWORD *)(v3 + 20);
    }
    v5 = (unsigned __int16)sub_80023E2(*(unsigned __int8 **)(v3 + 20));
    v6 = *(_DWORD *)(v3 + 20);
    v7 = v5 - 1;
    if ( *(_BYTE *)(v6 + v7) == 34 )
      *(_BYTE *)(v6 + v7) = 0;
  }
  return result;
}

//----- (080213E0) --------------------------------------------------------
int __fastcall sub_80213E0(int result)
{
  unsigned int v1; // r1

  v1 = *(unsigned __int16 *)(result + 14);
  if ( v1 < *(unsigned __int16 *)(result + 12) )
  {
    *(_WORD *)(result + 14) = v1 + 1;
    return sub_802181A(result, *(unsigned __int8 *)(*(_DWORD *)(result + 16) + v1));
  }
  return result;
}

//----- (080213F6) --------------------------------------------------------
unsigned int __fastcall sub_80213F6(int a1, int a2)
{
  unsigned int v4; // r7
  int v5; // r0
  int v6; // r0

  v4 = 0;
  *(_BYTE *)(a1 + 96) |= 2u;
  v5 = *(unsigned __int8 *)(a2 + 1);
  if ( !(v5 << 28) )
  {
    sub_802139E(a1);
    v4 = (*(int (__fastcall **)(_DWORD, int))(a2 + 8))(*(unsigned __int16 *)(a1 + 54), a1 + 20);
    if ( (*(_BYTE *)(a2 + 1) & 0x20) != 0 )
      goto LABEL_11;
LABEL_6:
    sub_802193C(a1, v4);
    goto LABEL_11;
  }
  v6 = v5 & 0xF;
  if ( v6 == 1 )
  {
    v4 = sub_8020CF8(a1, a2, *(unsigned __int16 *)(a1 + 54), a1 + 20);
    if ( (*(_BYTE *)(a2 + 1) & 0x20) != 0 )
      goto LABEL_11;
    goto LABEL_6;
  }
  if ( (unsigned int)(v6 - 2) > 5 )
  {
    if ( v6 == 8 )
      sub_80214FC(a1, a2);
  }
  else
  {
    sub_802155C(a1, a2);
  }
LABEL_11:
  *(_BYTE *)(a1 + 96) &= ~2u;
  return v4;
}

//----- (08021488) --------------------------------------------------------
int __fastcall sub_8021488(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v8; // r7
  unsigned int i; // r4
  _BYTE *v10; // r1

  v8 = (unsigned __int16)(*(_WORD *)(a1 + 92) - ((unsigned int)(a3 - *(_DWORD *)(a1 + 88)) >> 4));
  for ( i = 0; ; i = (unsigned __int16)(i + 1) )
  {
    if ( i >= v8 )
      return 0;
    if ( (*(_BYTE *)(a3 + 16 * i + 1) & 0xF) == 9 || sub_802091C(a1, (_BYTE *)(a3 + 16 * i)) )
      continue;
    v10 = sub_8020E04(a3 + 16 * i);
    if ( a4 )
      break;
    if ( !sub_80023F0(a2, (int)v10) )
      return a3 + 16 * i;
LABEL_8:
    ;
  }
  if ( sub_800241E(a2, (int)v10, a4) )
    goto LABEL_8;
  return a3 + 16 * i;
}

//----- (080214FC) --------------------------------------------------------
int __fastcall sub_80214FC(int a1, int a2)
{
  unsigned __int8 *v4; // r0
  char v5; // r0
  int result; // r0

  *(_DWORD *)a1 = a2;
  v4 = *(unsigned __int8 **)(a2 + 8);
  if ( v4
    && sub_80023E2(v4)
    && (*(unsigned __int16 *)(a1 + 54) < 2u || sub_80023F0(*(_DWORD *)(a2 + 8), *(_DWORD *)(a1 + 24))) )
  {
    v5 = *(_BYTE *)(a1 + 96) & 0xFE;
  }
  else
  {
    v5 = *(_BYTE *)(a1 + 96) | 1;
  }
  *(_BYTE *)(a1 + 96) = v5;
  sub_80219C4(a1, (unsigned __int8 *)dword_2000163C);
  result = *(unsigned __int8 *)(a1 + 96) << 31;
  if ( result )
    return sub_80219C4(a1, (unsigned __int8 *)dword_20001604);
  return result;
}
// 20001604: using guessed type int dword_20001604;
// 2000163C: using guessed type int dword_2000163C;

//----- (0802155C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_802155C(int a1, int a2)
{
  unsigned __int8 *v4; // r6
  int v5; // r0
  int i; // r0
  char v8[32]; // [sp+0h] [bp-20h] BYREF

  strcpy(v8, "00000000000");
  v4 = (unsigned __int8 *)sub_8020E6C(a1, a2);
  sub_80219C4(a1, *(unsigned __int8 **)(a2 + 4));
  sub_80219C4(a1, " = ");
  if ( (*(_BYTE *)(a2 + 1) & 0xF) == 5 )
  {
    sub_80219C4(a1, "\"");
    sub_80219C4(a1, v4);
    sub_80219C4(a1, "\"");
  }
  else
  {
    v5 = sub_8021798((int)v4, (int)v8);
    sub_80219C4(a1, (unsigned __int8 *)&v8[11 - v5]);
    sub_80219C4(a1, ", 0x");
    for ( i = 0; i < 11; i = (__int16)(i + 1) )
      v8[i] = 48;
    sub_80217EA((unsigned int)v4, (int)v8);
    sub_80219C4(a1, (unsigned __int8 *)v8);
  }
  sub_80219C4(a1, "\r\n");
  return v4;
}

//----- (08021618) --------------------------------------------------------
int __fastcall sub_8021618(int a1, int a2)
{
  int result; // r0
  int i; // r2

  result = 0;
  for ( i = 0;
        *(_BYTE *)(a1 + i) && *(_BYTE *)(a2 + i) && *(unsigned __int8 *)(a1 + i) == *(unsigned __int8 *)(a2 + i);
        i = (unsigned __int16)(i + 1) )
  {
    result = (unsigned __int16)(result + 1);
  }
  return result;
}

//----- (0802163C) --------------------------------------------------------
int __fastcall sub_802163C(int a1, int a2)
{
  int result; // r0

  for ( result = 0; *(_BYTE *)(a2 + result); result = (unsigned __int16)(result + 1) )
    *(_BYTE *)(a1 + result) = *(_BYTE *)(a2 + result);
  *(_BYTE *)(a1 + result) = 0;
  return result;
}

//----- (08021654) --------------------------------------------------------
int __fastcall sub_8021654(int a1)
{
  unsigned int v2; // r7
  int v3; // r11
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r9
  int i; // r6
  _BYTE *v8; // r0
  int v9; // r11
  _BYTE *v10; // r8
  _BYTE *v11; // r0
  unsigned int v12; // r0
  int result; // r0
  _BYTE *v14; // r0
  int v15; // t1

  v2 = *(unsigned __int16 *)(a1 + 52);
  v3 = 0;
  v4 = 0;
  v5 = *(unsigned __int16 *)(a1 + 12);
  if ( !v5 )
  {
    sub_802121E(a1);
    sub_80218D8(a1, 1);
LABEL_21:
    result = sub_8012948();
    if ( result )
    {
      if ( v4 == 1 && (*(_BYTE *)(a1 + 96) & 4) != 0 && (unsigned int)(sub_8012948() - *(_DWORD *)(a1 + 4)) < 0xC8 )
      {
        sub_80219C4(a1, (unsigned __int8 *)&dword_8021794);
        sub_8021878(a1, *(_DWORD *)(a1 + 16));
        sub_80218D8(a1, 1);
        return sub_80219C4(a1, *(unsigned __int8 **)(a1 + 16));
      }
      else
      {
        v15 = *(unsigned __int8 *)(a1 + 96);
        result = v15 | 4;
        *(_BYTE *)(a1 + 96) = v15 | 4;
      }
    }
    return result;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 16) + v5) = 0;
  v6 = *(_DWORD *)(a1 + 88);
  for ( i = 0; ; i = (__int16)(i + 1) )
  {
    result = *(unsigned __int16 *)(a1 + 92);
    if ( result <= i )
      break;
    if ( !sub_802091C(a1, (_BYTE *)(v6 + 16 * i)) )
    {
      v8 = sub_8020E04(v6 + 16 * i);
      if ( sub_8021618(*(_DWORD *)(a1 + 16), (int)v8) == *(unsigned __int16 *)(a1 + 12) )
      {
        if ( v4 )
        {
          if ( v4 == 1 )
            sub_80219C4(a1, (unsigned __int8 *)&dword_8021794);
          v9 = v6 + 16 * v3;
          sub_8021270(a1, v9);
          v10 = sub_8020E04(v6 + 16 * i);
          v11 = sub_8020E04(v9);
          v12 = sub_8021618((int)v11, (int)v10);
          if ( v2 <= v12 )
            v12 = v2;
          v2 = v12;
        }
        v3 = (unsigned __int16)i;
        v4 = (unsigned __int16)(v4 + 1);
      }
    }
  }
  if ( v4 )
  {
    if ( v4 == 1 )
      sub_8020968(a1);
    v14 = sub_8020E04(v6 + 16 * v3);
    *(_WORD *)(a1 + 12) = sub_802163C(*(_DWORD *)(a1 + 16), (int)v14);
    if ( v4 > 1 )
    {
      sub_8021270(a1, v6 + 16 * v3);
      sub_80218D8(a1, 1);
      *(_WORD *)(a1 + 12) = v2;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(a1 + 12)) = 0;
    *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 12);
    sub_80219C4(a1, *(unsigned __int8 **)(a1 + 16));
    goto LABEL_21;
  }
  return result;
}
// 8021794: using guessed type int dword_8021794;

//----- (08021798) --------------------------------------------------------
int __fastcall sub_8021798(int a1, int a2)
{
  int v2; // r2
  int v3; // r3

  LOBYTE(v2) = 11;
  v3 = a1;
  if ( a1 < 0 )
    v3 = -a1;
  *(_BYTE *)(a2 + 11) = 0;
  while ( v3 )
  {
    LOBYTE(v2) = v2 - 1;
    *(_BYTE *)(a2 + (unsigned __int8)v2) = v3 % 10 + 48;
    v3 /= 10;
  }
  if ( a1 < 0 )
  {
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = 45;
  }
  if ( !a1 )
  {
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = 48;
  }
  return (char)(11 - v2);
}

//----- (080217EA) --------------------------------------------------------
int __fastcall sub_80217EA(unsigned int a1, int a2)
{
  int v2; // r3
  char v3; // r2
  char v4; // r2

  LOBYTE(v2) = 8;
  *(_BYTE *)(a2 + 8) = 0;
  while ( a1 )
  {
    v3 = a1 & 0xF;
    if ( (a1 & 0xF) <= 9 )
      v4 = v3 + 48;
    else
      v4 = v3 + 87;
    v2 = (unsigned __int8)(v2 - 1);
    *(_BYTE *)(a2 + v2) = v4;
    a1 >>= 4;
  }
  return (char)(8 - v2);
}

//----- (08021814) --------------------------------------------------------
int __fastcall sub_8021814(int a1)
{
  return sub_8020FAC(a1, 1);
}

//----- (0802181A) --------------------------------------------------------
int __fastcall sub_802181A(int a1, int a2)
{
  int v3; // [sp+4h] [bp-Ch] BYREF

  v3 = a2;
  return (*(int (__fastcall **)(int *, int))(a1 + 104))(&v3, 1);
}

//----- (08021828) --------------------------------------------------------
int __fastcall sub_8021828(int a1, _BYTE *a2)
{
  unsigned int v4; // r4
  _BYTE *v5; // r0
  void (__fastcall *v6)(_BYTE *, unsigned int); // r2
  int v8; // r1

  v4 = 0;
  v5 = a2;
  v6 = *(void (__fastcall **)(_BYTE *, unsigned int))(a1 + 104);
  if ( !v6 )
    return 0;
  while ( 1 )
  {
    v8 = (unsigned __int8)*v5;
    if ( !*v5 || v8 == 13 || v8 == 10 )
      break;
    ++v5;
    v4 = (unsigned __int16)(v4 + 1);
  }
  if ( v4 <= 0x96 )
  {
    v6(a2, v4);
  }
  else
  {
    v6(a2, 150u);
    (*(void (__fastcall **)(int (*)(), int))(a1 + 104))(sub_8021874, 3);
  }
  if ( v4 <= 0x96 )
    return 153;
  else
    return 150;
}

//----- (08021874) --------------------------------------------------------
int sub_8021874()
{
  return sub_8021878();
}
// 8021878: using guessed type int sub_8021878(void);

//----- (08021878) --------------------------------------------------------
int __fastcall sub_8021878(int a1, int a2)
{
  int v3; // r4
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r0

  v3 = sub_8021488(a1, a2, *(_DWORD *)(a1 + 88), 0);
  if ( !v3 )
    return sub_80219C4(a1, (unsigned __int8 *)dword_2000161C);
  sub_80219C4(a1, (unsigned __int8 *)dword_20001630);
  v4 = sub_8020E04(v3);
  sub_80219C4(a1, v4);
  sub_80219C4(a1, (unsigned __int8 *)&dword_80218D4);
  v5 = (unsigned __int8 *)sub_8020DF8(v3);
  sub_80219C4(a1, v5);
  return sub_80219C4(a1, (unsigned __int8 *)&dword_80218D4);
}
// 80218D4: using guessed type int dword_80218D4;
// 2000161C: using guessed type int dword_2000161C;
// 20001630: using guessed type int dword_20001630;

//----- (080218D8) --------------------------------------------------------
int __fastcall sub_80218D8(int a1, int a2)
{
  unsigned __int8 *v3; // r1

  if ( !(*(unsigned __int8 *)(a1 + 96) << 31) )
    return sub_80219C4(a1, (unsigned __int8 *)dword_20001634);
  if ( a2 )
    sub_80219C4(a1, (unsigned __int8 *)&dword_8021928);
  sub_80219C4(a1, *(unsigned __int8 **)(*(_DWORD *)a1 + 4));
  sub_80219C4(a1, (unsigned __int8 *)&dword_802192C);
  v3 = *(unsigned __int8 **)(a1 + 8);
  if ( !v3 )
    v3 = (unsigned __int8 *)&dword_8021930;
  sub_80219C4(a1, v3);
  return sub_80219C4(a1, (unsigned __int8 *)&dword_8021934);
}
// 8021928: using guessed type int dword_8021928;
// 802192C: using guessed type int dword_802192C;
// 8021930: using guessed type int dword_8021930;
// 8021934: using guessed type int dword_8021934;
// 20001634: using guessed type int dword_20001634;

//----- (0802193C) --------------------------------------------------------
int __fastcall sub_802193C(int a1, unsigned int a2)
{
  int v4; // r0
  int i; // r2
  char v7[32]; // [sp+0h] [bp-20h] BYREF

  strcpy(v7, "00000000000");
  sub_80219C4(a1, "Return: ");
  v4 = sub_8021798(a2, (int)v7);
  sub_80219C4(a1, (unsigned __int8 *)&v7[11 - v4]);
  sub_80219C4(a1, ", 0x");
  for ( i = 0; i < 11; i = (__int16)(i + 1) )
    v7[i] = 48;
  sub_80217EA(a2, (int)v7);
  sub_80219C4(a1, (unsigned __int8 *)v7);
  return sub_80219C4(a1, "\r\n");
}

//----- (080219C4) --------------------------------------------------------
int __fastcall sub_80219C4(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // r0
  int v4; // r2
  unsigned __int16 (__fastcall *v5)(unsigned __int8 *, int); // r4

  v3 = a2;
  v4 = 0;
  v5 = *(unsigned __int16 (__fastcall **)(unsigned __int8 *, int))(a1 + 104);
  if ( !v5 )
    return 0;
  while ( *a2++ )
    v4 = (unsigned __int16)(v4 + 1);
  return v5(v3, v4);
}

//----- (080219F0) --------------------------------------------------------
void __fastcall sub_80219F0(int a1)
{
  if ( a1 )
    sub_801E93C((int)sub_8021A18);
  else
    sub_801E93C((int)&loc_8021A2C);
  sub_80031EE();
}
// 8021A18: using guessed type int sub_8021A18();

//----- (08021ADC) --------------------------------------------------------
void sub_8021ADC()
{
  JUMPOUT(0x802183E);
}
// 8021ADE: control flows out of bounds to 802183E

//----- (08021B7C) --------------------------------------------------------
int sub_8021B7C()
{
  return sub_801E93C((int)"[BLE] type=%s,id=%s,mac=%s", (const char *)&dword_20003A0B, byte_200038E3, byte_20004152);
}
// 20003A0B: using guessed type int dword_20003A0B;

//----- (08021BB0) --------------------------------------------------------
int __fastcall sub_8021BB0(int a1)
{
  int result; // r0

  if ( a1 == 1 )
  {
    result = 1;
    byte_200037D5 = 1;
  }
  else if ( a1 == 2 )
  {
    result = 2;
    byte_200037D5 = 2;
  }
  else
  {
    result = 0;
    byte_200037D5 = 0;
  }
  return result;
}
// 200037D5: using guessed type char byte_200037D5;

//----- (08021BD0) --------------------------------------------------------
int sub_8021BD0()
{
  return sub_80080B4(0);
}

//----- (08021BD8) --------------------------------------------------------
int sub_8021BD8()
{
  sub_8008028();
  return sub_801E93C((int)"[BLE] firmware version: %s", (const char *)&dword_200038FD);
}
// 200038FD: using guessed type int dword_200038FD;

//----- (08021C0C) --------------------------------------------------------
int __fastcall sub_8021C0C(int result)
{
  unsigned int i; // r4
  unsigned __int16 *v2; // r0
  unsigned int j; // r4
  unsigned __int16 *v4; // r0
  __int64 v5; // [sp+Ch] [bp-1Ch]

  if ( result )
  {
    if ( result == 1 )
    {
      sub_801E93C((int)"Event info:\r\n");
      for ( i = 0; i < 0x14; ++i )
      {
        v2 = (unsigned __int16 *)&byte_20003E99[9 * i];
        result = sub_801E93C(
                   (int)"event%d=%d|%d|%d|%d|%d|%d|%d\r\n",
                   i,
                   *v2,
                   *((unsigned __int8 *)v2 + 2),
                   *((unsigned __int8 *)v2 + 3),
                   *((unsigned __int8 *)v2 + 4),
                   *((unsigned __int8 *)v2 + 5),
                   *((unsigned __int8 *)v2 + 6),
                   *(unsigned __int16 *)((char *)v2 + 7));
      }
    }
  }
  else
  {
    sub_801E93C((int)"Error code info:\r\n");
    for ( j = 0; j < 0x14; ++j )
    {
      v4 = (unsigned __int16 *)&dword_20003D81 + 7 * j;
      HIDWORD(v5) = *(_DWORD *)(v4 + 3);
      result = sub_801E93C(
                 (int)"err%d=%d|%d|%d|%d|%d|%lld\r\n",
                 j,
                 *v4,
                 *((unsigned __int8 *)v4 + 2),
                 *((unsigned __int8 *)v4 + 3),
                 *((unsigned __int8 *)v4 + 4),
                 *((unsigned __int8 *)v4 + 5),
                 v5);
    }
  }
  return result;
}
// 8021C86: variable 'v5' is possibly undefined
// 20003D81: using guessed type int dword_20003D81;
// 20003E99: using guessed type _BYTE byte_20003E99[180];

//----- (08021CFC) --------------------------------------------------------
int sub_8021CFC()
{
  sub_801E93C((int)sub_8021D1C);
  sub_801E93C((int)sub_8021D34);
  sub_801E93C((int)dword_8021D48);
  return sub_801E93C((int)dword_8021D5C);
}
// 8021D1C: using guessed type int sub_8021D1C();
// 8021D48: using guessed type int dword_8021D48[5];
// 8021D5C: using guessed type int dword_8021D5C[5];

//----- (08021D34) --------------------------------------------------------
int sub_8021D34()
{
  return sub_8021B7C();
}

//----- (08021D3A) --------------------------------------------------------
void __fastcall sub_8021D3A(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R0-R2,R5-R7,PC} }
}
// 8021D3C: unbalanced stack, ignored a potential tail call

//----- (08021D70) --------------------------------------------------------
int __fastcall sub_8021D70(int result, int a2)
{
  BOOL v2; // r1
  BOOL v3; // r1
  BOOL v4; // r1
  BOOL v5; // r1
  BOOL v6; // r1
  BOOL v7; // r1
  BOOL v8; // r1
  BOOL v9; // r1
  BOOL v10; // r1
  BOOL v11; // r1
  BOOL v12; // r1
  BOOL v13; // r1
  BOOL v14; // r1
  BOOL v15; // r1
  BOOL v16; // r1
  BOOL v17; // r1
  BOOL v18; // r1
  BOOL v19; // r1
  BOOL v20; // r1
  BOOL v21; // r1
  BOOL v22; // r1
  BOOL v23; // r1
  BOOL v24; // r1
  BOOL v25; // r1

  v2 = a2 != 0;
  switch ( result )
  {
    case 1:
      sub_801292E(1207962624, 2, v2);
      v3 = sub_8012910(1207962624, 2);
      result = sub_801E93C((int)"1 LED0  =  %d\r\n", v3);
      break;
    case 2:
      sub_801292E(1207962624, 1, v2);
      v4 = sub_8012910(1207962624, 1);
      result = sub_801E93C((int)"2 LED1  =  %d\r\n", v4);
      break;
    case 3:
      return result;
    case 4:
      sub_801292E(1207962624, 128, v2);
      v5 = sub_8012910(1207962624, 128);
      result = sub_801E93C((int)dword_80220C0, v5);
      break;
    case 5:
      sub_801292E(1207962624, 8, v2);
      v6 = sub_8012910(1207962624, 8);
      result = sub_801E93C((int)dword_80220E4, v6);
      break;
    case 6:
      sub_801292E(1207959552, 4096, v2);
      v7 = sub_8012910(1207959552, 4096);
      result = sub_801E93C((int)sub_8022108, v7);
      break;
    case 7:
      sub_801292E(1207961600, 1024, v2);
      v8 = sub_8012910(1207961600, 1024);
      result = sub_801E93C((int)&loc_802212C, v8);
      break;
    case 8:
      sub_801292E(1207960576, 8, v2);
      v9 = sub_8012910(1207960576, 8);
      result = sub_801E93C((int)&loc_8022150, v9);
      break;
    case 9:
      sub_801292E(1207962624, 2048, v2);
      v10 = sub_8012910(1207962624, 2048);
      result = sub_801E93C((int)&loc_8022170, v10);
      break;
    case 10:
      sub_801292E(1207962624, 1024, v2);
      v11 = sub_8012910(1207962624, 1024);
      result = sub_801E93C((int)&loc_802218C, v11);
      break;
    case 11:
      sub_801292E(1207963648, 64, v2);
      v12 = sub_8012910(1207963648, 64);
      result = sub_801E93C((int)"11 LED_A  =  %d\r\n", v12);
      break;
    case 12:
      sub_801292E(1207961600, 2048, v2);
      v13 = sub_8012910(1207961600, 2048);
      result = sub_801E93C((int)"11 LED_B  =  %d\r\n", v13);
      break;
    case 13:
      sub_801292E(1207959552, 16, v2);
      v14 = sub_8012910(1207959552, 16);
      result = sub_801E93C((int)"11 LED_C  =  %d\r\n", v14);
      break;
    case 14:
      sub_801292E(1207963648, 4, v2);
      v15 = sub_8012910(1207963648, 4);
      result = sub_801E93C((int)"11 LED_D  =  %d\r\n", v15);
      break;
    case 15:
      sub_801292E(1207963648, 8, v2);
      v16 = sub_8012910(1207963648, 8);
      result = sub_801E93C((int)"11 LED_E  =  %d\r\n", v16);
      break;
    case 16:
      sub_801292E(1207963648, 16, v2);
      v17 = sub_8012910(1207963648, 16);
      result = sub_801E93C((int)"11 LED_F  =  %d\r\n", v17);
      break;
    case 17:
      sub_801292E(1207963648, 32, v2);
      v18 = sub_8012910(1207963648, 32);
      result = sub_801E93C((int)"11 LED_G  =  %d\r\n", v18);
      break;
    case 18:
      sub_801292E(1207960576, 16, v2);
      v19 = sub_8012910(1207960576, 16);
      result = sub_801E93C((int)"11 LED_H  =  %d\r\n", v19);
      break;
    case 19:
      sub_801292E(1207959552, 8, v2);
      v20 = sub_8012910(1207959552, 8);
      result = sub_801E93C((int)"11 LED_I  =  %d\r\n", v20);
      break;
    case 20:
      sub_801292E(1207959552, 32, v2);
      v21 = sub_8012910(1207959552, 32);
      result = sub_801E93C((int)"11    LED_J  =  %d\r\n", v21);
      break;
    case 21:
      sub_801292E(1207961600, 16, v2);
      v22 = sub_8012910(1207961600, 16);
      result = sub_801E93C((int)"11 LED_K  =  %d\r\n", v22);
      break;
    case 22:
      sub_801292E(1207961600, 32, v2);
      v23 = sub_8012910(1207961600, 32);
      result = sub_801E93C((int)"11 LED_L  =  %d\r\n", v23);
      break;
    case 23:
      sub_801292E(1207960576, 4, v2);
      v24 = sub_8012910(1207960576, 4);
      result = sub_801E93C((int)"11 LED_M  =  %d\r\n", v24);
      break;
    case 24:
      sub_801292E(1207960576, 0x8000, v2);
      v25 = sub_8012910(1207960576, 0x8000);
      result = sub_801E93C((int)"11 LED_N  =  %d\r\n", v25);
      break;
    default:
      result = sub_801E93C((int)sub_80222C8, v2);
      break;
  }
  return result;
}
// 80220C0: using guessed type int dword_80220C0[9];
// 80220E4: using guessed type int dword_80220E4[3];
// 8022108: using guessed type int sub_8022108();
// 80222C8: using guessed type int sub_80222C8();

//----- (08022114) --------------------------------------------------------
void sub_8022114()
{
  __int16 v0; // r5
  int v1; // r7

  if ( v1 )
  {
    *(_WORD *)(*(unsigned __int16 *)(v1 + 60) + 0x2E) = v0;
    JUMPOUT(0x8021A2E);
  }
  JUMPOUT(0x802206A);
}
// 8021A2C: control flows out of bounds to 8021A2E
// 8022118: control flows out of bounds to 802206A
// 8022116: variable 'v1' is possibly undefined
// 8021A2C: variable 'v0' is possibly undefined

//----- (08022868) --------------------------------------------------------
int sub_8022868()
{
  sub_801E93C((int)sub_8022884);
  byte_20000508 = 0;
  return sub_800591C(0x900u, &byte_20000508, 1u);
}
// 20000508: using guessed type char byte_20000508;

//----- (08022884) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_8022884(int a1, int a2)
{
  BOOL v2; // r0
  BOOL v3; // r0
  BOOL v4; // r0
  BOOL v5; // r0
  BOOL v6; // r0
  BOOL v7; // r0
  int v8; // r9
  int v9; // [sp-14h] [bp-14h]
  int v10; // [sp-Ch] [bp-Ch]
  int v11; // [sp-4h] [bp-4h]

  sub_801E93C(v9, a2);
  v2 = sub_8012910(1207963648, 64);
  sub_801E93C((int)"11 LED_A  =  %d\r\n", v2);
  v3 = sub_8012910(v11, v8);
  sub_801E93C((int)"12 LED_B  =  %d\r\n", v3);
  v4 = sub_8012910(v10, 16);
  sub_801E93C((int)"13 LED_C  =  %d\r\n", v4);
  v5 = sub_8012910(1207963648, 4);
  sub_801E93C((int)"14 LED_D  =  %d\r\n", v5);
  v6 = sub_8012910(1207963648, 8);
  sub_801E93C((int)"15 LED_E  =  %d\r\n", v6);
  v7 = sub_8012910(1207963648, 16);
  sub_801E93C((int)"16 LED_F  =  %d\r\n", v7);
  sub_8012910(1207963648, 32);
  JUMPOUT(0x80223FC);
}
// 802238A: positive sp value 14 has been found
// 80223FA: control flows out of bounds to 80223FC
// 802238A: variable 'v9' is possibly undefined
// 80223A6: variable 'v11' is possibly undefined
// 80223A6: variable 'v8' is possibly undefined
// 80223B6: variable 'v10' is possibly undefined

//----- (08022898) --------------------------------------------------------
__int16 *sub_8022898()
{
  __int16 *result; // r0

  byte_20002F60 = 14;
  result = &word_20002F08;
  word_20002F08 = 0;
  word_20002F0A = 0;
  word_20002F0C = 0;
  return result;
}
// 20002F08: using guessed type __int16 word_20002F08;
// 20002F0A: using guessed type __int16 word_20002F0A;
// 20002F0C: using guessed type __int16 word_20002F0C;
// 20002F60: using guessed type char byte_20002F60;

//----- (080228B4) --------------------------------------------------------
void __fastcall sub_80228B4(int a1)
{
  if ( a1 == 2 )
  {
    sub_801E93C((int)sub_8022904);
  }
  else if ( a1 == 1 )
  {
    sub_801E93C((int)dword_8022918);
  }
  else
  {
    sub_801E93C((int)dword_80228F0);
  }
  sub_80031F8();
}
// 80228F0: using guessed type int dword_80228F0[5];
// 8022904: using guessed type int sub_8022904();
// 8022918: using guessed type int dword_8022918[5];

//----- (08022970) --------------------------------------------------------
void sub_8022970()
{
  float v0; // s0

  sub_801E93C((int)dword_80229A0, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
  sub_8003284();
}
// 802297E: variable 'v0' is possibly undefined
// 80229A0: using guessed type int dword_80229A0[8];

//----- (080229C0) --------------------------------------------------------
void sub_80229C0()
{
  float v0; // s0

  sub_801E93C((int)dword_80229F0, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
  sub_800328E();
}
// 80229CE: variable 'v0' is possibly undefined
// 80229F0: using guessed type int dword_80229F0[4];

//----- (08022A78) --------------------------------------------------------
int __fastcall sub_8022A78(int a1)
{
  if ( a1 == 1 )
  {
    sub_801E93C((int)sub_8022AC8);
    return sub_8005398(0);
  }
  else
  {
    sub_801E93C((int)&unk_8022AA0);
    return sub_8005398(2);
  }
}
// 8022AC8: using guessed type int sub_8022AC8();

//----- (08022AE0) --------------------------------------------------------
#error "8022AF6: call analysis failed (funcsize=14)"

//----- (08022B14) --------------------------------------------------------
int __fastcall sub_8022B14(int result)
{
  dword_200004E0 = 3600;
  return sub_801AF98(result);
}
// 200004E0: using guessed type int dword_200004E0;

//----- (08022B24) --------------------------------------------------------
int __fastcall sub_8022B24(int a1)
{
  if ( a1 == 1 )
  {
    sub_801E93C((int)sub_8022BD4);
    byte_20002F60 = 1;
  }
  else if ( a1 )
  {
    switch ( a1 )
    {
      case 4:
        sub_801E93C((int)"Ctl_mode_default");
        byte_20002F60 = 4;
        break;
      case 2:
        sub_801E93C((int)dword_8022C04);
        byte_20002F60 = 2;
        break;
      case 12:
        sub_801E93C((int)dword_8022C14);
        byte_20002F60 = 12;
        break;
      case 11:
        sub_801E93C((int)dword_8022C24);
        byte_20002F60 = 11;
        break;
      case 14:
        sub_801E93C((int)dword_8022C2C);
        byte_20002F60 = 14;
        break;
      case 15:
        sub_801E93C((int)sub_8022C38);
        byte_20002F60 = 15;
        break;
      default:
        sub_801E93C((int)&unk_8022BC4);
        byte_20002F60 = 3;
        break;
    }
  }
  else
  {
    sub_801E93C((int)"anti-feed");
    byte_20002F60 = 0;
  }
  return sub_800591C(0x301u, &byte_20002F60, 1u);
}
// 8022BD4: using guessed type int sub_8022BD4();
// 8022C04: using guessed type int dword_8022C04[4];
// 8022C14: using guessed type int dword_8022C14[4];
// 8022C24: using guessed type int dword_8022C24[2];
// 8022C2C: using guessed type int dword_8022C2C[3];
// 8022C38: using guessed type int sub_8022C38();
// 20002F60: using guessed type char byte_20002F60;

//----- (08022C78) --------------------------------------------------------
int sub_8022C78()
{
  float v0; // s0

  sub_8003234();
  return sub_801E93C((int)sub_8022C98, (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v0)), v0);
}
// 8022C82: variable 'v0' is possibly undefined

//----- (08022C98) --------------------------------------------------------
void sub_8022C98()
{
  JUMPOUT(0x8022178);
}
// 802281C: control flows out of bounds to 8022178

//----- (08022DF6) --------------------------------------------------------
void sub_8022DF6()
{
  JUMPOUT(0x8022A3C);
}
// 8022DF8: control flows out of bounds to 8022A3C

//----- (08022F4E) --------------------------------------------------------
void __fastcall sub_8022F4E(int a1)
{
  unsigned int v1; // r4
  __int16 v2; // r5

  *(_WORD *)(a1 + 44) = v2;
  STACK[0x3B4] = v1;
  JUMPOUT(0x80227D2);
}
// 8022EB8: control flows out of bounds to 80227D2
// 8022F4E: variable 'v2' is possibly undefined
// 8022F50: variable 'v1' is possibly undefined

//----- (08022FF8) --------------------------------------------------------
int __fastcall sub_8022FF8(char a1)
{
  byte_2000050C = a1;
  sub_800591C(0x92u, &byte_2000050C, 1u);
  return sub_801E93C((int)" %d\r\n", (unsigned __int8)byte_2000050C);
}
// 2000050C: using guessed type char byte_2000050C;

//----- (08023020) --------------------------------------------------------
int sub_8023020()
{
  int result; // r0

  byte_200004AD = 5;
  sub_80031E4();
  result = 1;
  byte_20000294 = 1;
  byte_20000031 = 1;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200004AD: using guessed type char byte_200004AD;

//----- (08023054) --------------------------------------------------------
char *sub_8023054()
{
  char *result; // r0

  byte_200110B4 = 1;
  sub_80031E4();
  byte_20000294 = 1;
  result = &byte_20000031;
  byte_20000031 = 1;
  return result;
}
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200110B4: using guessed type char byte_200110B4;

//----- (08023084) --------------------------------------------------------
int __fastcall sub_8023084(int a1)
{
  if ( a1 )
  {
    sub_801E93C((int)sub_80230AC);
    return sub_8007D00(1);
  }
  else
  {
    sub_801E93C((int)sub_80230AC);
    return sub_8007D00(0);
  }
}
// 80230AC: using guessed type int sub_80230AC();

//----- (080231BC) --------------------------------------------------------
unsigned int sub_80231BC()
{
  int v0; // r0
  int v1; // r0
  unsigned int result; // r0
  _DWORD v3[5]; // [sp+4h] [bp-5Ch] BYREF
  _DWORD v4[7]; // [sp+18h] [bp-48h] BYREF
  int v5; // [sp+34h] [bp-2Ch]
  int v6; // [sp+38h] [bp-28h]
  int v7; // [sp+3Ch] [bp-24h]
  int v8; // [sp+40h] [bp-20h]
  int v9; // [sp+44h] [bp-1Ch]
  int v10; // [sp+48h] [bp-18h]
  int v11; // [sp+4Ch] [bp-14h]

  sub_8002364(v4, 56);
  sub_8002364(v3, 20);
  sub_80139F8(0);
  sub_8013AC4();
  MEMORY[0x40021090] &= 0xFFFFFFE7;
  v4[0] = 1;
  v4[1] = 0x10000;
  v5 = 2;
  v6 = 3;
  v7 = 2;
  v8 = 85;
  v9 = 4;
  v10 = 8;
  v11 = 2;
  v0 = sub_8014074((unsigned __int8 *)v4);
  if ( v0 )
    sub_8005C1C(v0);
  v4[0] = 4;
  v5 = 0;
  v4[2] = 1;
  sub_8014074((unsigned __int8 *)v4);
  v3[0] = 15;
  v3[1] = 3;
  memset(&v3[2], 0, 12);
  v1 = sub_8013DE4((unsigned __int8 *)v3, 4u);
  if ( v1 )
    sub_8005C1C(v1);
  result = sub_801293C();
  if ( result == 4097 )
  {
    result = 1073881088;
    MEMORY[0x40022000] |= 0x100u;
  }
  return result;
}
// 8005C1C: using guessed type void __fastcall __noreturn sub_8005C1C(_DWORD);

//----- (0802325C) --------------------------------------------------------
void __noreturn sub_802325C()
{
  __dsb(0xFu);
  AIRCR = AIRCR & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}
// E000ED0C: using guessed type int AIRCR;

//----- (08023280) --------------------------------------------------------
int sub_8023280()
{
  float v0; // s0

  v0 = 0.0;
  if ( flt_20001C30 > 0.0 )
    v0 = flt_20001C30;
  if ( flt_20001C34 > v0 )
    v0 = flt_20001C34;
  if ( flt_20001C2C > v0 )
    v0 = flt_20001C2C;
  if ( dword_200004E0 )
  {
    return --dword_200004E0;
  }
  else if ( SLODWORD(v0) <= 1109393408 )
  {
    return sub_801AF98(400);
  }
  else
  {
    return sub_801AF98(300 - (int)(float)((float)(v0 - 40.0) * 30.0));
  }
}
// 200004E0: using guessed type int dword_200004E0;
// 20001C2C: using guessed type float flt_20001C2C;
// 20001C30: using guessed type float flt_20001C30;
// 20001C34: using guessed type float flt_20001C34;

//----- (08023310) --------------------------------------------------------
int sub_8023310()
{
  int v1; // [sp+4h] [bp-24h] BYREF
  int v2; // [sp+8h] [bp-20h]

  MEMORY[0x40021058] |= 4u;
  sub_8002364(&v1, 28);
  dword_20001AF8 = 1073743872;
  dword_20001AFC = 8499;
  dword_20001B00 = 0;
  dword_20001B04 = 65533;
  dword_20001B08 = 0;
  dword_20001B0C = 0;
  dword_20001B10 = 0;
  sub_8015140((int)&dword_20001AF8);
  v1 = 0;
  v2 = 0xFFFF;
  sub_8015090((_DWORD **)&dword_20001AF8, &v1, 0);
  v2 = 0xFFFF;
  sub_8015090((_DWORD **)&dword_20001AF8, &v1, 4);
  off_20000064 = (int (*)(void))(&loc_801B814 + 1);
  off_20000068 = (int (*)(void))(&loc_801B814 + 1);
  sub_8013970(30, 0xAu, 0);
  sub_8013954(30);
  return sub_8015190((unsigned __int8 *)&dword_20001AF8, 0);
}
// 20000064: using guessed type int (*off_20000064)(void);
// 20000068: using guessed type int (*off_20000068)(void);
// 20001AF8: using guessed type int dword_20001AF8;
// 20001AFC: using guessed type int dword_20001AFC;
// 20001B00: using guessed type int dword_20001B00;
// 20001B04: using guessed type int dword_20001B04;
// 20001B08: using guessed type int dword_20001B08;
// 20001B0C: using guessed type int dword_20001B0C;
// 20001B10: using guessed type int dword_20001B10;

//----- (080233A4) --------------------------------------------------------
int __fastcall sub_80233A4(int a1, int a2, int a3)
{
  int v6; // r5

  if ( a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4697);
  sub_80237E4();
  if ( !*(_DWORD *)(dword_20001658 + 4 * a1 + 84) )
  {
    *(_BYTE *)(dword_20001658 + a1 + 88) = 1;
    if ( a3 )
    {
      sub_801FF9C(a3, 1);
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_8023864();
  sub_80237E4();
  v6 = *(_DWORD *)(dword_20001658 + 4 * a1 + 84);
  if ( v6 )
  {
    if ( a2 )
      *(_DWORD *)(dword_20001658 + 4 * a1 + 84) = 0;
    else
      *(_DWORD *)(dword_20001658 + 4 * a1 + 84) = v6 - 1;
  }
  *(_BYTE *)(dword_20001658 + a1 + 88) = 0;
  sub_8023864();
  return v6;
}
// 20001658: using guessed type int dword_20001658;
// E000ED04: using guessed type int ICSR;

//----- (08023464) --------------------------------------------------------
int __fastcall sub_8023464(unsigned int a1, __int16 a2, unsigned int a3, int a4)
{
  unsigned int v6; // r0
  int v7; // r9
  int v8; // r6
  unsigned int v9; // r7
  int i; // r5
  int v11; // r1
  float v12; // s0
  int v13; // r0
  unsigned int v14; // r0
  int v15; // r1
  unsigned int v16; // r0
  _BYTE v18[80]; // [sp+0h] [bp-78h] BYREF
  float v19; // [sp+50h] [bp-28h] BYREF
  unsigned int v20; // [sp+54h] [bp-24h] BYREF

  v6 = ((*(_BYTE *)(a4 + 9) & 0xF) * (unsigned int)*(unsigned __int8 *)(a4 + 11)) >> 1;
  v7 = (unsigned __int16)(a2 - *(_WORD *)a4);
  v20 = 0;
  v19 = 0.0;
  v8 = 0;
  v9 = (unsigned __int16)(v6 - v7);
  if ( v9 > a3 )
    v9 = a3;
  for ( i = 0; *(unsigned __int8 *)(a4 + 11) > i; ++i )
  {
    v11 = *(unsigned __int8 *)(a4 + 8);
    if ( v11 == 36 )
    {
      v12 = *(float *)(*(_DWORD *)(a4 + 4) + 4 * i);
      v19 = v12;
      v13 = *(unsigned __int8 *)(a4 + 10);
      switch ( v13 )
      {
        case 1:
          v19 = v12 * 10.0;
          break;
        case 2:
          v19 = v12 * 100.0;
          break;
        case 3:
          v19 = v12 * 0.1;
          break;
        case 4:
          v19 = v12 * 0.01;
          break;
      }
      v14 = *(unsigned __int8 *)(a4 + 8);
      v15 = *(unsigned __int8 *)(a4 + 9);
      if ( v14 == v15 )
      {
        sub_8004FA2((int)&v18[v8], (int)&v19, v15 & 0xF);
        v8 = (unsigned __int8)((*(_BYTE *)(a4 + 9) & 0xF) + v8);
        continue;
      }
      if ( v14 >= 0x11 )
        v20 = (int)v19;
      else
        v20 = (unsigned int)v19;
    }
    else
    {
      if ( v11 == 17 )
      {
        v20 = *(char *)(*(_DWORD *)(a4 + 4) + i);
      }
      else if ( *(unsigned __int8 *)(a4 + 8) > 0x11u )
      {
        switch ( v11 )
        {
          case 18:
            v20 = *(__int16 *)(*(_DWORD *)(a4 + 4) + 2 * i);
            break;
          case 20:
            v20 = *(_DWORD *)(*(_DWORD *)(a4 + 4) + 4 * i);
            break;
          case 49:
            v16 = *(unsigned __int8 *)(*(_DWORD *)(a4 + 4) + i);
            v20 = v16;
            if ( v16 >= 0x61 )
              v20 = v16 - 32;
            break;
        }
      }
      else
      {
        switch ( v11 )
        {
          case 1:
            v20 = *(unsigned __int8 *)(*(_DWORD *)(a4 + 4) + i);
            break;
          case 2:
            v20 = *(unsigned __int16 *)(*(_DWORD *)(a4 + 4) + 2 * i);
            break;
          case 4:
            v20 = *(_DWORD *)(*(_DWORD *)(a4 + 4) + 4 * i);
            break;
        }
      }
      switch ( *(_BYTE *)(a4 + 10) )
      {
        case 1:
          v20 *= 10;
          break;
        case 2:
          v20 *= 100;
          break;
        case 3:
          v20 /= 0xAu;
          break;
        case 4:
          v20 /= 0x64u;
          break;
        case 5:
          v20 = -v20;
          break;
        default:
          break;
      }
    }
    sub_8004FA2((int)&v18[v8], (int)&v20, *(_BYTE *)(a4 + 9) & 0xF);
    v8 = (unsigned __int8)((*(_BYTE *)(a4 + 9) & 0xF) + v8);
  }
  qmemcpy(a1, (unsigned int)&v18[v7], 2 * v9);
  return (unsigned __int8)v9;
}

//----- (0802368C) --------------------------------------------------------
int sub_802368C()
{
  int result; // r0

  result = dword_2000002C;
  dword_20000498 = dword_2000002C;
  return result;
}
// 2000002C: using guessed type int dword_2000002C;
// 20000498: using guessed type int dword_20000498;

//----- (080236A0) --------------------------------------------------------
int __fastcall sub_80236A0(_DWORD *a1)
{
  _DWORD *v1; // r1

  v1 = (_DWORD *)a1[4];
  *(_DWORD *)(a1[1] + 8) = a1[2];
  *(_DWORD *)(a1[2] + 4) = a1[1];
  if ( (_DWORD *)v1[1] == a1 )
    v1[1] = a1[2];
  a1[4] = 0;
  return --*v1;
}

//----- (080236C8) --------------------------------------------------------
int sub_80236C8()
{
  return dword_20001660;
}
// 20001660: using guessed type int dword_20001660;

//----- (080236D4) --------------------------------------------------------
int __fastcall sub_80236D4(int a1, int a2, _DWORD *a3)
{
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r3
  int v8; // r4
  int v9; // r4
  int v10; // r4

  v5 = 0;
  v6 = 32;
  sub_8023EB4();
  if ( v7 >= dword_20001660 )
  {
    do
    {
      --v6;
      v5 += sub_8020438(a1 + 36 * v5, &dword_20011758[5 * v6], 1);
    }
    while ( v6 );
    v8 = v5 + sub_8020438(a1 + 36 * v5, (_DWORD *)dword_20001690, 2);
    v9 = v8 + sub_8020438(a1 + 36 * v8, (_DWORD *)dword_20001694, 2);
    v10 = v9 + sub_8020438(a1 + 36 * v9, dword_20011A14, 4);
    v5 = v10 + sub_8020438(a1 + 36 * v10, &dword_20011A28, 3);
    if ( a3 )
      *a3 = 0;
  }
  sub_8025F2C();
  return v5;
}
// 80236F0: variable 'v7' is possibly undefined
// 20001660: using guessed type int dword_20001660;
// 20001690: using guessed type int dword_20001690;
// 20001694: using guessed type int dword_20001694;
// 20011758: using guessed type int dword_20011758[160];
// 20011A14: using guessed type _DWORD dword_20011A14[3];
// 20011A28: using guessed type int dword_20011A28;

//----- (08023780) --------------------------------------------------------
_DWORD *__fastcall sub_8023780(_DWORD *result)
{
  result[1] = result + 2;
  result[2] = -1;
  result[3] = result + 2;
  result[4] = result + 2;
  *result = 0;
  return result;
}

//----- (08023796) --------------------------------------------------------
int __fastcall sub_8023796(int result)
{
  *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (0802379C) --------------------------------------------------------
_DWORD *__fastcall sub_802379C(_DWORD *result, _DWORD *a2)
{
  _DWORD *i; // r2
  int v3; // r3

  if ( *a2 == -1 )
  {
    i = (_DWORD *)result[4];
  }
  else
  {
    for ( i = result + 2; *(_DWORD *)i[1] <= *a2; i = (_DWORD *)i[1] )
      ;
  }
  v3 = i[1];
  a2[1] = v3;
  *(_DWORD *)(v3 + 8) = a2;
  a2[2] = i;
  i[1] = a2;
  a2[4] = result;
  ++*result;
  return result;
}

//----- (080237CC) --------------------------------------------------------
_DWORD *__fastcall sub_80237CC(_DWORD *result, _DWORD *a2)
{
  int v2; // r2

  v2 = result[1];
  a2[1] = v2;
  a2[2] = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4) = a2;
  *(_DWORD *)(v2 + 8) = a2;
  a2[4] = result;
  ++*result;
  return result;
}

//----- (080237E4) --------------------------------------------------------
int sub_80237E4()
{
  int result; // r0

  _R0 = 144;
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  result = ++dword_200016B8;
  if ( dword_200016B8 == 1 )
  {
    result = ICSR;
    if ( (_BYTE)ICSR )
      return sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 441);
  }
  return result;
}
// 200016B8: using guessed type int dword_200016B8;
// E000ED04: using guessed type int ICSR;

//----- (08023864) --------------------------------------------------------
int sub_8023864()
{
  int result; // r0

  if ( !dword_200016B8 )
    sub_801E93C((int)sub_80238C4, "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 448);
  result = dword_200016B8 - 1;
  dword_200016B8 = result;
  if ( !result )
    __asm { MSR.W           BASEPRI, R0 }
  return result;
}
// 200016B8: using guessed type int dword_200016B8;

//----- (080238C4) --------------------------------------------------------
int __fastcall sub_80238C4(int result)
{
  char v1; // r5
  int *v2; // r4

  *(_BYTE *)(result + 9) = v1;
  if ( result )
  {
    v2 = (int *)(result - 8);
    if ( *(int *)(result - 4) >= 0 )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 303);
    if ( *v2 )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\MemMang\\heap_4.c", 304);
    result = v2[1];
    if ( result < 0 && !*v2 )
    {
      v2[1] = result & 0x7FFFFFFF;
      sub_8023EB4();
      dword_2000169C += v2[1];
      sub_80203AC(v2);
      ++dword_200016A8;
      return sub_8025F2C();
    }
  }
  return result;
}
// 80238C4: could not find valid save-restore pair for r4
// 80238C4: variable 'v1' is possibly undefined
// 8025F2C: using guessed type int sub_8025F2C(void);
// 2000169C: using guessed type int dword_2000169C;
// 200016A8: using guessed type int dword_200016A8;

//----- (0802397C) --------------------------------------------------------
int sub_802397C()
{
  int result; // r0

  result = -536813568;
  SYST_CVR = 0;
  SYST_RVR = dword_20000290 / 0x3E8u - 1;
  SYST_CSR = 7;
  return result;
}
// 20000290: using guessed type int dword_20000290;
// E000E010: using guessed type int SYST_CSR;
// E000E014: using guessed type int SYST_RVR;
// E000E018: using guessed type int SYST_CVR;

//----- (080239A0) --------------------------------------------------------
unsigned int sub_80239A0()
{
  unsigned int v0; // r0
  unsigned int result; // r0

  v0 = sub_80022A4();
  if ( v0 >= 0x10 && *(unsigned __int8 *)(v0 - 536812560) < (unsigned int)(unsigned __int8)byte_200016B4 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 845);
  result = AIRCR & 0x700;
  if ( result > dword_200016BC )
    return sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 861);
  return result;
}
// 200016B4: using guessed type char byte_200016B4;
// 200016BC: using guessed type int dword_200016BC;
// E000ED0C: using guessed type int AIRCR;

//----- (08023A34) --------------------------------------------------------
int __fastcall sub_8023A34(int a1)
{
  int result; // r0

  result = 0;
  if ( a1 )
  {
    if ( dword_2000168C )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1308);
    sub_8023EB4();
    sub_801FF9C(a1, 0);
    result = sub_8025F2C();
  }
  if ( !result )
  {
    result = 0x10000000;
    ICSR = 0x10000000;
    __dsb(0xFu);
    __isb(0xFu);
  }
  return result;
}
// 2000168C: using guessed type int dword_2000168C;
// E000ED04: using guessed type int ICSR;

//----- (08023AAC) --------------------------------------------------------
int __fastcall sub_8023AAC(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  int result; // r0

  if ( a1 )
    v6 = a1;
  else
    v6 = dword_20001658;
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v6 + 52;
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(v6 + 44);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(v6 + 48);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(v6 + 76);
  *(_DWORD *)(a2 + 24) = 0;
  if ( a4 == 5 )
  {
    result = sub_801F484(v6);
    *(_BYTE *)(a2 + 12) = result;
  }
  else
  {
    result = dword_20001658;
    if ( v6 == dword_20001658 )
    {
      *(_BYTE *)(a2 + 12) = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 12) = a4;
      if ( a4 == 3 )
      {
        sub_8023EB4();
        if ( *(_DWORD *)(v6 + 40) )
          *(_BYTE *)(a2 + 12) = 2;
        result = sub_8025F2C();
      }
    }
  }
  if ( a3 )
  {
    result = sub_8020560(*(unsigned __int8 **)(v6 + 48));
    *(_WORD *)(a2 + 32) = result;
  }
  else
  {
    *(_WORD *)(a2 + 32) = 0;
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;

//----- (08023B20) --------------------------------------------------------
_DWORD *__fastcall sub_8023B20(_DWORD *result)
{
  *result = dword_20001678;
  result[1] = dword_20001664;
  return result;
}
// 20001664: using guessed type int dword_20001664;
// 20001678: using guessed type int dword_20001678;

//----- (08023B30) --------------------------------------------------------
int __fastcall sub_8023B30(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r8
  int v2; // r4
  int result; // r0
  int v4; // r7
  unsigned int v5; // r9
  unsigned int i; // r6
  unsigned int v7; // r5
  int v8; // r4
  unsigned __int8 *v9; // r8

  v1 = a1;
  *a1 = 0;
  v2 = dword_20001660;
  result = ((int (__fastcall *)(int))loc_8020680)(36 * dword_20001660);
  v4 = result;
  if ( result )
  {
    v5 = sub_80236D4(result, v2, 0);
    for ( i = 0; i < v5; ++i )
    {
      v7 = v4 + 36 * i;
      switch ( *(_BYTE *)(v7 + 12) )
      {
        case 0:
          v8 = 88;
          break;
        case 1:
          v8 = 82;
          break;
        case 2:
          v8 = 66;
          break;
        case 3:
          v8 = 83;
          break;
        case 4:
          v8 = 68;
          break;
        default:
          v8 = 0;
          break;
      }
      v9 = sub_802065C(v1, *(unsigned __int8 **)(v7 + 4));
      sprintf(
        (int)v9,
        "\t%c\t%u\t%u\t%u\r\n",
        v8,
        *(_DWORD *)(v7 + 16),
        *(unsigned __int16 *)(v7 + 32),
        *(_DWORD *)(v7 + 8));
      v1 = &sub_80023E2(v9)[(_DWORD)v9];
    }
    JUMPOUT(0x80238D4);
  }
  return result;
}
// 8023BC0: control flows out of bounds to 80238D4
// 20001660: using guessed type int dword_20001660;

//----- (08023BDC) --------------------------------------------------------
int sub_8023BDC()
{
  int result; // r0

  result = 1;
  dword_20001674 = 1;
  return result;
}
// 20001674: using guessed type int dword_20001674;

//----- (08023BE8) --------------------------------------------------------
_DWORD *__fastcall sub_8023BE8(_DWORD *a1, int a2)
{
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3086);
  sub_802379C(a1, (_DWORD *)(dword_20001658 + 24));
  return sub_801FF9C(a2, 1);
}
// 20001658: using guessed type int dword_20001658;

//----- (08023C48) --------------------------------------------------------
int __fastcall sub_8023C48(int result, unsigned int a2)
{
  _DWORD *v3; // r4
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r0
  int v7; // r0

  v3 = (_DWORD *)result;
  if ( result )
  {
    if ( !*(_DWORD *)(result + 80) )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4248);
    v4 = v3[19];
    if ( v4 < a2 )
      v4 = a2;
    result = v3[11];
    if ( result != v4 )
    {
      result = v3[20];
      if ( result == 1 )
      {
        if ( v3 == (_DWORD *)dword_20001658 )
          sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4275);
        v5 = v3[11];
        v3[11] = v4;
        if ( (int)v3[6] >= 0 )
          v3[6] = 32 - v4;
        result = (int)&dword_20011758[5 * v5];
        if ( v3[5] == result )
        {
          if ( !sub_80236A0(v3 + 1) )
            dword_20001668 &= ~(1 << *((_BYTE *)v3 + 44));
          v6 = v3[11];
          dword_20001668 |= 1 << v6;
          v7 = dword_20011758[5 * v6 + 1];
          v3[2] = v7;
          v3[3] = *(_DWORD *)(v7 + 8);
          *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4) = v3 + 1;
          *(_DWORD *)(v7 + 8) = v3 + 1;
          v3[5] = &dword_20011758[5 * v3[11]];
          result = 5 * v3[11];
          ++dword_20011758[5 * v3[11]];
        }
      }
    }
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001668: using guessed type int dword_20001668;
// 20011758: using guessed type int dword_20011758[160];

//----- (08023D38) --------------------------------------------------------
int sub_8023D38()
{
  int v0; // r0

  v0 = sub_8025904(134351393, (int)"IDLE", 128, 0, 0, &dword_20001684);
  if ( v0 == 1 )
  {
    _R0 = 144;
    __asm { MSR.W           BASEPRI, R0 }
    __dsb(0xFu);
    __isb(0xFu);
    dword_20001680 = -1;
    dword_2000166C = 1;
    dword_20001664 = 0;
    sub_8024EAC();
  }
  else if ( v0 == -1 )
  {
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2066);
  }
  return dword_20001688;
}
// 20001664: using guessed type int dword_20001664;
// 2000166C: using guessed type int dword_2000166C;
// 20001680: using guessed type int dword_20001680;
// 20001684: using guessed type _DWORD dword_20001684;
// 20001688: using guessed type int dword_20001688;

//----- (08023DC8) --------------------------------------------------------
int __fastcall sub_8023DC8(_DWORD *a1)
{
  int v2; // r0
  int i; // r0
  int result; // r0

  sub_80237E4();
  if ( !a1 )
    a1 = (_DWORD *)dword_20001658;
  if ( !sub_80236A0(a1 + 1) )
  {
    v2 = a1[11];
    if ( !dword_20011758[5 * v2] )
      dword_20001668 &= ~(1 << v2);
  }
  if ( a1[10] )
    sub_80236A0(a1 + 6);
  sub_80237CC(&dword_20011A28, a1 + 1);
  for ( i = 0; i < 1; ++i )
  {
    if ( *((_BYTE *)a1 + i + 88) == 1 )
      *((_BYTE *)a1 + i + 88) = 0;
  }
  sub_8023864();
  if ( dword_2000166C )
  {
    sub_80237E4();
    sub_8020540();
    sub_8023864();
  }
  result = dword_20001658;
  if ( a1 == (_DWORD *)dword_20001658 )
  {
    if ( dword_2000166C )
    {
      if ( dword_2000168C )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 1746);
      result = 0x10000000;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
    else
    {
      result = dword_20011A28;
      if ( dword_20011A28 == dword_20001660 )
        dword_20001658 = 0;
      else
        return sub_8023EC4();
    }
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001660: using guessed type int dword_20001660;
// 20001668: using guessed type int dword_20001668;
// 2000166C: using guessed type int dword_2000166C;
// 2000168C: using guessed type int dword_2000168C;
// 20011758: using guessed type int dword_20011758[160];
// 20011A28: using guessed type int dword_20011A28;
// E000ED04: using guessed type int ICSR;

//----- (08023EB4) --------------------------------------------------------
int *sub_8023EB4()
{
  int *result; // r0

  result = &dword_20001658;
  ++dword_2000168C;
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 2000168C: using guessed type int dword_2000168C;

//----- (08023EC4) --------------------------------------------------------
int sub_8023EC4()
{
  int result; // r0
  unsigned int v1; // r0
  int v2; // r4
  int *v3; // r0
  int *v4; // r1

  if ( dword_2000168C )
  {
    result = 1;
    dword_20001674 = 1;
  }
  else
  {
    dword_20001674 = 0;
    v1 = __clz(dword_20001668);
    v2 = 5 * (31 - v1);
    if ( !dword_20011758[5 * (31 - v1)] )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3062);
    v3 = &dword_20011758[v2];
    v4 = *(int **)(v3[1] + 4);
    v3[1] = (int)v4;
    if ( v4 == v3 + 2 )
      v3[1] = v4[1];
    result = *(_DWORD *)(v3[1] + 12);
    dword_20001658 = result;
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001668: using guessed type int dword_20001668;
// 20001674: using guessed type int dword_20001674;
// 2000168C: using guessed type int dword_2000168C;
// 20011758: using guessed type int dword_20011758[160];

//----- (0802407C) --------------------------------------------------------
int __fastcall sub_802407C(_BYTE *a1, int a2, int a3, unsigned int a4)
{
  int v8; // r2
  char v9; // r8
  unsigned int v10; // r2
  bool v11; // zf
  bool v12; // cc
  int v13; // r0
  bool v14; // zf
  bool v15; // cc
  int v16; // r9
  int v17; // r1
  int v18; // r0
  bool v19; // zf
  bool v20; // cc
  int result; // r0
  int v22; // r9
  char *v23; // r0
  unsigned int v24; // r0
  unsigned int v25; // r0
  char *v26; // r2
  unsigned int v27; // r1
  unsigned int v28; // r0
  unsigned int v29; // r0
  char *v30; // r2
  unsigned int v31; // r1
  unsigned int v32; // r0
  unsigned int v33; // r0
  unsigned int v34; // r0
  char *v35; // r0
  unsigned int v36; // r1
  unsigned int v37; // r2
  unsigned int v38; // r2
  unsigned int v39; // [sp+0h] [bp-38h] BYREF
  int v40; // [sp+4h] [bp-34h] BYREF
  unsigned int v41; // [sp+8h] [bp-30h]

  v40 = 0;
  v41 = a4 >> 8;
  v8 = a2 - 43000;
  v9 = a4;
  if ( a2 != 43000 )
  {
    if ( a2 <= 43000 )
    {
      v10 = a2 - 41607;
      v11 = a2 == 41607;
      v12 = a2 <= 41607;
      while ( 2 )
      {
        if ( !v11 )
        {
          if ( v12 )
          {
            v10 = 41509;
            v13 = a2 - 41509;
            v14 = a2 == 41509;
            v15 = a2 <= 41509;
            while ( 1 )
            {
              if ( v14 )
                goto LABEL_128;
              if ( !v15 )
                break;
              v10 = 41501;
              v13 = a2 - 41501;
              v14 = a2 == 41501;
              v15 = a2 <= 41501;
              if ( a2 != 41501 )
              {
                if ( a2 > 41501 )
                {
                  switch ( a2 )
                  {
                    case 41502:
                    case 41503:
                    case 41504:
                    case 41505:
                    case 41506:
                    case 41507:
                    case 41508:
                      goto LABEL_128;
                    default:
                      return 2;
                  }
                }
                if ( a2 == 41010 )
                {
                  if ( a3 )
                  {
                    if ( a4 == 800 )
                    {
                      byte_2000050B = 1;
                      word_2000051A = 800;
                      sub_800591C(0x204u, &word_2000051A, 2u);
                      sub_800591C(0x90u, &byte_2000050B, 1u);
                      return 0;
                    }
                    else if ( a4 == 2500 )
                    {
                      byte_2000050B = 0;
                      word_2000051A = 2500;
                      sub_800591C(0x204u, &word_2000051A, 2u);
                      sub_800591C(0x90u, &byte_2000050B, 1u);
                      return 0;
                    }
                    else
                    {
                      return 3;
                    }
                  }
                  else
                  {
                    *a1 = 0;
                    a1[1] = byte_2000050B;
                    return 0;
                  }
                }
                if ( a2 > 41010 )
                {
                  if ( a2 == 41100 )
                  {
                    if ( a3 )
                    {
                      if ( a4 )
                      {
                        byte_20000512 = a4;
                        sub_800591C(0x101u, &byte_20000512, 1u);
                        return 0;
                      }
                      else
                      {
                        return 3;
                      }
                    }
                    else
                    {
                      *a1 = 0;
                      a1[1] = byte_20000512;
                      return 0;
                    }
                  }
                  if ( a2 != 41200 )
                  {
                    if ( a2 != 41500 )
                      return 2;
LABEL_128:
                    v22 = a2 - 41500;
                    if ( a3 )
                    {
                      byte_20002FDB[2 * v22] = v41;
                      byte_20002FDB[2 * v22 + 1] = a4;
                    }
                    else
                    {
                      *a1 = byte_20002FDB[2 * v22];
                      a1[1] = byte_20002FDB[2 * v22 + 1];
                    }
                    return 0;
                  }
                  if ( a3 )
                  {
                    if ( a4 < 2 )
                    {
                      sub_80031EE();
                      return 0;
                    }
                    else
                    {
                      return 3;
                    }
                  }
                  else
                  {
                    *a1 = 0;
                    a1[1] = byte_20002F5F[0] != 1;
                    return 0;
                  }
                }
                else
                {
                  switch ( a2 )
                  {
                    case 40000:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          byte_20002F60 = 14;
                          word_20002F08 = 0;
                          word_20002F0A = 0;
                          word_20002F0C = 0;
                          return 0;
                        }
                        else if ( a4 - 21921 > 5 )
                        {
                          return 3;
                        }
                        else
                        {
                          byte_20002F60 = 14;
                          word_20002F08 = a4 - 21920;
                          word_20002F0A = 0;
                          word_20002F0C = 0;
                          return 0;
                        }
                      }
                      else
                      {
                        return 2;
                      }
                    case 41000:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          byte_20000528 = 1;
                          return 0;
                        }
                        else
                        {
                          return 3;
                        }
                      }
                      else
                      {
                        *a1 = 0;
                        a1[1] = byte_20000528;
                        return 0;
                      }
                    case 41001:
                      if ( a3 )
                      {
                        if ( a4 == 21930 )
                        {
                          sub_80053F8(3);
                          byte_20000528 = 1;
                          return 0;
                        }
                        else
                        {
                          return 3;
                        }
                      }
                      else
                      {
                        *a1 = 0;
                        a1[1] = byte_20000528;
                        return 0;
                      }
                    default:
                      return 2;
                  }
                }
              }
            }
            v11 = v13 == 91;
            v12 = v13 <= 91;
            if ( v13 == 91 )
              continue;
            if ( v13 <= 91 )
            {
              switch ( v13 )
              {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                  goto LABEL_128;
                default:
                  return 2;
              }
            }
            if ( (unsigned int)(v13 - 92) > 5 )
              return 2;
          }
          else if ( v10 != 16 )
          {
            if ( v10 < 0x10 )
            {
              switch ( v10 )
              {
                case 0u:
                  return 2;
                case 1u:
                case 2u:
                case 3u:
                case 4u:
                case 5u:
                case 6u:
                case 7u:
                case 8u:
                case 9u:
                case 0xAu:
                case 0xBu:
                case 0xCu:
                case 0xDu:
                case 0xEu:
                case 0xFu:
                  goto LABEL_132;
                default:
                  if ( v10 - 17 <= 6 )
                    goto LABEL_132;
                  return 2;
              }
            }
            return 2;
          }
        }
        break;
      }
LABEL_132:
      if ( a3 )
      {
        v23 = &byte_20002FDB[2 * a2 - 83200];
        v23[32] = v41;
        v40 = (unsigned __int8)a4;
        v23[33] = a4;
        if ( !(_BYTE)a4 )
        {
          byte_2000435F = 1;
          byte_20000931 = 0;
          byte_20000930 = 0;
          byte_200037D4[0] = 2;
          byte_200037D6 = 0;
        }
        return 0;
      }
      else
      {
        result = 0;
        *a1 = 0;
        a1[1] = 0;
      }
      return result;
    }
    if ( a2 == 44000 )
    {
      if ( a3 )
      {
        if ( a4 - 800 > 0xC8 )
        {
          return 3;
        }
        else
        {
          byte_20000516 = a4 / 0xA;
          sub_800591C(0x201u, &byte_20000516, 1u);
          return 0;
        }
      }
      else
      {
        v40 = 10 * (unsigned __int8)byte_20000516;
        sub_8004FA2((int)a1, (int)&v40, 2u);
        return 0;
      }
    }
    if ( v8 <= 1000 )
    {
      v16 = a2 - 43100;
      switch ( a2 )
      {
        case 43100:
        case 43105:
        case 43110:
        case 43115:
        case 43120:
        case 43125:
          v24 = (unsigned __int8)(v16 / 5);
          if ( v24 <= 5 )
          {
            if ( a3 )
            {
              *(_WORD *)&byte_20002F5F[10 * v24 + 2] = (unsigned __int8)a4;
            }
            else
            {
              v40 = (unsigned __int8)byte_20002F5F[10 * v24 + 2];
              sub_8004FA2((int)a1, (int)&v40, 2u);
            }
            result = 0;
          }
          else
          {
            result = 3;
          }
          break;
        case 43101:
        case 43106:
        case 43111:
        case 43116:
        case 43121:
        case 43126:
          v25 = (unsigned __int8)(v16 / 5);
          if ( v25 <= 5 )
          {
            if ( a3 )
            {
              v26 = &byte_20002F5F[10 * v25];
              v26[3] = 0;
              v27 = a4 % 0x64;
              if ( a4 / 0x64 >= 0x18 || v27 >= 0x3C )
              {
                result = 3;
              }
              else
              {
                *((_WORD *)v26 + 3) = v27 | ((unsigned __int16)(a4 / 0x64) << 8);
                result = 0;
              }
            }
            else
            {
              v28 = *(unsigned __int16 *)&byte_20002F5F[10 * v25 + 6];
              v40 = (unsigned __int8)v28 + 100 * (v28 >> 8);
              sub_8004FA2((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43102:
        case 43107:
        case 43112:
        case 43117:
        case 43122:
        case 43127:
          v29 = (unsigned __int8)(v16 / 5);
          if ( v29 <= 5 )
          {
            if ( a3 )
            {
              v30 = &byte_20002F5F[10 * v29];
              v30[3] = 0;
              v31 = a4 % 0x64;
              if ( a4 / 0x64 >= 0x18 || v31 >= 0x3C )
              {
                result = 3;
              }
              else
              {
                *((_WORD *)v30 + 4) = v31 | ((unsigned __int16)(a4 / 0x64) << 8);
                result = 0;
              }
            }
            else
            {
              v32 = *(unsigned __int16 *)&byte_20002F5F[10 * v29 + 8];
              v40 = (unsigned __int8)v32 + 100 * (v32 >> 8);
              sub_8004FA2((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43103:
        case 43108:
        case 43113:
        case 43118:
        case 43123:
        case 43128:
          v33 = (unsigned __int8)(v16 / 5);
          if ( v33 <= 5 )
          {
            if ( a3 )
            {
              if ( (unsigned int)((__int16)a4 + 2500) < 0x1389 )
              {
                *(_WORD *)&byte_20002F5F[10 * v33 + 4] = a4;
                result = 0;
              }
              else
              {
                result = 3;
              }
            }
            else
            {
              v40 = *(unsigned __int16 *)&byte_20002F5F[10 * v33 + 4];
              sub_8004FA2((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        case 43104:
        case 43109:
        case 43114:
        case 43119:
        case 43124:
        case 43129:
          v34 = (unsigned __int8)(v16 / 5);
          if ( v34 <= 5 )
          {
            if ( a3 )
            {
              if ( a4 == 1 )
              {
                byte_20002F5F[10 * v34 + 3] = 1;
                result = 0;
              }
              else if ( a4 )
              {
                result = 3;
              }
              else
              {
                byte_20002F5F[10 * v34 + 3] = 0;
                result = 0;
              }
            }
            else
            {
              v40 = (unsigned __int8)byte_20002F5F[10 * v34 + 3];
              sub_8004FA2((int)a1, (int)&v40, 2u);
              result = 0;
            }
          }
          else
          {
            result = 3;
          }
          break;
        default:
          return 2;
      }
      return result;
    }
    v17 = a2 - 45100;
    if ( a2 == 45100 )
    {
      if ( !a3 || byte_20002F60 != 13 && byte_20002F60 != 4 )
        return 1;
      if ( a4 << 31 )
        sub_801292E(1207963648, 64, 1);
      else
        sub_801292E(1207963648, 64, 0);
      if ( (a4 & 2) != 0 )
        sub_801292E(1207961600, 2048, 1);
      else
        sub_801292E(1207961600, 2048, 0);
      if ( (a4 & 4) != 0 )
        sub_801292E(1207959552, 16, 1);
      else
        sub_801292E(1207959552, 16, 0);
      if ( (a4 & 8) != 0 )
        sub_801292E(1207963648, 4, 1);
      else
        sub_801292E(1207963648, 4, 0);
      if ( (a4 & 0x10) != 0 )
        sub_801292E(1207963648, 8, 1);
      else
        sub_801292E(1207963648, 8, 0);
      if ( (a4 & 0x20) != 0 )
        sub_801292E(1207963648, 16, 1);
      else
        sub_801292E(1207963648, 16, 0);
      if ( (a4 & 0x40) != 0 )
        sub_801292E(1207963648, 32, 1);
      else
        sub_801292E(1207963648, 32, 0);
      sub_801AFB8(0x2710u);
      if ( (a4 & 0x100) != 0 )
        sub_801AFD0(0x2710u);
      else
        sub_801AFD0(0);
      if ( (a4 & 0x200) != 0 )
        sub_801292E(1207959552, 32, 1);
      else
        sub_801292E(1207959552, 32, 0);
      return 0;
    }
    if ( v8 <= 2100 )
    {
      v18 = a2 - 45012;
      v19 = v8 == 2012;
      v20 = v8 <= 2012;
      while ( 1 )
      {
        if ( v19 )
          goto LABEL_232;
        if ( !v20 )
        {
          switch ( v18 )
          {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              goto LABEL_232;
            default:
              return 2;
          }
        }
        if ( a2 == 44100 )
        {
          if ( a3 )
          {
            if ( a4 > 9 )
            {
              return 3;
            }
            else
            {
              byte_2000051C = a4;
              sub_800591C(0x206u, &byte_2000051C, 1u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int8)byte_2000051C;
            sub_8004FA2((int)a1, (int)&v40, 2u);
            return 0;
          }
        }
        if ( v8 <= 1100 )
          break;
        if ( v8 == 2000 )
        {
          if ( a3 )
          {
            if ( a4 == 21998 )
            {
              sub_80032A2();
              sub_801F3C4();
              sub_801F76C();
              byte_20000513 = 0;
              byte_20002F5F[0] = 0;
              byte_20002F60 = 13;
              return 0;
            }
            if ( a4 != 22015 )
            {
              if ( a4 != 21981 )
                return 3;
              sub_80032A2();
              sub_801F3C4();
              sub_801F76C();
              sub_80057C4(0x102u, (int)&byte_20000513, 1);
              sub_80057C4(0x300u, (int)byte_20002F5F, 1);
              sub_80057C4(0x301u, (int)&byte_20002F60, 1);
              return 0;
            }
            sub_80032A2();
            sub_801F3C4();
            sub_801F76C();
            byte_2000050B = 0;
            word_2000051A = 2500;
            dword_200002DC = 0;
            byte_20000513 = 0;
            byte_20002F5F[0] = 0;
            byte_20002F60 = 4;
            sub_8003234();
          }
          goto LABEL_232;
        }
        v18 = v8 - 2010;
        v19 = v8 == 2010;
        v20 = v8 - 1868 <= 142;
        if ( v8 != 2010 )
        {
          if ( v8 != 2011 )
            return 2;
LABEL_232:
          if ( !a3 || byte_20002F60 != 13 && byte_20002F60 != 4 )
            return 1;
          v35 = (char *)&unk_20002F30 + 2 * a2 - 90020;
          v35[20] = v41;
          v35[21] = v9;
          if ( a2 == 45019 )
            sub_800591C(0x21u, byte_20002F44, 0x14u);
          return 0;
        }
      }
      switch ( a2 )
      {
        case 44001:
          if ( a3 )
          {
            if ( a4 - 120 > 0xB4 )
            {
              return 3;
            }
            else
            {
              byte_20000517 = a4 / 0xA;
              sub_800591C(0x201u, &byte_20000517, 1u);
              return 0;
            }
          }
          else
          {
            v40 = 10 * (unsigned __int8)byte_20000517;
            sub_8004FA2((int)a1, (int)&v40, 2u);
            return 0;
          }
        case 44002:
          if ( a3 )
          {
            if ( a4 > 0x9C4 )
            {
              return 3;
            }
            else
            {
              word_20000518 = a4;
              sub_800591C(0x202u, &word_20000518, 2u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int16)word_20000518;
            sub_8004FA2((int)a1, (int)&v40, 2u);
            return 0;
          }
        case 44003:
          if ( a3 )
          {
            if ( a4 > 0x9C4 )
            {
              return 3;
            }
            else if ( byte_2000050B == 1 && a4 > 0x320 )
            {
              return 3;
            }
            else
            {
              word_2000051A = a4;
              sub_800591C(0x204u, &word_2000051A, 2u);
              return 0;
            }
          }
          else
          {
            v40 = (unsigned __int16)word_2000051A;
            sub_8004FA2((int)a1, (int)&v40, 2u);
            return 0;
          }
        default:
          return 2;
      }
    }
    if ( v8 == 2502 )
    {
      if ( !a3 )
        return 1;
      if ( byte_20002F60 == 13 )
      {
        if ( !a4 )
          goto LABEL_301;
        if ( a4 != 1 )
          return 3;
        goto LABEL_339;
      }
      if ( byte_20002F60 != 4 )
        return 1;
      if ( a4 >= 2 )
        return 3;
    }
    else
    {
      if ( v17 > 402 )
      {
        if ( v8 != 2604 )
        {
          if ( v17 > 504 )
          {
            if ( v8 == 3000 )
            {
              if ( !a3 )
                return 1;
              if ( a4 == 20736 )
              {
                byte_20000508 = 1;
                sub_800591C(0x900u, &byte_20000508, 1u);
                return 0;
              }
              if ( a4 != 1234 )
                return 1;
              byte_20000508 = 1;
              byte_200004AD = 5;
              sub_80031E4();
              byte_20000294 = 1;
              byte_20000031 = 1;
            }
            else if ( v8 != 4000 )
            {
              return 2;
            }
            if ( !a3 )
              return 1;
            if ( a4 != 1 )
              return 1;
            v39 = 1;
            sub_800591C(0x480u, &v39, 1u);
            byte_20000528 = 1;
            return 0;
          }
          if ( v8 == 2600 )
          {
            if ( !a3 )
              return 1;
            if ( byte_20002F60 != 4 )
              return 1;
            goto LABEL_342;
          }
          if ( v8 == 2601 )
          {
            if ( !a3 )
              return 1;
            if ( byte_20002F60 != 4 )
              return 1;
            goto LABEL_342;
          }
          if ( v8 != 2603 )
            return 2;
        }
        if ( a3 )
          return 1;
        if ( a2 == 45603 )
          sub_80057C4(0x950u, (int)&v39, 2);
        else
          sub_80057C4(0x952u, (int)&v39, 2);
        if ( (unsigned __int16)v39 < 0xFFFEu )
        {
          v36 = (unsigned __int16)v39 / 0xAu;
          v37 = (unsigned __int16)v39 % 0xAu + (unsigned __int16)v40 + 16 * (v36 % 0xA);
          v36 /= 0xAu;
          v38 = v37 + ((v36 % 0xA) << 8);
          v36 /= 0xAu;
          v40 = v38 + ((v36 % 0xA) << 12);
          v39 = v36 / 0xA;
        }
        sub_8004FA2((int)a1, (int)&v40, 2u);
        return 0;
      }
      if ( a2 == 45401 )
      {
        if ( !a3 || byte_20002F60 != 13 )
          return 1;
        if ( !a4 )
          goto LABEL_301;
LABEL_289:
        sub_80032AC();
        goto LABEL_301;
      }
      if ( v17 <= 301 )
      {
        switch ( a2 )
        {
          case 45200:
            if ( !a3 || byte_20002F60 != 13 && byte_20002F60 != 4 )
              return 1;
            sub_801F420();
            return 0;
          case 45300:
            if ( !a3 || byte_20002F60 != 13 && byte_20002F60 != 4 )
              return 1;
            dword_200004E0 = 100;
            if ( a4 )
              sub_801AF98(200);
            else
              sub_801AF98(0);
            return 0;
          case 45400:
            if ( !a3 || byte_20002F60 != 13 )
              return 1;
            if ( !a4 )
              goto LABEL_301;
            goto LABEL_289;
        }
        return 2;
      }
      if ( a2 == 45402 )
      {
        if ( !a3 || byte_20002F60 != 13 )
          return 1;
        if ( a4 )
        {
          sub_80032AC();
          word_20000522 = 0;
        }
        goto LABEL_301;
      }
      if ( a2 != 45500 )
      {
        if ( a2 != 45501 )
          return 2;
        if ( !a3 )
          return 1;
        if ( byte_20002F60 != 13 )
        {
          if ( byte_20002F60 != 4 )
            return 1;
          if ( a4 )
          {
            if ( a4 == 1 )
            {
              byte_20002F5F[0] = 1;
              return 0;
            }
            else
            {
              return 3;
            }
          }
          else
          {
            sub_8003234();
            result = 0;
            byte_20002F5F[0] = 0;
          }
          return result;
        }
        if ( !a4 )
        {
LABEL_301:
          sub_80032A2();
          return 0;
        }
        if ( a4 != 1 )
          return 3;
LABEL_339:
        sub_80032A2();
        sub_8011D58(1u);
        sub_80032AC();
        sub_80032A2();
        return 0;
      }
      if ( !a3 )
        return 1;
      if ( byte_20002F60 == 13 )
      {
        if ( !a4 )
          goto LABEL_301;
        if ( a4 != 1 )
          return 3;
        goto LABEL_339;
      }
      if ( byte_20002F60 != 4 )
        return 1;
      if ( a4 >= 2 )
        return 3;
    }
LABEL_342:
    sub_8003234();
    return 0;
  }
  if ( a3 )
  {
    if ( a4 )
    {
      if ( a4 == 1 )
      {
        byte_20002F60 = 0;
      }
      else
      {
        if ( a4 != 2 )
          return 3;
        byte_20002F60 = 5;
      }
    }
    else
    {
      byte_20002F60 = 1;
    }
    sub_800591C(0x301u, &byte_20002F60, 1u);
    return 0;
  }
  else
  {
    if ( byte_20002F60 != 1 )
    {
      if ( byte_20002F60 == 2 )
        v40 = 2;
      else
        v40 = 1;
    }
    sub_8004FA2((int)a1, (int)&v40, 2u);
    return 0;
  }
}
// 8024170: conditional instruction was optimized away because r2.4<10u
// 8024172: conditional instruction was optimized away because r2.4<10u
// 20000031: using guessed type char byte_20000031;
// 20000294: using guessed type char byte_20000294;
// 200002DC: using guessed type int dword_200002DC;
// 200004AD: using guessed type char byte_200004AD;
// 200004E0: using guessed type int dword_200004E0;
// 20000508: using guessed type char byte_20000508;
// 2000050B: using guessed type char byte_2000050B;
// 2000050D: using guessed type __int16 word_2000050D;
// 2000050F: using guessed type __int16 word_2000050F;
// 20000512: using guessed type char byte_20000512;
// 20000513: using guessed type char byte_20000513;
// 20000516: using guessed type char byte_20000516;
// 20000517: using guessed type char byte_20000517;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 2000051C: using guessed type char byte_2000051C;
// 20000522: using guessed type __int16 word_20000522;
// 20000528: using guessed type char byte_20000528;
// 20000529: using guessed type char byte_20000529;
// 2000052A: using guessed type char byte_2000052A;
// 20000930: using guessed type char byte_20000930;
// 20000931: using guessed type char byte_20000931;
// 20002F08: using guessed type __int16 word_20002F08;
// 20002F0A: using guessed type __int16 word_20002F0A;
// 20002F0C: using guessed type __int16 word_20002F0C;
// 20002F44: using guessed type _BYTE[20];
// 20002F60: using guessed type char byte_20002F60;
// 200037D6: using guessed type char byte_200037D6;
// 2000435F: using guessed type char byte_2000435F;

//----- (08024EAC) --------------------------------------------------------
int sub_8024EAC()
{
  void *v0; // r2
  void *v1; // r3
  char v3; // [sp+0h] [bp-18h]
  char v4; // [sp+4h] [bp-14h]

  if ( CPUID == 1091551857 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 326);
  if ( CPUID == 1091551856 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 327);
  v4 = NVIC_IPR_0;
  NVIC_IPR_0 = -1;
  v3 = -1;
  sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 352);
  byte_200016B4 = -112;
  dword_200016BC = 7;
  while ( v3 < 0 )
  {
    --dword_200016BC;
    v3 *= 2;
  }
  if ( dword_200016BC != 3 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 372);
  if ( dword_200016BC != 3 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\port.c", 381);
  dword_200016BC = ((unsigned __int8)dword_200016BC << 8) & 0x700;
  NVIC_IPR_0 = v4;
  SHPR3 |= 0xF00000u;
  SHPR3 |= 0xF0000000;
  sub_802397C();
  dword_200016B8 = 0;
  sub_8002234();
  FPCCR |= 0xC0000000;
  sub_800220C((int)&FPCCR, (void *)FPCCR, v0, v1);
  return 0;
}
// 8024F88: variable 'v0' is possibly undefined
// 8024F88: variable 'v1' is possibly undefined
// 200016B4: using guessed type char byte_200016B4;
// 200016B8: using guessed type int dword_200016B8;
// 200016BC: using guessed type int dword_200016BC;
// E000E400: using guessed type char NVIC_IPR_0;
// E000ED00: using guessed type int CPUID;
// E000ED20: using guessed type int SHPR3;
// E000EF34: using guessed type int FPCCR;

//----- (08024FE8) --------------------------------------------------------
int sub_8024FE8()
{
  int result; // r0

  _R0 = 144;
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  if ( sub_8025B3C() )
    ICSR = 0x10000000;
  result = 0;
  __asm { MSR.W           BASEPRI, R0 }
  return result;
}
// E000ED04: using guessed type int ICSR;

//----- (08025014) --------------------------------------------------------
_DWORD *__fastcall sub_8025014(char a1)
{
  _DWORD *v1; // r4

  v1 = (_DWORD *)sub_802502C(1u, 0, a1);
  sub_8020248(v1);
  return v1;
}

//----- (0802502C) --------------------------------------------------------
int __fastcall sub_802502C(unsigned int a1, unsigned int a2, char a3)
{
  int v6; // r4
  int v7; // r0

  v6 = 0;
  if ( a1 && 0xFFFFFFFF / a1 >= a2 && a1 * a2 <= 0xFFFFFFAB )
  {
    v7 = ((int (__fastcall *)(unsigned int))loc_8020680)(a1 * a2 + 84);
    v6 = v7;
    if ( v7 )
      sub_8020260(a1, a2, v7 + 84, a3, v7);
  }
  else
  {
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 484);
  }
  return v6;
}

//----- (080250A8) --------------------------------------------------------
int __fastcall sub_80250A8(int a1, int a2)
{
  int v4; // r5
  unsigned int v5; // r0
  _DWORD *v6; // r0

  v4 = 1;
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 302);
  if ( a1 && (v5 = *(_DWORD *)(a1 + 60)) != 0 && 0xFFFFFFFF / v5 >= *(_DWORD *)(a1 + 64) )
  {
    sub_80237E4();
    *(_DWORD *)(a1 + 8) = *(_DWORD *)a1 + *(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a1 + (*(_DWORD *)(a1 + 60) - 1) * *(_DWORD *)(a1 + 64);
    *(_BYTE *)(a1 + 68) = -1;
    *(_BYTE *)(a1 + 69) = -1;
    v6 = (_DWORD *)(a1 + 16);
    if ( a2 )
    {
      sub_8023780(v6);
      sub_8023780((_DWORD *)(a1 + 36));
    }
    else if ( *(_DWORD *)(a1 + 16) && sub_8025E24((int)v6) )
    {
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
    sub_8023864();
  }
  else
  {
    v4 = 0;
  }
  if ( !v4 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 355);
  return v4;
}
// E000ED04: using guessed type int ICSR;

//----- (08025188) --------------------------------------------------------
int __fastcall sub_8025188(int a1, unsigned int a2, unsigned int a3, int a4)
{
  int v7; // r5
  int v8; // r5
  int v9; // r0
  _DWORD v11[4]; // [sp+0h] [bp-38h] BYREF
  unsigned int v12[10]; // [sp+10h] [bp-28h] BYREF

  v11[2] = a1;
  v11[3] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v7 = 0;
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 844);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 845);
  if ( a4 == 2 && *(_DWORD *)(a1 + 60) != 1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 846);
  if ( !sub_8025B14() && v12[0] )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 849);
  while ( 1 )
  {
    sub_80237E4();
    if ( *(_DWORD *)(a1 + 56) < *(_DWORD *)(a1 + 60) || a4 == 2 )
    {
      v8 = *(_DWORD *)(a1 + 56);
      v9 = sub_8020140((unsigned int *)a1, a2, a4);
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( a4 == 2 && v8 || !sub_8020494(a1) )
          goto LABEL_27;
        goto LABEL_26;
      }
      if ( *(_DWORD *)(a1 + 36) )
      {
        if ( sub_8025E24(a1 + 36) )
          goto LABEL_26;
      }
      else if ( v9 )
      {
LABEL_26:
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
LABEL_27:
      sub_8023864();
      return 1;
    }
    if ( !v12[0] )
    {
      sub_8023864();
      return 0;
    }
    if ( !v7 )
    {
      sub_8023B20(v11);
      v7 = 1;
    }
    sub_8023864();
    sub_8023EB4();
    sub_80237E4();
    if ( *(char *)(a1 + 68) == -1 )
      *(_BYTE *)(a1 + 68) = 0;
    if ( *(char *)(a1 + 69) == -1 )
      *(_BYTE *)(a1 + 69) = 0;
    sub_8023864();
    if ( sub_802584C(v11, v12) )
      break;
    if ( sub_802041A(a1) )
    {
      sub_8023BE8((_DWORD *)(a1 + 16), v12[0]);
      sub_80205E0(a1);
      if ( !sub_8025F2C() )
      {
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
    }
    else
    {
      sub_80205E0(a1);
      sub_8025F2C();
    }
  }
  sub_80205E0(a1);
  sub_8025F2C();
  return 0;
}
// E000ED04: using guessed type int ICSR;

//----- (0802532C) --------------------------------------------------------
int __fastcall sub_802532C(int a1, unsigned int a2, _DWORD *a3, int a4)
{
  int result; // r0
  unsigned int v15; // r5
  int v16; // r9

  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1056);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1057);
  if ( a4 == 2 && *(_DWORD *)(a1 + 60) != 1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1058);
  sub_80239A0();
  _R0 = 144;
  _R8 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  if ( *(_DWORD *)(a1 + 56) < *(_DWORD *)(a1 + 60) || a4 == 2 )
  {
    v15 = *(char *)(a1 + 69);
    v16 = *(_DWORD *)(a1 + 56);
    sub_8020140((unsigned int *)a1, a2, a4);
    if ( v15 == -1 )
    {
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( (a4 != 2 || !v16) && sub_8020494(a1) && a3 )
          *a3 = 1;
      }
      else if ( *(_DWORD *)(a1 + 36) && sub_8025E24(a1 + 36) && a3 )
      {
        *a3 = 1;
      }
    }
    else if ( v15 < sub_80236C8() )
    {
      if ( v15 == 127 )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1195);
      *(_BYTE *)(a1 + 69) = v15 + 1;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  __asm { MSR.W           BASEPRI, R8 }
  return result;
}

//----- (08025438) --------------------------------------------------------
int __fastcall sub_8025438(int a1, _DWORD *a2)
{
  unsigned int v10; // r0
  unsigned int v11; // r5
  int result; // r0

  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1225);
  if ( *(_DWORD *)(a1 + 64) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1229);
  if ( !*(_DWORD *)a1 && *(_DWORD *)(a1 + 8) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1234);
  sub_80239A0();
  _R0 = 144;
  _R7 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  v10 = *(_DWORD *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 60) <= v10 )
  {
    result = 0;
  }
  else
  {
    v11 = *(char *)(a1 + 69);
    *(_DWORD *)(a1 + 56) = v10 + 1;
    if ( v11 == -1 )
    {
      if ( *(_DWORD *)(a1 + 72) )
      {
        if ( sub_8020494(a1) && a2 )
          *a2 = 1;
      }
      else if ( *(_DWORD *)(a1 + 36) && sub_8025E24(a1 + 36) && a2 )
      {
        *a2 = 1;
      }
    }
    else if ( v11 < sub_80236C8() )
    {
      if ( v11 == 127 )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1361);
      *(_BYTE *)(a1 + 69) = v11 + 1;
    }
    result = 1;
  }
  __asm { MSR.W           BASEPRI, R7 }
  return result;
}

//----- (08025520) --------------------------------------------------------
BOOL __fastcall sub_8025520(int a1)
{
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 2466);
  return *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 60);
}

//----- (08025570) --------------------------------------------------------
int __fastcall sub_8025570(int a1, unsigned int a2, int a3)
{
  int v5; // r6
  int v6; // r5
  _DWORD v8[4]; // [sp+4h] [bp-34h] BYREF
  int v9; // [sp+14h] [bp-24h] BYREF

  v8[2] = a1;
  v8[3] = a2;
  v9 = a3;
  v5 = 0;
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1387);
  if ( !a2 && *(_DWORD *)(a1 + 64) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1391);
  if ( !sub_8025B14() && v9 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1396);
  while ( 1 )
  {
    sub_80237E4();
    v6 = *(_DWORD *)(a1 + 56);
    if ( v6 )
      break;
    if ( !v9 )
    {
      sub_8023864();
      return 0;
    }
    if ( !v5 )
    {
      sub_8023B20(v8);
      v5 = 1;
    }
    sub_8023864();
    sub_8023EB4();
    sub_80237E4();
    if ( *(char *)(a1 + 68) == -1 )
      *(_BYTE *)(a1 + 68) = 0;
    if ( *(char *)(a1 + 69) == -1 )
      *(_BYTE *)(a1 + 69) = 0;
    sub_8023864();
    if ( sub_802584C(v8, (unsigned int *)&v9) )
    {
      sub_80205E0(a1);
      sub_8025F2C();
      if ( sub_8020400(a1) )
        return 0;
    }
    else if ( sub_8020400(a1) )
    {
      sub_8023BE8((_DWORD *)(a1 + 36), v9);
      sub_80205E0(a1);
      if ( !sub_8025F2C() )
      {
        ICSR = 0x10000000;
        __dsb(0xFu);
        __isb(0xFu);
      }
    }
    else
    {
      sub_80205E0(a1);
      sub_8025F2C();
    }
  }
  sub_8020118((_DWORD *)a1, a2);
  *(_DWORD *)(a1 + 56) = v6 - 1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    if ( sub_8025E24(a1 + 16) )
    {
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_8023864();
  return 1;
}
// E000ED04: using guessed type int ICSR;

//----- (080256C8) --------------------------------------------------------
int __fastcall sub_80256C8(int a1, int a2)
{
  int v3; // r5
  int v4; // r9
  int v5; // r0
  unsigned int v7; // r0
  _DWORD v8[3]; // [sp+4h] [bp-2Ch] BYREF
  int v9; // [sp+10h] [bp-20h] BYREF

  v8[2] = a1;
  v9 = a2;
  v3 = 0;
  v4 = 0;
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1533);
  if ( *(_DWORD *)(a1 + 64) )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1537);
  if ( !sub_8025B14() && v9 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\queue.c", 1542);
  do
  {
    while ( 1 )
    {
      sub_80237E4();
      v5 = *(_DWORD *)(a1 + 56);
      if ( v5 )
      {
        *(_DWORD *)(a1 + 56) = v5 - 1;
        if ( !*(_DWORD *)a1 )
          *(_DWORD *)(a1 + 8) = sub_8020788();
        if ( *(_DWORD *)(a1 + 16) )
        {
          if ( sub_8025E24(a1 + 16) )
          {
            ICSR = 0x10000000;
            __dsb(0xFu);
            __isb(0xFu);
          }
        }
        sub_8023864();
        return 1;
      }
      if ( !v9 )
      {
        sub_8023864();
        return 0;
      }
      if ( !v3 )
      {
        sub_8023B20(v8);
        v3 = 1;
      }
      sub_8023864();
      sub_8023EB4();
      sub_80237E4();
      if ( *(char *)(a1 + 68) == -1 )
        *(_BYTE *)(a1 + 68) = 0;
      if ( *(char *)(a1 + 69) == -1 )
        *(_BYTE *)(a1 + 69) = 0;
      sub_8023864();
      if ( sub_802584C(v8, (unsigned int *)&v9) )
        break;
      if ( sub_8020400(a1) )
      {
        if ( !*(_DWORD *)a1 )
        {
          sub_80237E4();
          v4 = sub_8025D70(*(_DWORD *)(a1 + 8));
          sub_8023864();
        }
        sub_8023BE8((_DWORD *)(a1 + 36), v9);
        sub_80205E0(a1);
        if ( !sub_8025F2C() )
        {
          ICSR = 0x10000000;
          __dsb(0xFu);
          __isb(0xFu);
        }
      }
      else
      {
        sub_80205E0(a1);
        sub_8025F2C();
      }
    }
    sub_80205E0(a1);
    sub_8025F2C();
  }
  while ( !sub_8020400(a1) );
  if ( v4 )
  {
    sub_80237E4();
    v7 = sub_80201C2(a1);
    sub_8023C48(*(_DWORD *)(a1 + 8), v7);
    sub_8023864();
  }
  return 0;
}
// E000ED04: using guessed type int ICSR;

//----- (0802584C) --------------------------------------------------------
int __fastcall sub_802584C(_DWORD *a1, unsigned int *a2)
{
  unsigned int v4; // r3
  unsigned int v5; // r0
  int v6; // r4
  unsigned int v7; // r1

  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3311);
  if ( !a2 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3312);
  sub_80237E4();
  v4 = a1[1];
  v5 = dword_20001664 - v4;
  if ( *(_BYTE *)(dword_20001658 + 89) )
  {
    *(_BYTE *)(dword_20001658 + 89) = 0;
    v6 = 1;
  }
  else
  {
    v7 = *a2;
    if ( *a2 == -1 )
    {
      v6 = 0;
    }
    else if ( *a1 == dword_20001678 || v4 > dword_20001664 )
    {
      if ( v7 <= v5 )
      {
        *a2 = 0;
        v6 = 1;
      }
      else
      {
        *a2 = v7 - v5;
        sub_8023B20(a1);
        v6 = 0;
      }
    }
    else
    {
      v6 = 1;
      *a2 = 0;
    }
  }
  sub_8023864();
  return v6;
}
// 20001658: using guessed type int dword_20001658;
// 20001664: using guessed type int dword_20001664;
// 20001678: using guessed type int dword_20001678;

//----- (08025904) --------------------------------------------------------
int __fastcall sub_8025904(int a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6)
{
  int v10; // r5
  _BYTE *v11; // r0
  _DWORD *v12; // r4

  v10 = ((int (__fastcall *)(int))loc_8020680)(4 * a3);
  if ( v10 )
  {
    v11 = (_BYTE *)((int (__fastcall *)(int))loc_8020680)(92);
    v12 = v11;
    if ( v11 )
    {
      sub_8002364(v11, 92);
      v12[12] = v10;
    }
    else
    {
      ((void (__fastcall *)(int))loc_80238D4)(v10);
    }
  }
  else
  {
    v12 = 0;
  }
  if ( !v12 )
    return -1;
  sub_8020288(a1, a2, a3, a4, a5, a6, (int)v12);
  sub_8020030(v12);
  return 1;
}

//----- (0802596C) --------------------------------------------------------
int __fastcall sub_802596C(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  int v10; // r8
  _DWORD *v17; // r0
  _BYTE *v18; // r1
  int v19; // r6
  int v20; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r1
  int v24; // r0
  int v25; // r0

  v10 = 1;
  if ( !a1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4984);
  if ( a2 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4985);
  sub_80239A0();
  _R0 = 144;
  _R7 = __get_CPSR();
  __asm { MSR.W           BASEPRI, R0 }
  __dsb(0xFu);
  __isb(0xFu);
  v17 = &a1[a2];
  if ( a5 )
    *a5 = v17[21];
  v18 = (char *)a1 + a2 + 88;
  v19 = (unsigned __int8)*v18;
  *v18 = 2;
  switch ( a4 )
  {
    case 0:
      break;
    case 1:
      v17[21] |= a3;
      break;
    case 2:
      ++v17[21];
      break;
    case 3:
      v17[21] = a3;
      break;
    case 4:
      if ( v19 == 2 )
        v10 = 0;
      else
        v17[21] = a3;
      break;
    default:
      if ( dword_20001664 )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 5056);
      break;
  }
  if ( v19 == 1 )
  {
    if ( a1[10] )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 5067);
    if ( dword_2000168C )
    {
      v20 = dword_20011A04;
      a1[7] = dword_20011A04;
      a1[8] = *(_DWORD *)(v20 + 8);
      *(_DWORD *)(*(_DWORD *)(v20 + 8) + 4) = a1 + 6;
      *(_DWORD *)(v20 + 8) = a1 + 6;
      a1[10] = &dword_20011A00;
      ++dword_20011A00;
    }
    else
    {
      v22 = (_DWORD *)a1[5];
      *(_DWORD *)(a1[2] + 8) = a1[3];
      *(_DWORD *)(a1[3] + 4) = a1[2];
      v23 = a1 + 1;
      if ( (_DWORD *)v22[1] == a1 + 1 )
        v22[1] = a1[3];
      a1[5] = 0;
      --*v22;
      v24 = a1[11];
      dword_20001668 |= 1 << v24;
      v25 = dword_20011758[5 * v24 + 1];
      a1[2] = v25;
      a1[3] = *(_DWORD *)(v25 + 8);
      *(_DWORD *)(*(_DWORD *)(v25 + 8) + 4) = v23;
      *(_DWORD *)(v25 + 8) = v23;
      a1[5] = &dword_20011758[5 * a1[11]];
      ++dword_20011758[5 * a1[11]];
    }
    if ( a1[11] > *(_DWORD *)(dword_20001658 + 44) )
    {
      if ( a6 )
        *a6 = 1;
      dword_20001674 = 1;
    }
  }
  __asm { MSR.W           BASEPRI, R7 }
  return v10;
}
// 20001658: using guessed type int dword_20001658;
// 20001664: using guessed type int dword_20001664;
// 20001668: using guessed type int dword_20001668;
// 20001674: using guessed type int dword_20001674;
// 2000168C: using guessed type int dword_2000168C;
// 20011758: using guessed type int dword_20011758[160];
// 20011A00: using guessed type int dword_20011A00;
// 20011A04: using guessed type int dword_20011A04;

//----- (08025B14) --------------------------------------------------------
int sub_8025B14()
{
  if ( !dword_2000166C )
    return 1;
  if ( dword_2000168C )
    return 0;
  return 2;
}
// 2000166C: using guessed type int dword_2000166C;
// 2000168C: using guessed type int dword_2000168C;

//----- (08025B30) --------------------------------------------------------
int sub_8025B30()
{
  return dword_20001664;
}
// 20001664: using guessed type int dword_20001664;

//----- (08025B3C) --------------------------------------------------------
int sub_8025B3C()
{
  int v0; // r5
  unsigned int v2; // r4
  int v3; // r0
  _DWORD *v4; // r1
  _DWORD *v5; // r2
  _DWORD *v6; // r3
  _DWORD *v7; // r2
  int v8; // r0
  int v9; // r2
  int v10; // r0

  v0 = 0;
  if ( dword_2000168C )
  {
    ++dword_20001670;
  }
  else
  {
    v2 = dword_20001664 + 1;
    dword_20001664 = v2;
    if ( !v2 )
    {
      if ( *(_DWORD *)dword_20001690 )
        sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2743);
      v3 = dword_20001690;
      dword_20001690 = dword_20001694;
      dword_20001694 = v3;
      ++dword_20001678;
      sub_8020540();
    }
    if ( v2 >= dword_20001680 )
    {
      while ( *(_DWORD *)dword_20001690 )
      {
        v4 = *(_DWORD **)(*(_DWORD *)(dword_20001690 + 12) + 12);
        if ( v2 < v4[1] )
        {
          dword_20001680 = v4[1];
          goto LABEL_13;
        }
        v5 = (_DWORD *)v4[5];
        *(_DWORD *)(v4[2] + 8) = v4[3];
        *(_DWORD *)(v4[3] + 4) = v4[2];
        v6 = v4 + 1;
        if ( (_DWORD *)v5[1] == v4 + 1 )
          v5[1] = v4[3];
        v4[5] = 0;
        --*v5;
        v7 = (_DWORD *)v4[10];
        if ( v7 )
        {
          *(_DWORD *)(v4[7] + 8) = v4[8];
          *(_DWORD *)(v4[8] + 4) = v4[7];
          if ( (_DWORD *)v7[1] == v4 + 6 )
            v7[1] = v4[8];
          v4[10] = 0;
          --*v7;
        }
        v8 = v4[11];
        dword_20001668 |= 1 << v8;
        v9 = dword_20011758[5 * v8 + 1];
        v4[2] = v9;
        v4[3] = *(_DWORD *)(v9 + 8);
        *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = v6;
        *(_DWORD *)(v9 + 8) = v6;
        v10 = 5 * v4[11];
        v4[5] = &dword_20011758[5 * v4[11]];
        ++dword_20011758[v10];
        if ( v4[11] > *(_DWORD *)(dword_20001658 + 44) )
          v0 = 1;
      }
      dword_20001680 = -1;
    }
LABEL_13:
    if ( (unsigned int)dword_20011758[5 * *(_DWORD *)(dword_20001658 + 44)] > 1 )
      v0 = 1;
    if ( dword_20001674 )
      return 1;
  }
  return v0;
}
// 20001658: using guessed type int dword_20001658;
// 20001664: using guessed type int dword_20001664;
// 20001668: using guessed type int dword_20001668;
// 20001670: using guessed type int dword_20001670;
// 20001674: using guessed type int dword_20001674;
// 20001678: using guessed type int dword_20001678;
// 20001680: using guessed type int dword_20001680;
// 2000168C: using guessed type int dword_2000168C;
// 20001690: using guessed type int dword_20001690;
// 20001694: using guessed type int dword_20001694;
// 20011758: using guessed type int dword_20011758[160];

//----- (08025C94) --------------------------------------------------------
int __fastcall sub_8025C94(int a1)
{
  int v2; // r6
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0

  v2 = 0;
  if ( a1 )
  {
    if ( a1 != dword_20001658 )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4168);
    if ( !*(_DWORD *)(a1 + 80) )
      sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 4169);
    v3 = *(_DWORD *)(a1 + 80) - 1;
    *(_DWORD *)(a1 + 80) = v3;
    if ( *(_DWORD *)(a1 + 44) != *(_DWORD *)(a1 + 76) && !v3 )
    {
      if ( !sub_80236A0((_DWORD *)(a1 + 4)) )
        dword_20001668 &= ~(1 << *(_BYTE *)(a1 + 44));
      v4 = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a1 + 44) = v4;
      *(_DWORD *)(a1 + 24) = 32 - v4;
      v5 = *(_DWORD *)(a1 + 44);
      dword_20001668 |= 1 << v5;
      v6 = dword_20011758[5 * v5 + 1];
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = a1 + 4;
      *(_DWORD *)(v6 + 8) = a1 + 4;
      *(_DWORD *)(a1 + 20) = &dword_20011758[5 * *(_DWORD *)(a1 + 44)];
      ++dword_20011758[5 * *(_DWORD *)(a1 + 44)];
      return 1;
    }
  }
  return v2;
}
// 20001658: using guessed type int dword_20001658;
// 20001668: using guessed type int dword_20001668;
// 20011758: using guessed type int dword_20011758[160];

//----- (08025D70) --------------------------------------------------------
int __fastcall sub_8025D70(int a1)
{
  int result; // r0
  int v3; // r0
  int v4; // r0

  result = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 44) >= *(_DWORD *)(dword_20001658 + 44) )
    {
      if ( *(_DWORD *)(a1 + 76) < *(_DWORD *)(dword_20001658 + 44) )
        return 1;
    }
    else
    {
      if ( *(int *)(a1 + 24) >= 0 )
        *(_DWORD *)(a1 + 24) = 32 - *(_DWORD *)(dword_20001658 + 44);
      if ( *(int **)(a1 + 20) == &dword_20011758[5 * *(_DWORD *)(a1 + 44)] )
      {
        if ( !sub_80236A0((_DWORD *)(a1 + 4)) )
          dword_20001668 &= ~(1 << *(_BYTE *)(a1 + 44));
        v3 = *(_DWORD *)(dword_20001658 + 44);
        *(_DWORD *)(a1 + 44) = v3;
        dword_20001668 |= 1 << v3;
        v4 = dword_20011758[5 * v3 + 1];
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4) = a1 + 4;
        *(_DWORD *)(v4 + 8) = a1 + 4;
        *(_DWORD *)(a1 + 20) = &dword_20011758[5 * *(_DWORD *)(a1 + 44)];
        ++dword_20011758[5 * *(_DWORD *)(a1 + 44)];
      }
      else
      {
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(dword_20001658 + 44);
      }
      return 1;
    }
  }
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001668: using guessed type int dword_20001668;
// 20011758: using guessed type int dword_20011758[160];

//----- (08025E24) --------------------------------------------------------
int __fastcall sub_8025E24(int a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  _DWORD *v3; // r1
  int v4; // r0
  int result; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r1
  int v8; // r0
  int v9; // r0
  int v10; // r0

  v1 = *(_DWORD **)(*(_DWORD *)(a1 + 12) + 12);
  if ( !v1 )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 3188);
  v2 = (_DWORD *)v1[10];
  *(_DWORD *)(v1[7] + 8) = v1[8];
  *(_DWORD *)(v1[8] + 4) = v1[7];
  v3 = v1 + 6;
  if ( (_DWORD *)v2[1] == v1 + 6 )
    v2[1] = v1[8];
  v1[10] = 0;
  --*v2;
  if ( dword_2000168C )
  {
    v4 = dword_20011A04;
    v1[7] = dword_20011A04;
    v1[8] = *(_DWORD *)(v4 + 8);
    *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4) = v3;
    *(_DWORD *)(v4 + 8) = v3;
    v1[10] = &dword_20011A00;
    ++dword_20011A00;
  }
  else
  {
    v6 = (_DWORD *)v1[5];
    *(_DWORD *)(v1[2] + 8) = v1[3];
    *(_DWORD *)(v1[3] + 4) = v1[2];
    v7 = v1 + 1;
    if ( (_DWORD *)v6[1] == v1 + 1 )
      v6[1] = v1[3];
    v1[5] = 0;
    --*v6;
    v8 = v1[11];
    dword_20001668 |= 1 << v8;
    v9 = dword_20011758[5 * v8 + 1];
    v1[2] = v9;
    v1[3] = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = v7;
    *(_DWORD *)(v9 + 8) = v7;
    v10 = 5 * v1[11];
    v1[5] = &dword_20011758[5 * v1[11]];
    ++dword_20011758[v10];
  }
  if ( v1[11] <= *(_DWORD *)(dword_20001658 + 44) )
    return 0;
  result = 1;
  dword_20001674 = 1;
  return result;
}
// 20001658: using guessed type int dword_20001658;
// 20001668: using guessed type int dword_20001668;
// 20001674: using guessed type int dword_20001674;
// 2000168C: using guessed type int dword_2000168C;
// 20011758: using guessed type int dword_20011758[160];
// 20011A00: using guessed type int dword_20011A00;
// 20011A04: using guessed type int dword_20011A04;

//----- (08025F2C) --------------------------------------------------------
int sub_8025F2C()
{
  _DWORD *v0; // r4
  int v1; // r8
  _DWORD *v2; // r1
  _DWORD *v3; // r1
  _DWORD *v4; // r0
  int v5; // r1
  int v6; // r1
  int v7; // r0
  int v8; // r4

  v0 = 0;
  v1 = 0;
  if ( !dword_2000168C )
    sub_801E93C((int)"Error: %s, %d\r\n", "..\\..\\SDK\\FreeRTOS\\tasks.c", 2181);
  sub_80237E4();
  if ( !--dword_2000168C && dword_20001660 )
  {
    while ( dword_20011A00 )
    {
      v0 = *(_DWORD **)(dword_20011A0C + 12);
      v2 = (_DWORD *)v0[10];
      *(_DWORD *)(v0[7] + 8) = v0[8];
      *(_DWORD *)(v0[8] + 4) = v0[7];
      if ( (_DWORD *)v2[1] == v0 + 6 )
        v2[1] = v0[8];
      v0[10] = 0;
      --*v2;
      v3 = (_DWORD *)v0[5];
      *(_DWORD *)(v0[2] + 8) = v0[3];
      *(_DWORD *)(v0[3] + 4) = v0[2];
      v4 = v0 + 1;
      if ( (_DWORD *)v3[1] == v0 + 1 )
        v3[1] = v0[3];
      v0[5] = 0;
      --*v3;
      v5 = v0[11];
      dword_20001668 |= 1 << v5;
      v6 = dword_20011758[5 * v5 + 1];
      v0[2] = v6;
      v0[3] = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = v4;
      *(_DWORD *)(v6 + 8) = v4;
      v7 = 5 * v0[11];
      v0[5] = &dword_20011758[5 * v0[11]];
      ++dword_20011758[v7];
      if ( v0[11] >= *(_DWORD *)(dword_20001658 + 44) )
        dword_20001674 = 1;
    }
    if ( v0 )
      sub_8020540();
    v8 = dword_20001670;
    if ( dword_20001670 )
    {
      do
      {
        if ( sub_8025B3C() )
          dword_20001674 = 1;
        --v8;
      }
      while ( v8 );
      dword_20001670 = 0;
    }
    if ( dword_20001674 )
    {
      v1 = 1;
      ICSR = 0x10000000;
      __dsb(0xFu);
      __isb(0xFu);
    }
  }
  sub_8023864();
  return v1;
}
// 20001658: using guessed type int dword_20001658;
// 20001660: using guessed type int dword_20001660;
// 20001668: using guessed type int dword_20001668;
// 20001670: using guessed type int dword_20001670;
// 20001674: using guessed type int dword_20001674;
// 2000168C: using guessed type int dword_2000168C;
// 20011758: using guessed type int dword_20011758[160];
// 20011A00: using guessed type int dword_20011A00;
// 20011A0C: using guessed type int dword_20011A0C;
// E000ED04: using guessed type int ICSR;

//----- (08029BFC) --------------------------------------------------------
void sub_8029BFC()
{
  JUMPOUT(0x801312E);
}
// 8029C04: control flows out of bounds to 801312E

//----- (08029C06) --------------------------------------------------------
void sub_8029C06()
{
  JUMPOUT(0x8012558);
}
// 8029C0E: control flows out of bounds to 8012558

//----- (08029C10) --------------------------------------------------------
void sub_8029C10()
{
  JUMPOUT(0x8013110);
}
// 8029C18: control flows out of bounds to 8013110

//----- (08029C1A) --------------------------------------------------------
void sub_8029C1A()
{
  JUMPOUT(0x8018C34);
}
// 8029C22: control flows out of bounds to 8018C34

//----- (08029C24) --------------------------------------------------------
void sub_8029C24()
{
  JUMPOUT(0x8006490);
}
// 8029C2C: control flows out of bounds to 8006490

//----- (08029C2E) --------------------------------------------------------
void sub_8029C2E()
{
  JUMPOUT(0x8002FBC);
}
// 8029C36: control flows out of bounds to 8002FBC

//----- (08029C42) --------------------------------------------------------
void sub_8029C42()
{
  JUMPOUT(0x8002B32);
}
// 8029C4A: control flows out of bounds to 8002B32

//----- (08029C4C) --------------------------------------------------------
void sub_8029C4C()
{
  JUMPOUT(0x80047A0);
}
// 8029C54: control flows out of bounds to 80047A0

//----- (08029C56) --------------------------------------------------------
void sub_8029C56()
{
  JUMPOUT(0x801F274);
}
// 8029C5E: control flows out of bounds to 801F274

//----- (08029C60) --------------------------------------------------------
void sub_8029C60()
{
  JUMPOUT(0x8002FE4);
}
// 8029C68: control flows out of bounds to 8002FE4

//----- (08029C6A) --------------------------------------------------------
void sub_8029C6A()
{
  JUMPOUT(0x8003F20);
}
// 8029C72: control flows out of bounds to 8003F20

//----- (08029C74) --------------------------------------------------------
void sub_8029C74()
{
  JUMPOUT(0x8017614);
}
// 8029C7C: control flows out of bounds to 8017614

//----- (08029C7E) --------------------------------------------------------
void sub_8029C7E()
{
  JUMPOUT(0x8017724);
}
// 8029C86: control flows out of bounds to 8017724

//----- (08029C88) --------------------------------------------------------
void sub_8029C88()
{
  JUMPOUT(0x8017754);
}
// 8029C90: control flows out of bounds to 8017754

//----- (08029C92) --------------------------------------------------------
void sub_8029C92()
{
  JUMPOUT(0x8017664);
}
// 8029C9A: control flows out of bounds to 8017664

//----- (08029C9C) --------------------------------------------------------
void sub_8029C9C()
{
  JUMPOUT(0x8017740);
}
// 8029CA4: control flows out of bounds to 8017740

//----- (08029CA6) --------------------------------------------------------
void sub_8029CA6()
{
  JUMPOUT(0x80175AC);
}
// 8029CAE: control flows out of bounds to 80175AC
// 80175AC: using guessed type __int16 word_80175AC;

//----- (08029CB0) --------------------------------------------------------
void sub_8029CB0()
{
  JUMPOUT(0x8017138);
}
// 8029CB8: control flows out of bounds to 8017138

//----- (08029CBA) --------------------------------------------------------
void sub_8029CBA()
{
  JUMPOUT(0x80176E4);
}
// 8029CC2: control flows out of bounds to 80176E4

//----- (08029CC4) --------------------------------------------------------
void sub_8029CC4()
{
  JUMPOUT(0x8017144);
}
// 8029CCC: control flows out of bounds to 8017144

//----- (08029CCE) --------------------------------------------------------
void sub_8029CCE()
{
  JUMPOUT(0x80176F0);
}
// 8029CD6: control flows out of bounds to 80176F0

//----- (08029CD8) --------------------------------------------------------
void sub_8029CD8()
{
  JUMPOUT(0x8017718);
}
// 8029CE0: control flows out of bounds to 8017718

//----- (08029CE2) --------------------------------------------------------
void sub_8029CE2()
{
  JUMPOUT(0x80176C0);
}
// 8029CEA: control flows out of bounds to 80176C0

//----- (08029CEC) --------------------------------------------------------
void sub_8029CEC()
{
  JUMPOUT(0x80176B4);
}
// 8029CF4: control flows out of bounds to 80176B4

//----- (08029CF6) --------------------------------------------------------
void sub_8029CF6()
{
  JUMPOUT(0x801711C);
}
// 8029CFE: control flows out of bounds to 801711C

//----- (08029D00) --------------------------------------------------------
void sub_8029D00()
{
  JUMPOUT(0x8017110);
}
// 8029D08: control flows out of bounds to 8017110

//----- (08029D0A) --------------------------------------------------------
void sub_8029D0A()
{
  JUMPOUT(0x80175E0);
}
// 8029D12: control flows out of bounds to 80175E0
// 80175E0: using guessed type __int16 word_80175E0;

//----- (08029D14) --------------------------------------------------------
void sub_8029D14()
{
  JUMPOUT(0x8018BA4);
}
// 8029D1C: control flows out of bounds to 8018BA4

//----- (08029D1E) --------------------------------------------------------
void sub_8029D1E()
{
  JUMPOUT(0x801311E);
}
// 8029D26: control flows out of bounds to 801311E

//----- (08029D28) --------------------------------------------------------
void sub_8029D28()
{
  JUMPOUT(0x80041A8);
}
// 8029D30: control flows out of bounds to 80041A8

//----- (08029D32) --------------------------------------------------------
__int64 __fastcall sub_8029D32(__int64 a1)
{
  return sub_800FFA4(a1);
}

//----- (08029D3C) --------------------------------------------------------
void sub_8029D3C()
{
  JUMPOUT(0x8010ECC);
}
// 8029D44: control flows out of bounds to 8010ECC

//----- (08029D46) --------------------------------------------------------
int __fastcall sub_8029D46(int a1, unsigned int a2, int a3)
{
  return sub_801712C(a1, a2, a3);
}

//----- (08029D50) --------------------------------------------------------
void sub_8029D50()
{
  JUMPOUT(0x80063FC);
}
// 8029D58: control flows out of bounds to 80063FC

//----- (08029D5A) --------------------------------------------------------
void sub_8029D5A()
{
  JUMPOUT(0x801FC14);
}
// 8029D62: control flows out of bounds to 801FC14

//----- (08029D6E) --------------------------------------------------------
void sub_8029D6E()
{
  JUMPOUT(0x8011EF0);
}
// 8029D76: control flows out of bounds to 8011EF0

//----- (08029D78) --------------------------------------------------------
void sub_8029D78()
{
  JUMPOUT(0x8011EA8);
}
// 8029D80: control flows out of bounds to 8011EA8

//----- (08029DAC) --------------------------------------------------------
int sub_8029DAC()
{
  int v1; // [sp+0h] [bp-8h]

  return v1 & 0x7FFFFFFF;
}
// 8029DB2: variable 'v1' is possibly undefined

//----- (08029E4C) --------------------------------------------------------
void sub_8029E4C()
{
  int v0; // r0
  int v1; // r0

  sub_8029C10();
  if ( v0 == 1 )
  {
    sub_8029BFC();
    dword_20000400 = 0;
  }
  else
  {
    ++dword_20000400;
  }
  if ( (unsigned int)dword_20000400 > 0x14 && dword_20001C10 < 1133248512 )
    sub_8029BFC();
  sub_8029C10();
  if ( v1 == 1 )
  {
    if ( dword_20001C10 < 1132593152 )
      sub_8029BFC();
    dword_20000404 = 0;
  }
  else if ( (unsigned int)++dword_20000404 > 0xEA60 && dword_20001C10 > 1133248512 )
  {
    sub_8029BFC();
  }
}
// 8029E68: variable 'v0' is possibly undefined
// 8029E9C: variable 'v1' is possibly undefined
// 20000400: using guessed type int dword_20000400;
// 20000404: using guessed type int dword_20000404;
// 20001C10: using guessed type int dword_20001C10;

//----- (08029F04) --------------------------------------------------------
void sub_8029F04()
{
  if ( byte_20000513 )
  {
    if ( (unsigned int)dword_20002E88 >> 2 )
    {
      if ( !byte_200002B6 )
      {
        sub_8029C1A();
        BYTE2(dword_200028C0) |= 0x20u;
        byte_200002B6 = 1;
      }
    }
    else if ( byte_200002B6 == 1 )
    {
      sub_8029C1A();
      BYTE2(dword_200028C0) &= ~0x20u;
      byte_200002B6 = 0;
    }
    if ( byte_20000478 )
    {
      if ( !byte_200002B5 )
      {
        sub_8029C1A();
        byte_200002B5 = 1;
      }
      BYTE2(dword_200028C0) &= ~0x10u;
    }
    else if ( byte_200002B5 )
    {
      sub_8029C1A();
      BYTE2(dword_200028C0) |= 0x10u;
      byte_200002B5 = 0;
    }
  }
  else
  {
    byte_200002B6 = 0;
    byte_200002B5 = 1;
  }
  if ( byte_200002B4 )
  {
    if ( flt_20001C14 < flt_20002444 )
    {
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      dword_200003FC = 0;
      byte_200002B4 = 0;
    }
    if ( byte_20002F60 != 14 )
    {
      if ( SLODWORD(flt_20002440) < 1036831949 )
      {
        sub_8029C24();
        sub_8029C1A();
        byte_200002B4 = 0;
        dword_200003FC = 0;
      }
      if ( word_20002434 < (int)(unsigned __int8)byte_20000517 )
      {
        sub_8029C1A();
        byte_200002B4 = 0;
        dword_200003FC = 0;
      }
    }
  }
  else if ( flt_20001C14 <= (float)(flt_20002444 + 1.0)
         || SLODWORD(flt_20002440) <= 1036831949
         || word_20002434 < (int)(unsigned __int8)byte_20000517 )
  {
    if ( (unsigned int)dword_2000002C > 5 )
      dword_200003FC = 0;
  }
  else if ( ++dword_200003FC > 10000 || byte_20002F60 == 13 )
  {
    sub_8029C1A();
    byte_200002B4 = 1;
  }
  if ( byte_20000513 )
  {
    if ( byte_20002F60 == 14 )
    {
      if ( flt_20001C14 >= (float)(flt_20002444 + 1.0) )
      {
        if ( flt_20001C14 > (float)(flt_20002444 + 2.0) )
          byte_200002B7 = 0;
      }
      else
      {
        byte_200002B7 = 1;
      }
    }
    else if ( byte_200002B6 )
    {
      byte_200002B7 = 0;
    }
    else if ( byte_200002B7 )
    {
      if ( word_20002434 > (unsigned __int8)byte_20000517 - 2 )
        byte_200002B7 = 0;
    }
    else if ( word_20002434 < 6 )
    {
      byte_200002B7 = 1;
    }
  }
  else
  {
    byte_200002B7 = 0;
  }
  if ( byte_200002B3 )
  {
    if ( flt_20001C14 > (float)(flt_2000243C + 1.5) )
    {
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    if ( dword_20001BF4 > 1140899840 )
    {
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    if ( SLODWORD(flt_20002438) < 1036831949 )
    {
      sub_8029C24();
      sub_8029C1A();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
    if ( word_20002434 > 99 || word_20002434 >= (int)(unsigned __int8)byte_20000516 )
    {
      sub_8029C1A();
      dword_200003F8 = 0;
      byte_200002B3 = 0;
    }
  }
  else if ( flt_20001C14 >= flt_2000243C
         || SLODWORD(flt_20002438) <= 1036831949
         || SLODWORD(flt_2000243C) <= 1110704128
         || word_20002434 >= (int)(unsigned __int8)byte_20000516 )
  {
    if ( (unsigned int)dword_2000002C > 5 )
      dword_200003F8 = 0;
  }
  else if ( ++dword_200003F8 > 10000 || byte_20002F60 == 13 )
  {
    sub_8029C1A();
    byte_200002B3 = 1;
  }
}
// 2000002C: using guessed type int dword_2000002C;
// 200002B3: using guessed type char byte_200002B3;
// 200002B4: using guessed type char byte_200002B4;
// 200002B5: using guessed type char byte_200002B5;
// 200002B6: using guessed type char byte_200002B6;
// 200002B7: using guessed type char byte_200002B7;
// 200003F8: using guessed type int dword_200003F8;
// 200003FC: using guessed type int dword_200003FC;
// 20000478: using guessed type char byte_20000478;
// 20000513: using guessed type char byte_20000513;
// 20000516: using guessed type char byte_20000516;
// 20000517: using guessed type char byte_20000517;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C14: using guessed type float flt_20001C14;
// 20002434: using guessed type __int16 word_20002434;
// 20002438: using guessed type float flt_20002438;
// 2000243C: using guessed type float flt_2000243C;
// 20002440: using guessed type float flt_20002440;
// 20002444: using guessed type float flt_20002444;
// 200028C0: using guessed type int dword_200028C0;
// 20002E88: using guessed type int dword_20002E88;
// 20002F60: using guessed type char byte_20002F60;

//----- (0802A274) --------------------------------------------------------
int sub_802A274()
{
  float v0; // s0
  int result; // r0

  if ( SLODWORD(v0) > 1065353216 )
    v0 = v0 - 2.0;
  dword_20000418 = (int)(float)(v0 * 2147500000.0);
  *(_DWORD *)(dword_200028D0 + 4) = dword_20000418;
  dword_20000424 = *(_DWORD *)(dword_200028D0 + 8);
  result = *(_DWORD *)(dword_200028D0 + 8);
  dword_20000428 = result;
  return result;
}
// 802A27C: variable 'v0' is possibly undefined
// 20000418: using guessed type int dword_20000418;
// 20000424: using guessed type int dword_20000424;
// 20000428: using guessed type int dword_20000428;
// 200028D0: using guessed type int dword_200028D0;

//----- (0802A2BC) --------------------------------------------------------
int sub_802A2BC()
{
  float v0; // s0
  float v1; // s1
  int result; // r0

  if ( v0 < 0.0 )
    v0 = -v0;
  v1 = -0.032366;
  if ( SLODWORD(v0) <= 1065353216 )
  {
    for ( result = 1; result < 10; ++result )
      v1 = *(float *)(4 * (9 - result) + 0x10007804) + (float)(v0 * v1);
  }
  else
  {
    for ( result = 1; result < 10; ++result )
      v1 = *(float *)(4 * (9 - result) + 0x10007804) + (float)((float)(1.0 / v0) * v1);
  }
  return result;
}
// 802A2CA: variable 'v0' is possibly undefined

//----- (0802A35C) --------------------------------------------------------
float *__fastcall sub_802A35C(float *result, float *a2)
{
  float v2; // s3
  float v3; // s2
  float v4; // s1
  float v5; // s0

  v2 = *result;
  v3 = result[2];
  v4 = result[3];
  v5 = (float)((float)((float)((float)(a2[4] * *result) + (float)(a2[3] * result[1])) + (float)(a2[2] * v3))
             + (float)(a2[1] * v4))
     + (float)(*a2 * result[4]);
  result[5] = v5;
  result[1] = v2;
  *result = v5;
  result[4] = v4;
  result[3] = v3;
  return result;
}

//----- (0802A3AE) --------------------------------------------------------
float *__fastcall sub_802A3AE(float *result)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  float v4; // s3
  float v5; // s2
  float v6; // s3
  float v7; // s0

  v5 = (float)((float)(v3 * 2.0) * v2) * v1;
  v6 = (float)((float)(v4 * 2.0) * v2) * v1;
  v7 = (float)((float)(v2 * v1) * v2) * v1;
  result[4] = 2.0 - v6;
  result[3] = -1.0 - (float)(v7 - v6);
  result[2] = 1.0;
  result[1] = v5 - 2.0;
  *result = (float)(v7 - v5) + 1.0;
  return result;
}
// 802A3B2: variable 'v3' is possibly undefined
// 802A3B6: variable 'v2' is possibly undefined
// 802A3BA: variable 'v1' is possibly undefined
// 802A3BE: variable 'v4' is possibly undefined

//----- (0802A40C) --------------------------------------------------------
_DWORD *__fastcall sub_802A40C(_DWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (0802A430) --------------------------------------------------------
float *__fastcall sub_802A430(float *result)
{
  float v1; // s1
  float v2; // s0
  float v3; // s0

  v1 = (float)(*result - result[1]) * result[4];
  result[8] = v1;
  v2 = result[11];
  if ( result[3] == result[10] )
    v2 = v2 + (float)(result[5] * v1);
  result[9] = v2;
  result[11] = v2;
  v3 = v1 + v2;
  result[10] = v3;
  if ( v3 > result[6] )
    v3 = result[6];
  result[2] = v3;
  if ( v3 < result[7] )
    v3 = result[7];
  result[3] = v3;
  return result;
}

//----- (0802A4A4) --------------------------------------------------------
_DWORD *__fastcall sub_802A4A4(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[3] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = 0;
  result[11] = 0;
  return result;
}

//----- (0802A4CC) --------------------------------------------------------
float *__fastcall sub_802A4CC(float *result, float *a2)
{
  float v2; // s0
  float v3; // s3
  float v4; // s2
  float v5; // s1
  float v6; // s0

  a2[5] = v2;
  v3 = *a2;
  v4 = a2[2];
  v5 = (float)((float)((float)((float)(result[3] * a2[1]) + (float)(result[4] * *a2)) + (float)(*result * a2[3]))
             + (float)(result[1] * v4))
     + (float)(result[2] * v2);
  a2[4] = v5;
  a2[3] = v4;
  a2[2] = v2;
  a2[6] = v5;
  if ( v5 >= result[6] )
    v5 = result[6];
  a2[6] = v5;
  if ( v5 <= result[7] )
    v5 = result[7];
  a2[6] = v5;
  a2[1] = v3;
  *a2 = v5;
  v6 = (float)(v5 + (float)(v2 * result[5])) + v5;
  a2[6] = v6;
  if ( v6 <= result[7] )
    v6 = result[7];
  a2[6] = v6;
  if ( v6 >= result[6] )
    v6 = result[6];
  a2[6] = v6;
  return result;
}
// 802A4CC: variable 'v2' is possibly undefined

//----- (0802A590) --------------------------------------------------------
int __fastcall sub_802A590(int result)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  float v4; // s3
  float v5; // s4
  float v6; // s1

  v4 = (float)(v3 * 6.2832) * (float)(v3 * 6.2832);
  v5 = 1.0 / (float)((float)((float)((float)(v1 * v1) * v4) + (float)(6.0 * v1)) + 4.0);
  v6 = (float)((float)((float)(v2 * 4.0) * 1.5) * v1) * v5;
  *(float *)(result + 8) = v6;
  *(_DWORD *)(result + 4) = 0;
  *(float *)result = -v6;
  *(float *)(result + 16) = (float)(8.0 - (float)((float)((float)(v1 * v1) * 2.0) * v4)) * v5;
  *(float *)(result + 12) = (float)((float)((float)((float)(v1 * 4.0) * 1.5) + -4.0) - (float)((float)(v1 * v1) * v4))
                          * v5;
  return result;
}
// 802A598: variable 'v3' is possibly undefined
// 802A59C: variable 'v1' is possibly undefined
// 802A5C0: variable 'v2' is possibly undefined

//----- (0802A620) --------------------------------------------------------
_DWORD *__fastcall sub_802A620(_DWORD *result)
{
  result[5] = 0;
  result[2] = 0;
  result[3] = 0;
  result[6] = 0;
  *result = 1084856730;
  result[1] = 1085066445;
  result[4] = 0;
  return result;
}

//----- (0802A658) --------------------------------------------------------
int __fastcall sub_802A658(int result)
{
  *(_DWORD *)(result + 20) = -1138501878;
  *(_DWORD *)(result + 8) = -1138501878;
  *(_DWORD *)(result + 12) = 1025758986;
  *(_DWORD *)(result + 24) = 0;
  *(float *)result = 6.25;
  *(_DWORD *)(result + 4) = 1086681252;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (0802A73C) --------------------------------------------------------
char *sub_802A73C()
{
  float v0; // s0
  char *result; // r0
  float v2; // s2
  float v3; // s0
  float v4; // s0
  float v5; // [sp+0h] [bp-8h]
  float v6; // [sp+0h] [bp-8h]

  result = &byte_200002A4;
  if ( SLODWORD(v0) <= 1065336439 && LODWORD(v0) <= 0xBF7FBE77 )
  {
    v2 = v0 * v0;
    if ( SLODWORD(v0) <= 1061830001 )
    {
      if ( LODWORD(v0) > 0xBF4A3D71 )
      {
        v4 = (float)(1.0 / v2) - 1.0;
        if ( v4 < 0.0 )
          v6 = 0.0;
        else
          v6 = sqrtf(v4);
        flt_20000300 = (float)-v6 * *(float *)&dword_200002FC;
      }
    }
    else
    {
      v3 = (float)(1.0 / v2) - 1.0;
      if ( v3 < 0.0 )
        v5 = 0.0;
      else
        v5 = sqrtf(v3);
      flt_20000300 = v5 * *(float *)&dword_200002FC;
    }
  }
  else
  {
    flt_20000300 = 0.0;
  }
  return result;
}
// 802A74C: variable 'v0' is possibly undefined
// 200002A4: using guessed type char byte_200002A4;
// 200002FC: using guessed type int dword_200002FC;
// 20000300: using guessed type float flt_20000300;

//----- (0802A814) --------------------------------------------------------
int sub_802A814()
{
  float v0; // s0
  int result; // r0

  flt_200027DC = v0;
  sub_802A590((int)&unk_200027C8);
  result = 0;
  dword_2000034C = 0;
  return result;
}
// 802A818: variable 'v0' is possibly undefined
// 2000034C: using guessed type int dword_2000034C;
// 200027DC: using guessed type float flt_200027DC;

//----- (0802A840) --------------------------------------------------------
unsigned int __fastcall sub_802A840(unsigned int result)
{
  float v1; // s0

  if ( result == 10 )
  {
    if ( (unsigned int)(LODWORD(v1) - 1169301505) < 0x47DFFF )
    {
      flt_200025C0 = v1;
      dword_200025BC = 30;
      sub_8029C2E();
    }
LABEL_15:
    JUMPOUT(0x801F13C);
  }
  if ( result < 0xA )
  {
    switch ( result )
    {
      case 1u:
        dword_200025BC = 1;
        goto LABEL_15;
      case 2u:
        flt_200025C0 = v1;
        dword_200025BC = 23;
        sub_8029C2E();
        goto LABEL_15;
      case 3u:
        flt_200025C0 = v1;
        dword_200025BC = 25;
        sub_8029C2E();
        goto LABEL_15;
      case 4u:
        dword_200025BC = 4;
        goto LABEL_15;
      case 6u:
        dword_200025BC = 6;
        goto LABEL_15;
      case 8u:
        flt_200025C0 = v1;
        dword_200025BC = 3;
        sub_8029C2E();
        goto LABEL_15;
      case 9u:
        flt_200025C0 = v1;
        dword_200025BC = 24;
        goto LABEL_15;
      default:
        return result;
    }
  }
  return result;
}
// 8029C40: control flows out of bounds to 801F13C
// 802A864: conditional instruction was optimized away because r0.4<Au
// 802A866: conditional instruction was optimized away because r0.4<Au
// 802A86A: conditional instruction was optimized away because r0.4<Au
// 802A86E: conditional instruction was optimized away because r0.4<Au
// 802A872: conditional instruction was optimized away because r0.4<Au
// 802A8CC: variable 'v1' is possibly undefined
// 200025BC: using guessed type int dword_200025BC;
// 200025C0: using guessed type float flt_200025C0;

//----- (0802AF9C) --------------------------------------------------------
_DWORD *__fastcall sub_802AF9C(_DWORD *result)
{
  float v1; // s0

  *result = 0;
  result[1] = (int)(float)(1000.0 / (float)(v1 + 15.0));
  result[2] = 0;
  result[3] = (int)(float)(1000.0 / (float)(v1 - 5.0));
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[16] = 0;
  result[17] = 0;
  result[15] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  result[18] = 0;
  return result;
}
// 802AFA8: variable 'v1' is possibly undefined

//----- (0802B00C) --------------------------------------------------------
int sub_802B00C()
{
  int v0; // r6
  int v1; // r0
  float v2; // s0
  int v3; // s0
  float v4; // s0
  float v5; // s0
  float v6; // s0
  int v7; // r0
  float v8; // s0
  float v9; // s0
  int v10; // s0
  float v11; // s0
  float v12; // s0
  float v13; // s0
  int v14; // r0
  float v15; // s0
  int v16; // s0
  unsigned int v17; // r0
  unsigned int v18; // r0
  unsigned int v19; // r0
  unsigned int v20; // r0
  int v21; // r0
  int result; // r0
  int v23; // r0

  v0 = 0;
  sub_8029C6A();
  v1 = (unsigned __int8)byte_200002C7++;
  dword_20002558[v1] = dword_20001C08;
  if ( (unsigned __int8)byte_200002C7 >= 0x19u )
    byte_200002C7 = 0;
  LODWORD(flt_2000289C) = dword_20001BF4;
  sub_802A35C(flt_20002894, flt_200028AC);
  dword_20001C10 = LODWORD(flt_200028A8);
  sub_8030CF4(flt_200025D4);
  sub_8030E80((int)&unk_20002660, (unsigned __int8)byte_200002C5);
  if ( (unsigned int)dword_200003AC >= 0xBA83126F && (unsigned int)dword_20002630 < 0xBA83126F )
    v0 = 1;
  if ( byte_200002AA
    && ((unsigned int)dword_200003AC >= 0xBC23D70A && (unsigned int)dword_20002630 < 0xBC23D70A
     || dword_200003AC >= 1008981770 && dword_20002630 < 1008981770) )
  {
    sub_8029BFC();
    byte_200002AA = 0;
  }
  dword_200003AC = dword_20002630;
  if ( byte_200002AB && byte_200002BD == 1 && dword_200027C0 )
  {
    if ( flt_2000261C <= flt_200027B4 )
    {
      if ( COERCE_INT(flt_200027B4 - flt_2000261C) >= 1008981770 )
      {
        flt_200027B4 = flt_200027B4 - 0.001;
      }
      else
      {
        sub_8029C24();
        sub_8029C24();
        sub_8029C24();
        sub_8029C1A();
        flt_200027B4 = flt_2000261C;
        byte_200002BE = 1;
        byte_200002BD = 0;
      }
    }
    else if ( COERCE_INT(flt_2000261C - flt_200027B4) >= 1008981770 )
    {
      flt_200027B4 = flt_200027B4 + 0.005;
    }
    else
    {
      flt_200027B4 = flt_2000261C;
      sub_8029C24();
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      byte_200002BE = 1;
      byte_200002BD = 0;
    }
  }
  sub_8030A94((int)&unk_200027AC);
  sub_802FBEC((int)&unk_20002784, v0);
  if ( !byte_200002A4 )
  {
    if ( byte_200002B2 )
    {
      if ( byte_200002A6 == 4 )
      {
        byte_200002A6 = 0;
        byte_200002A4 = 26;
        if ( flt_200027B4 <= 0.0 )
          flt_200027B4 = 0.0;
        else
          flt_200027B4 = -0.99999;
        flt_200027B8 = 0.0;
        sub_8029C74();
        sub_8029C7E();
      }
      else if ( byte_200002A6 == 33 && byte_200026D8 == 1 )
      {
        byte_200002A6 = 0;
        byte_200002A4 = 33;
        byte_200002C5 = 0;
        sub_8029C74();
        sub_8029C7E();
      }
      if ( byte_200002A6 == 3 && byte_200002AB && v0 == 1 )
      {
        sub_8029C74();
        sub_8029C88();
        byte_200002A6 = 0;
        byte_200002A4 = 3;
        sub_802A658((int)flt_200027E8);
      }
    }
    if ( byte_200002B1 )
    {
      if ( byte_200002A6 == 5 && byte_200002AB && v0 == 1 )
      {
        sub_8029C74();
        sub_8029C7E();
        byte_200002A6 = 0;
        byte_200002A4 = 5;
        sub_802A620(flt_200027E8);
      }
      if ( byte_200002A6 == 9 && byte_200002AB && v0 == 1 )
      {
        sub_8029C74();
        sub_8029C7E();
        byte_200002A6 = 0;
        byte_200002A4 = 9;
        sub_802A658((int)flt_200027E8);
      }
    }
    if ( byte_200002A6 == 23 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 23;
      sub_8029C74();
      sub_8029C7E();
    }
    else if ( byte_200002A6 == 24 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 24;
      sub_8029C74();
      sub_8029C7E();
    }
    else if ( dword_200027C0 && byte_200002A6 == 25 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 25;
      sub_8029C74();
      sub_8029C7E();
    }
    else if ( dword_200027C0 && byte_200002A6 == 26 )
    {
      byte_200002A6 = 0;
      byte_200002A4 = 26;
      sub_8029C74();
      sub_8029C7E();
    }
  }
  if ( byte_200002A6 == 2 )
  {
    byte_200002A4 = 0;
    byte_200002A6 = 0;
    dword_200025BC = 0;
    sub_8029C88();
    goto LABEL_150;
  }
  if ( byte_200002A4 == 23 )
    goto LABEL_77;
  if ( (unsigned __int8)byte_200002A4 > 0x17u )
  {
    if ( byte_200002A4 != 24 )
    {
      if ( byte_200002A4 == 25 )
      {
        v15 = *(float *)&dword_20001BF0;
        sub_8029DAC();
        if ( v15 >= flt_2000035C )
        {
          v16 = dword_20001BF0;
          sub_8029DAC();
          LODWORD(flt_2000035C) = v16;
        }
        if ( dword_200027C0 )
        {
          flt_20000360 = 21.8 - (float)(130.37 / (float)(flt_2000035C + 6.0));
          flt_2000035C = 0.0;
        }
        flt_20000364 = flt_200027B8 * (float)(flt_200025C0 + flt_20000360);
        sub_8029C74();
        goto LABEL_150;
      }
      if ( byte_200002A4 != 26 )
      {
        if ( byte_200002A4 == 33 )
        {
          flt_20002864 = flt_200026DC - *(float *)&dword_2000033C;
          LODWORD(flt_20002868) = dword_20001BF8;
          sub_802A430(&flt_20002864);
          flt_20000364 = (float)(flt_20002870 - *(float *)&dword_20001BF0) * 5.0;
          flt_20000368 = *(float *)&dword_20001BF8 + flt_20000364;
          sub_8029C92();
        }
        goto LABEL_150;
      }
LABEL_76:
      flt_20002864 = (float)(flt_200027B8 * 326.0) - *(float *)&dword_2000033C;
      LODWORD(flt_20002868) = dword_20001BF8;
      sub_802A430(&flt_20002864);
      flt_20000364 = (float)(flt_20002870 - *(float *)&dword_20001BF0) * 10.0;
      flt_20000368 = *(float *)&dword_20001BF8 + flt_20000364;
      sub_8029C92();
      goto LABEL_150;
    }
LABEL_77:
    sub_8029C74();
    goto LABEL_150;
  }
  switch ( byte_200002A4 )
  {
    case 3:
      if ( dword_20000308 < 1045220557 )
        flt_20002460 = 0.0;
      if ( v0 == 1 )
      {
        flt_200002D4 = 0.0;
        v2 = flt_20002460;
        flt_200002D0 = flt_20002460 + flt_200002D0;
        sub_8029DAC();
        flt_200002D8 = v2;
        if ( SLODWORD(v2) >= 1017370378 )
        {
          if ( SLODWORD(v2) >= 1041865114 )
          {
            if ( SLODWORD(v2) >= 1051931443 )
            {
              if ( SLODWORD(v2) >= 1060320051 )
              {
                flt_200002D4 = flt_20002460;
                flt_200002D0 = flt_200002D0 - flt_20002460;
              }
              else
              {
                v6 = flt_200002D0;
                sub_8029DAC();
                if ( v6 > (float)(flt_200002D8 * 2.0) )
                {
                  flt_200002D4 = flt_200002D0;
                  flt_200002D0 = flt_200002D4 - flt_200002D4;
                }
              }
            }
            else
            {
              v5 = flt_200002D0;
              sub_8029DAC();
              if ( v5 > (float)(flt_200002D8 * 3.0) )
              {
                flt_200002D4 = flt_200002D0;
                flt_200002D0 = flt_200002D4 - flt_200002D4;
              }
            }
          }
          else
          {
            v4 = flt_200002D0;
            sub_8029DAC();
            if ( v4 > (float)(flt_200002D8 * 4.0) )
            {
              flt_200002D4 = flt_200002D0;
              flt_200002D0 = flt_200002D4 - flt_200002D4;
            }
          }
        }
        else
        {
          v3 = LODWORD(flt_200002D0);
          sub_8029DAC();
          if ( v3 > 1034147594 )
          {
            flt_200002D4 = flt_200002D0;
            flt_200002D0 = flt_200002D4 - flt_200002D4;
          }
        }
        if ( flt_200002D4 == 0.0 )
          sub_8029C88();
        else
          sub_8029C7E();
      }
      sub_8029C9C();
      if ( v7 )
        sub_802A4CC(flt_200027C8, flt_200027E8);
      goto LABEL_105;
    case 4:
      goto LABEL_76;
    case 5:
      v8 = *(float *)&dword_20001BF4 - flt_200002F4;
      flt_20000358 = *(float *)&dword_20001BF4 - flt_200002F4;
      if ( COERCE_INT(*(float *)&dword_20001BF4 - flt_200002F4) <= 1103626240 )
      {
        if ( LODWORD(v8) > 0xC1C80000 )
        {
          flt_20000358 = (float)(v8 + 25.0) * 0.3;
          flt_20002830 = flt_20002830 - flt_20000358;
          flt_20002810 = flt_20002810 - flt_20000358;
          ++dword_2000034C;
        }
      }
      else
      {
        flt_20000358 = (float)(v8 - 25.0) * 0.3;
        flt_20002830 = flt_20002830 - flt_20000358;
        flt_20002810 = flt_20002810 - flt_20000358;
      }
      if ( flt_20002830 < flt_20002820 )
        flt_20002830 = flt_20002820;
      if ( flt_20002810 < flt_20002820 )
        flt_20002810 = flt_20002820;
      if ( flt_20002830 > flt_2000281C )
        flt_20002830 = flt_2000281C;
      if ( flt_20002810 > flt_2000281C )
        flt_20002810 = flt_2000281C;
      flt_20000354 = (float)(flt_20002810 * -1.4142) / flt_20002798;
      sub_802A4CC(flt_200027C8, flt_200027E8);
      flt_20000350 = (float)(flt_20002800 + *(float *)&dword_20001BEC) / *(float *)&dword_20001BF4;
      sub_8029C74();
      break;
    case 9:
      flt_20000358 = *(float *)&dword_20001BF4 - 510.0;
      if ( (float)(*(float *)&dword_20001BF4 - 510.0) > 0.0 )
      {
        flt_20002460 = flt_20002460 + (float)((float)(*(float *)&dword_20001BF4 - 510.0) * 0.01);
        if ( flt_20002460 > 0.0 )
        {
          flt_20002830 = 0.0;
          flt_20002460 = 0.0;
        }
      }
      if ( dword_20000308 < 1045220557 )
        flt_20002460 = 0.0;
      if ( v0 == 1 )
      {
        flt_200002D4 = 0.0;
        v9 = flt_20002460;
        flt_200002D0 = flt_20002460 + flt_200002D0;
        sub_8029DAC();
        flt_200002D8 = v9;
        if ( SLODWORD(v9) >= 1017370378 )
        {
          if ( SLODWORD(v9) >= 1041865114 )
          {
            if ( SLODWORD(v9) >= 1051931443 )
            {
              if ( SLODWORD(v9) >= 1060320051 )
              {
                flt_200002D4 = flt_20002460;
                flt_200002D0 = flt_200002D0 - flt_20002460;
              }
              else
              {
                v13 = flt_200002D0;
                sub_8029DAC();
                if ( v13 > (float)(flt_200002D8 * 2.0) )
                {
                  flt_200002D4 = flt_200002D0;
                  flt_200002D0 = flt_200002D4 - flt_200002D4;
                }
              }
            }
            else
            {
              v12 = flt_200002D0;
              sub_8029DAC();
              if ( v12 > (float)(flt_200002D8 * 3.0) )
              {
                flt_200002D4 = flt_200002D0;
                flt_200002D0 = flt_200002D4 - flt_200002D4;
              }
            }
          }
          else
          {
            v11 = flt_200002D0;
            sub_8029DAC();
            if ( v11 > (float)(flt_200002D8 * 4.0) )
            {
              flt_200002D4 = flt_200002D0;
              flt_200002D0 = flt_200002D4 - flt_200002D4;
            }
          }
        }
        else
        {
          v10 = LODWORD(flt_200002D0);
          sub_8029DAC();
          if ( v10 > 1034147594 )
          {
            flt_200002D4 = flt_200002D0;
            flt_200002D0 = flt_200002D4 - flt_200002D4;
          }
        }
        if ( flt_200002D4 == 0.0 )
          sub_8029C88();
        else
          sub_8029C7E();
      }
      sub_8029C9C();
      if ( v14 )
        sub_802A4CC(flt_200027C8, flt_200027E8);
LABEL_105:
      flt_20000350 = (float)(flt_20002800 + *(float *)&dword_20001BF8) / *(float *)&dword_20001BF4;
      sub_8029C74();
      break;
  }
LABEL_150:
  if ( byte_200002A7 == 17 )
  {
    byte_200002A7 = 0;
    byte_200002A5 = 17;
    sub_8029CA6();
    sub_8029CEC();
  }
  else if ( (unsigned __int8)byte_200002A7 > 0x11u )
  {
    if ( byte_200002A7 == 21 )
    {
      byte_200002A7 = 0;
      if ( byte_2000050C == 1 )
        byte_200002A5 = 19;
      else
        byte_200002A5 = 21;
      dword_20000040 = 6550;
      sub_8029CA6();
      sub_8029CC4();
      sub_8029CCE();
    }
    else if ( (unsigned __int8)byte_200002A7 > 0x15u )
    {
      if ( byte_200002A7 == 30 )
      {
        byte_200002A7 = 0;
        byte_200002A5 = 30;
        dword_20000040 = (unsigned int)flt_200025C0;
        sub_8029CA6();
        sub_8029CB0();
        if ( byte_200002C3 == 1 )
          sub_8029CBA();
      }
      else if ( byte_200002A7 == 31 )
      {
        byte_200002A7 = 0;
        byte_200002A5 = 31;
        dword_20000040 = (unsigned int)flt_200025C0;
        sub_8029CA6();
        sub_8029CC4();
        if ( byte_200002C3 == 1 )
          sub_8029CCE();
      }
    }
    else if ( byte_200002A7 == 19 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 19;
      dword_20000040 = 6550;
      sub_8029CA6();
      sub_8029CC4();
      sub_8029CCE();
    }
    else if ( byte_200002A7 == 20 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 20;
      dword_20000040 = 6550;
      sub_8029CA6();
      sub_8029CC4();
      sub_8029CCE();
    }
  }
  else if ( byte_200002A7 == 14 )
  {
    byte_200002A7 = 0;
    byte_200002A5 = 14;
    dword_20000040 = 6550;
    sub_8029CA6();
    sub_8029CC4();
    sub_8029CD8();
  }
  else if ( (unsigned __int8)byte_200002A7 > 0xEu )
  {
    if ( byte_200002A7 == 15 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 15;
      dword_20000040 = 6550;
      sub_8029CA6();
      sub_8029CC4();
      sub_8029CD8();
    }
    else if ( byte_200002A7 == 16 )
    {
      byte_200002A7 = 0;
      byte_200002A5 = 16;
      sub_8029CA6();
      sub_8029CB0();
      sub_8029CBA();
    }
  }
  else if ( byte_200002A7 && byte_200002A7 == 13 )
  {
    dword_20000044 = 450;
    byte_200002A7 = 0;
    byte_200002A5 = 13;
    dword_20000040 = 6550;
    sub_8029CA6();
    sub_8029CE2();
  }
  if ( byte_2000003D == 1 && !byte_2000003C )
  {
    if ( *(float *)&dword_20001BF4 <= (float)(flt_20001C14 * 8.5) )
    {
      if ( *(float *)&dword_20001BF4 < (float)(flt_20001C14 * 8.1) )
        sub_8029D00();
    }
    else if ( byte_200002A5 != 15 )
    {
      sub_8029CF6();
    }
  }
  if ( byte_200002A7 == 2 )
  {
    byte_200002A5 = 0;
    byte_200002A7 = 0;
    dword_200025BC = 0;
    sub_8029D0A();
  }
  else
  {
    switch ( byte_200002A5 )
    {
      case 21:
        if ( byte_2000003D == 1 )
        {
          if ( byte_2000003C )
          {
            if ( byte_2000003C == 3 )
            {
              if ( *(float *)&dword_20000318 <= 0.0 )
              {
                if ( (unsigned int)dword_20000318 >= 0xC0800000 )
                {
                  if ( (unsigned int)dword_20000370 > 0xA )
                    dword_20000370 -= 10;
                  if ( (unsigned int)dword_2000036C > 0xA )
                    dword_2000036C -= 10;
                }
                else
                {
                  v19 = dword_20000370++;
                  if ( v19 > 0xEA60 )
                  {
                    dword_2000036C = 0;
                    dword_20000370 = 0;
                    sub_8029CD8();
                    sub_8029D14();
                  }
                }
              }
              else
              {
                v18 = dword_2000036C++;
                if ( v18 > 0x1388 )
                {
                  dword_2000036C = 0;
                  dword_20000370 = 0;
                  sub_8029CB0();
                  sub_8029CBA();
                  sub_8029D14();
                }
              }
            }
          }
          else
          {
            if ( (unsigned int)dword_200002FC > 0xC1A00000 && (unsigned __int8)byte_200002A8 == 206 )
            {
              sub_8029D00();
              sub_8029CB0();
              sub_8029CBA();
              sub_8029D14();
            }
            if ( *(float *)&dword_20001BF4 <= (float)(flt_20001C14 * 9.0) )
            {
              if ( (unsigned int)dword_20000318 <= 0xC0800000 )
              {
                if ( (unsigned int)dword_2000036C > 0xA )
                  dword_2000036C -= 10;
              }
              else
              {
                v17 = dword_2000036C++;
                if ( v17 > 0x5DC )
                {
                  dword_2000036C = 0;
                  dword_20000370 = 0;
                  sub_8029D00();
                  sub_8029CCE();
                  sub_8029D14();
                }
              }
            }
            else
            {
              sub_8029D00();
              sub_8029CB0();
              sub_8029CBA();
              sub_8029D14();
            }
          }
        }
        else if ( byte_2000003C == 1 && byte_2000003D == 3 )
        {
          if ( (unsigned int)dword_20000318 <= 0xBE4CCCCD )
          {
            if ( (unsigned int)dword_20000370 > 0xA )
              dword_20000370 -= 10;
            if ( (unsigned int)dword_2000036C > 0xA )
              dword_2000036C -= 10;
          }
          else
          {
            v20 = dword_2000036C++;
            if ( v20 > 0x1388 )
            {
              dword_2000036C = 0;
              dword_20000370 = 0;
              sub_8029CC4();
              sub_8029CCE();
              sub_8029D14();
            }
          }
        }
        break;
      case 30:
        dword_20000040 = (unsigned int)flt_200025C0;
        break;
      case 31:
        dword_20000040 = (unsigned int)flt_200025C0;
        break;
    }
  }
  if ( byte_200002A4 )
  {
    if ( dword_20001BF0 <= 1106247680 && (unsigned int)dword_20001BF0 <= 0xC1F00000 )
    {
      if ( dword_20001BF4 <= 1141145600 )
      {
        sub_8029C10();
        if ( !v21 )
        {
          byte_200002A6 = 2;
          byte_200002AE = 1;
          byte_200002AF = 1;
          sub_80306FC();
        }
      }
      else
      {
        byte_200002A6 = 2;
        byte_200002AE = 1;
        byte_200002AF = 1;
        sub_8029C24();
        sub_8029C1A();
        LOBYTE(dword_200028C4) = dword_200028C4 | 0x40;
      }
    }
    else
    {
      byte_200002A6 = 2;
      byte_200002AE = 1;
      byte_200002AF = 1;
      sub_8029C24();
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      LOBYTE(dword_200028C4) = dword_200028C4 | 0x20;
    }
  }
  result = (unsigned __int8)byte_200002A5;
  if ( byte_200002A5 )
  {
    sub_8029C10();
    if ( v23 )
    {
      result = dword_20001BF4;
      if ( dword_20001BF4 > 1141145600 )
      {
        if ( byte_200002A5 != 15 || (result = dword_20001BF4, dword_20001BF4 > 1141800960) )
        {
          byte_200002A7 = 2;
          byte_200002AE = 1;
          byte_200002B0 = 1;
          sub_8029C24();
          sub_8029C1A();
          result = (unsigned __int8)dword_200028C4 | 0x40;
          LOBYTE(dword_200028C4) = dword_200028C4 | 0x40;
        }
      }
    }
    else
    {
      byte_200002A7 = 2;
      byte_200002AE = 1;
      byte_200002B0 = 1;
      word_20000522 = 1;
      return sub_80306FC();
    }
  }
  return result;
}
// 802B5F4: variable 'v7' is possibly undefined
// 802B90E: variable 'v14' is possibly undefined
// 802BE66: variable 'v21' is possibly undefined
// 802BE86: variable 'v23' is possibly undefined
// 2000003C: using guessed type char byte_2000003C;
// 2000003D: using guessed type char byte_2000003D;
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 200002A4: using guessed type char byte_200002A4;
// 200002A5: using guessed type char byte_200002A5;
// 200002A6: using guessed type char byte_200002A6;
// 200002A7: using guessed type char byte_200002A7;
// 200002A8: using guessed type char byte_200002A8;
// 200002AA: using guessed type char byte_200002AA;
// 200002AB: using guessed type char byte_200002AB;
// 200002AE: using guessed type char byte_200002AE;
// 200002AF: using guessed type char byte_200002AF;
// 200002B0: using guessed type char byte_200002B0;
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200002BD: using guessed type char byte_200002BD;
// 200002BE: using guessed type char byte_200002BE;
// 200002C3: using guessed type char byte_200002C3;
// 200002C5: using guessed type char byte_200002C5;
// 200002C7: using guessed type char byte_200002C7;
// 200002D0: using guessed type float flt_200002D0;
// 200002D4: using guessed type float flt_200002D4;
// 200002D8: using guessed type float flt_200002D8;
// 200002F4: using guessed type float flt_200002F4;
// 200002FC: using guessed type int dword_200002FC;
// 20000308: using guessed type int dword_20000308;
// 20000318: using guessed type int dword_20000318;
// 2000033C: using guessed type int dword_2000033C;
// 2000034C: using guessed type int dword_2000034C;
// 20000350: using guessed type float flt_20000350;
// 20000354: using guessed type float flt_20000354;
// 20000358: using guessed type float flt_20000358;
// 2000035C: using guessed type float flt_2000035C;
// 20000360: using guessed type float flt_20000360;
// 20000364: using guessed type float flt_20000364;
// 20000368: using guessed type float flt_20000368;
// 2000036C: using guessed type int dword_2000036C;
// 20000370: using guessed type int dword_20000370;
// 200003AC: using guessed type int dword_200003AC;
// 2000050C: using guessed type char byte_2000050C;
// 20000522: using guessed type __int16 word_20000522;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BF8: using guessed type int dword_20001BF8;
// 20001C08: using guessed type int dword_20001C08;
// 20001C10: using guessed type int dword_20001C10;
// 20001C14: using guessed type float flt_20001C14;
// 20001C20: using guessed type int dword_20001C20;
// 20002460: using guessed type float flt_20002460;
// 20002558: using guessed type _DWORD dword_20002558[25];
// 200025BC: using guessed type int dword_200025BC;
// 200025C0: using guessed type float flt_200025C0;
// 200025D4: using guessed type float flt_200025D4[15];
// 2000261C: using guessed type float flt_2000261C;
// 20002630: using guessed type int dword_20002630;
// 200026D8: using guessed type char byte_200026D8;
// 200026DC: using guessed type float flt_200026DC;
// 20002798: using guessed type float flt_20002798;
// 200027B4: using guessed type float flt_200027B4;
// 200027B8: using guessed type float flt_200027B8;
// 200027C0: using guessed type int dword_200027C0;
// 200027C8: using guessed type float flt_200027C8[5];
// 200027E8: using guessed type float flt_200027E8[6];
// 20002800: using guessed type float flt_20002800;
// 20002810: using guessed type float flt_20002810;
// 2000281C: using guessed type float flt_2000281C;
// 20002820: using guessed type float flt_20002820;
// 20002830: using guessed type float flt_20002830;
// 20002864: using guessed type float flt_20002864;
// 20002868: using guessed type float flt_20002868;
// 20002870: using guessed type float flt_20002870;
// 20002894: using guessed type float flt_20002894[2];
// 2000289C: using guessed type float flt_2000289C;
// 200028A8: using guessed type float flt_200028A8;
// 200028AC: using guessed type float flt_200028AC[5];
// 200028C4: using guessed type int dword_200028C4;

//----- (0802BF18) --------------------------------------------------------
void sub_802BF18()
{
  int v0; // r0
  float v1; // s22
  __int64 v2; // r0
  float v3; // s0
  char v4; // r11
  bool v5; // cf
  bool v6; // zf
  unsigned int v7; // r0
  int v8; // s24
  unsigned int v9; // r0
  bool v10; // cf
  float v11; // s19
  float v12; // s0
  float v13; // s19
  float v14; // s0
  float v15; // s19
  float v16; // s19
  int v17; // r0
  int v18; // r0
  float v19; // s19
  int v20; // s0
  unsigned int v21; // r1
  float v22; // s19
  int v23; // r0
  int v24; // r0
  int v25; // r0
  float v26; // s19
  float v27; // s0
  float v28; // s19
  int v29; // r0
  float v30; // s0
  float v31; // s1
  float v32; // s2
  float v33; // s0
  float v34; // s0
  float v35; // s0
  float v36; // s0
  float v37; // s0
  float v38; // s1
  float v39; // s0
  float v40; // s0
  float v41; // s1
  float v42; // s2
  float v43; // s3
  float v44; // s1
  float v45; // s0
  float v46; // s2
  float v47; // s1
  float v48; // s0
  float v49; // s0

  if ( byte_200002C8 == 1 )
  {
    if ( LODWORD(flt_200025C8) == 1114636288 )
      flt_200027B0 = 0.0042;
    else
      flt_200027B0 = 0.0035333;
  }
  else if ( LODWORD(flt_200025C8) == 1114636288 )
  {
    flt_200027B0 = 0.004;
  }
  else
  {
    flt_200027B0 = 0.0033333;
  }
  v0 = dword_20000384++;
  if ( v0 > 1000 )
  {
    dword_20000384 = 0;
    sub_8029D1E();
  }
  v1 = *(float *)&dword_20001C24 + 0.0;
  sub_8029D28();
  sub_8029D32(v2);
  flt_200002F0 = 0.0;
  ((void (__fastcall *)(void *))loc_802ADAC)(&unk_20002738);
  sub_802FD28();
  sub_803078C();
  sub_80308EC();
  sub_8029F04();
  v3 = *(float *)&dword_20001BEC;
  sub_8029DAC();
  *(float *)&dword_2000031C = (float)(v3 * 0.05) + (float)(*(float *)&dword_2000031C * 0.95);
  ++dword_20000374;
  if ( byte_200002C9 != byte_200002A8 )
    dword_20000374 = 0;
  byte_200002C9 = byte_200002A8;
  v4 = 2;
  if ( byte_200002A8 == 101 )
  {
    if ( dword_200025BC != 1 )
    {
      if ( byte_200002B4 )
      {
        if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
        {
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
            v16 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          else
            v16 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v16) < 1138819072 )
            v16 = 450.0;
          dword_20000044 = (unsigned int)v16;
          if ( dword_20000374 > 3000 )
          {
            sub_8029C1A();
            byte_200002A8 = 1;
          }
        }
        else
        {
          sub_8029C1A();
          byte_200002A8 = 102;
          byte_200002A7 = 21;
        }
      }
      else
      {
LABEL_920:
        sub_8029C1A();
        byte_200002A8 = 1;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_922;
    }
    goto LABEL_914;
  }
  if ( (unsigned __int8)byte_200002A8 > 0x65u )
  {
    if ( (unsigned __int8)byte_200002A8 == 217 )
    {
      if ( dword_200025BC == 1 )
      {
        sub_8029C1A();
        byte_200002A8 = 1;
      }
      else
      {
        if ( byte_200002B3 && byte_200002B1 && byte_200002AE != 1 )
        {
          if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = -56;
            byte_200002A6 = 2;
          }
        }
        else
        {
          sub_8029C1A();
          byte_200002A8 = -56;
          dword_200002DC = 60000;
          byte_200002A6 = 2;
        }
        if ( dword_20000374 >= 100 )
        {
          if ( SLODWORD(flt_20001C14) < 1113325568 && SLODWORD(flt_20001C18) < 1092616192 )
            flt_200002F4 = flt_200002F4 + 0.001;
          *(float *)&dword_200002FC = -flt_20002810;
          if ( byte_200002B5 == 1 )
            dword_200002FC = -990248960;
          if ( SLODWORD(flt_200002F4) > 1139474432 )
            flt_200002F4 = 470.0;
          if ( dword_20001BF4 <= 1139146752 )
          {
            if ( byte_200002B4 && !byte_200002B7 )
            {
              byte_200002C0 = 1;
              sub_8029C1A();
              byte_200002A8 = -56;
            }
          }
          else
          {
            sub_8029C24();
            sub_8029C24();
            sub_8029C1A();
            sub_8029C1A();
            byte_200002A8 = -56;
            dword_200002DC = 60000;
          }
        }
      }
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 > 0xD9u )
    {
      v7 = (unsigned __int8)byte_200002A8 - 218;
      v8 = 1137836032;
      v5 = v7 >= 0x11;
      switch ( byte_200002A8 )
      {
        case -38:
          goto LABEL_922;
        case -37:
          byte_200002A6 = 23;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -36:
          byte_200002A6 = 25;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -35:
          byte_200002A6 = 26;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -34:
          byte_200002A6 = 24;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -33:
          byte_200002A7 = 30;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -32:
          byte_200002A7 = 31;
          byte_200002A8 = 2;
          goto LABEL_922;
        case -31:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( dword_200002DC <= 0 )
          {
            sub_8029D3C();
            byte_200002AE = 0;
            sub_803085C();
            if ( byte_200002A9 )
            {
              if ( byte_200002A9 == 2 )
              {
                sub_8029C10();
                if ( v25 == 1 )
                {
                  sub_8029BFC();
                  byte_200002A9 = 0;
                }
              }
            }
            else
            {
              sub_8029C10();
              if ( v24 )
              {
                if ( byte_200002AB )
                {
                  sub_8029C74();
                  if ( dword_20001BF4 <= 1131413504 )
                    byte_200002A8 = -29;
                  else
                    byte_200002A8 = -30;
                }
                else
                {
                  sub_8029C1A();
                  byte_200002A8 = -25;
                }
              }
              else
              {
                byte_200002A9 = 2;
                sub_8029BFC();
                sub_8029C24();
                sub_8029C1A();
              }
            }
          }
          else
          {
            if ( dword_200002DC > 2000 )
              sub_8029BFC();
            --dword_200002DC;
          }
          goto LABEL_922;
        case -30:
          if ( dword_20000374 == 1 )
            sub_8029BFC();
          if ( dword_20001BF4 > 1131413504 )
            byte_200002A8 = -29;
          if ( dword_20000374 > 3000 )
          {
            sub_8029C1A();
            BYTE1(dword_200028C4) |= 8u;
            dword_200002DC = 60000;
            byte_200002A8 = -56;
          }
          goto LABEL_922;
        case -29:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029BFC();
            sub_8029BFC();
          }
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( !byte_200002AB || byte_200002AE == 1 || byte_20000511 == 1 || byte_20002FD3 == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          else
          {
            if ( dword_20000374 == 60 )
              sub_8029BFC();
            if ( dword_20000374 == 80 )
              sub_8029BFC();
            if ( dword_20000374 == 120 )
            {
              sub_803085C();
              dword_200002FC = -1007026176;
              sub_802A4A4(&flt_20002804);
              flt_2000287C = 19.5;
              flt_20002880 = -19.5;
              flt_20002810 = 200.0;
              if ( *(float *)&dword_20001BF4 >= (float)(flt_20002798 * 1.5) )
                flt_200002F4 = *(float *)&dword_20001BF4 + 10.0;
              else
                flt_200002F4 = flt_20002798 * 1.5;
              sub_8029C1A();
              byte_200002A6 = 5;
            }
            if ( dword_20000374 >= 160 )
            {
              if ( SLODWORD(flt_200002F4) >= 1137836032 )
              {
                if ( SLODWORD(flt_200002F4) > 1137836032 )
                  flt_200002F4 = flt_200002F4 - 0.05;
              }
              else
              {
                flt_200002F4 = flt_200002F4 + 0.05;
              }
              if ( (unsigned int)(LODWORD(flt_200002F4) - 1137737728) <= 0x30000 && byte_200002B2 )
              {
                if ( *(float *)&dword_20001BF4 > (float)(*(float *)&dword_20001BFC * 8.2) )
                {
                  byte_200002A8 = -28;
                }
                else
                {
                  sub_8029C1A();
                  byte_200002A8 = -27;
                  byte_200002A7 = 20;
                  flt_200002F4 = 420.0;
                }
              }
              else if ( dword_20000374 > 10000 )
              {
                sub_8029C1A();
                BYTE1(dword_200028C4) |= 8u;
                dword_200002DC = 60000;
                byte_200002A8 = -25;
              }
            }
          }
          goto LABEL_922;
        case -28:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( byte_200002B2 && byte_200002AB && byte_200002AE != 1 )
          {
            if ( dword_20000374 == 1 )
            {
              flt_2000037C = 0.0;
              sub_8029C1A();
              byte_200002A7 = 17;
              dword_20000380 = 0;
            }
            flt_2000037C = flt_2000037C + 0.0005;
            if ( SLODWORD(flt_2000037C) > 1065185444 )
              flt_2000037C = 1.0;
            v26 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
            if ( SLODWORD(v26) < 1138819072 )
              v26 = 450.0;
            dword_20000044 = (unsigned int)v26;
            if ( *(float *)&dword_20001BF4 <= (float)(*(float *)&dword_20001BFC * 8.2) )
            {
              sub_8029C1A();
              byte_200002A8 = -27;
              byte_200002A7 = 20;
              flt_200002F4 = 420.0;
              goto LABEL_922;
            }
            if ( (float)(*(float *)&dword_20001BFC * 8.5) > *(float *)&dword_20001BF4 )
              sub_8029CF6();
          }
          else
          {
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 > 5000 )
          {
            sub_8029C1A();
            byte_200002A8 = -25;
          }
          break;
        case -27:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( !byte_200002B2 || !byte_200002AB || byte_200002AE == 1 )
          {
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -25;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 > 200 )
            byte_200002A5 = 22;
          goto LABEL_922;
        case -26:
          goto LABEL_921;
        case -25:
          byte_200002AA = 0;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          byte_200002A8 = -31;
          dword_200002DC = 60000;
          sub_8029BFC();
          sub_8029BFC();
          sub_803085C();
          goto LABEL_922;
        case -24:
          if ( !byte_200002B4 )
            goto LABEL_170;
          if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
          {
            dword_20000044 = 450;
            byte_200002A7 = 13;
            byte_200002A8 = -23;
          }
          else
          {
            byte_200002A8 = -22;
            byte_200002A7 = 15;
          }
          goto LABEL_922;
        case -23:
          if ( dword_200025BC == 1 || !byte_200002B4 )
          {
            sub_8029C1A();
            byte_200002A8 = 1;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          if ( *(float *)&dword_20001BF4 >= (float)(*(float *)&dword_20001BFC * 8.3) )
          {
            dword_20000040 = 6550;
            byte_200002A8 = -22;
            byte_200002A7 = 15;
          }
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          v27 = (float)(flt_2000037C * 850.0) + 5700.0;
          if ( v27 <= (float)(unsigned int)dword_20000040 )
            v28 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v27) - 180.0;
          else
            v28 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v28) < 1138819072 )
            v28 = 450.0;
          dword_20000044 = (unsigned int)v28;
          dword_20000040 = (unsigned int)v27;
          if ( dword_20000374 > 3000 )
            goto LABEL_914;
          goto LABEL_922;
        case -22:
          if ( dword_200025BC != 1 && byte_200002B4 && !byte_200002AE )
            goto LABEL_922;
          sub_8029C10();
          if ( !v29 )
            word_20000522 = 1;
          goto LABEL_920;
        default:
          goto LABEL_59;
      }
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 == 207 )
    {
      if ( dword_20000374 == 1 )
        sub_8029BFC();
      if ( dword_20001BF4 > 1131413504 )
        byte_200002A8 = -48;
      if ( dword_20000374 > 3000 )
      {
LABEL_646:
        sub_8029C1A();
        BYTE1(dword_200028C4) |= 8u;
        dword_200002DC = 60000;
        byte_200002A8 = -56;
      }
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 > 0xCFu )
    {
      v7 = (unsigned __int8)byte_200002A8 - 208;
      v8 = -1018691584;
      v5 = v7 >= 9;
LABEL_59:
      switch ( v7 )
      {
        case 0u:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029BFC();
            flt_200002F4 = *(float *)&dword_20001BFC * 8.2;
            if ( COERCE_INT(*(float *)&dword_20001BFC * 8.2) < 1136197632 )
            {
              flt_200002F4 = 370.0;
              sub_8029C1A();
              byte_200002A8 = -41;
              goto LABEL_922;
            }
          }
          if ( dword_200025BC == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = 1;
            goto LABEL_922;
          }
          if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
            goto LABEL_559;
          if ( byte_200002AE == 1 )
          {
            dword_200002F8 = 0;
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            goto LABEL_922;
          }
          if ( dword_20000374 == 60 )
            sub_8029BFC();
          if ( dword_20000374 == 80 )
            sub_8029BFC();
          if ( dword_20000374 == 120 )
          {
            sub_803085C();
            dword_200002FC = v8;
            sub_802A4A4(&flt_20002804);
            flt_20002810 = 200.0;
            if ( *(float *)&dword_20001BF4 >= (float)(flt_20002798 * 1.5) )
              flt_200002F4 = *(float *)&dword_20001BF4 + 10.0;
            else
              flt_200002F4 = flt_20002798 * 1.5;
            sub_8029C1A();
            byte_200002A6 = 9;
          }
          if ( dword_20000374 < 160 )
            goto LABEL_922;
          if ( (float)(*(float *)&dword_20001BFC * 8.2) <= flt_200002F4 )
          {
            if ( (float)(*(float *)&dword_20001BFC * 8.5) < flt_200002F4 )
              flt_200002F4 = flt_200002F4 - 0.05;
          }
          else
          {
            flt_200002F4 = flt_200002F4 + 0.05;
          }
          if ( (float)(*(float *)&dword_20001BFC * 8.1) <= flt_200002F4
            && (float)(*(float *)&dword_20001BFC * 8.5) >= flt_200002F4
            && byte_200002B2 )
          {
            byte_200002A8 = -47;
            goto LABEL_922;
          }
          if ( dword_20000374 > 10000 )
            goto LABEL_646;
          goto LABEL_922;
        case 1u:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_922;
          }
          if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
            goto LABEL_559;
          if ( dword_20000374 > 200 )
          {
            sub_8029C1A();
            byte_200002A7 = 21;
            byte_200002A8 = -46;
          }
          goto LABEL_922;
        case 2u:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( byte_200002B3 && byte_200002B1 && byte_200002B2 && byte_200002AE != 1 )
          {
            if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
            {
              sub_8029C1A();
              byte_200002A8 = -56;
              byte_200002A6 = 2;
            }
          }
          else
          {
            sub_8029C1A();
            byte_200002A8 = -56;
            dword_200002DC = 60000;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 >= 100 )
          {
            if ( (unsigned int)dword_200002FC < 0xC47A0000 )
              *(float *)&dword_200002FC = *(float *)&dword_200002FC - 0.1;
            if ( (unsigned int)dword_200002F8 <= 0xC1A00000 )
            {
              if ( byte_200002B4 || !byte_200002B7 )
              {
                sub_8029C1A();
                byte_200002C0 = 1;
                byte_200002A8 = -56;
              }
            }
            else
            {
              byte_200002C0 = 1;
              byte_200002A8 = -50;
            }
          }
          goto LABEL_922;
        case 3u:
        case 5u:
          goto LABEL_921;
        case 4u:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( !byte_200002B2 || byte_200002B0 == 1 || byte_200002AF == 1 || !byte_200002B4 )
            goto LABEL_796;
          if ( byte_200002AE == 1 )
          {
            sub_8029C1A();
            dword_200002DC = 300000;
            byte_200002A8 = -56;
            goto LABEL_922;
          }
          if ( !byte_20002F5F[0] && byte_20002FD3 != 2 || byte_20000511 == 1 || byte_20002FD3 == 1 )
            goto LABEL_798;
          if ( dword_20000374 == 1 )
          {
            byte_200002A7 = 21;
            sub_803085C();
          }
          if ( byte_20002FD3 == 2 )
          {
            if ( dword_20000374 == 15 )
            {
              byte_200002C5 = 1;
              sub_8030C20((int)&unk_20002660);
            }
            else if ( dword_20000374 == 250 )
            {
              sub_8029C1A();
              sub_803085C();
              byte_200002A7 = 19;
              byte_200002A6 = 33;
            }
            if ( dword_20000374 >= 350 && byte_200002AB )
            {
              sub_8029C1A();
              byte_200002A6 = 2;
              byte_200002A7 = 21;
              byte_200002A8 = -52;
              dword_200002E8 = 0;
            }
          }
          else
          {
            if ( dword_20000374 == 9 )
            {
              sub_8029C1A();
              sub_803085C();
              byte_200002A6 = 4;
              byte_200002BE = 0;
            }
            if ( dword_20000374 >= 10 && byte_200002AB )
            {
              if ( byte_200002BE )
              {
                byte_200002BD = 0;
                byte_200002BF = 0;
                byte_200002A8 = -42;
              }
              else
              {
                byte_200002BD = 1;
              }
            }
          }
          goto LABEL_922;
        case 6u:
          if ( dword_20000374 == 1 )
            sub_803085C();
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( byte_200002B2 && byte_200002AE != 1 && byte_200002B4 )
          {
            if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
            {
LABEL_798:
              sub_8029C1A();
              byte_200002A8 = -56;
            }
            else
            {
              byte_200002AA = 1;
              if ( byte_200002BF )
              {
                if ( (unsigned __int8)byte_200002BF + 7 < dword_20000374 )
                {
                  sub_8029C1A();
                  byte_200002A6 = 2;
                  byte_200002A8 = -52;
                }
              }
              else
              {
                sub_8029C10();
                if ( v23 == 1 )
                  byte_200002BF = dword_20000374;
              }
              if ( dword_20000374 > 100 )
              {
                sub_8029C1A();
                BYTE1(dword_200028C4) |= 8u;
                byte_200002A8 = -56;
              }
            }
          }
          else
          {
LABEL_796:
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -56;
          }
          goto LABEL_922;
        case 7u:
          if ( dword_20000374 == 1 )
          {
            byte_200002AA = 1;
            sub_8029BFC();
            sub_8029BFC();
          }
          if ( dword_200025BC == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = 1;
            goto LABEL_922;
          }
          if ( !byte_200002B3 || !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = -56;
            dword_200002DC = 60000;
            byte_200002A6 = 2;
            goto LABEL_922;
          }
          if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_922;
          }
          if ( dword_20000374 == 60 )
            sub_8029BFC();
          if ( dword_20000374 == 80 )
            sub_8029BFC();
          if ( dword_20000374 == 120 )
          {
            sub_803085C();
            dword_200002FC = v8;
            sub_802A4A4(&flt_20002804);
            flt_20002810 = 200.0;
            if ( *(float *)&dword_20001BF4 >= (float)(flt_20002798 * 1.5) )
              flt_200002F4 = *(float *)&dword_20001BF4 + 10.0;
            else
              flt_200002F4 = flt_20002798 * 1.5;
            sub_8029C1A();
            byte_200002A6 = 5;
            dword_200002E4 = 0;
          }
          if ( dword_20000374 >= 125 )
          {
            if ( SLODWORD(flt_200002F4) >= 1135869952 )
            {
              if ( SLODWORD(flt_200002F4) > 1135869952 )
                flt_200002F4 = flt_200002F4 - 0.05;
            }
            else
            {
              flt_200002F4 = flt_200002F4 + 0.05;
            }
            if ( (unsigned int)(dword_20001BF4 - 1135706113) >= 0x4FFFF )
              dword_200002E4 = 0;
            else
              ++dword_200002E4;
            if ( (unsigned int)dword_200002E4 > 0x3E8 )
            {
              dword_20000044 = 450;
              byte_200002A8 = -40;
            }
            if ( dword_20000374 > 5000 )
              goto LABEL_646;
          }
          goto LABEL_922;
        case 8u:
          if ( dword_200025BC == 1 )
            goto LABEL_914;
          if ( !byte_200002B1 || byte_200002AE == 1 )
          {
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -56;
            byte_200002A6 = 2;
            goto LABEL_922;
          }
          if ( !byte_200002AB || byte_20000511 == 1 || byte_20002FD3 == 1 )
            goto LABEL_559;
          if ( dword_20000374 == 1 )
          {
            flt_2000037C = 0.0;
            sub_8029C1A();
            byte_200002A7 = 17;
            dword_20000380 = 0;
          }
          if ( dword_20000374 < 10000 )
          {
            v21 = dword_20001BFC;
            if ( dword_20001BFC <= 1113063424 )
              goto LABEL_670;
            goto LABEL_662;
          }
          v21 = dword_20001BFC;
          if ( dword_20001BFC > 1113063424 )
          {
LABEL_662:
            sub_8029D46(1113063424, v21, 10000);
            dword_20000380 = dword_20000374;
            goto LABEL_670;
          }
          if ( dword_20001C00 <= 1106247680 )
          {
            if ( dword_20001C00 <= 1092616192 && (dword_20001C00 <= 1084227584 || SLODWORD(flt_20001C14) >= 1106247680) )
              flt_2000037C = flt_2000037C + 0.00005;
          }
          else
          {
            flt_2000037C = 0.0;
          }
LABEL_670:
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          v22 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          if ( SLODWORD(v22) < 1138819072 )
            v22 = 450.0;
          dword_20000044 = (unsigned int)v22;
          *(float *)&dword_200002FC = -flt_20002810;
          if ( dword_20000374 <= 6000 )
            goto LABEL_922;
          if ( SLODWORD(flt_20001C14) >= 1110179840 )
          {
            if ( SLODWORD(flt_2000037C) > 1065185444 && (unsigned int)(dword_20000374 - dword_20000380) > 0x1770 )
            {
              byte_200002A7 = 19;
              byte_200002A8 = -39;
              goto LABEL_922;
            }
            if ( dword_20000374 > 60000 )
            {
              sub_8029C1A();
              if ( byte_200002B5 )
              {
                byte_200002A8 = -56;
              }
              else
              {
                BYTE1(dword_200028C4) |= 8u;
                byte_200002A8 = -56;
                dword_200002DC = 60000;
              }
              goto LABEL_922;
            }
          }
          if ( dword_20000374 <= 6000000 )
            goto LABEL_922;
          break;
        default:
          goto LABEL_15;
      }
LABEL_471:
      sub_8029C1A();
      BYTE1(dword_200028C4) |= 8u;
      byte_200002A8 = -56;
      dword_200002DC = 60000;
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 == 203 )
    {
      if ( dword_200025BC == 1 )
        goto LABEL_914;
      if ( !byte_200002B4 )
      {
LABEL_514:
        sub_8029C1A();
        dword_200002DC = 60000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_922;
      }
      if ( byte_20000511 != 1 && byte_20002FD3 != 1 )
      {
        if ( *(float *)&dword_20001BF4 >= (float)(*(float *)&dword_20001BFC * 8.3) )
        {
          sub_8029C1A();
          dword_200002E8 = 0;
          byte_200002A8 = -52;
          dword_200002DC = 0;
          byte_200002A7 = 21;
          goto LABEL_922;
        }
        flt_2000037C = (float)dword_20000374 * 0.001;
        if ( SLODWORD(flt_2000037C) > 1065185444 )
          flt_2000037C = 1.0;
        if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
          v19 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
        else
          v19 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
        if ( SLODWORD(v19) < 1138819072 )
          v19 = 450.0;
        dword_20000044 = (unsigned int)v19;
        if ( dword_20000374 <= 3000 )
          goto LABEL_922;
        goto LABEL_471;
      }
LABEL_521:
      sub_8029C1A();
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 <= 0xCBu )
    {
      if ( byte_200002A8 == 102 )
      {
        byte_200002A8 = 2;
        goto LABEL_922;
      }
      if ( (unsigned __int8)byte_200002A8 == 200 )
      {
        byte_200002AA = 0;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = -54;
        dword_200002F8 = 0;
        sub_8029BFC();
        sub_8029BFC();
        sub_8029BFC();
        sub_803085C();
        goto LABEL_922;
      }
      if ( (unsigned __int8)byte_200002A8 == 201 )
      {
        byte_200002AA = 0;
        byte_200002A6 = 2;
        byte_200002A8 = -52;
        byte_200002A7 = 21;
        sub_8029BFC();
        sub_8029BFC();
        sub_803085C();
        goto LABEL_922;
      }
      v6 = (unsigned __int8)byte_200002A8 == 202;
      if ( (unsigned __int8)byte_200002A8 != 202 )
      {
LABEL_25:
        if ( v6 )
        {
          if ( dword_200025BC == 1 || !byte_200002B4 )
          {
            sub_8029C1A();
            byte_200002A8 = 44;
            byte_200002A7 = v4;
            byte_200002A6 = v4;
          }
          if ( byte_200002B2 )
          {
            sub_8029BFC();
            byte_200002A8 = 43;
          }
          if ( dword_20000374 > 2000 )
          {
            sub_8029C1A();
            byte_200002A8 = 44;
          }
          goto LABEL_922;
        }
        goto LABEL_921;
      }
      if ( dword_200025BC != 1 )
      {
        byte_200002AE = 0;
        byte_200002AF = 0;
        byte_200002B0 = 0;
        byte_200002C0 = 1;
        sub_803085C();
        if ( dword_20000374 >= 1000 )
        {
          if ( byte_20000511 )
          {
            dword_200002DC = 2000;
          }
          else if ( dword_200002DC <= 0 )
          {
            sub_8029D3C();
            if ( byte_20002FD3 != 1 )
            {
              if ( byte_200002A9 )
              {
                if ( byte_200002A9 == 2 )
                {
                  sub_8029C10();
                  if ( v18 == 1 )
                  {
                    sub_8029BFC();
                    byte_200002A9 = 0;
                  }
                }
                else if ( byte_200002A9 == 3 )
                {
                  if ( byte_200002B5 )
                  {
                    if ( (unsigned int)(dword_20000374 - 10000) >= 0xBB9 )
                      byte_200002A9 = 0;
                  }
                  else if ( dword_20000374 == 10000 )
                  {
                    byte_200002C6 = 1;
                  }
                  else if ( dword_20000374 > 30000
                         && byte_200002B3
                         && byte_200002AB
                         && !byte_200002B4
                         && byte_200002B7 == 1 )
                  {
                    sub_8029C74();
                    byte_200002C0 = 0;
                    if ( dword_20001BF4 <= 1131413504 )
                      byte_200002A8 = -49;
                    else
                      byte_200002A8 = -48;
                  }
                }
                else
                {
                  byte_200002A9 = 0;
                }
              }
              else
              {
                sub_8029C10();
                if ( v17 )
                {
                  if ( byte_200002B5 )
                  {
                    if ( byte_200002B6 )
                    {
                      dword_200002DC = 3000;
                    }
                    else if ( byte_200002B4 )
                    {
                      if ( byte_20002F5F[0] || *(float *)&dword_200002F8 != 0.0 && byte_200002AB || byte_20002FD3 == 2 )
                      {
                        if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
                        {
                          sub_8029C1A();
                          dword_20000044 = 450;
                          byte_200002A7 = 13;
                          byte_200002A8 = -53;
                        }
                        else
                        {
                          sub_8029C1A();
                          dword_200002E8 = 0;
                          byte_200002A8 = -52;
                          dword_200002DC = 0;
                          byte_200002A7 = 21;
                          byte_200002AA = 1;
                          sub_8029BFC();
                        }
                      }
                    }
                    else if ( byte_200002B3
                           && byte_200002AB
                           && (unsigned int)dword_20002E88 <= 1
                           && (byte_200002B7 || (unsigned int)dword_200002F8 > 0xC1200000) )
                    {
                      sub_8029C74();
                      if ( dword_20001BF4 <= 1131413504 )
                        byte_200002A8 = -49;
                      else
                        byte_200002A8 = -48;
                    }
                  }
                  else
                  {
                    byte_200002A9 = 3;
                    sub_8029C1A();
                  }
                }
                else
                {
                  byte_200002A9 = 2;
                  sub_8029BFC();
                  sub_8029C24();
                  sub_8029C1A();
                }
              }
            }
          }
          else
          {
            if ( dword_200002DC > 2000 )
              sub_8029D3C();
            --dword_200002DC;
          }
        }
        goto LABEL_922;
      }
LABEL_914:
      sub_8029C1A();
      byte_200002A8 = 1;
      goto LABEL_922;
    }
    if ( (unsigned __int8)byte_200002A8 != 204 )
    {
      if ( (unsigned __int8)byte_200002A8 == 205 )
      {
        if ( dword_200025BC != 1 )
        {
          if ( !byte_200002B2 || byte_200002B0 == 1 )
          {
            sub_8029C1A();
            dword_200002DC = 60000;
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          else if ( byte_20000511 == 1 || byte_20002FD3 == 1 )
          {
            sub_8029C1A();
            byte_200002A8 = -56;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          else if ( byte_200002AF == 1 || !byte_200002AB )
          {
            sub_8029C1A();
            byte_200002A8 = -55;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 >= 40 )
          {
            sub_803085C();
            byte_200002A6 = 9;
            sub_8029C1A();
            byte_200002A7 = 21;
            byte_200002A8 = -50;
          }
          goto LABEL_922;
        }
      }
      else if ( dword_200025BC != 1 )
      {
        if ( byte_200002AE || !byte_200002B2 || !byte_200002B5 )
        {
          dword_200002F8 = 0;
          sub_8029C1A();
          dword_200002DC = 60000;
          byte_200002A8 = -56;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          goto LABEL_922;
        }
        if ( byte_20000511 != 1 && byte_20002FD3 != 1 )
        {
          if ( !byte_200002AB )
          {
            if ( byte_20002F5F[0] || byte_20002FD3 == 2 )
            {
              sub_8029C1A();
              byte_200002A6 = 2;
              byte_200002AA = 0;
              sub_803085C();
              sub_8029BFC();
              sub_8029BFC();
              byte_200002A8 = -44;
            }
            else
            {
LABEL_559:
              sub_8029C1A();
              byte_200002A8 = -56;
              byte_200002A6 = 2;
            }
            goto LABEL_922;
          }
          if ( !byte_200002B3 && *(float *)&dword_200002F8 < -0.0 )
          {
            dword_200002F8 = 0;
            sub_8029C1A();
            byte_200002A8 = -55;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            dword_200002DC = 2000;
            goto LABEL_922;
          }
          if ( byte_200002B4 || (unsigned int)dword_200002F8 >= 0xC0A00000 )
          {
            if ( *(float *)&dword_200002F8 == 0.0 )
            {
              sub_8029C1A();
              byte_200002A8 = -55;
              byte_200002A6 = 2;
            }
            else
            {
              dword_200002FC = dword_200002F8;
            }
            goto LABEL_922;
          }
        }
        dword_200002F8 = 0;
        sub_8029C1A();
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_922;
      }
      goto LABEL_914;
    }
    if ( dword_200025BC == 1 )
      goto LABEL_914;
    if ( byte_200002B6 )
    {
      sub_8029C1A();
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      dword_200002DC = 3000;
    }
    byte_200002AF = 0;
    if ( byte_200002B0 != 1 && byte_200002B5 && byte_200002B1 )
    {
      if ( byte_20000511 == 1 || byte_20002FD3 == 1 )
      {
        sub_8029C1A();
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      else if ( byte_200002AE == 1 )
      {
        sub_8029C1A();
        dword_200002DC = 300000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
    }
    else
    {
      sub_8029C1A();
      dword_200002DC = 60000;
      byte_200002A8 = -56;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
    }
    if ( byte_20002FD3 == 2 )
    {
      if ( byte_200002AB )
      {
        if ( (unsigned int)dword_200002E8 < 0xC8 && dword_20002770 > 1126170624 )
        {
          *(float *)&v20 = *(float *)&dword_20001BEC - *(float *)&dword_20001C20;
          sub_8029DAC();
          if ( v20 > 1106247680 )
            dword_200002E8 = 0;
        }
        ++dword_200002E8;
      }
      else
      {
        dword_200002E8 = 0;
      }
      if ( (unsigned int)dword_200002E8 > 0xC8 )
      {
        sub_8029BFC();
        dword_200002E8 = 210;
        byte_200002AA = 1;
        goto LABEL_500;
      }
    }
    else if ( byte_200002AB && byte_20002F5F[0] )
    {
      sub_8029BFC();
      byte_200002AA = 1;
      goto LABEL_500;
    }
    byte_200002AA = 0;
    sub_8029BFC();
    sub_8029BFC();
LABEL_500:
    if ( dword_200002DC > 0 )
      --dword_200002DC;
    if ( dword_20000374 < 1000 )
    {
      byte_200002BC = 0;
      goto LABEL_922;
    }
    if ( !byte_200002B2 )
      goto LABEL_514;
    if ( byte_200002AB )
    {
      if ( *(float *)&dword_200002F8 < 0.0 && !byte_200002B3 )
        dword_200002F8 = 0;
      if ( !byte_200002B4 && (unsigned int)dword_200002F8 < 0xC1200000 )
        goto LABEL_514;
      if ( *(float *)&dword_200002F8 != 0.0 )
      {
        if ( dword_200002DC < 10 )
        {
          byte_200002A8 = -51;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029BFC();
        }
        goto LABEL_922;
      }
      if ( byte_20002FD3 == 2 || byte_20002F5F[0] )
        goto LABEL_922;
    }
    else
    {
      if ( !byte_200002B4 )
      {
        sub_8029C1A();
        dword_200002DC = 60000;
        byte_200002A8 = -56;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        goto LABEL_922;
      }
      if ( byte_20002FD3 == 2 || byte_20002F5F[0] )
      {
        byte_200002AA = 0;
        sub_8029C1A();
        sub_8029BFC();
        sub_8029BFC();
        byte_200002A8 = -44;
        goto LABEL_922;
      }
    }
    goto LABEL_521;
  }
  v5 = (unsigned __int8)byte_200002A8 >= 0x21u;
  if ( byte_200002A8 == 33 )
  {
    if ( dword_20000374 == 50 )
    {
      sub_8029C1A();
      sub_803085C();
      byte_200002A6 = 4;
    }
    if ( dword_200025BC == 1 || !byte_200002B4 || !byte_200002B2 || byte_200002AE == 1 || byte_200002B9 || byte_200002BA )
    {
      sub_8029C1A();
      byte_200002A8 = 34;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
    }
    goto LABEL_922;
  }
LABEL_15:
  if ( v5 )
  {
LABEL_921:
    sub_8029C1A();
    BYTE1(dword_200028C4) |= 2u;
    byte_200002A8 = 1;
    goto LABEL_922;
  }
  switch ( byte_200002A8 )
  {
    case 0:
      byte_200002AE = 0;
      v9 = dword_200025BC;
      v10 = (unsigned int)dword_200025BC >= 0xB;
      if ( dword_200025BC == 11 )
      {
        dword_200025BC = 0;
        byte_200002A8 = 80;
      }
      else
      {
        while ( 2 )
        {
          if ( !v10 )
          {
            switch ( v9 )
            {
              case 0u:
              case 2u:
              case 8u:
                goto LABEL_922;
              case 1u:
                dword_200025BC = 0;
                byte_200002A8 = 1;
                break;
              case 3u:
                dword_200025BC = 0;
                byte_200002A8 = 20;
                break;
              case 4u:
                dword_200025BC = 0;
                byte_200002A8 = 30;
                break;
              case 5u:
                dword_200025BC = 0;
                byte_200002A8 = 10;
                break;
              case 6u:
                dword_200025BC = 0;
                byte_200002A8 = 40;
                break;
              case 7u:
                dword_200025BC = 0;
                byte_200002A8 = -31;
                break;
              case 9u:
                dword_200025BC = 0;
                byte_200002A8 = -56;
                break;
              case 0xAu:
                dword_200025BC = 0;
                byte_200002A8 = 70;
                break;
              default:
                v9 -= 23;
                v10 = v9 >= 0xC;
                switch ( v9 )
                {
                  case 0u:
                    dword_200025BC = 0;
                    byte_200002A8 = -37;
                    break;
                  case 1u:
                    dword_200025BC = 0;
                    byte_200002A8 = -34;
                    break;
                  case 2u:
                    sub_8029BFC();
                    sub_8029BFC();
                    if ( dword_20000374 >= 200 )
                    {
                      dword_200025BC = 0;
                      byte_200002A8 = -36;
                    }
                    break;
                  case 3u:
                    sub_8029BFC();
                    sub_8029BFC();
                    if ( dword_20000374 >= 200 )
                    {
                      dword_200025BC = 0;
                      byte_200002A8 = -35;
                    }
                    break;
                  case 4u:
                  case 5u:
                  case 6u:
                  case 0xAu:
                    goto LABEL_922;
                  case 7u:
                    dword_200025BC = 0;
                    byte_200002A8 = -33;
                    break;
                  case 8u:
                    dword_200025BC = 0;
                    byte_200002A8 = -32;
                    break;
                  case 9u:
                    dword_200025BC = 0;
                    byte_200002A8 = 100;
                    break;
                  case 0xBu:
                    dword_200025BC = 0;
                    byte_200002A8 = -24;
                    break;
                  default:
                    continue;
                }
                break;
            }
          }
          break;
        }
      }
      goto LABEL_922;
    case 1:
      byte_200002AA = 0;
      sub_8029BFC();
      sub_8029BFC();
      sub_8029BFC();
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      dword_200025BC = 0;
      sub_803085C();
      goto LABEL_922;
    case 2:
      if ( dword_200025BC == 1 || byte_200002AE == 1 )
      {
        sub_8029C1A();
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = 1;
      }
      goto LABEL_922;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 17:
    case 18:
    case 19:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
      goto LABEL_921;
    case 10:
      if ( !byte_200002AB )
        goto LABEL_170;
      if ( byte_200002B3 )
      {
        sub_8029C74();
        if ( dword_20001BF4 <= 1131413504 )
        {
          byte_200002A8 = 11;
        }
        else
        {
          byte_200002A8 = 12;
          flt_200002F4 = *(float *)&dword_20001BFC * 8.2;
        }
      }
      else
      {
        sub_8029C1A();
        byte_200002A8 = 0;
      }
      goto LABEL_922;
    case 11:
      if ( dword_20000374 == 1 )
        sub_8029BFC();
      if ( dword_20001BF4 > 1131413504 )
      {
        byte_200002A8 = 12;
        flt_200002F4 = *(float *)&dword_20001BFC * 8.2;
        sub_8029BFC();
      }
      if ( dword_20000374 > 3000 )
      {
        sub_8029C1A();
        byte_200002A8 = 15;
      }
      goto LABEL_922;
    case 12:
      if ( dword_20000374 == 1 )
      {
        byte_200002AA = 1;
        sub_8029BFC();
      }
      if ( dword_20000374 == 30 )
      {
        sub_8029BFC();
        sub_8029BFC();
      }
      if ( dword_200025BC == 1 || !byte_200002B3 || !byte_200002AB || byte_200002AE == 1 )
      {
        sub_8029C1A();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 80 )
        sub_8029BFC();
      if ( dword_20000374 == 100 )
        sub_8029BFC();
      if ( dword_20000374 >= 120 )
      {
        if ( dword_20000374 == 120 )
        {
          flt_2000281C = 2500.0;
          sub_802A4A4(&flt_20002804);
          flt_20002810 = 200.0;
          if ( *(float *)&dword_20001BF4 >= (float)(flt_20002798 * 1.5) )
            LODWORD(flt_200002F4) = dword_20001BF4;
          else
            flt_200002F4 = flt_20002798 * 1.5;
          sub_8029C1A();
          byte_200002A6 = 5;
        }
        if ( (float)(*(float *)&dword_20001BFC * 8.2) > flt_200002F4 )
          flt_200002F4 = flt_200002F4 + 0.05;
        if ( (float)(*(float *)&dword_20001BFC * 8.2) <= flt_200002F4 || SLODWORD(flt_200002F4) >= 1139474432 )
          byte_200002A8 = 13;
        if ( dword_20000374 > 10000 )
        {
          sub_8029C1A();
          byte_200002A8 = 15;
        }
      }
      goto LABEL_922;
    case 13:
      if ( dword_200025BC == 1 || !byte_200002B3 || !byte_200002AB || !byte_200002B1 || byte_200002AE == 1 )
      {
        sub_8029C1A();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 300 )
      {
        sub_8029C1A();
        byte_200002A7 = 16;
        byte_200002A8 = 14;
      }
      goto LABEL_922;
    case 14:
      if ( dword_200025BC == 1 || !byte_200002B3 || !byte_200002AB || !byte_200002B1 || byte_200002AE == 1 )
      {
        sub_8029C1A();
        byte_200002A8 = 15;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_922;
    case 15:
      byte_200002AA = 0;
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      sub_8029BFC();
      sub_8029BFC();
      sub_803085C();
      goto LABEL_922;
    case 20:
      if ( !byte_200002AB || !byte_200002B4 )
        goto LABEL_170;
      sub_8029C74();
      if ( dword_20000374 == 1 )
        sub_8029BFC();
      if ( dword_20000374 == 31 )
        sub_8029BFC();
      if ( dword_20000374 >= 33 )
      {
        if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
        {
          sub_8029C1A();
          dword_20000044 = 450;
          byte_200002A7 = 13;
          byte_200002A8 = 21;
        }
        else
        {
          sub_8029C1A();
          byte_200002A8 = 22;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029BFC();
        }
      }
      goto LABEL_922;
    case 21:
      if ( dword_200025BC != 1 && byte_200002B4 && byte_200002AB )
      {
        if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
        {
          flt_2000037C = (float)dword_20000374 * 0.001;
          if ( SLODWORD(flt_2000037C) > 1065185444 )
            flt_2000037C = 1.0;
          if ( (float)(unsigned int)dword_20000040 >= 6550.0 )
            v11 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * 6550.0) - 180.0;
          else
            v11 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
          if ( SLODWORD(v11) < 1138819072 )
            v11 = 450.0;
          dword_20000044 = (unsigned int)v11;
          if ( dword_20000374 > 3000 )
          {
            sub_8029C1A();
            byte_200002A8 = 24;
          }
        }
        else
        {
          sub_8029C1A();
          byte_200002A8 = 22;
          byte_200002A7 = 21;
          byte_200002AA = 1;
          sub_8029BFC();
        }
      }
      else
      {
        sub_8029C1A();
        byte_200002A8 = 24;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      goto LABEL_922;
    case 22:
      if ( dword_200025BC == 1 || !byte_200002B4 || !byte_200002AB )
      {
        sub_8029C1A();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( dword_20000374 == 100 )
        sub_8029BFC();
      if ( dword_20000374 == 120 )
        sub_8029BFC();
      if ( dword_20000374 >= 130 && byte_200002B2 )
      {
        sub_803085C();
        byte_200002A6 = 3;
        sub_8029C1A();
        byte_200002A8 = 23;
      }
      goto LABEL_922;
    case 23:
      if ( dword_200025BC == 1 || byte_200002AE == 1 || !byte_200002AB || !byte_200002B2 || !byte_200002B4 )
      {
        sub_8029C1A();
        byte_200002A8 = 24;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      dword_200002FC = LODWORD(flt_200025C0);
      goto LABEL_922;
    case 24:
      byte_200002AA = 0;
      sub_8029BFC();
      sub_8029BFC();
      byte_200002A7 = 2;
      byte_200002A6 = 2;
      byte_200002A8 = 0;
      sub_803085C();
      goto LABEL_922;
    case 30:
      if ( !byte_200002B4 )
        goto LABEL_170;
      sub_8029C74();
      if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
      {
        dword_20000044 = 450;
        byte_200002A7 = 13;
        byte_200002A8 = 31;
      }
      else
      {
        byte_200002A8 = 32;
        byte_200002A7 = 19;
      }
      goto LABEL_922;
    case 31:
      if ( dword_200025BC == 1 || !byte_200002B4 )
      {
        sub_8029C1A();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( *(float *)&dword_20001BF4 >= (float)(*(float *)&dword_20001BFC * 8.3) )
      {
        dword_20000040 = 6550;
        byte_200002A8 = 32;
        byte_200002A7 = 19;
      }
      flt_2000037C = (float)dword_20000374 * 0.001;
      if ( SLODWORD(flt_2000037C) > 1065185444 )
        flt_2000037C = 1.0;
      v12 = (float)(flt_2000037C * 850.0) + 5700.0;
      if ( v12 <= (float)(unsigned int)dword_20000040 )
        v13 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v12) - 180.0;
      else
        v13 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
      if ( SLODWORD(v13) < 1138819072 )
        v13 = 450.0;
      dword_20000044 = (unsigned int)v13;
      dword_20000040 = (unsigned int)v12;
      if ( dword_20000374 > 3000 )
      {
        sub_8029C1A();
        byte_200002A8 = 34;
      }
      goto LABEL_922;
    case 32:
      if ( dword_200025BC == 1 || !byte_200002B4 )
      {
        sub_8029C1A();
        byte_200002A8 = 34;
        byte_200002A7 = 2;
        byte_200002A6 = 2;
      }
      if ( byte_200002B2 )
      {
        sub_8029BFC();
        byte_200002A8 = 33;
      }
      if ( dword_20000374 > 2000 )
      {
        sub_8029C1A();
        byte_200002A8 = 34;
      }
      goto LABEL_922;
    default:
      if ( byte_200002A8 == 72 )
      {
        if ( dword_20000374 == 1 )
        {
          byte_200002AA = 1;
          sub_8029BFC();
          sub_8029BFC();
          flt_200002F4 = flt_200025C0;
        }
        if ( dword_200025BC == 1 || !byte_200002AB || byte_200002AE == 1 )
        {
          sub_8029C1A();
          byte_200002A8 = 1;
        }
        else
        {
          if ( dword_20000374 == 60 )
            sub_8029BFC();
          if ( dword_20000374 == 80 )
            sub_8029BFC();
          if ( dword_20000374 == 120 )
          {
            flt_2000281C = 2500.0;
            sub_802A4A4(&flt_20002804);
            flt_20002810 = 200.0;
            if ( *(float *)&dword_20001BF4 >= (float)(flt_20002798 * 1.5) )
              LODWORD(flt_200002F4) = dword_20001BF4;
            else
              flt_200002F4 = flt_20002798 * 1.5;
            sub_8029C1A();
            byte_200002A6 = 5;
          }
          if ( dword_20000374 >= 120 )
          {
            if ( flt_200025C0 > flt_200002F4 )
              flt_200002F4 = flt_200002F4 + 0.05;
            if ( flt_200025C0 <= flt_200002F4 || SLODWORD(flt_200002F4) >= 1138819072 )
            {
              flt_200002F4 = flt_200025C0;
              byte_200002A8 = 73;
            }
            if ( !byte_200002AB )
            {
              sub_8029C1A();
              byte_200002A8 = 74;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            if ( dword_20000374 > 10000 )
            {
              sub_8029C1A();
              byte_200002A8 = 74;
            }
          }
        }
        goto LABEL_922;
      }
      if ( (unsigned __int8)byte_200002A8 > 0x48u )
      {
        if ( byte_200002A8 == 81 )
        {
          if ( dword_200025BC == 1 || !byte_200002AB || !byte_200002B2 )
          {
            sub_8029C1A();
            byte_200002A8 = 83;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          if ( dword_20000374 == 200 )
            sub_8029BFC();
          if ( dword_20000374 == 500 )
            sub_8029BFC();
          if ( dword_20000374 >= 1000 )
          {
            flt_200002F4 = 360.0;
            flt_20002460 = 0.0;
            dword_200002FC = 0;
            flt_20002464 = 0.0;
            byte_200002A6 = 3;
            sub_8029C1A();
            byte_200002A8 = 82;
          }
          goto LABEL_922;
        }
        if ( (unsigned __int8)byte_200002A8 <= 0x51u )
        {
          if ( byte_200002A8 == 73 )
          {
            if ( dword_200025BC == 1 || byte_200002AE == 1 )
            {
              sub_8029C1A();
              byte_200002A7 = 2;
              byte_200002A6 = 2;
              byte_200002A8 = 74;
            }
            else if ( !byte_200002AB || !byte_200002B1 )
            {
              sub_8029C1A();
              byte_200002A8 = 74;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            flt_200002F4 = flt_200025C0;
            goto LABEL_922;
          }
          if ( byte_200002A8 == 74 )
          {
            byte_200002A7 = 2;
            byte_200002A6 = 2;
            byte_200002A8 = 0;
            sub_8029BFC();
            sub_8029BFC();
            goto LABEL_922;
          }
          v6 = byte_200002A8 == 80;
          if ( byte_200002A8 != 80 )
            goto LABEL_25;
          if ( byte_200002AB )
          {
            if ( dword_20001BF4 > 1135542272 )
            {
              byte_200002A8 = 81;
              byte_200002AA = 1;
              sub_8029BFC();
            }
            if ( dword_20000374 > 3000 )
            {
              sub_8029C1A();
              byte_200002A8 = 83;
            }
            goto LABEL_922;
          }
          goto LABEL_170;
        }
        if ( byte_200002A8 == 82 )
        {
          if ( dword_200025BC == 1 || byte_200002AE == 1 || !byte_200002AB || !byte_200002B2 )
          {
            sub_8029C1A();
            byte_200002A8 = 83;
            byte_200002A7 = 2;
            byte_200002A6 = 2;
          }
          dword_200002FC = LODWORD(flt_200025C0);
          goto LABEL_922;
        }
        if ( byte_200002A8 == 83 )
        {
          byte_200002AA = 0;
          sub_8029BFC();
          sub_8029BFC();
          byte_200002A7 = 2;
          byte_200002A6 = 2;
          byte_200002A8 = 0;
          goto LABEL_922;
        }
        v6 = byte_200002A8 == 100;
        if ( byte_200002A8 != 100 )
          goto LABEL_25;
        if ( byte_200002B5 )
        {
          if ( byte_200002B4 )
          {
            if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
            {
              sub_8029C1A();
              dword_20000044 = 450;
              byte_200002A7 = 13;
              byte_200002A8 = 101;
            }
            else
            {
              sub_8029C1A();
              byte_200002A7 = 21;
              byte_200002A8 = 102;
            }
          }
          else
          {
            sub_8029C24();
            sub_8029C24();
            sub_8029C1A();
            byte_200002A8 = 1;
          }
          goto LABEL_922;
        }
        goto LABEL_914;
      }
      if ( byte_200002A8 == 43 )
      {
        if ( dword_20000374 == 50 )
        {
          byte_200002C5 = 1;
          sub_8030C20((int)&unk_20002660);
        }
        else if ( dword_20000374 == 250 )
        {
          sub_8029C1A();
          sub_803085C();
          byte_200002A6 = 33;
        }
        if ( dword_200025BC == 1
          || !byte_200002B4
          || !byte_200002B2
          || byte_200002AE == 1
          || byte_200002B9
          || byte_200002BA )
        {
          sub_8029C1A();
          byte_200002A8 = 44;
          byte_200002A7 = 2;
          byte_200002A6 = 2;
        }
        goto LABEL_922;
      }
      if ( (unsigned __int8)byte_200002A8 <= 0x2Bu )
      {
        if ( byte_200002A8 != 34 )
        {
          if ( byte_200002A8 != 40 )
          {
            if ( byte_200002A8 != 41 )
            {
              v6 = byte_200002A8 == 42;
              goto LABEL_25;
            }
            if ( dword_200025BC == 1 || !byte_200002B4 )
            {
              sub_8029C1A();
              byte_200002A8 = 44;
              byte_200002A7 = 2;
              byte_200002A6 = 2;
            }
            if ( *(float *)&dword_20001BF4 >= (float)(*(float *)&dword_20001BFC * 8.3) )
            {
              dword_20000040 = 6550;
              byte_200002A8 = 42;
              byte_200002A7 = 19;
            }
            flt_2000037C = (float)dword_20000374 * 0.001;
            if ( SLODWORD(flt_2000037C) > 1065185444 )
              flt_2000037C = 1.0;
            v14 = (float)(flt_2000037C * 850.0) + 5700.0;
            if ( v14 <= (float)(unsigned int)dword_20000040 )
              v15 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * v14) - 180.0;
            else
              v15 = (float)((float)((float)(flt_2000037C * 0.4) + 0.1) * (float)(unsigned int)dword_20000040) - 180.0;
            if ( SLODWORD(v15) < 1138819072 )
              v15 = 450.0;
            dword_20000044 = (unsigned int)v15;
            dword_20000040 = (unsigned int)v14;
            if ( dword_20000374 > 3000 )
            {
              sub_8029C1A();
              byte_200002A8 = 44;
            }
            goto LABEL_922;
          }
          if ( byte_200002B4 )
          {
            sub_8029C74();
            if ( *(float *)&dword_20001BF4 < (float)(*(float *)&dword_20001BFC * 8.3) )
            {
              dword_20000044 = 450;
              byte_200002A7 = 13;
              byte_200002A8 = 41;
            }
            else
            {
              byte_200002A8 = 42;
              byte_200002A7 = 19;
            }
            goto LABEL_922;
          }
LABEL_170:
          sub_8029C1A();
          byte_200002A8 = 0;
          goto LABEL_922;
        }
LABEL_65:
        sub_8029BFC();
        sub_8029BFC();
        byte_200002A7 = 2;
        byte_200002A6 = 2;
        byte_200002A8 = 0;
        goto LABEL_922;
      }
      if ( byte_200002A8 == 44 )
        goto LABEL_65;
      v4 = 72;
      if ( byte_200002A8 == 70 )
      {
        if ( byte_200002AB )
        {
          sub_8029C74();
          if ( dword_20001BF4 <= 1131413504 )
            byte_200002A8 = 71;
          else
            byte_200002A8 = 72;
          goto LABEL_922;
        }
        goto LABEL_170;
      }
      v6 = byte_200002A8 == 71;
      if ( byte_200002A8 != 71 )
        goto LABEL_25;
      if ( dword_20000374 == 1 )
        sub_8029BFC();
      if ( dword_20001BF4 > 1131413504 )
        byte_200002A8 = 72;
      if ( dword_20000374 > 3000 )
      {
        sub_8029C1A();
        dword_200002DC = 60000;
        byte_200002A8 = -56;
      }
LABEL_922:
      if ( dword_20000388 >= 100 || dword_20002748 )
        dword_20000388 = 0;
      switch ( ++dword_20000388 )
      {
        case 2:
          v30 = 2550.0;
          if ( (float)(*(float *)&dword_20000308 * 2550.0) < 2550.0 )
            v30 = *(float *)&dword_20000308 * 2550.0;
          v31 = *(float *)&dword_20002778 - (float)(flt_20002798 * 16.0);
          if ( byte_2000050B == 1 && (unsigned __int16)word_2000051A > 0x320u )
            word_2000051A = 800;
          if ( byte_2000050B == 2 && (unsigned __int16)word_2000051A > 0x258u )
            word_2000051A = 600;
          if ( v31 < (float)-v30 )
            v31 = -v30;
          if ( (float)(unsigned __int16)word_2000051A < v30 )
            v30 = (float)(unsigned __int16)word_2000051A;
          if ( (float)-(float)(unsigned __int16)word_20000518 > v31 )
            v31 = -(float)(unsigned __int16)word_20000518;
          if ( byte_20000513 )
          {
            if ( v30 > (float)((float)(flt_20001C14 * flt_20002440) * 1.034) )
              v30 = (float)(flt_20001C14 * flt_20002440) * 1.034;
            if ( v31 < (float)((float)(flt_20001C14 * flt_20002438) * -1.06) )
              v31 = (float)(flt_20001C14 * flt_20002438) * -1.06;
          }
          flt_2000030C = v30;
          flt_20000310 = v31;
          v32 = (float)((float)(*(float *)&dword_20001C10 - (float)(flt_20002798 * 1.53)) * 2550.0) * 0.05;
          if ( flt_20000320 <= v32 )
            flt_20000320 = (float)((float)(*(float *)&dword_20001C10 - (float)(flt_20002798 * 1.53)) * 2550.0) * 0.05;
          else
            flt_20000320 = (float)(flt_20000320 * 0.6) + (float)(v32 * 0.4);
          if ( flt_20000320 < 0.0 )
            flt_20000320 = 0.0;
          if ( v30 > flt_20000320 )
            v30 = flt_20000320;
          if ( *(float *)&dword_200002FC <= v30 )
          {
            if ( *(float *)&dword_200002FC >= v31 )
              LODWORD(flt_2000244C) = dword_200002FC;
            else
              flt_2000244C = v31;
          }
          else
          {
            flt_2000244C = v30;
          }
          break;
        case 3:
          switch ( byte_200037D0 )
          {
            case 1:
              flt_2000038C = (float)(flt_2000038C * 0.8) + (float)(flt_200002F0 * 0.2);
              if ( flt_2000377C >= flt_2000038C )
              {
                byte_200002CA = 0;
                if ( byte_200008C1 == 1 && flt_200025C0 < flt_200037C0 )
                  flt_200025C0 = flt_200025C0 + (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
              }
              else if ( (unsigned __int8)byte_200002CA <= 2u )
              {
                ++byte_200002CA;
              }
              else
              {
                if ( !byte_200008C1 )
                {
                  sub_8029C24();
                  sub_8029C24();
                  sub_8029C24();
                  sub_8029C1A();
                }
                byte_200008C1 = 1;
                flt_2000244C = *(float *)&dword_200002FC
                             - (float)((float)((float)(flt_2000038C - flt_2000377C) * *(float *)&dword_200002FC)
                                     * flt_20003780);
                if ( flt_2000244C < 0.0 )
                  flt_2000244C = 0.0;
              }
              break;
            case 2:
              if ( flt_20003778 < (float)(flt_20002798 / 230.0) )
                flt_2000244C = 0.0;
              break;
            case 3:
              sub_802FB88();
              break;
            case 8:
            case 11:
            case 15:
              if ( byte_200002C4 )
              {
                if ( flt_2000244C > flt_20000390 )
                  flt_20000390 = flt_20000390 + (float)((float)(flt_20003784 * 0.00033333) * flt_2000244C);
              }
              else
              {
                flt_20000390 = 0.0;
              }
              flt_2000244C = flt_20000390;
              break;
            case 9:
              flt_20000300 = (float)(flt_200037B0 * flt_2000244C) * (float)(flt_200002F0 - 50.0);
              break;
            case 12:
              if ( flt_2000244C <= flt_20000394 )
                flt_20000394 = flt_20000394 - (float)((float)(flt_20003784 * 0.00033333) * flt_200037C0);
              else
                flt_20000394 = flt_20000394 + (float)((float)(flt_20003784 * 0.00033333) * flt_200037C0);
              flt_2000244C = flt_20000394;
              break;
            case 13:
              v33 = (float)(flt_20000398 * 0.8) + (float)(flt_200002F0 * 0.2);
              flt_20000398 = v33;
              if ( flt_2000377C >= v33 )
              {
                byte_200002CB = 0;
                if ( byte_200002CC == 1 )
                {
                  if ( SLODWORD(v33) >= 1112027955 )
                  {
                    dword_2000039C = 0;
                  }
                  else if ( (unsigned int)++dword_2000039C > 0xC1C )
                  {
                    byte_200002CC = 0;
                  }
                }
                if ( byte_200008C1 == 1 && !byte_200002CC && flt_200025C0 < flt_200037C0 )
                  flt_200025C0 = flt_200025C0 + (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
              }
              else
              {
                if ( (unsigned __int8)byte_200002CB <= 2u )
                {
                  ++byte_200002CB;
                }
                else
                {
                  byte_200008C1 = 1;
                  flt_2000244C = *(float *)&dword_200002FC
                               - (float)((float)(flt_200037C0 * (float)(v33 - flt_2000377C)) * flt_20003780);
                  if ( flt_2000244C < 0.0 )
                    flt_2000244C = 0.0;
                }
                if ( byte_200002CC )
                  flt_200025C0 = 0.0;
                else
                  byte_200002CC = SLODWORD(v33) > 1112421171;
              }
              break;
            case 16:
              v34 = (float)(flt_200003A0 * 0.8) + (float)(flt_200002F0 * 0.2);
              flt_200003A0 = v34;
              if ( SLODWORD(v34) >= 1111962419 )
              {
                if ( byte_200002CD == 1 )
                {
                  if ( SLODWORD(v34) <= 1111962419 )
                  {
                    dword_200003A4 = 0;
                  }
                  else if ( (unsigned int)++dword_200003A4 > 0xC1C )
                  {
                    byte_200002CD = 0;
                    flt_200003A8 = 0.0;
                  }
                  flt_2000244C = 0.0;
                }
                if ( !byte_200002CD )
                {
                  if ( byte_200008C1 == 1 )
                  {
                    v35 = flt_200003A8;
                    if ( flt_200003A8 >= *(float *)&dword_200002FC )
                    {
                      if ( flt_200003A8 <= *(float *)&dword_200002FC )
                      {
                        byte_200008C1 = 0;
                      }
                      else
                      {
                        flt_200003A8 = flt_200003A8 - (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
                        flt_2000244C = v35 - (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
                      }
                    }
                    else
                    {
                      flt_200003A8 = flt_200003A8 + (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
                      flt_2000244C = v35 + (float)((float)(flt_200037C0 / flt_200025C8) * 0.0015);
                    }
                  }
                  else
                  {
                    LODWORD(flt_2000244C) = dword_200002FC;
                  }
                }
              }
              else
              {
                if ( SLODWORD(v34) < 1111359488 )
                {
                  byte_200002CD = 1;
                  byte_200008C1 = 1;
                  dword_200003A4 = 0;
                }
                if ( byte_200002CD == 1 )
                {
                  flt_2000244C = 0.0;
                }
                else
                {
                  flt_2000244C = *(float *)&dword_200002FC
                               + (float)((float)(flt_200037C0 * (float)(49.8 - v34)) * flt_20003780);
                  if ( flt_2000244C > flt_200037C0 )
                    flt_2000244C = flt_200037C0;
                }
              }
              break;
            case 17:
              if ( flt_20003778 < (float)(flt_20002798 / 230.0) )
                flt_2000244C = (float)(1.0 - (float)((float)((float)(flt_20002798 / 230.0) - flt_20003778) * 20.0))
                             * *(float *)&dword_200002FC;
              if ( flt_2000244C < 0.0 )
                flt_2000244C = 0.0;
              break;
            default:
              break;
          }
          if ( flt_20000304 != 0.0 )
            sub_802A73C();
          goto LABEL_1025;
        case 4:
LABEL_1025:
          if ( byte_200037D1 == 1 )
          {
            v36 = (float)(flt_2000244C + 0.1) * 2.2913;
            flt_20002450 = v36;
            if ( (float)-v36 <= flt_20000300 )
            {
              if ( v36 >= flt_20000300 )
                flt_20002450 = (float)(flt_200037BC + flt_20000300) * *(float *)&dword_20000308;
              else
                flt_20002450 = v36 + flt_200037BC;
            }
            else
            {
              flt_20002450 = flt_200037BC - v36;
            }
          }
          else
          {
            flt_20002450 = (float)(flt_200037BC + flt_20000300) * *(float *)&dword_20000308;
          }
          break;
        case 5:
          flt_20000408 = flt_200037CC * 10.0;
          flt_20002454 = (float)(flt_20002450 + (float)(flt_20000408 * flt_20002454)) / (float)(flt_20000408 + 1.0);
          if ( COERCE_INT(flt_20002450 - flt_20002454) < 0x40000000
            && COERCE_UNSIGNED_INT(flt_20002450 - flt_20002454) < 0xC0000000 )
          {
            flt_20002454 = flt_20002450;
          }
          break;
        case 6:
          flt_20000408 = flt_200037C8 * 10.0;
          *(float *)&dword_20002458 = (float)(flt_2000244C + (float)(flt_20000408 * *(float *)&dword_20002458))
                                    / (float)(flt_20000408 + 1.0);
          if ( COERCE_INT(flt_2000244C - *(float *)&dword_20002458) < 0x40000000
            && COERCE_UNSIGNED_INT(flt_2000244C - *(float *)&dword_20002458) < 0xC0000000 )
          {
            dword_20002458 = LODWORD(flt_2000244C);
          }
          break;
        case 7:
          v37 = *(float *)&dword_20002458;
          if ( *(float *)&dword_20002458 < 0.0 )
          {
            flt_20002448 = 0.0;
            LODWORD(flt_2000245C) = dword_20002458;
          }
          else
          {
            v38 = flt_20002454;
            sub_802A2BC();
            flt_20002448 = v38 / (float)(v37 + 0.1);
            v39 = (float)((float)(*(float *)&dword_20002458 + 0.1) * (float)(*(float *)&dword_20002458 + 0.1))
                + (float)(flt_20002454 * flt_20002454);
            if ( v39 < 0.0 )
              flt_2000245C = 0.0;
            else
              flt_2000245C = sqrtf(v39);
          }
          flt_20002464 = (float)(flt_2000245C * 1.4142) / flt_20002798;
          break;
        case 8:
          if ( SLODWORD(flt_2000276C) > 1050253722 )
            flt_20000414 = flt_20000414 + (float)(flt_2000276C * flt_20002798);
          if ( *(float *)&dword_20002458 < 0.0 )
            flt_2000040C = flt_20002810 + flt_2000040C;
          else
            flt_20000410 = *(float *)&dword_20002458 + flt_20000410;
          ++dword_20000324;
          break;
        case 9:
          sub_8031260();
          break;
        case 10:
          if ( byte_200002A4 == 3 || byte_200002A4 == 9 || byte_200002A4 == 33 || byte_200002A4 == 26 )
          {
            v46 = v1 / 1.0;
            *(float *)&dword_20000348 = v1 / 1.0;
            v47 = flt_20000338 + (float)((float)(*(float *)&dword_20001C28 + flt_200008C4) * 0.01);
            flt_20000338 = v47;
            flt_20000344 = v46 * 0.3;
            if ( COERCE_INT(v46 * 0.3) <= 1090519040 )
            {
              if ( COERCE_UNSIGNED_INT(v46 * 0.3) > 0xC1000000 )
                flt_20000344 = -8.0;
            }
            else
            {
              flt_20000344 = 8.0;
            }
            v48 = flt_20000340 + (float)(v46 * 0.02);
            flt_20000340 = v48;
            *(float *)&dword_2000033C = v48 + flt_20000344;
            if ( SLODWORD(v47) <= 1050253722 )
            {
              if ( LODWORD(v47) > 0xBE99999A )
                flt_20000338 = -0.3;
            }
            else
            {
              flt_20000338 = 0.3;
            }
            if ( SLODWORD(v48) <= 1090519040 )
            {
              if ( LODWORD(v48) > 0xC1000000 )
                flt_20000340 = -8.0;
            }
            else
            {
              flt_20000340 = 8.0;
            }
          }
          else
          {
            flt_20000340 = 0.0;
            flt_20000338 = 0.0;
            dword_2000033C = 0;
          }
          break;
        default:
          break;
      }
      v40 = flt_20000330 + 1.0;
      flt_20000330 = flt_20000330 + 1.0;
      v41 = *(float *)&dword_20001BFC + flt_2000032C;
      flt_2000032C = *(float *)&dword_20001BFC + flt_2000032C;
      v42 = *(float *)&dword_20001C00 + flt_20000334;
      flt_20000334 = *(float *)&dword_20001C00 + flt_20000334;
      if ( dword_20002748 )
      {
        v43 = v41 / v40;
        flt_20000314 = v41 / v40;
        v44 = v42 / v40;
        *(float *)&dword_20000318 = v42 / v40;
        v45 = v43 + 0.3;
        flt_20001C14 = v43 + 0.3;
        flt_20001C18 = v44 * 1.05;
        flt_20001C04 = (float)((float)((float)(v43 + 0.3) * 0.1) * (float)(v44 * 1.05)) + (float)(flt_20001C04 * 0.9);
        flt_20000330 = 0.0;
        flt_2000032C = 0.0;
        flt_20000334 = 0.0;
        if ( SLODWORD(flt_200002F4) < 1133903872 )
          flt_200002F4 = 300.0;
        switch ( byte_200002A5 )
        {
          case 16:
            flt_20002804 = flt_200025C0 * 8.2;
            flt_20002808 = v45 * 8.2;
            v49 = (float)(v45 * flt_200025C4) * 1.08;
            flt_2000281C = v49;
            flt_20002820 = -100.0;
            if ( v49 > flt_2000030C )
              flt_2000281C = flt_2000030C;
            if ( flt_2000281C < flt_20002830 )
              flt_20002830 = flt_2000281C;
            sub_802A430(&flt_20002804);
            LODWORD(flt_200002F4) = dword_20001BF4;
            break;
          case 19:
          case 21:
            flt_20002804 = 475.6;
            flt_20002808 = v45 * 8.2;
            flt_2000281C = -flt_2000245C;
            flt_20002820 = -100.0;
            if ( (float)-flt_2000245C < 0.0 )
              flt_2000281C = 0.0;
            if ( flt_2000281C < flt_20002830 )
              flt_20002830 = flt_2000281C;
            sub_802A430(&flt_20002804);
            break;
          case 20:
            flt_2000281C = 2500.0;
            flt_20002820 = -2500.0;
            flt_20002804 = flt_200002F4;
            LODWORD(flt_20002808) = dword_20001BF4;
            sub_802A430(&flt_20002804);
            break;
          case 22:
            flt_2000281C = 2500.0;
            flt_20002820 = -2500.0;
            flt_20002804 = 410.0;
            flt_20002808 = v45 * 8.2;
            sub_802A430(&flt_20002804);
            LODWORD(flt_200002F4) = dword_20001BF4;
            break;
          default:
            flt_2000281C = 300.0;
            flt_20002820 = -300.0;
            flt_20002804 = flt_200002F4;
            LODWORD(flt_20002808) = dword_20001BF4;
            sub_802A430(&flt_20002804);
            break;
        }
        if ( SLODWORD(flt_20002448) < 1065353216 && LODWORD(flt_20002448) < 0xBF800000 )
          dword_20002624 = LODWORD(flt_20002448);
        if ( flt_2000245C < 0.0 )
          flt_20002464 = (float)(flt_20002810 * -1.4142) / flt_20002798;
        if ( byte_200002C2 )
        {
          if ( SLODWORD(flt_20002464) <= 1101004800 )
          {
            if ( LODWORD(flt_20002464) <= 0xC185D8CA )
              flt_20002460 = flt_20002464;
            else
              flt_20002460 = -16.731;
          }
          else
          {
            flt_20002460 = 20.0;
          }
        }
        else if ( SLODWORD(flt_20002464) <= 1099290826 )
        {
          if ( LODWORD(flt_20002464) <= 0xC185D8CA )
            flt_20002460 = flt_20002464;
          else
            flt_20002460 = -16.731;
        }
        else
        {
          flt_20002460 = 16.731;
        }
      }
      if ( ++dword_20000378 >= 1000 )
      {
        if ( dword_20000324 > 0 )
          sub_8029D50();
        flt_2000040C = 0.0;
        flt_20000410 = 0.0;
        flt_20000414 = 0.0;
        dword_20000324 = 0;
        dword_20000378 = 0;
      }
      sub_8029E4C();
      return;
  }
}
// 802C126: conditional instruction was optimized away because r1.4==CE
// 802BFA6: variable 'v2' is possibly undefined
// 802D3AA: variable 'v17' is possibly undefined
// 802D4FE: variable 'v18' is possibly undefined
// 802E6B6: variable 'v23' is possibly undefined
// 802E79C: variable 'v24' is possibly undefined
// 802E800: variable 'v25' is possibly undefined
// 802ED22: variable 'v29' is possibly undefined
// 20000040: using guessed type int dword_20000040;
// 20000044: using guessed type int dword_20000044;
// 200002A4: using guessed type char byte_200002A4;
// 200002A5: using guessed type char byte_200002A5;
// 200002A6: using guessed type char byte_200002A6;
// 200002A7: using guessed type char byte_200002A7;
// 200002A8: using guessed type char byte_200002A8;
// 200002A9: using guessed type char byte_200002A9;
// 200002AA: using guessed type char byte_200002AA;
// 200002AB: using guessed type char byte_200002AB;
// 200002AE: using guessed type char byte_200002AE;
// 200002AF: using guessed type char byte_200002AF;
// 200002B0: using guessed type char byte_200002B0;
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200002B3: using guessed type char byte_200002B3;
// 200002B4: using guessed type char byte_200002B4;
// 200002B5: using guessed type char byte_200002B5;
// 200002B6: using guessed type char byte_200002B6;
// 200002B7: using guessed type char byte_200002B7;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002BB: using guessed type char byte_200002BB;
// 200002BC: using guessed type char byte_200002BC;
// 200002BD: using guessed type char byte_200002BD;
// 200002BE: using guessed type char byte_200002BE;
// 200002BF: using guessed type char byte_200002BF;
// 200002C0: using guessed type char byte_200002C0;
// 200002C2: using guessed type char byte_200002C2;
// 200002C4: using guessed type char byte_200002C4;
// 200002C5: using guessed type char byte_200002C5;
// 200002C6: using guessed type char byte_200002C6;
// 200002C7: using guessed type char byte_200002C7;
// 200002C8: using guessed type char byte_200002C8;
// 200002C9: using guessed type char byte_200002C9;
// 200002CA: using guessed type char byte_200002CA;
// 200002CB: using guessed type char byte_200002CB;
// 200002CC: using guessed type char byte_200002CC;
// 200002CD: using guessed type char byte_200002CD;
// 200002DC: using guessed type int dword_200002DC;
// 200002E4: using guessed type int dword_200002E4;
// 200002E8: using guessed type int dword_200002E8;
// 200002F0: using guessed type float flt_200002F0;
// 200002F4: using guessed type float flt_200002F4;
// 200002F8: using guessed type int dword_200002F8;
// 200002FC: using guessed type int dword_200002FC;
// 20000300: using guessed type float flt_20000300;
// 20000304: using guessed type float flt_20000304;
// 20000308: using guessed type int dword_20000308;
// 2000030C: using guessed type float flt_2000030C;
// 20000310: using guessed type float flt_20000310;
// 20000314: using guessed type float flt_20000314;
// 20000318: using guessed type int dword_20000318;
// 2000031C: using guessed type int dword_2000031C;
// 20000320: using guessed type float flt_20000320;
// 20000324: using guessed type int dword_20000324;
// 2000032C: using guessed type float flt_2000032C;
// 20000330: using guessed type float flt_20000330;
// 20000334: using guessed type float flt_20000334;
// 20000338: using guessed type float flt_20000338;
// 2000033C: using guessed type int dword_2000033C;
// 20000340: using guessed type float flt_20000340;
// 20000344: using guessed type float flt_20000344;
// 20000348: using guessed type int dword_20000348;
// 20000374: using guessed type int dword_20000374;
// 20000378: using guessed type int dword_20000378;
// 2000037C: using guessed type float flt_2000037C;
// 20000380: using guessed type int dword_20000380;
// 20000384: using guessed type int dword_20000384;
// 20000388: using guessed type int dword_20000388;
// 2000038C: using guessed type float flt_2000038C;
// 20000390: using guessed type float flt_20000390;
// 20000394: using guessed type float flt_20000394;
// 20000398: using guessed type float flt_20000398;
// 2000039C: using guessed type int dword_2000039C;
// 200003A0: using guessed type float flt_200003A0;
// 200003A4: using guessed type int dword_200003A4;
// 200003A8: using guessed type float flt_200003A8;
// 20000408: using guessed type float flt_20000408;
// 2000040C: using guessed type float flt_2000040C;
// 20000410: using guessed type float flt_20000410;
// 20000414: using guessed type float flt_20000414;
// 2000050B: using guessed type char byte_2000050B;
// 20000511: using guessed type char byte_20000511;
// 20000513: using guessed type char byte_20000513;
// 20000518: using guessed type __int16 word_20000518;
// 2000051A: using guessed type __int16 word_2000051A;
// 20000522: using guessed type __int16 word_20000522;
// 200008C1: using guessed type char byte_200008C1;
// 200008C4: using guessed type float flt_200008C4;
// 20001BEC: using guessed type int dword_20001BEC;
// 20001BF0: using guessed type int dword_20001BF0;
// 20001BF4: using guessed type int dword_20001BF4;
// 20001BF8: using guessed type int dword_20001BF8;
// 20001BFC: using guessed type int dword_20001BFC;
// 20001C00: using guessed type int dword_20001C00;
// 20001C04: using guessed type float flt_20001C04;
// 20001C10: using guessed type int dword_20001C10;
// 20001C14: using guessed type float flt_20001C14;
// 20001C18: using guessed type float flt_20001C18;
// 20001C20: using guessed type int dword_20001C20;
// 20001C24: using guessed type int dword_20001C24;
// 20001C28: using guessed type int dword_20001C28;
// 20002438: using guessed type float flt_20002438;
// 20002440: using guessed type float flt_20002440;
// 20002444: using guessed type float flt_20002444;
// 20002448: using guessed type float flt_20002448;
// 2000244C: using guessed type float flt_2000244C;
// 20002450: using guessed type float flt_20002450;
// 20002454: using guessed type float flt_20002454;
// 20002458: using guessed type int dword_20002458;
// 2000245C: using guessed type float flt_2000245C;
// 20002460: using guessed type float flt_20002460;
// 20002464: using guessed type float flt_20002464;
// 200025BC: using guessed type int dword_200025BC;
// 200025C0: using guessed type float flt_200025C0;
// 200025C4: using guessed type float flt_200025C4;
// 200025C8: using guessed type float flt_200025C8;
// 20002624: using guessed type int dword_20002624;
// 20002748: using guessed type int dword_20002748;
// 2000276C: using guessed type float flt_2000276C;
// 20002770: using guessed type int dword_20002770;
// 20002778: using guessed type int dword_20002778;
// 20002798: using guessed type float flt_20002798;
// 200027B0: using guessed type float flt_200027B0;
// 200027B8: using guessed type float flt_200027B8;
// 20002804: using guessed type float flt_20002804;
// 20002808: using guessed type float flt_20002808;
// 20002810: using guessed type float flt_20002810;
// 2000281C: using guessed type float flt_2000281C;
// 20002820: using guessed type float flt_20002820;
// 20002830: using guessed type float flt_20002830;
// 2000287C: using guessed type float flt_2000287C;
// 20002880: using guessed type float flt_20002880;
// 200028C4: using guessed type int dword_200028C4;
// 20002E88: using guessed type int dword_20002E88;
// 20002FD3: using guessed type char byte_20002FD3;
// 20003778: using guessed type float flt_20003778;
// 2000377C: using guessed type float flt_2000377C;
// 20003780: using guessed type float flt_20003780;
// 20003784: using guessed type float flt_20003784;
// 200037B0: using guessed type float flt_200037B0;
// 200037BC: using guessed type float flt_200037BC;
// 200037C0: using guessed type float flt_200037C0;
// 200037C8: using guessed type float flt_200037C8;
// 200037CC: using guessed type float flt_200037CC;
// 200037D0: using guessed type char byte_200037D0;
// 200037D1: using guessed type char byte_200037D1;

//----- (0802FA88) --------------------------------------------------------
int sub_802FA88()
{
  int result; // r0

  flt_200025C8 = 50.0;
  flt_200025CC = 51.8;
  flt_200025D0 = 47.1;
  sub_8030A64((int)&unk_200027AC);
  sub_802A590((int)flt_200027C8);
  sub_8031260();
  result = 2;
  byte_20000509 = 2;
  return result;
}
// 200002F0: using guessed type float flt_200002F0;
// 20000509: using guessed type char byte_20000509;
// 200025C8: using guessed type float flt_200025C8;
// 200025CC: using guessed type float flt_200025CC;
// 200025D0: using guessed type float flt_200025D0;
// 200027C8: using guessed type float flt_200027C8[5];

//----- (0802FB08) --------------------------------------------------------
int sub_802FB08()
{
  int result; // r0

  flt_200025C8 = 60.0;
  flt_200025CC = 61.8;
  flt_200025D0 = 57.0;
  sub_8030A64((int)&unk_200027AC);
  sub_802A590((int)flt_200027C8);
  sub_8031260();
  result = 3;
  byte_20000509 = 3;
  return result;
}
// 200002F0: using guessed type float flt_200002F0;
// 20000509: using guessed type char byte_20000509;
// 200025C8: using guessed type float flt_200025C8;
// 200025CC: using guessed type float flt_200025CC;
// 200025D0: using guessed type float flt_200025D0;
// 200027C8: using guessed type float flt_200027C8[5];

//----- (0802FB88) --------------------------------------------------------
char *sub_802FB88()
{
  float v0; // s0
  char *result; // r0

  result = &byte_200002A4;
  if ( (unsigned int)(LODWORD(v0) - 1050253723) >= 0xE66665 )
  {
    if ( (unsigned int)(LODWORD(v0) + 1097229925) >= 0xE66665 )
    {
      flt_20000300 = 0.0;
      flt_20000304 = 0.0;
    }
    else
    {
      flt_20000304 = v0;
    }
  }
  else
  {
    flt_20000304 = v0;
  }
  return result;
}
// 802FB8E: variable 'v0' is possibly undefined
// 200002A4: using guessed type char byte_200002A4;
// 20000300: using guessed type float flt_20000300;
// 20000304: using guessed type float flt_20000304;

//----- (0802FBD4) --------------------------------------------------------
int __fastcall sub_802FBD4(int a1)
{
  int result; // r0

  if ( a1 )
  {
    result = 1;
    byte_200002C3 = 1;
  }
  else
  {
    result = 0;
    byte_200002C3 = 0;
  }
  return result;
}
// 200002C3: using guessed type char byte_200002C3;

//----- (0802FBEC) --------------------------------------------------------
int __fastcall sub_802FBEC(int result, int a2)
{
  float v2; // s0
  float v3; // s1
  int v4; // r2
  float v5; // s3
  float v6; // s2
  float v7; // s0
  int v8; // s0

  v4 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v4;
  v5 = *(float *)(result + 16) + (float)(v2 * v2);
  *(float *)(result + 16) = v5;
  v6 = *(float *)(result + 24) + (float)(v2 * v3);
  *(float *)(result + 24) = v6;
  if ( a2 == 1 )
  {
    if ( *(_DWORD *)(result + 4) >= v4 || v4 >= *(_DWORD *)(result + 12) )
    {
      *(_DWORD *)(result + 32) = 0;
      *(float *)(result + 20) = 10.0;
    }
    else
    {
      v7 = v5 / (float)v4;
      if ( v7 < 0.0 )
        *(_DWORD *)(result + 20) = 0;
      else
        *(float *)(result + 20) = sqrtf(v7);
      *(float *)(result + 20) = *(float *)(result + 20) + 0.6;
      *(float *)&v8 = *(float *)(result + 28) + 1.0;
      *(float *)(result + 28) = *(float *)&v8;
      if ( v8 <= 1112014848 )
      {
        *(float *)(result + 36) = (float)(v6 / (float)v4) + *(float *)(result + 36);
      }
      else
      {
        *(_DWORD *)(result + 28) = 0;
        *(float *)(result + 32) = *(float *)(result + 36) * 0.02;
        *(_DWORD *)(result + 36) = 0;
      }
    }
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 24) = 0;
  }
  return result;
}
// 802FBF6: variable 'v2' is possibly undefined
// 802FC02: variable 'v3' is possibly undefined

//----- (0802FCCC) --------------------------------------------------------
_DWORD *__fastcall sub_802FCCC(_DWORD *result)
{
  float v1; // s0

  *result = 0;
  result[1] = (int)(float)(30000.0 / (float)(v1 + 25.0));
  result[2] = 0;
  result[3] = (int)(float)(30000.0 / (float)(v1 - 15.0));
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  return result;
}
// 802FCD8: variable 'v1' is possibly undefined

//----- (0802FD28) --------------------------------------------------------
void sub_802FD28()
{
  int v0; // r0
  int v1; // r2
  int v2; // r2
  int v3; // r1
  int v4; // r3
  char v5; // r3
  unsigned int v6; // r3
  int i; // r3
  int v8; // s0
  int v9; // s0

  if ( !byte_200002AB )
  {
    if ( flt_200025D0 >= flt_200002F0 || flt_200025CC <= flt_200002F0 || dword_2000031C <= 1122893824 )
    {
      if ( --dword_200003C4 < 0 )
        dword_200003C4 = 0;
    }
    else if ( COERCE_INT(*(float *)&dword_20002610 - flt_200002F0) <= 0x40000000
           && COERCE_INT(flt_200002F0 - *(float *)&dword_20002610) <= 0x40000000 )
    {
      if ( --dword_200003C4 < 0 )
        dword_200003C4 = 0;
    }
    else if ( ++dword_200003C4 > 2000 )
    {
      sub_8030B88((int)flt_200025D4);
      sub_8029C24();
      sub_8029C24();
      sub_8029C24();
      sub_8029C1A();
      dword_200003C4 = 0;
    }
  }
  if ( byte_200002CE || byte_2000051C )
  {
    v0 = (unsigned __int8)byte_20002FD3;
    if ( byte_20002FD3 == 2 )
    {
      if ( flt_200025CC >= flt_200002F0 )
      {
        if ( flt_200025D0 <= flt_200002F0 )
        {
          dword_200003CC = 0;
        }
        else
        {
          v2 = ++dword_200003CC;
          if ( byte_200037D0 != 5 && v2 > 40 || v2 > 100 )
          {
            if ( byte_200002AB )
            {
              sub_8029C24();
              sub_8029C24();
              sub_8029C24();
              sub_8029C1A();
              LOBYTE(dword_200028C0) = dword_200028C0 | 8;
            }
            dword_200003C0 = 0;
            byte_200002AB = 0;
            return;
          }
        }
      }
      else
      {
        v1 = ++dword_200003CC;
        if ( byte_200037D0 != 5 && v1 > 40 || v1 > 400 )
        {
          if ( byte_200002AB )
          {
            sub_8029C24();
            sub_8029C24();
            sub_8029C24();
            sub_8029C1A();
            LOBYTE(dword_200028C0) = dword_200028C0 | 4;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
      }
      if ( *(float *)&dword_20002610 <= (float)(flt_200025CC + 1.0)
        && *(float *)&dword_20002610 >= (float)(flt_200025D0 - 1.0) )
      {
        dword_200003C8 = 0;
      }
      else if ( ++dword_200003C8 > 40 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C1A();
          BYTE1(dword_200028C0) = 1;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    else if ( flt_200025CC >= flt_200002F0 )
    {
      if ( flt_200025D0 <= flt_200002F0 )
      {
        dword_200003CC = 0;
      }
      else if ( ++dword_200003CC > 100 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C24();
          sub_8029C24();
          sub_8029C1A();
          LOBYTE(dword_200028C0) = dword_200028C0 | 8;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    else if ( ++dword_200003CC > 100 )
    {
      if ( byte_200002AB )
      {
        sub_8029C24();
        sub_8029C24();
        sub_8029C24();
        sub_8029C1A();
        LOBYTE(dword_200028C0) = dword_200028C0 | 4;
      }
      dword_200003C0 = 0;
      byte_200002AB = 0;
      return;
    }
    v3 = (unsigned __int8)byte_200037D0;
    if ( byte_200037D0 == 6 )
    {
      if ( flt_20002798 <= flt_20003790
        && flt_20002798 >= flt_20003794
        && flt_20003798 >= flt_200002F0
        && flt_2000379C <= flt_200002F0 )
      {
        if ( --dword_200003D0 < 0 )
          dword_200003D0 = 0;
      }
      else
      {
        ++dword_200003D0;
        dword_200003C0 = 0;
      }
      if ( dword_200037B4 < (unsigned int)dword_200003D0 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C1A();
          LOBYTE(dword_200028C0) = dword_200028C0 | 1;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200037D0 == 10 )
    {
      if ( flt_20002798 >= flt_20003794 )
      {
        if ( flt_20002798 <= flt_200037A4 )
        {
          if ( flt_20002798 <= flt_20003790 )
          {
            if ( flt_20003798 >= flt_200002F0 )
            {
              if ( flt_200037AC <= flt_200002F0 )
              {
                if ( flt_2000379C <= flt_200002F0 )
                {
                  dword_200003D4 -= 4;
                  if ( dword_200003D4 < 0 )
                    dword_200003D4 = 0;
                }
                else
                {
                  ++dword_200003D4;
                  dword_200003C0 = 0;
                }
              }
              else
              {
                dword_200003D4 += 40;
                dword_200003C0 = 0;
              }
            }
            else
            {
              dword_200003D4 += 40;
              dword_200003C0 = 0;
            }
          }
          else
          {
            dword_200003D4 += 20;
            dword_200003C0 = 0;
          }
        }
        else
        {
          dword_200003D4 += 40;
          dword_200003C0 = 0;
        }
      }
      else
      {
        dword_200003D4 += 40;
        dword_200003C0 = 0;
      }
      if ( dword_200003D4 > 20000 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C24();
          sub_8029C1A();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200037D0 == 14 )
    {
      if ( flt_20003798 >= flt_200002F0 )
      {
        if ( flt_2000379C <= flt_200002F0 )
        {
          if ( flt_20002798 <= flt_20003790 )
          {
            if ( flt_20002798 >= flt_200037A8 )
            {
              if ( flt_20002798 >= flt_20003794 )
              {
                dword_200003D8 -= 4;
                if ( dword_200003D8 < 0 )
                  dword_200003D8 = 0;
              }
              else
              {
                ++dword_200003D8;
                dword_200003C0 = 0;
              }
            }
            else
            {
              dword_200003D8 += 10;
              dword_200003C0 = 0;
            }
          }
          else
          {
            dword_200003D8 += 30;
            dword_200003C0 = 0;
          }
        }
        else
        {
          dword_200003D8 += 30;
          dword_200003C0 = 0;
        }
      }
      else
      {
        dword_200003D8 += 30;
        dword_200003C0 = 0;
      }
      if ( dword_200003D8 > 3000 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C24();
          sub_8029C1A();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        return;
      }
    }
    if ( byte_200037D0 == 7 )
    {
      v4 = dword_200003DC++;
      if ( v4 > 9998 )
      {
        dword_200003DC = 0;
        v5 = byte_200002C1;
        flt_20002468[(unsigned __int8)byte_200002C1] = flt_20002798;
        v6 = (unsigned __int8)(v5 + 1);
        byte_200002C1 = v6;
        if ( v6 >= 0x3C )
          byte_200002C1 = 0;
        dword_20000328 = 0;
        for ( i = 0; i < 60; ++i )
          *(float *)&dword_20000328 = flt_20002468[i] + *(float *)&dword_20000328;
      }
      if ( (float)(flt_200037A0 * 60.0) < *(float *)&dword_20000328 )
      {
        byte_200002AB = 0;
        dword_200003C0 = 0;
      }
    }
    if ( v3 == 8 )
    {
      if ( (unsigned int)(LODWORD(flt_20002798) - 1129250817) >= 0x2DFFFF
        || SLODWORD(flt_200002F0) <= 1111975526
        || SLODWORD(flt_200002F0) >= 1112054170 )
      {
        dword_200003E0 = 0;
      }
      else
      {
        ++dword_200003E0;
        dword_200003C0 = 0;
      }
      if ( dword_20003788 >= (unsigned int)dword_200003E0 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E0 = dword_20003788;
        byte_200002C4 = 1;
      }
    }
    if ( v3 == 15 )
    {
      if ( (unsigned int)(LODWORD(flt_20002798) - 1128497153) >= 0x397FFF
        || SLODWORD(flt_200002F0) <= 1111359488
        || SLODWORD(flt_200002F0) >= 1112041062 )
      {
        dword_200003E4 = 0;
      }
      else
      {
        ++dword_200003E4;
        dword_200003C0 = 0;
      }
      if ( dword_200003E4 <= 61000 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E4 = 61000;
        byte_200002C4 = 1;
      }
    }
    if ( v3 == 11 )
    {
      if ( (unsigned int)(LODWORD(flt_20002798) - 1128536475) >= 0x40FFFF
        || SLODWORD(flt_200002F0) <= 1111333274
        || SLODWORD(flt_200002F0) >= 1112565350 )
      {
        dword_200003E8 = 0;
      }
      else
      {
        ++dword_200003E8;
        dword_200003C0 = 0;
      }
      if ( dword_200003E8 <= 21000 )
      {
        byte_200002C4 = 0;
      }
      else
      {
        dword_200003E8 = 21000;
        byte_200002C4 = 1;
      }
    }
    if ( v3 != 5 )
    {
      if ( v3 != 14 )
      {
        if ( SLODWORD(flt_20002798) > 1133412352 )
        {
          if ( byte_200002AB )
          {
            sub_8029C24();
            sub_8029C1A();
            LOBYTE(dword_200028C0) = dword_200028C0 | 1;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
        if ( SLODWORD(flt_20002798) < 1126825984 )
        {
          if ( byte_200002AB )
          {
            sub_8029C24();
            sub_8029C1A();
            LOBYTE(dword_200028C0) = dword_200028C0 | 2;
          }
          dword_200003C0 = 0;
          byte_200002AB = 0;
          return;
        }
        if ( v0 != 2 )
        {
          *(float *)&v8 = *(float *)&dword_20001BEC
                        - (float)((float)(flt_20002798 * 1.4142) * *(float *)&dword_20002630);
          sub_8029DAC();
          if ( v8 <= 1117782016 )
          {
            dword_200003BC = 0;
          }
          else if ( ++dword_200003BC > 4 )
          {
            if ( byte_200002AB )
            {
              sub_8029C24();
              sub_8029C24();
              sub_8029C24();
              sub_8029C1A();
              LOBYTE(dword_200028C0) = dword_200028C0 | 0x80;
            }
            dword_200003C0 = 0;
            byte_200002AB = 0;
            return;
          }
        }
      }
      goto LABEL_189;
    }
    if ( (unsigned int)(LODWORD(flt_20002798) - 1083388723) >= 0x3024CCE )
    {
      if ( byte_200002AB )
      {
        sub_8029C24();
        sub_8029C1A();
      }
      dword_200003C0 = 0;
      byte_200002AB = 0;
      dword_200003EC = 0;
      return;
    }
    if ( (unsigned int)(LODWORD(flt_20002798) - 1127592756) < 0x50D999 )
    {
      if ( SLODWORD(flt_20002798) >= 1128346419 )
      {
        dword_200003EC = 0;
        dword_20000308 = 1.0;
      }
      else
      {
        ++dword_200003EC;
        dword_20000308 = 0;
      }
    }
    else
    {
      ++dword_200003EC;
      dword_20000308 = 0;
    }
    if ( SLODWORD(flt_20002798) < 1128044953
      && (float)((float)((float)((float)(flt_20002798 / 230.0) - 0.02) * 4071.4) + 320.0) < (float)dword_200003EC )
    {
      if ( byte_200002AB )
      {
        sub_8029C24();
        sub_8029C1A();
      }
      dword_200003C0 = 0;
      byte_200002AB = 0;
      dword_200003EC = 0;
      return;
    }
    if ( SLODWORD(flt_20002798) > 1133343539 )
    {
      if ( dword_200003EC > 300 )
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C1A();
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
        dword_200003EC = 0;
        return;
      }
LABEL_189:
      v9 = dword_20001BEC;
      sub_8029DAC();
      if ( v9 <= 1138163712 )
      {
        if ( dword_200003C0 >= 1000 )
        {
          if ( !byte_200002AB )
          {
            sub_8029C1A();
            byte_200002AB = 1;
            dword_200028C0 &= 0xFFFF0000;
          }
        }
        else
        {
          ++dword_200003C0;
        }
      }
      else
      {
        if ( byte_200002AB )
        {
          sub_8029C24();
          sub_8029C1A();
          LOBYTE(dword_200028C0) = dword_200028C0 | 0x10;
        }
        dword_200003C0 = 0;
        byte_200002AB = 0;
      }
      return;
    }
    if ( SLODWORD(flt_20002798) <= 1132891340 || dword_200003EC <= 5500 )
      goto LABEL_189;
    if ( byte_200002AB )
    {
      sub_8029C24();
      sub_8029C1A();
    }
    dword_200003C0 = 0;
    byte_200002AB = 0;
    dword_200003EC = 0;
  }
  else
  {
    if ( SLODWORD(flt_20002798) > 1126825984 )
    {
      if ( (unsigned int)(LODWORD(flt_200002F0) - 1113849857) >= 0x17FFFF )
      {
        if ( (unsigned int)(LODWORD(flt_200002F0) - 1111228417) < 0x17FFFF )
          --dword_200003B8;
      }
      else
      {
        ++dword_200003B8;
      }
    }
    if ( dword_200003B8 <= 1000 )
    {
      if ( dword_200003B8 < -1000 )
      {
        sub_802FA88();
        sub_8029C1A();
        byte_200002CE = 1;
      }
    }
    else
    {
      sub_802FB08();
      sub_8029C1A();
      byte_200002CE = 1;
    }
  }
}
// 200002AB: using guessed type char byte_200002AB;
// 200002C1: using guessed type char byte_200002C1;
// 200002C4: using guessed type char byte_200002C4;
// 200002CE: using guessed type char byte_200002CE;
// 200002F0: using guessed type float flt_200002F0;
// 20000308: using guessed type int dword_20000308;
// 2000031C: using guessed type int dword_2000031C;
// 20000328: using guessed type int dword_20000328;
// 200003B8: using guessed type int dword_200003B8;
// 200003BC: using guessed type int dword_200003BC;
// 200003C0: using guessed type int dword_200003C0;
// 200003C4: using guessed type int dword_200003C4;
// 200003C8: using guessed type int dword_200003C8;
// 200003CC: using guessed type int dword_200003CC;
// 200003D0: using guessed type int dword_200003D0;
// 200003D4: using guessed type int dword_200003D4;
// 200003D8: using guessed type int dword_200003D8;
// 200003DC: using guessed type int dword_200003DC;
// 200003E0: using guessed type int dword_200003E0;
// 200003E4: using guessed type int dword_200003E4;
// 200003E8: using guessed type int dword_200003E8;
// 200003EC: using guessed type int dword_200003EC;
// 2000051C: using guessed type char byte_2000051C;
// 20001BEC: using guessed type int dword_20001BEC;
// 20002468: using guessed type float flt_20002468[60];
// 200025C8: using guessed type float flt_200025C8;
// 200025CC: using guessed type float flt_200025CC;
// 200025D0: using guessed type float flt_200025D0;
// 200025D4: using guessed type float flt_200025D4[15];
// 20002610: using guessed type int dword_20002610;
// 20002630: using guessed type int dword_20002630;
// 20002798: using guessed type float flt_20002798;
// 200028C0: using guessed type int dword_200028C0;
// 20002FD3: using guessed type char byte_20002FD3;
// 20003788: using guessed type int dword_20003788;
// 20003790: using guessed type float flt_20003790;
// 20003794: using guessed type float flt_20003794;
// 20003798: using guessed type float flt_20003798;
// 2000379C: using guessed type float flt_2000379C;
// 200037A0: using guessed type float flt_200037A0;
// 200037A4: using guessed type float flt_200037A4;
// 200037A8: using guessed type float flt_200037A8;
// 200037AC: using guessed type float flt_200037AC;
// 200037B4: using guessed type int dword_200037B4;
// 200037D0: using guessed type char byte_200037D0;

//----- (080306D4) --------------------------------------------------------
int __fastcall sub_80306D4(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result == 1073875968 )
  {
    MEMORY[0x40021048] |= 8u;
    return MEMORY[0x40021048] & 8;
  }
  return result;
}

//----- (080306FC) --------------------------------------------------------
int sub_80306FC()
{
  sub_8029C24();
  sub_8029C1A();
  if ( (unsigned __int8)byte_200002BB << 31 )
    LOBYTE(dword_200028C4) = dword_200028C4 | 2;
  if ( (byte_200002BB & 2) != 0 )
    LOBYTE(dword_200028C4) = dword_200028C4 | 8;
  if ( (byte_200002BB & 4) != 0 )
    LOBYTE(dword_200028C4) = dword_200028C4 | 4;
  if ( (byte_200002BB & 8) != 0 )
    LOBYTE(dword_200028C4) = dword_200028C4 | 1;
  LOBYTE(dword_200028C4) = dword_200028C4 | 0x10;
  byte_200002BB = 0;
  sub_80312C8(23);
  return sub_80312C8(40);
}
// 200002BB: using guessed type char byte_200002BB;
// 20001BF0: using guessed type int dword_20001BF0;
// 200028C4: using guessed type int dword_200028C4;

//----- (08030774) --------------------------------------------------------
char *__fastcall sub_8030774(char *result)
{
  int v1; // r1

  if ( (unsigned int)result < 4 )
  {
    v1 = 1 << (char)result;
    result = &byte_200002A4;
    byte_200002BB |= v1;
  }
  return result;
}
// 200002A4: using guessed type char byte_200002A4;
// 200002BB: using guessed type char byte_200002BB;

//----- (0803078C) --------------------------------------------------------
void sub_803078C()
{
  if ( byte_200002B2 )
  {
    if ( dword_20001BF4 < 1135214592 )
    {
      sub_8029C24();
      sub_8029C1A();
      dword_200003F4 = 0;
      byte_200002B2 = 0;
    }
  }
  else
  {
    if ( dword_20001BF4 < 1135706112 )
      dword_200003F4 = 0;
    if ( ++dword_200003F4 >= 1000 )
    {
      sub_8029C1A();
      byte_200002B2 = 1;
    }
  }
  if ( byte_200002B1 )
  {
    if ( dword_20001BF4 > 1140981760 )
    {
      sub_8029C24();
      sub_8029C1A();
      dword_200003F0 = 0;
      byte_200002B1 = 0;
    }
  }
  else
  {
    if ( dword_20001BF4 > 1139802112 )
      dword_200003F0 = 0;
    if ( ++dword_200003F0 >= 1000 )
    {
      sub_8029C1A();
      byte_200002B1 = 1;
    }
  }
}
// 200002B1: using guessed type char byte_200002B1;
// 200002B2: using guessed type char byte_200002B2;
// 200003F0: using guessed type int dword_200003F0;
// 200003F4: using guessed type int dword_200003F4;
// 20001BF4: using guessed type int dword_20001BF4;

//----- (0803085C) --------------------------------------------------------
float *sub_803085C()
{
  float *result; // r0

  dword_200002FC = 0;
  flt_20000300 = 0.0;
  flt_20002448 = 0.0;
  flt_20002460 = 0.0;
  flt_20000320 = 2500.0;
  dword_200002E0 = 0;
  byte_200002B8 = 0;
  byte_200002B9 = 0;
  byte_200002C8 = 0;
  dword_200002EC = 0;
  byte_200002BA = 0;
  flt_200002D0 = 0.0;
  flt_200002D4 = 0.0;
  flt_2000244C = 0.0;
  flt_20002450 = 0.0;
  flt_20002454 = 0.0;
  dword_20002458 = 0;
  flt_2000245C = 0.0;
  flt_20002464 = 0.0;
  dword_20001C1C = 0;
  sub_802A4A4(&flt_20002804);
  sub_802A4A4(&flt_20002864);
  result = &flt_20002804;
  flt_2000281C = 100.0;
  return result;
}
// 200002B8: using guessed type char byte_200002B8;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002C8: using guessed type char byte_200002C8;
// 200002D0: using guessed type float flt_200002D0;
// 200002D4: using guessed type float flt_200002D4;
// 200002E0: using guessed type int dword_200002E0;
// 200002EC: using guessed type int dword_200002EC;
// 200002FC: using guessed type int dword_200002FC;
// 20000300: using guessed type float flt_20000300;
// 20000320: using guessed type float flt_20000320;
// 20001C1C: using guessed type int dword_20001C1C;
// 20002448: using guessed type float flt_20002448;
// 2000244C: using guessed type float flt_2000244C;
// 20002450: using guessed type float flt_20002450;
// 20002454: using guessed type float flt_20002454;
// 20002458: using guessed type int dword_20002458;
// 2000245C: using guessed type float flt_2000245C;
// 20002460: using guessed type float flt_20002460;
// 20002464: using guessed type float flt_20002464;
// 20002804: using guessed type float flt_20002804;
// 2000281C: using guessed type float flt_2000281C;
// 20002864: using guessed type float flt_20002864;

//----- (080308EC) --------------------------------------------------------
int sub_80308EC()
{
  int result; // r0
  float v1; // s1

  result = (unsigned __int8)byte_200002C2;
  if ( !byte_200002C2 )
  {
    v1 = flt_20002768;
    if ( flt_20002768 <= flt_2000276C )
      v1 = flt_2000276C;
    if ( v1 <= 14.67 )
    {
      if ( v1 <= 13.58 )
      {
        if ( v1 <= 11.95 )
        {
          if ( v1 <= 9.0 )
          {
            if ( v1 <= 4.5 )
              dword_200002E0 -= 1800;
            else
              dword_200002E0 -= 240;
          }
          else
          {
            --dword_200002E0;
          }
        }
        else
        {
          ++dword_200002E0;
        }
      }
      else
      {
        dword_200002E0 += 10;
      }
    }
    else
    {
      dword_200002E0 += 60;
    }
    if ( dword_200002E0 >= 0 )
    {
      if ( dword_200002E0 > 600000 )
      {
        dword_200002E0 = 600000;
        if ( !byte_200002B9 )
        {
          sub_8029C24();
          sub_8029C24();
          sub_8029C1A();
          byte_200002B9 = 1;
        }
      }
    }
    else
    {
      dword_200002E0 = 0;
      byte_200002B9 = 0;
    }
    if ( dword_200002E0 <= 60000 )
    {
      byte_200002B8 = 0;
    }
    else
    {
      byte_200002B8 = 1;
      sub_8029D5A();
    }
    if ( byte_200002A4 == 4 )
    {
      if ( dword_20002774 >= 1129250816 )
      {
        if ( --dword_200002EC < 0 )
          dword_200002EC = 0;
      }
      else if ( dword_200002EC <= 200 )
      {
        ++dword_200002EC;
      }
      else if ( !byte_200002BA )
      {
        sub_8029C24();
        sub_8029C24();
        sub_8029C1A();
        byte_200002BA = 1;
      }
    }
    if ( byte_200002BA == 1 || byte_200002B9 == 1 )
    {
      result = (unsigned __int8)byte_200002AD;
      if ( byte_200002AD == 1 )
      {
        byte_200002AD = 0;
        byte_200002AE = 1;
      }
    }
    else
    {
      result = dword_200002EC | dword_200002E0;
      if ( !(dword_200002EC | dword_200002E0) )
      {
        byte_200002BA = 0;
        byte_200002B9 = 0;
        byte_200002AD = 1;
      }
    }
  }
  return result;
}
// 200002A4: using guessed type char byte_200002A4;
// 200002AD: using guessed type char byte_200002AD;
// 200002AE: using guessed type char byte_200002AE;
// 200002B8: using guessed type char byte_200002B8;
// 200002B9: using guessed type char byte_200002B9;
// 200002BA: using guessed type char byte_200002BA;
// 200002C2: using guessed type char byte_200002C2;
// 200002E0: using guessed type int dword_200002E0;
// 200002EC: using guessed type int dword_200002EC;
// 20002768: using guessed type float flt_20002768;
// 2000276C: using guessed type float flt_2000276C;
// 20002774: using guessed type int dword_20002774;

//----- (08030A64) --------------------------------------------------------
int __fastcall sub_8030A64(int result)
{
  float v1; // s0
  float v2; // s1

  *(float *)result = v1;
  *(float *)(result + 4) = (float)(v1 * 2.0) / v2;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  return result;
}
// 8030A64: variable 'v1' is possibly undefined
// 8030A70: variable 'v2' is possibly undefined

//----- (08030A94) --------------------------------------------------------
int __fastcall sub_8030A94(int a1)
{
  float v1; // s0
  int v2; // s0
  int result; // r0
  _DWORD *v4; // r3

  v1 = *(float *)(a1 + 8) + *(float *)(a1 + 4);
  *(float *)(a1 + 8) = v1;
  if ( *(_DWORD *)(a1 + 24) && SLODWORD(v1) > 1065353216 )
  {
    *(_DWORD *)(a1 + 20) = 1;
    *(_DWORD *)(a1 + 24) = 0;
  }
  else if ( SLODWORD(v1) <= 0x40000000 )
  {
    *(_DWORD *)(a1 + 20) = 0;
  }
  else
  {
    *(float *)(a1 + 8) = v1 - 2.0;
    *(_DWORD *)(a1 + 24) = 1;
  }
  v2 = *(_DWORD *)(a1 + 8);
  sub_802A274();
  result = sub_803138C(dword_20000424);
  v4[3] = v2;
  v4[4] = v4[2];
  return result;
}
// 8030AEE: variable 'v4' is possibly undefined
// 20000424: using guessed type int dword_20000424;

//----- (08030B00) --------------------------------------------------------
float *__fastcall sub_8030B00(float *result)
{
  float v1; // s0
  float v2; // s0
  float v3; // s2
  float v4; // s0
  float v5; // s1
  float v6; // s0

  v2 = v1 * 6.2832;
  v3 = v2 * 0.000033333;
  v4 = (float)((float)(v2 * 0.000033333) * v2) * 0.000033333;
  v5 = 1.0 / (float)((float)(v3 + v4) + 4.0);
  result[25] = v3 * v5;
  result[26] = -(float)(v3 * v5);
  result[27] = (float)((float)(4.0 - v4) * 2.0) * v5;
  result[28] = (float)((float)(v3 - v4) - 4.0) * v5;
  v6 = (float)(v4 * 0.5) * v5;
  result[29] = v6;
  result[30] = v6 * 2.0;
  result[31] = v6;
  return result;
}
// 8030B08: variable 'v1' is possibly undefined

//----- (08030B88) --------------------------------------------------------
void __fastcall sub_8030B88(int a1)
{
  int v1; // s0

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = v1;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 132) = 1126627692;
  *(_DWORD *)(a1 + 128) = -1020902375;
  *(float *)(a1 + 136) = -1.0;
  *(_DWORD *)(a1 + 96) = 940298085;
  sub_80313C4();
}
// 8030BCC: variable 'v1' is possibly undefined

//----- (08030C20) --------------------------------------------------------
int __fastcall sub_8030C20(int result)
{
  float v1; // s0

  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(_DWORD *)(result + 92) = 0;
  *(_DWORD *)(result + 96) = 1001099969;
  *(_DWORD *)(result + 108) = 970045207;
  *(_DWORD *)(result + 104) = 981668463;
  *(_DWORD *)(result + 112) = 1110704128;
  *(_DWORD *)(result + 72) = 0;
  *(_DWORD *)(result + 76) = 0;
  *(_DWORD *)(result + 128) = 0;
  *(_DWORD *)(result + 132) = 0;
  *(_DWORD *)(result + 136) = 0;
  *(float *)(result + 140) = v1 + 0.011;
  *(_DWORD *)(result + 144) = 0;
  *(_DWORD *)(result + 148) = 0;
  *(_DWORD *)(result + 152) = 0;
  *(_DWORD *)(result + 156) = 0;
  *(_DWORD *)(result + 160) = 0;
  *(_DWORD *)(result + 168) = 0;
  *(_DWORD *)(result + 164) = 0;
  *(_DWORD *)(result + 208) = 1126627692;
  *(_DWORD *)(result + 204) = -1020902375;
  *(float *)(result + 212) = -1.0;
  *(_DWORD *)(result + 172) = 940298085;
  return result;
}
// 8030C88: variable 'v1' is possibly undefined

//----- (08030CF4) --------------------------------------------------------
int __fastcall sub_8030CF4(float *a1)
{
  float v1; // s0
  float v2; // s5
  float v3; // s3
  float v4; // s4
  float v5; // s2
  float v6; // s1
  float v7; // s6
  float v8; // s2
  float v9; // s5
  float v10; // s2
  float v11; // s0
  int v12; // s1
  float v13; // s1
  float v14; // s0
  int v15; // s0
  int v16; // s0
  int v17; // r3
  int v18; // r3
  float v19; // s0
  int v20; // s0
  int result; // r0
  int v22; // r3

  *a1 = v1;
  v2 = a1[2];
  v3 = a1[27];
  v4 = a1[28];
  v5 = a1[4];
  v6 = (float)((float)((float)(v1 - v2) * a1[25]) + (float)(v3 * v5)) + (float)(v4 * a1[5]);
  a1[3] = v6;
  a1[5] = v5;
  a1[4] = v6;
  v7 = a1[1];
  v8 = (float)((float)(a1[29] * v1) + (float)(a1[30] * v7)) + (float)(a1[31] * v2);
  v9 = a1[7];
  v10 = (float)(v8 + (float)(v3 * v9)) + (float)(v4 * a1[8]);
  a1[6] = v10;
  a1[8] = v9;
  a1[7] = v10;
  a1[2] = v7;
  a1[1] = v1;
  v11 = (float)(a1[22] * v6) + (float)(a1[23] * v10);
  a1[9] = v11;
  *(float *)&v12 = (float)(a1[14] + (float)(a1[33] * v11)) + (float)(a1[32] * a1[10]);
  a1[13] = *(float *)&v12;
  if ( v12 > 1106247680 )
    a1[13] = 30.0;
  if ( *((_DWORD *)a1 + 13) > 0xC1F00000 )
    a1[13] = -30.0;
  v13 = a1[13];
  a1[14] = v13;
  a1[10] = v11;
  v14 = a1[16] + v13;
  a1[15] = v14;
  *(float *)&v15 = a1[18] + (float)((float)(v14 * a1[24]) * 2.0);
  a1[17] = *(float *)&v15;
  if ( v15 > 0x40000000 )
    a1[17] = 0.0;
  v16 = *((_DWORD *)a1 + 17);
  *((_DWORD *)a1 + 18) = v16;
  sub_802A274();
  sub_803138C(dword_20000424);
  *(_DWORD *)(v17 + 92) = v16;
  sub_803138C(dword_20000428);
  *(_DWORD *)(v18 + 88) = v16;
  v19 = *(float *)(v18 + 72) + *(float *)(v18 + 80);
  *(float *)(v18 + 76) = v19;
  if ( SLODWORD(v19) <= 0x40000000 )
  {
    if ( v19 < 0.0 )
      *(float *)(v18 + 76) = v19 + 2.0;
  }
  else
  {
    *(float *)(v18 + 76) = v19 - 2.0;
  }
  v20 = *(_DWORD *)(v18 + 76);
  sub_802A274();
  result = sub_803138C(dword_20000424);
  *(_DWORD *)(v22 + 84) = v20;
  return result;
}
// 8030CF8: variable 'v1' is possibly undefined
// 8030E1A: variable 'v17' is possibly undefined
// 8030E24: variable 'v18' is possibly undefined
// 8030E6A: variable 'v22' is possibly undefined
// 20000424: using guessed type int dword_20000424;
// 20000428: using guessed type int dword_20000428;

//----- (08030E80) --------------------------------------------------------
int __fastcall sub_8030E80(int a1, int a2)
{
  int v2; // s0
  float v3; // s1
  float v4; // s2
  int v5; // s3
  float v6; // s9
  float v7; // s0
  float v8; // s13
  float v9; // s3
  float v10; // s7
  float v11; // s8
  float v12; // s4
  float v13; // s6
  float v14; // s12
  float v15; // s4
  float v16; // s14
  float v17; // s11
  float v18; // s5
  float v19; // s13
  float v20; // s5
  float v21; // s13
  float v22; // s0
  float v23; // s3
  float v24; // s0
  float v25; // s12
  float v26; // s0
  float v27; // s4
  float v28; // s0
  float v29; // s4
  float v30; // s1
  float v31; // s0
  float v32; // s0
  int v33; // s1
  float v34; // s1
  float v35; // s4
  int v36; // s0
  int v37; // s0
  int v38; // r3
  int v39; // r1
  int result; // r0
  int v41; // r3

  v6 = *(float *)(a1 + 140);
  if ( a2 )
    *(_DWORD *)a1 = v2;
  else
    *(_DWORD *)a1 = v5;
  v7 = *(float *)a1;
  v8 = *(float *)(a1 + 8);
  v9 = *(float *)(a1 + 176);
  v10 = *(float *)(a1 + 184);
  v11 = *(float *)(a1 + 188);
  v12 = *(float *)(a1 + 28);
  v13 = (float)((float)((float)(*(float *)a1 - v8) * v9) + (float)(v10 * v12)) + (float)(v11 * *(float *)(a1 + 32));
  *(float *)(a1 + 24) = v13;
  *(float *)(a1 + 32) = v12;
  *(float *)(a1 + 28) = v13;
  v14 = *(float *)(a1 + 192);
  v15 = *(float *)(a1 + 196);
  v16 = *(float *)(a1 + 4);
  v17 = *(float *)(a1 + 200);
  v18 = (float)((float)(v14 * v7) + (float)(v15 * v16)) + (float)(v17 * v8);
  v19 = *(float *)(a1 + 40);
  v20 = (float)(v18 + (float)(v10 * v19)) + (float)(v11 * *(float *)(a1 + 44));
  *(float *)(a1 + 36) = v20;
  *(float *)(a1 + 44) = v19;
  *(float *)(a1 + 40) = v20;
  *(float *)(a1 + 8) = v16;
  *(float *)(a1 + 4) = v7;
  *(float *)(a1 + 100) = v3 - *(float *)(a1 + 12);
  *(float *)(a1 + 12) = v3;
  v21 = *(float *)(a1 + 20);
  v22 = *(float *)(a1 + 52);
  v23 = (float)((float)((float)(v3 - v21) * v9) + (float)(v10 * v22)) + (float)(v11 * *(float *)(a1 + 56));
  *(float *)(a1 + 48) = v23;
  *(float *)(a1 + 56) = v22;
  *(float *)(a1 + 52) = v23;
  v24 = v14 * v3;
  v25 = *(float *)(a1 + 16);
  v26 = v24 + (float)(v15 * v25);
  v27 = *(float *)(a1 + 64);
  v28 = (float)((float)(v26 + (float)(v17 * v21)) + (float)(v10 * v27)) + (float)(v11 * *(float *)(a1 + 68));
  *(float *)(a1 + 60) = v28;
  *(float *)(a1 + 68) = v27;
  *(float *)(a1 + 64) = v28;
  *(float *)(a1 + 20) = v25;
  *(float *)(a1 + 16) = v3;
  v29 = *(float *)(a1 + 96);
  v30 = *(float *)(a1 + 88)
      + (float)((float)((float)((float)((float)(v23 * v13) + (float)(v28 * v20)) * 0.5) - *(float *)(a1 + 88)) * v29);
  *(float *)(a1 + 88) = v30;
  v31 = *(float *)(a1 + 92)
      + (float)((float)((float)((float)((float)(v13 * v28) - (float)(v20 * v23)) * 0.5) - *(float *)(a1 + 92)) * v29);
  *(float *)(a1 + 92) = v31;
  if ( a2 )
  {
    v32 = (float)((float)(*(float *)(a1 + 164) * v13) + (float)(*(float *)(a1 + 168) * v20)) / 500.0;
    *(float *)(a1 + 72) = v32;
    *(float *)&v33 = (float)(*(float *)(a1 + 132) + (float)(*(float *)(a1 + 208) * v32))
                   + (float)(*(float *)(a1 + 204) * *(float *)(a1 + 76));
    *(float *)(a1 + 128) = *(float *)&v33;
    if ( v33 > 1106247680 )
      *(float *)(a1 + 128) = 30.0;
    if ( *(_DWORD *)(a1 + 128) > 0xC1F00000 )
      *(float *)(a1 + 128) = -30.0;
    v34 = *(float *)(a1 + 128);
    *(float *)(a1 + 132) = v34;
    *(float *)(a1 + 76) = v32;
    *(float *)(a1 + 136) = v6 + v34;
  }
  else
  {
    v35 = 1.2 - (float)(v30 * 0.0006);
    if ( v35 < 0.0 )
      v35 = 0.0;
    if ( SLODWORD(v35) > 1065353216 )
      v35 = 1.0;
    flt_20000420 = (float)(flt_20000420 * 0.2) + (float)(v35 * 0.8);
    *(float *)(a1 + 136) = v6
                         - (float)((float)(*(float *)(a1 + 108) * v30)
                                 * (float)(1.0 - (float)((float)((float)(v4 - 40.0) * 0.01) * flt_20000420)));
    *(float *)(a1 + 116) = 326.0 - (float)(*(float *)(a1 + 104) * v31);
  }
  *(float *)&v36 = *(float *)(a1 + 148) + (float)((float)(*(float *)(a1 + 136) * *(float *)(a1 + 172)) * 2.0);
  *(float *)(a1 + 144) = *(float *)&v36;
  if ( v36 <= 0x40000000 )
  {
    *(_BYTE *)(a1 + 120) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 144) = 0;
    *(_BYTE *)(a1 + 120) = 1;
  }
  v37 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 148) = v37;
  sub_802A274();
  sub_803138C(dword_20000424);
  *(_DWORD *)(v38 + 168) = v37;
  result = sub_803138C(*(_DWORD *)(v39 + 4));
  *(_DWORD *)(v41 + 164) = v37;
  *(float *)(v41 + 124) = *(float *)(v41 + 168) * *(float *)(v41 + 116);
  return result;
}
// 8030E90: variable 'v2' is possibly undefined
// 8030E96: variable 'v5' is possibly undefined
// 8030F16: variable 'v3' is possibly undefined
// 8031084: variable 'v4' is possibly undefined
// 80310FA: variable 'v38' is possibly undefined
// 80310FE: variable 'v39' is possibly undefined
// 8031104: variable 'v41' is possibly undefined
// 20000420: using guessed type float flt_20000420;
// 20000424: using guessed type int dword_20000424;

//----- (0803114C) --------------------------------------------------------
void sub_803114C()
{
  ;
}

//----- (08031260) --------------------------------------------------------
float *sub_8031260()
{
  float v0; // s0
  float *result; // r0

  result = (float *)(LODWORD(v0) - 1110704129);
  if ( (unsigned int)(LODWORD(v0) - 1110704129) < 0x4DFFFF )
  {
    sub_802A3AE(flt_200028AC);
    sub_8030B00(flt_200025D4);
    result = flt_200025D4;
    flt_20002614 = v0;
  }
  return result;
}
// 8031270: variable 'v0' is possibly undefined
// 200025D4: using guessed type float flt_200025D4[15];
// 20002614: using guessed type float flt_20002614;
// 200028AC: using guessed type float flt_200028AC[5];

//----- (080312C8) --------------------------------------------------------
int __fastcall sub_80312C8(int result)
{
  int v1; // r1

  if ( result >= 0 )
  {
    v1 = 1 << (result & 0x1F);
    result = 4 * ((unsigned int)result >> 5) - 536813568;
    *(_DWORD *)(result + 256) = v1;
  }
  return result;
}

//----- (0803137C) --------------------------------------------------------
int *sub_803137C()
{
  int *result; // r0

  result = &dword_200028C0;
  dword_200028C4 &= 0xFFFF0000;
  return result;
}
// 200028C0: using guessed type int dword_200028C0;
// 200028C4: using guessed type int dword_200028C4;

//----- (0803138C) --------------------------------------------------------
int __fastcall sub_803138C(int result)
{
  if ( result < 0 )
    return result & 0x7FFFFFFF;
  return result;
}

//----- (080313C4) --------------------------------------------------------
void sub_80313C4()
{
  dword_200028D0 = 1073875968;
  sub_8029D6E();
  sub_8029D78();
}
// 200028D0: using guessed type int dword_200028D0;

// nfuncs=980 queued=882 decompiled=882 lumina nreq=0 worse=0 better=0
#error "There were 7 decompilation failure(s) on 882 function(s)"
